/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.4
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGLUA
#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_LUA
#define SWIG_LUA_MODULE_GLOBAL
#define SWIG_LUA_SQUASH_BASES


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#include "lua.h"
#include "lauxlib.h"
#include <stdlib.h>  /* for malloc */
#include <assert.h>  /* for a few sanity tests */

/* -----------------------------------------------------------------------------
 * Lua flavors
 * ----------------------------------------------------------------------------- */

#define SWIG_LUA_FLAVOR_LUA 1
#define SWIG_LUA_FLAVOR_ELUA 2
#define SWIG_LUA_FLAVOR_ELUAC 3

#if !defined(SWIG_LUA_TARGET)
# error SWIG_LUA_TARGET not defined
#endif

#if defined(SWIG_LUA_ELUA_EMULATE)

struct swig_elua_entry;

typedef struct swig_elua_key {
  int type;
  union {
    const char* strkey;
    lua_Number numkey;
  } key;
} swig_elua_key;

typedef struct swig_elua_val {
  int type;
  union {
    lua_Number number;
    const struct swig_elua_entry *table;
    const char *string;
    lua_CFunction function;
    struct {
      char member;
      long lvalue;
      void *pvalue;
      swig_type_info **ptype;
    } userdata;
  } value;
} swig_elua_val;

typedef struct swig_elua_entry {
  swig_elua_key key;
  swig_elua_val value;
} swig_elua_entry;

#define LSTRKEY(x) {LUA_TSTRING, {.strkey = x} }
#define LNUMKEY(x) {LUA_TNUMBER, {.numkey = x} }
#define LNILKEY {LUA_TNIL, {.strkey = 0} }

#define LNUMVAL(x) {LUA_TNUMBER, {.number = x} }
#define LFUNCVAL(x) {LUA_TFUNCTION, {.function = x} }
#define LROVAL(x) {LUA_TTABLE, {.table = x} }
#define LNILVAL {LUA_TNIL, {.string = 0} }
#define LSTRVAL(x) {LUA_TSTRING, {.string = x} }

#define LUA_REG_TYPE swig_elua_entry

#define SWIG_LUA_ELUA_EMUL_METATABLE_KEY "__metatable"

#define lua_pushrotable(L,p)\
  lua_newtable(L);\
  assert(p);\
  SWIG_Lua_elua_emulate_register(L,(swig_elua_entry*)(p));

#define SWIG_LUA_CONSTTAB_POINTER(B,C,D)\
  LSTRKEY(B), {LUA_TUSERDATA, { .userdata={0,0,(void*)(C),&D} } }

#define SWIG_LUA_CONSTTAB_BINARY(B,S,C,D)\
  LSTRKEY(B), {LUA_TUSERDATA, { .userdata={1,S,(void*)(C),&D} } }
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define SWIG_LUA_CONSTTAB_INT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_STRING(B, C) LSTRKEY(B), LSTRVAL(C)
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) LSTRKEY(B), LNUMVAL(C)
    /* Those two types of constants are not supported in elua */

#ifndef SWIG_LUA_CONSTTAB_POINTER
#warning eLua does not support pointers as constants. By default, nil will be used as value
#define SWIG_LUA_CONSTTAB_POINTER(B,C,D) LSTRKEY(B), LNILVAL
#endif

#ifndef SWIG_LUA_CONSTTAB_BINARY
#warning eLua does not support pointers to member as constants. By default, nil will be used as value
#define SWIG_LUA_CONSTTAB_BINARY(B, S, C, D) LSTRKEY(B), LNILVAL
#endif
#else /* SWIG_LUA_FLAVOR_LUA */
#  define SWIG_LUA_CONSTTAB_INT(B, C) SWIG_LUA_INT, (char *)B, (long)C, 0, 0, 0
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) SWIG_LUA_FLOAT, (char *)B, 0, (double)C, 0, 0
#  define SWIG_LUA_CONSTTAB_STRING(B, C) SWIG_LUA_STRING, (char *)B, 0, 0, (void *)C, 0
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) SWIG_LUA_CHAR, (char *)B, (long)C, 0, 0, 0
#  define SWIG_LUA_CONSTTAB_POINTER(B,C,D)\
       SWIG_LUA_POINTER, (char *)B, 0, 0, (void *)C, &D
#  define SWIG_LUA_CONSTTAB_BINARY(B, S, C, D)\
       SWIG_LUA_BINARY,  (char *)B, S, 0, (void *)C, &D
#endif

#ifndef SWIG_LUA_ELUA_EMULATE
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define LRO_STRVAL(v) {{.p = (char *) v}, LUA_TSTRING}
#  define LSTRVAL LRO_STRVAL
#endif
#endif /* SWIG_LUA_ELUA_EMULATE*/

#ifndef SWIG_LUA_ELUA_EMULATE
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)

#ifndef MIN_OPT_LEVEL
#define MIN_OPT_LEVEL 2
#endif

#include "lrodefs.h"
#include "lrotable.h"
#endif
#endif /* SWIG_LUA_ELUA_EMULATE*/
/* -----------------------------------------------------------------------------
 * compatibility defines
 * ----------------------------------------------------------------------------- */

/* History of Lua C API length functions:  In Lua 5.0 (and before?)
   there was "lua_strlen".  In Lua 5.1, this was renamed "lua_objlen",
   but a compatibility define of "lua_strlen" was added.  In Lua 5.2,
   this function was again renamed, to "lua_rawlen" (to emphasize that
   it doesn't call the "__len" metamethod), and the compatibility
   define of lua_strlen was removed.  All SWIG uses have been updated
   to "lua_rawlen", and we add our own defines of that here for older
   versions of Lua.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
# define lua_rawlen lua_strlen
#elif LUA_VERSION_NUM == 501
# define lua_rawlen lua_objlen
#endif


/* lua_pushglobaltable is the recommended "future-proof" way to get
   the global table for Lua 5.2 and later.  Here we define
   lua_pushglobaltable ourselves for Lua versions before 5.2.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
# define lua_pushglobaltable(L) lua_pushvalue(L, LUA_GLOBALSINDEX)
#endif

/* lua_absindex was introduced in Lua 5.2 */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
# define lua_absindex(L,i) ((i)>0 || (i) <= LUA_REGISTRYINDEX ? (i) : lua_gettop(L) + (i) + 1)
#endif

/* lua_rawsetp was introduced in Lua 5.2 */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
#define lua_rawsetp(L,index,ptr)\
  lua_pushlightuserdata(L,(void*)(ptr));\
  lua_insert(L,-2);\
  lua_rawset(L,index);

#define lua_rawgetp(L,index,ptr)\
  lua_pushlightuserdata(L,(void*)(ptr));\
  lua_rawget(L,index);

#endif

/* --------------------------------------------------------------------------
 * Helper functions for error handling
 * -------------------------------------------------------------------------- */

/* Push the string STR on the Lua stack, like lua_pushstring, but
   prefixed with the the location of the innermost Lua call-point
   (as formated by luaL_where).  */
SWIGRUNTIME void
SWIG_Lua_pusherrstring (lua_State *L, const char *str)
{
  luaL_where (L, 1);
  lua_pushstring (L, str);
  lua_concat (L, 2);
}

/* Push a formatted string generated from FMT and following args on
   the Lua stack, like lua_pushfstring, but prefixed with the the
   location of the innermost Lua call-point (as formated by luaL_where).  */
SWIGRUNTIME void
SWIG_Lua_pushferrstring (lua_State *L, const char *fmt, ...)
{
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
}


/* -----------------------------------------------------------------------------
 * global swig types
 * ----------------------------------------------------------------------------- */
/* Constant table */
#define SWIG_LUA_INT     1
#define SWIG_LUA_FLOAT   2
#define SWIG_LUA_STRING  3
#define SWIG_LUA_POINTER 4
#define SWIG_LUA_BINARY  5
#define SWIG_LUA_CHAR    6

/* Structure for variable linking table */
typedef struct {
  const char *name;
  lua_CFunction get;
  lua_CFunction set;
} swig_lua_var_info;

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
typedef const LUA_REG_TYPE swig_lua_method;
typedef const LUA_REG_TYPE swig_lua_const_info;
#else /* Normal lua */
typedef luaL_Reg swig_lua_method;

/* Constant information structure */
typedef struct {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_lua_const_info;

#endif

typedef struct {
  const char     *name;
  lua_CFunction   getmethod;
  lua_CFunction   setmethod;
} swig_lua_attribute;


struct swig_lua_class;
/* Can be used to create namespaces. Currently used to wrap class static methods/variables/constants */
typedef struct swig_lua_namespace {
  const char            *name;
  swig_lua_method       *ns_methods;
  swig_lua_attribute    *ns_attributes;
  swig_lua_const_info   *ns_constants;
  struct swig_lua_class        **ns_classes;
  struct swig_lua_namespace    **ns_namespaces;
} swig_lua_namespace;

typedef struct swig_lua_class {
  const char    *name; /* Name that this class has in Lua */
  const char    *fqname; /* Fully qualified name - Scope + class name */
  swig_type_info   **type;
  lua_CFunction  constructor;
  void    (*destructor)(void *);
  swig_lua_method   *methods;
  swig_lua_attribute     *attributes;
  swig_lua_namespace    *cls_static;
  swig_lua_method   *metatable; /* 0 for -eluac */
  struct swig_lua_class **bases;
  const char **base_names;
} swig_lua_class;

/* this is the struct for wrapping all pointers in SwigLua
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  void        *ptr;
} swig_lua_userdata;

/* this is the struct for wrapping arbitrary packed binary data
(currently it is only used for member function pointers)
the data ordering is similar to swig_lua_userdata, but it is currently not possible
to tell the two structures apart within SWIG, other than by looking at the type
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  char data[1];       /* arbitary amount of data */    
} swig_lua_rawdata;

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { SWIG_Lua_pusherrstring(L, (char *) msg); goto fail; } else


/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(func_name,argnum,type) \
  {SWIG_Lua_pushferrstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
  goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
#define SWIG_check_num_args(func_name,a,b) \
  if (lua_gettop(L)<a || lua_gettop(L)>b) \
  {SWIG_Lua_pushferrstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
  goto fail;}


#define SWIG_Lua_get_table(L,n) \
  (lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
  (lua_pushstring(L, n), \
      lua_pushcfunction(L, f), \
      lua_rawset(L,-3))

#define SWIG_Lua_add_boolean(L,n,b) \
  (lua_pushstring(L, n), \
      lua_pushboolean(L, b), \
      lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
/*#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a))) */
#endif

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State *L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
    ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);  /* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State *L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* this function is called when trying to set an immutable.
default action is to print an error.
This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
SWIGINTERN int SWIG_Lua_set_immutable(lua_State *L)
{
/*  there should be 1 param passed in: the new value */
#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
  lua_pop(L,1);  /* remove it */
  luaL_error(L,"This variable is immutable");
#endif
    return 0;   /* should not return anything */
}

#ifdef SWIG_LUA_ELUA_EMULATE

SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State *L,void *ptr,swig_type_info *type, int own);
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State *L,void *ptr,size_t size,swig_type_info *type);
static int swig_lua_elua_emulate_unique_key;

/* This function emulates eLua rotables behaviour. It loads a rotable definition into the usual lua table. */
SWIGINTERN void SWIG_Lua_elua_emulate_register(lua_State *L, const swig_elua_entry *table)
{
  int i, table_parsed, parsed_tables_array, target_table;
  assert(lua_istable(L,-1));
  target_table = lua_gettop(L);
  /* Get the registry where we put all parsed tables to avoid loops */
  lua_rawgetp(L, LUA_REGISTRYINDEX, &swig_lua_elua_emulate_unique_key);
  if(lua_isnil(L,-1)) {
    lua_pop(L,1);
    lua_newtable(L);
    lua_pushvalue(L,-1);
    lua_rawsetp(L,LUA_REGISTRYINDEX,(void*)(&swig_lua_elua_emulate_unique_key));
  }
  parsed_tables_array = lua_gettop(L);
  lua_pushvalue(L,target_table);
  lua_rawsetp(L, parsed_tables_array, table);
  table_parsed = 0;
  const int SWIGUNUSED pairs_start = lua_gettop(L);
  for(i = 0;table[i].key.type != LUA_TNIL || table[i].value.type != LUA_TNIL;i++)
  {
    const swig_elua_entry *entry = table + i;
    int is_metatable = 0;
    switch(entry->key.type) {
      case LUA_TSTRING:
        lua_pushstring(L,entry->key.key.strkey);
        if(strcmp(entry->key.key.strkey, SWIG_LUA_ELUA_EMUL_METATABLE_KEY) == 0)
          is_metatable = 1;
        break;
      case  LUA_TNUMBER:
        lua_pushnumber(L,entry->key.key.numkey);
        break;
      case LUA_TNIL:
        lua_pushnil(L);
        break;
      default:
        assert(0);
    }
    switch(entry->value.type) {
      case LUA_TSTRING:
        lua_pushstring(L,entry->value.value.string);
        break;
      case  LUA_TNUMBER:
        lua_pushnumber(L,entry->value.value.number);
        break;
      case LUA_TFUNCTION:
        lua_pushcfunction(L,entry->value.value.function);
        break;
      case LUA_TTABLE:
        lua_rawgetp(L,parsed_tables_array, entry->value.value.table);
        table_parsed = !lua_isnil(L,-1);
        if(!table_parsed) {
          lua_pop(L,1); /*remove nil */
          lua_newtable(L);
          SWIG_Lua_elua_emulate_register(L,entry->value.value.table);
        } 
        if(is_metatable) {
          assert(lua_istable(L,-1));
          lua_pushvalue(L,-1);
          lua_setmetatable(L,target_table);
        }

        break;
      case LUA_TUSERDATA:
        if(entry->value.value.userdata.member) 
          SWIG_NewMemberObj(L,entry->value.value.userdata.pvalue,
              entry->value.value.userdata.lvalue,
              *(entry->value.value.userdata.ptype));
        else 
          SWIG_NewPointerObj(L,entry->value.value.userdata.pvalue,
              *(entry->value.value.userdata.ptype),0);
        break;
      case LUA_TNIL:
        lua_pushnil(L);
        break;
      default:
        assert(0);
    }
    assert(lua_gettop(L) == pairs_start + 2);
    lua_rawset(L,target_table);
  }
  lua_pop(L,1); /* Removing parsed tables storage */
  assert(lua_gettop(L) == target_table);
}

SWIGINTERN void SWIG_Lua_elua_emulate_register_clear(lua_State *L)
{
  lua_pushnil(L);
  lua_rawsetp(L, LUA_REGISTRYINDEX, &swig_lua_elua_emulate_unique_key);
}

SWIGINTERN void SWIG_Lua_get_class_registry(lua_State *L);

SWIGINTERN int SWIG_Lua_emulate_elua_getmetatable(lua_State *L)
{
  SWIG_check_num_args("getmetatable(SWIG eLua emulation)", 1, 1);
  SWIG_Lua_get_class_registry(L);
  lua_getfield(L,-1,"lua_getmetatable");
  lua_remove(L,-2); /* remove the registry*/
  assert(!lua_isnil(L,-1));
  lua_pushvalue(L,1);
  assert(lua_gettop(L) == 3); /* object | function | object again */
  lua_call(L,1,1);
  if(!lua_isnil(L,-1)) /*There is an ordinary metatable */
    return 1;
  /*if it is a table, then emulate elua behaviour - check for __metatable attribute of a table*/
  assert(lua_gettop(L) == 2);
  if(lua_istable(L,-2)) {
    lua_pop(L,1); /*remove the nil*/
    lua_getfield(L,-1, SWIG_LUA_ELUA_EMUL_METATABLE_KEY);
  }
  assert(lua_gettop(L) == 2);
  return 1;
  
fail:
  lua_error(L);
  return 0;
}

SWIGINTERN void SWIG_Lua_emulate_elua_swap_getmetatable(lua_State *L)
{
  SWIG_Lua_get_class_registry(L);
  lua_pushglobaltable(L);
  lua_pushstring(L,"lua_getmetatable");
  lua_getfield(L,-2,"getmetatable");
  assert(!lua_isnil(L,-1));
  lua_rawset(L,-4);
  lua_pushstring(L, "getmetatable");
  lua_pushcfunction(L, SWIG_Lua_emulate_elua_getmetatable);
  lua_rawset(L,-3);
  lua_pop(L,2);
      
}
/* END OF REMOVE */

#endif
/* -----------------------------------------------------------------------------
 * global variable support code: namespaces and modules (which are the same thing)
 * ----------------------------------------------------------------------------- */

SWIGINTERN int SWIG_Lua_namespace_get(lua_State *L)
{
/*  there should be 2 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
*/
  assert(lua_istable(L,-2));  /* just in case */
  lua_getmetatable(L,-2);
  assert(lua_istable(L,-1));
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));
  /* look for the key in the .get table */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_call(L,0,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: whether it's a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  return 0;
}

SWIGINTERN int SWIG_Lua_namespace_set(lua_State *L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
*/

  assert(lua_istable(L,1));
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,1,0);
      return 0;
    }
    lua_pop(L,1);  /* remove the value */
  }
  lua_pop(L,1);  /* remove the value .set table */
  lua_pop(L,1); /* remote metatable */
  lua_rawset(L,-3);
  return 0;
}

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA) /* In elua this is useless */
SWIGINTERN void SWIG_Lua_InstallConstants(lua_State *L, swig_lua_const_info constants[]); /* forward declaration */
SWIGINTERN void  SWIG_Lua_add_variable(lua_State *L,const char *name,lua_CFunction getFn,lua_CFunction setFn); /* forward declaration */
SWIGINTERN void  SWIG_Lua_class_register(lua_State *L,swig_lua_class *clss);

/* helper function - register namespace methods and attributes into namespace */
SWIGINTERN int SWIG_Lua_add_namespace_details(lua_State *L, swig_lua_namespace *ns)
{
  int i;
  /* There must be namespace table (not metatable) at the top of the stack */
  assert(lua_istable(L,-1));
  SWIG_Lua_InstallConstants(L, ns->ns_constants);

  /* add methods to the namespace/module table */
  for(i=0;ns->ns_methods[i].name;i++){
    SWIG_Lua_add_function(L,ns->ns_methods[i].name,ns->ns_methods[i].func);
  }
  lua_getmetatable(L,-1);

  /* add fns */
  for(i=0;ns->ns_attributes[i].name;i++){
    SWIG_Lua_add_variable(L,ns->ns_attributes[i].name,ns->ns_attributes[i].getmethod,ns->ns_attributes[i].setmethod);
  }

  /* clear stack - remove metatble */
  lua_pop(L,1);
  return 0;
}

/* Register all classes in the namespace */
SWIGINTERN void SWIG_Lua_add_namespace_classes(lua_State *L, swig_lua_namespace *ns)
{
  swig_lua_class **classes;

  /* There must be a module/namespace table at the top of the stack */
  assert(lua_istable(L,-1));

  classes = ns->ns_classes;

  if( classes != 0 ) {
    while(*classes != 0) {
      SWIG_Lua_class_register(L, *classes);
      classes++;
    }
  }
}

/* Helper function. Creates namespace table and adds it to module table
   if 'reg' is true, then will register namespace table to parent one (must be on top of the stack
   when function is called).
   Function always returns newly registered table on top of the stack.
*/
SWIGINTERN void SWIG_Lua_namespace_register(lua_State *L, swig_lua_namespace *ns, int reg)
{
  swig_lua_namespace **sub_namespace;
  /* 1 argument - table on the top of the stack */
  const int SWIGUNUSED begin = lua_gettop(L);
  assert(lua_istable(L,-1)); /* just in case. This is supposed to be module table or parent namespace table */
  lua_checkstack(L,5);
  lua_newtable(L); /* namespace itself */
  lua_newtable(L); /* metatable for namespace */

  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  lua_rawset(L,-3);

  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_namespace_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_namespace_set);

  lua_setmetatable(L,-2); /* set metatable */

  /* Register all functions, variables etc */
  SWIG_Lua_add_namespace_details(L,ns);
  /* Register classes */
  SWIG_Lua_add_namespace_classes(L,ns);

  sub_namespace = ns->ns_namespaces;
  if( sub_namespace != 0) {
    while(*sub_namespace != 0) {
      SWIG_Lua_namespace_register(L, *sub_namespace, 1);
      lua_pop(L,1); /* removing sub-namespace table */
      sub_namespace++;
    }
  }

  if (reg) {
    lua_pushstring(L,ns->name);
    lua_pushvalue(L,-2);
    lua_rawset(L,-4); /* add namespace to module table */
  }
  assert(lua_gettop(L) == begin+1);
}
#endif /* SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA */

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State *L,const char *cname);

typedef int (*swig_lua_base_iterator_func)(lua_State*,swig_type_info*, int, int *ret);

SWIGINTERN int SWIG_Lua_iterate_bases(lua_State *L, swig_type_info * SWIGUNUSED swig_type,
  int first_arg, swig_lua_base_iterator_func func, int  *const ret)
{
    /* first_arg - position of the object in stack. Everything that is above are arguments
     * and is passed to every evocation of the func */
    int last_arg = lua_gettop(L);/* position of last argument */
    int original_metatable = last_arg + 1;
    size_t bases_count;
    int result = SWIG_ERROR;
    int bases_table;
    (void)swig_type;
    lua_getmetatable(L,first_arg);

    /* initialise base search */
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
    SWIG_Lua_get_table(L,".bases");
    assert(lua_istable(L,-1));
    bases_count = lua_rawlen(L,-1);
    bases_table = lua_gettop(L);
#else
    /* In elua .bases table doesn't exist. Use table from swig_lua_class */
    (void)bases_table;
    assert(swig_type!=0);
    swig_module_info *module=SWIG_GetModule(L);
    swig_lua_class **bases= ((swig_lua_class*)(swig_type->clientdata))->bases;
    const char **base_names= ((swig_lua_class*)(swig_type->clientdata))->base_names;
    bases_count = 0;
    for(;base_names[bases_count];
      bases_count++);/* get length of bases */
#endif

    if(ret)
      *ret = 0;
    if(bases_count>0)
    {
      int to_remove;
      size_t i;
      int j;
      int subcall_last_arg;
      int subcall_first_arg = lua_gettop(L) + 1;/* Here a copy of first_arg and arguments begin */
      int valid = 1;
      swig_type_info *base_swig_type = 0;
      for(j=first_arg;j<=last_arg;j++)
        lua_pushvalue(L,j);
      subcall_last_arg = lua_gettop(L);

      /* Trick: temporarily replacing original metatable with metatable for base class and call getter */
      for(i=0;i<bases_count;i++) {
        /* Iteration through class bases */
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
        lua_rawgeti(L,bases_table,i+1);
        base_swig_type = 0;
        if(lua_isnil(L,-1)) {
          valid = 0;
          lua_pop(L,1);
        } else {
          valid = 1;
        }
#else /* In elua .bases table doesn't exist. Use table from swig_lua_class */
        swig_lua_class *base_class = bases[i];
        if(!base_class) {
          valid = 0;
        } else {
          valid = 1;
          SWIG_Lua_get_class_metatable(L,base_class->fqname);
          base_swig_type = SWIG_TypeQueryModule(module,module,base_names[i]);
          assert(base_swig_type != 0);
        }
#endif

        if(!valid)
          continue;
        assert(lua_isuserdata(L, subcall_first_arg));
        assert(lua_istable(L,-1));
        lua_setmetatable(L,subcall_first_arg); /* Set new metatable */
        assert(lua_gettop(L) == subcall_last_arg);
        result = func(L, base_swig_type,subcall_first_arg, ret); /* Forward call */
        if(result != SWIG_ERROR) {
          break;
        }
      }
      /* Restore original metatable */
      lua_pushvalue(L,original_metatable);
      lua_setmetatable(L,first_arg);
      /* Clear - remove everything between last_arg and subcall_last_arg including */
      to_remove = subcall_last_arg - last_arg;
      for(j=0;j<to_remove;j++)
        lua_remove(L,last_arg+1);
    } else {
      /* Remove everything after last_arg */
      lua_pop(L, lua_gettop(L) - last_arg);
    }
    if(ret) assert(lua_gettop(L) == last_arg + *ret);
    return result;
}

/* The class.get method helper, performs the lookup of class attributes.
 * It returns an error code. Number of function return values is passed inside 'ret'.
 * first_arg is not used in this function because function always has 2 arguments.
 */
SWIGINTERN int  SWIG_Lua_class_do_get(lua_State *L, swig_type_info *type, int SWIGUNUSED first_arg, int *ret)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  int bases_search_result;
  int substack_start = lua_gettop(L)-2;
  assert(first_arg == substack_start+1);
  lua_checkstack(L,5);
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  /* look for the key in the .get table */
  lua_pushvalue(L,substack_start+2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret)
      *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,substack_start+2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret)
      *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* NEW: looks for the __getitem() fn
  this is a user provided get fn */
  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_pushvalue(L,substack_start+2);  /* the parameter */
    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret) *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);
  /* Remove the metatable */
  lua_pop(L,1);
  /* Search in base classes */
  bases_search_result = SWIG_Lua_iterate_bases(L,type,substack_start+1,SWIG_Lua_class_do_get,ret);
  return bases_search_result;  /* sorry not known */
}

/* the class.get method, performs the lookup of class attributes
 */
SWIGINTERN int  SWIG_Lua_class_get(lua_State *L)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  int result;
  swig_lua_userdata *usr;
  swig_type_info *type;
  int ret = 0;
  assert(lua_isuserdata(L,1));
  usr=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  type = usr->type;
  result = SWIG_Lua_class_do_get(L,type,1,&ret);
  if(result == SWIG_OK)
    return ret;

  return 0;
}

/* helper for the class.set method, performs the lookup of class attributes
 * It returns error code. Number of function return values is passed inside 'ret'
 */
SWIGINTERN int  SWIG_Lua_class_do_set(lua_State *L, swig_type_info *type, int first_arg, int *ret)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
  */

  int bases_search_result;
  int substack_start = lua_gettop(L) - 3;
  lua_checkstack(L,5);
  assert(lua_isuserdata(L,substack_start+1));  /* just in case */
  lua_getmetatable(L,substack_start+1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  if(ret)
    *ret = 0; /* it is setter - number of return values is always 0 */

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,substack_start+2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,-2); /* tidy stack, remove .set table */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,substack_start+1);  /* userdata */
      lua_pushvalue(L,substack_start+3);  /* value */
      lua_call(L,2,0);
      lua_remove(L,substack_start+4); /*remove metatable*/
      return SWIG_OK;
    }
    lua_pop(L,1);  /* remove the value */
  } else {
    lua_pop(L,1);  /* remove the answer for .set table request*/
  }
  /* NEW: looks for the __setitem() fn
  this is a user provided set fn */
  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_pushvalue(L,substack_start+2);  /* the parameter */
    lua_pushvalue(L,substack_start+3);  /* the value */
    lua_call(L,3,0);  /* 3 values in ,0 out */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return SWIG_OK;
  }
  lua_pop(L,1); /* remove value */

  lua_pop(L,1); /* remove metatable */
  /* Search among bases */
  bases_search_result = SWIG_Lua_iterate_bases(L,type,first_arg,SWIG_Lua_class_do_set,ret);
  if(ret)
    assert(*ret == 0);
  assert(lua_gettop(L) == substack_start + 3);
  return bases_search_result;
}

/* This is the actual method exported to Lua. It calls SWIG_Lua_class_do_set and correctly
 * handles return values.
 */
SWIGINTERN int  SWIG_Lua_class_set(lua_State *L)
{
/*  There should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
  */
  int ret = 0;
  int result;
  swig_lua_userdata *usr;
  swig_type_info *type;
  assert(lua_isuserdata(L,1));
  usr=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  type = usr->type;
  result = SWIG_Lua_class_do_set(L,type,1,&ret);
  if(result != SWIG_OK) {
   SWIG_Lua_pushferrstring(L,"Assignment not possible. No setter/member with this name. For custom assignments implement __setitem method.");
   lua_error(L);
  } else {
    assert(ret==0);
  }
  return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State *L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata *usr;
  swig_lua_class *clss;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  /* if must be destroyed & has a destructor */
  if (usr->own) /* if must be destroyed */
  {
    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
    if (clss && clss->destructor)  /* there is a destroy fn */
    {
      clss->destructor(usr->ptr);  /* bye bye */
    }
  }
  return 0;
}

/* the class.__tostring method called by the interpreter and print */
SWIGINTERN int  SWIG_Lua_class_tostring(lua_State *L)
{
/*  there should be 1 param passed in
  (1) userdata (not the metatable) */
  const char *className;
  void* userData;
  assert(lua_isuserdata(L,1));  /* just in case */
  userData = lua_touserdata(L,1); /* get the userdata address for later */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */

  lua_getfield(L, -1, ".type");
  className = lua_tostring(L, -1);

  lua_pushfstring(L, "<%s userdata: %p>", className, userData);
  return 1;
}

/* to manually disown some userdata */
SWIGINTERN int  SWIG_Lua_class_disown(lua_State *L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata *usr;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  
  usr->own = 0; /* clear our ownership */
  return 0;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_class_equal(lua_State *L)
{
  int result;
  swig_lua_userdata *usr1,*usr2;
  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
    return 0;  /* nil reply */
  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
  result=(usr1->ptr==usr2->ptr);
   lua_pushboolean(L,result);
  return 1;
}

/* populate table at the top of the stack with metamethods that ought to be inherited */
SWIGINTERN void SWIG_Lua_populate_inheritable_metamethods(lua_State *L)
{
  SWIG_Lua_add_boolean(L, "__add", 1);
  SWIG_Lua_add_boolean(L, "__sub", 1);
  SWIG_Lua_add_boolean(L, "__mul", 1);
  SWIG_Lua_add_boolean(L, "__div", 1);
  SWIG_Lua_add_boolean(L, "__mod", 1);
  SWIG_Lua_add_boolean(L, "__pow", 1);
  SWIG_Lua_add_boolean(L, "__unm", 1);
  SWIG_Lua_add_boolean(L, "__len", 1 );
  SWIG_Lua_add_boolean(L, "__concat", 1 );
  SWIG_Lua_add_boolean(L, "__eq", 1);
  SWIG_Lua_add_boolean(L, "__lt", 1);
  SWIG_Lua_add_boolean(L, "__le", 1);
  SWIG_Lua_add_boolean(L, "__call", 1);
  SWIG_Lua_add_boolean(L, "__tostring", 1);
  SWIG_Lua_add_boolean(L, "__gc", 0);
}

/* creates the swig registry */
SWIGINTERN void SWIG_Lua_create_class_registry(lua_State *L)
{
  /* create main SWIG registry table */
  lua_pushstring(L,"SWIG");
  lua_newtable(L);
  /* populate it with some predefined data */

  /* .library table. Placeholder */
  lua_pushstring(L,".library");
  lua_newtable(L);
  {
    /* list of metamethods that class inherits from its bases */
    lua_pushstring(L,"inheritable_metamethods");
    lua_newtable(L);
    /* populate with list of metamethods */
    SWIG_Lua_populate_inheritable_metamethods(L);
    lua_rawset(L,-3);
  }
  lua_rawset(L,-3);

  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* gets the swig registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State *L)
{
  /* add this all into the swig registry: */
  lua_pushstring(L,"SWIG");
  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
  if (!lua_istable(L,-1))  /* not there */
  {  /* must be first time, so add it */
    lua_pop(L,1);  /* remove the result */
    SWIG_Lua_create_class_registry(L);
    /* then get it */
    lua_pushstring(L,"SWIG");
    lua_rawget(L,LUA_REGISTRYINDEX);
  }
}

SWIGINTERN void SWIG_Lua_get_inheritable_metamethods(lua_State *L)
{
  SWIG_Lua_get_class_registry(L);
  lua_pushstring(L, ".library");
  lua_rawget(L,-2);
  assert( !lua_isnil(L,-1) );
  lua_pushstring(L, "inheritable_metamethods");
  lua_rawget(L,-2);

  /* Remove class registry and library table */
  lua_remove(L,-2);
  lua_remove(L,-2);
}

/* Helper function to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State *L,const char *cname)
{
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,cname);  /* get the name */
  lua_rawget(L,-2);    /* get it */
  lua_remove(L,-2);    /* tidy up (remove registry) */
}

/* Set up the base classes pointers.
Each class structure has a list of pointers to the base class structures.
This function fills them.
It cannot be done at compile time, as this will not work with hireachies
spread over more than one swig file. 
Therefore it must be done at runtime, querying the SWIG type system.
*/
SWIGINTERN void SWIG_Lua_init_base_class(lua_State *L,swig_lua_class *clss)
{
  int i=0;
  swig_module_info *module=SWIG_GetModule(L);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* not found yet */
    {
      /* lookup and cache the base class */
      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
    }
  }
}

#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
/* Merges two tables  */
SWIGINTERN void SWIG_Lua_merge_tables_by_index(lua_State *L, int target, int source)
{
  /* iterating */
  lua_pushnil(L);
  while (lua_next(L,source) != 0) {
    /* -1 - value, -2 - index */
    /* have to copy to assign */
    lua_pushvalue(L,-2); /* copy of index */
    lua_pushvalue(L,-2); /* copy of value */
    lua_rawset(L, target);
    lua_pop(L,1);
    /* only key is left */
  }
}

/* Merges two tables with given name. original - index of target metatable, base - index of source metatable */
SWIGINTERN void SWIG_Lua_merge_tables(lua_State *L, const char* name, int original, int base)
{
  /* push original[name], then base[name] */
  lua_pushstring(L,name);
  lua_rawget(L,original);
  int original_table = lua_gettop(L);
  lua_pushstring(L,name);
  lua_rawget(L,base);
  int base_table = lua_gettop(L);
  SWIG_Lua_merge_tables_by_index(L, original_table, base_table);
  /* clearing stack */
  lua_pop(L,2);
}

/* Function takes all symbols from base and adds it to derived class. It's just a helper. */
SWIGINTERN void SWIG_Lua_class_squash_base(lua_State *L, swig_lua_class *base_cls)
{
  /* There is one parameter - original, i.e. 'derived' class metatable */
  assert(lua_istable(L,-1));
  int original = lua_gettop(L);
  SWIG_Lua_get_class_metatable(L,base_cls->fqname);
  int base = lua_gettop(L);
  SWIG_Lua_merge_tables(L, ".fn", original, base );
  SWIG_Lua_merge_tables(L, ".set", original, base );
  SWIG_Lua_merge_tables(L, ".get", original, base );
  lua_pop(L,1);
}

/* Function squashes all symbols from 'clss' bases into itself */
SWIGINTERN void  SWIG_Lua_class_squash_bases(lua_State *L, swig_lua_class *clss)
{
  int i;
  SWIG_Lua_get_class_metatable(L,clss->fqname);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* Somehow it's not found. Skip it */
      continue;
    /* Thing is: all bases are already registered. Thus they have already executed
     * this function. So we just need to squash them into us, because their bases
     * are already squashed into them. No need for recursion here!
     */
    SWIG_Lua_class_squash_base(L, clss->bases[i]);
  }
  lua_pop(L,1); /*tidy stack*/
}
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA) /* In elua this is useless */
/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_variable(lua_State *L,const char *name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* just in case */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
}

/* helper to recursively add class static details (static attributes, operations and constants) */
SWIGINTERN void SWIG_Lua_add_class_static_details(lua_State *L, swig_lua_class *clss)
{
  int i = 0;
  /* The class namespace table must be on the top of the stack */
  assert(lua_istable(L,-1));
  /* call all the base classes first: we can then override these later: */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_add_class_static_details(L,clss->bases[i]);
  }

  SWIG_Lua_add_namespace_details(L, clss->cls_static);
}

SWIGINTERN void SWIG_Lua_add_class_user_metamethods(lua_State *L, swig_lua_class *clss); /* forward declaration */

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_instance_details(lua_State *L, swig_lua_class *clss)
{
  int i;
  size_t bases_count = 0;
  /* Add bases to .bases table */
  SWIG_Lua_get_table(L,".bases");
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_get_class_metatable(L,clss->bases[i]->fqname);
    /* Base class must be already registered */
    assert(lua_istable(L,-1));
    lua_rawseti(L,-2,i+1); /* In lua indexing starts from 1 */
    bases_count++;
  }
  assert(lua_rawlen(L,-1) == bases_count);
  lua_pop(L,1); /* remove .bases table */
  /* add attributes */
  for(i=0;clss->attributes[i].name;i++){
    SWIG_Lua_add_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
  }
  /* add methods to the metatable */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->methods[i].name;i++){
    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].func);
  }
  lua_pop(L,1);       /* tidy stack (remove table) */
  /* add operator overloads
    This adds methods from metatable array to metatable. Can mess up garbage
    collectind if someone defines __gc method
    */
  if(clss->metatable) {
    for(i=0;clss->metatable[i].name;i++) {
      SWIG_Lua_add_function(L,clss->metatable[i].name,clss->metatable[i].func);
    }
  }

#if !defined(SWIG_LUA_SQUASH_BASES)
  /* Adding metamethods that are defined in base classes. If bases were squashed
   * then it is obviously unnecessary
   */
  SWIG_Lua_add_class_user_metamethods(L, clss);
#endif
}

/* Helpers to add user defined class metamedhods - __add, __sub etc. The helpers are needed
   for the following issue: Lua runtime checks for metamethod existence with rawget function
   ignoring our SWIG-provided __index and __newindex functions. Thus our inheritance-aware method
   search algorithm doesn't work in such case. (Not to say that Lua runtime queries metamethod directly
   in metatable and not in object).
   Current solution is this: if somewhere in hierarchy metamethod __x is defined, then all descendants
   are automatically given a special proxy __x that calls the real __x method.
   Obvious idea - to copy __x instead of creating __x-proxy is wrong because if someone changes __x in runtime,
   those changes must be reflected in all descendants.
*/

SWIGRUNTIME int SWIG_Lua_resolve_metamethod(lua_State *L); /*forward declaration*/

/* The real function that resolves a metamethod.
 * Function searches given class and all it's bases(recursively) for first instance of something that is
 * not equal to SWIG_Lua_resolve_metatmethod. (Almost always this 'something' is actual metamethod implementation
 * and it is a SWIG-generated C function.). It returns value on the top of the L and there is no garbage below the
 * answer.
 * Returns 1 if found, 0 otherwise.
 * clss is class which metatable we will search for method
 * metamethod_name_idx is index in L where metamethod name (as string) lies
 * skip_check allows to skip searching metamethod in givel clss and immideatelly go to searching in bases. skip_check
 * is not caried to subsequent recursive calls - false is always passed. It is set to true only at first call from
 * SWIG_Lua_resolve_metamethod
 * */
SWIGINTERN int SWIG_Lua_do_resolve_metamethod(lua_State *L, const swig_lua_class *clss, int metamethod_name_idx,
    int skip_check)
{
  /* This function is called recursively */
  int result = 0;
  int i = 0;

  if (!skip_check) {
    SWIG_Lua_get_class_metatable(L, clss->fqname);
    lua_pushvalue(L, metamethod_name_idx);
    lua_rawget(L,-2);
    /* If this is cfunction and it is equal to SWIG_Lua_resolve_metamethod then
     * this isn't the function we are looking for :)
     * lua_tocfunction will return NULL if not cfunction
     */
    if (!lua_isnil(L,-1) && lua_tocfunction(L,-1) != SWIG_Lua_resolve_metamethod ) {
      lua_remove(L,-2); /* removing class metatable */
      return 1;
    }
    lua_pop(L,2); /* remove class metatable and query result */
  }

  /* Forwarding calls to bases */
  for(i=0;clss->bases[i];i++)
  {
    result = SWIG_Lua_do_resolve_metamethod(L, clss->bases[i], metamethod_name_idx, 0);
    if (result)
      break;
  }

  return result;
}

/* The proxy function for metamethod. All parameters are passed as cclosure. Searches for actual method
 * and calls it */
SWIGRUNTIME int SWIG_Lua_resolve_metamethod(lua_State *L)
{
  int numargs;
  int metamethod_name_idx;
  const swig_lua_class* clss;
  int result;

  lua_checkstack(L,5);
  numargs = lua_gettop(L); /* number of arguments to pass to actual metamethod */
  
  /* Get upvalues from closure */
  lua_pushvalue(L, lua_upvalueindex(1)); /*Get function name*/
  metamethod_name_idx = lua_gettop(L);
  
  lua_pushvalue(L, lua_upvalueindex(2));
  clss = (const swig_lua_class*)(lua_touserdata(L,-1));
  lua_pop(L,1); /* remove lightuserdata with clss from stack */

  /* Actual work */
  result = SWIG_Lua_do_resolve_metamethod(L, clss, metamethod_name_idx, 1);
  if (!result) {
   SWIG_Lua_pushferrstring(L,"The metamethod proxy is set, but it failed to find actual metamethod. Memory corruption is most likely explanation.");
   lua_error(L);
   return 0;
  }

  lua_remove(L,-2); /* remove metamethod key */
  lua_insert(L,1); /* move function to correct position */
  lua_call(L, numargs, LUA_MULTRET);
  return lua_gettop(L); /* return all results */
}


/* If given metamethod must be present in given class, then creates appropriate proxy
 * Returns 1 if successfully added, 0 if not added because no base class has it, -1
 * if method is defined in the class metatable itself
 */
SWIGINTERN int SWIG_Lua_add_class_user_metamethod(lua_State *L, swig_lua_class *clss, const int metatable_index)
{
  int key_index;
  int success = 0;
  int i = 0;

  /* metamethod name - on the top of the stack */
  assert(lua_isstring(L,-1));
  
  key_index = lua_gettop(L);

  /* Check whether method is already defined in metatable */
  lua_pushvalue(L,key_index); /* copy of the key */
  lua_gettable(L,metatable_index);
  if( !lua_isnil(L,-1) ) {
    lua_pop(L,1);
    return -1;
  }
  lua_pop(L,1); 

  /* Iterating over immediate bases */
  for(i=0;clss->bases[i];i++)
  {
    const swig_lua_class *base = clss->bases[i];
    SWIG_Lua_get_class_metatable(L, base->fqname);
    lua_pushvalue(L, key_index);
    lua_rawget(L, -2);
    if( !lua_isnil(L,-1) ) {
      lua_pushvalue(L, key_index); 

      /* Add proxy function */
      lua_pushvalue(L, key_index); /* first closure value is function name */
      lua_pushlightuserdata(L, clss); /* second closure value is swig_lua_class structure */
      lua_pushcclosure(L, SWIG_Lua_resolve_metamethod, 2);
      
      lua_rawset(L, metatable_index);
      success = 1;
    }
    lua_pop(L,1); /* remove function or nil */
    lua_pop(L,1); /* remove base class metatable */

    if( success )
      break;
  }

  return success; 
}

SWIGINTERN void SWIG_Lua_add_class_user_metamethods(lua_State *L, swig_lua_class *clss)
{
  int metatable_index;
  int metamethods_info_index;
  int tostring_undefined;
  int eq_undefined = 0;

  SWIG_Lua_get_class_metatable(L, clss->fqname);
  metatable_index = lua_gettop(L);
  SWIG_Lua_get_inheritable_metamethods(L);
  assert(lua_istable(L,-1));
  metamethods_info_index = lua_gettop(L);
  lua_pushnil(L); /* first key */
  while(lua_next(L, metamethods_info_index) != 0 ) {
    /* key at index -2, value at index -1 */
    const int is_inheritable = lua_toboolean(L,-2);
    lua_pop(L,1); /* remove value - we don't need it anymore */

    if(is_inheritable) { /* if metamethod is inheritable */
      SWIG_Lua_add_class_user_metamethod(L,clss,metatable_index);
    }
  }

  lua_pop(L,1); /* remove inheritable metatmethods table */

  /* Special handling for __tostring method */
  lua_pushstring(L, "__tostring");
  lua_pushvalue(L,-1);
  lua_rawget(L,metatable_index);
  tostring_undefined = lua_isnil(L,-1);
  lua_pop(L,1);
  if( tostring_undefined ) {
    lua_pushcfunction(L, SWIG_Lua_class_tostring);
    lua_rawset(L, metatable_index);
  } else {
    lua_pop(L,1); /* remove copy of the key */
  }

  /* Special handling for __eq method */
  lua_pushstring(L, "__eq");
  lua_pushvalue(L,-1);
  lua_rawget(L,metatable_index);
  eq_undefined = lua_isnil(L,-1);
  lua_pop(L,1);
  if( eq_undefined ) {
    lua_pushcfunction(L, SWIG_Lua_class_equal);
    lua_rawset(L, metatable_index);
  } else {
    lua_pop(L,1); /* remove copy of the key */
  }
  /* Warning: __index and __newindex are SWIG-defined. For user-defined operator[]
   * a __getitem/__setitem method should be defined
   */
  lua_pop(L,1); /* pop class metatable */
}

/* Register class static methods,attributes etc as well as constructor proxy */
SWIGINTERN void SWIG_Lua_class_register_static(lua_State *L, swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  lua_checkstack(L,5); /* just in case */
  assert(lua_istable(L,-1));  /* just in case */
  assert(strcmp(clss->name, clss->cls_static->name) == 0); /* in class those 2 must be equal */

  SWIG_Lua_namespace_register(L,clss->cls_static, 1);

  assert(lua_istable(L,-1)); /* just in case */

  /*  add its constructor to module with the name of the class
  so you can do MyClass(...) as well as new_MyClass(...)
  BUT only if a constructor is defined
  (this overcomes the problem of pure virtual classes without constructors)*/
  if (clss->constructor)
  {
    lua_getmetatable(L,-1);
    assert(lua_istable(L,-1)); /* just in case */
    SWIG_Lua_add_function(L,"__call", clss->constructor);
    lua_pop(L,1);
  }

  assert(lua_istable(L,-1)); /* just in case */
  SWIG_Lua_add_class_static_details(L, clss);

  /* clear stack */
  lua_pop(L,1);
  assert( lua_gettop(L) == begin );
}

/* Performs the instance (non-static) class registration process. Metatable for class is created
 * and added to the class registry.
 */
SWIGINTERN void  SWIG_Lua_class_register_instance(lua_State *L,swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  int i;
  /* if name already there (class is already registered) then do nothing */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_rawget(L,-2);
  if(!lua_isnil(L,-1)) {
    lua_pop(L,2);
    assert(lua_gettop(L)==begin);
    return;
  }
  lua_pop(L,2); /* tidy stack */
  /* Recursively initialize all bases */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_class_register_instance(L,clss->bases[i]);
  }
  /* Again, get registry and push name */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_newtable(L);    /* create the metatable */
#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  /* If squashing is requested, then merges all bases metatable into this one.
   * It would get us all special methods: __getitem, __add etc.
   * This would set .fn, .type, and other .xxx incorrectly, but we will overwrite it right away
   */
  {
    int new_metatable_index = lua_absindex(L,-1);
    for(i=0;clss->bases[i];i++)
    {
      int base_metatable;
      SWIG_Lua_get_class_metatable(L,clss->bases[i]->fqname);
      base_metatable = lua_absindex(L,-1);
      SWIG_Lua_merge_tables_by_index(L,new_metatable_index, base_metatable);
      lua_pop(L,1);
    }
  }
  /* And now we will overwrite all incorrectly set data */
#endif
  /* add string of class name called ".type" */
  lua_pushstring(L,".type");
  lua_pushstring(L,clss->fqname);
  lua_rawset(L,-3);
  /* add a table called bases */
  lua_pushstring(L,".bases");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  /* add manual disown method */
  SWIG_Lua_add_function(L,"__disown",SWIG_Lua_class_disown);
  lua_rawset(L,-3);
  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
  /* add it */
  lua_rawset(L,-3);  /* metatable into registry */
  lua_pop(L,1);      /* tidy stack (remove registry) */
  assert(lua_gettop(L) == begin);

#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  /* Now merge all symbols from .fn, .set, .get etc from bases to our tables */
  SWIG_Lua_class_squash_bases(L,clss);
#endif
  SWIG_Lua_get_class_metatable(L,clss->fqname);
  SWIG_Lua_add_class_instance_details(L,clss);  /* recursive adding of details (atts & ops) */
  lua_pop(L,1);      /* tidy stack (remove class metatable) */
  assert( lua_gettop(L) == begin );
}

SWIGINTERN void  SWIG_Lua_class_register(lua_State *L,swig_lua_class *clss)
{
  int SWIGUNUSED begin;
  assert(lua_istable(L,-1)); /* This is a table (module or namespace) where classes will be added */
  SWIG_Lua_class_register_instance(L,clss);
  SWIG_Lua_class_register_static(L,clss);

  /* Add links from static part to instance part and vice versa */
  /* [SWIG registry]                                   [Module]
   *    "MyClass" ----> [MyClass metatable] <=====     "MyClass" -+> [static part]
   *                     ".get" ----> ...        |                |     getmetatable()----|
   *                     ".set" ----> ...        |                |                       |
   *                     ".static" --------------)----------------/           [static part metatable]
   *                                             |                                ".get" --> ...
   *                                             |                                ".set" --> ....
   *                                             |=============================== ".instance"
   */
  begin = lua_gettop(L);
  lua_pushstring(L,clss->cls_static->name);
  lua_rawget(L,-2); /* get class static table */
  assert(lua_istable(L,-1));
  lua_getmetatable(L,-1);
  assert(lua_istable(L,-1)); /* get class static metatable */
  lua_pushstring(L,".instance"); /* prepare key */

  SWIG_Lua_get_class_metatable(L,clss->fqname); /* get class metatable */
  assert(lua_istable(L,-1));
  lua_pushstring(L,".static"); /* prepare key */
  lua_pushvalue(L, -4); /* push static class TABLE */
  assert(lua_istable(L,-1));
  lua_rawset(L,-3); /* assign static class table(!NOT metatable) as ".static" member of class metatable */
  lua_rawset(L,-3); /* assign class metatable as ".instance" member of class static METATABLE */
  lua_pop(L,2);
  assert(lua_gettop(L) == begin);
}
#endif /* SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA */

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
SWIGINTERN void SWIG_Lua_elua_class_register_instance(lua_State *L, swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  int i;
  /* if name already there (class is already registered) then do nothing */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_rawget(L,-2);
  if(!lua_isnil(L,-1)) {
    lua_pop(L,2);
    assert(lua_gettop(L)==begin);
    return;
  }
  lua_pop(L,2); /* tidy stack */
  /* Recursively initialize all bases */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_elua_class_register_instance(L,clss->bases[i]);
  }
  /* Again, get registry and push name */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  assert(clss->metatable);
  lua_pushrotable(L, (void*)(clss->metatable));    /* create the metatable */
  lua_rawset(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == begin);
}
#endif /* elua && eluac */

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void SWIG_Lua_AddMetatable(lua_State *L,swig_type_info *type)
{
  if (type->clientdata)  /* there is clientdata: so add the metatable */
  {
    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->fqname);
    if (lua_istable(L,-1))
    {
      lua_setmetatable(L,-2);
    }
    else
    {
      lua_pop(L,1);
    }
  }
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State *L,void *ptr,swig_type_info *type, int own)
{
  swig_lua_userdata *usr;
  if (!ptr){
    lua_pushnil(L);
    return;
  }
  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
  usr->ptr=ptr;  /* set the ptr */
  usr->type=type;
  usr->own=own;
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  SWIG_Lua_AddMetatable(L,type); /* add metatable */
#endif
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State *L,int index,void **ptr,swig_type_info *type,int flags)
{
  swig_lua_userdata *usr;
  swig_cast_info *cast;
  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
  if (usr)
  {
    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
    {
        usr->own=0;
    }
    if (!type)            /* special cast void*, no casting fn */
    {
      *ptr=usr->ptr;
      return SWIG_OK; /* ok */
    }
    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
    if (cast)
    {
      int newmemory = 0;
      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
      return SWIG_OK;  /* ok */
    }
  }
  return SWIG_ERROR;  /* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State *L,int index,swig_type_info *type,int flags,
       int argnum,const char *func_name){
  void *result;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
    luaL_error (L,"Error in %s, expected a %s at argument number %d\n",
		func_name,(type && type->str)?type->str:"void*",argnum);
  }
  return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State *L,void *ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata *raw;
  assert(ptr); /* not acceptable to pass in a NULL value */
  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
  raw->type=type;
  raw->own=0;
  memcpy(raw->data,ptr,size); /* copy the data */
  SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State *L,int index,void *ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata *raw;
  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
  if (!raw) return SWIG_ERROR;  /* error */
  if (type==0 || type==raw->type) /* void* or identical type */
  {
    memcpy(ptr,raw->data,size); /* copy it */
    return SWIG_OK; /* ok */
  }
  return SWIG_ERROR;  /* error */
}

/* a function to get the typestring of a piece of data */
SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
{
  swig_lua_userdata *usr;
  if (lua_isuserdata(L,tp))
  {
    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
    if (usr && usr->type && usr->type->str)
      return usr->type->str;
    return "userdata (unknown type)";
  }
  return lua_typename(L,lua_type(L,tp));
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State *L)
{
  lua_pushstring(L,SWIG_Lua_typename(L,1));
  return 1;
}

/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State *L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
      lua_pushstring(L,constants[i].name);
      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
      lua_rawset(L,-3);
      break;
    default:
      break;
    }
  }
}
#endif

/* -----------------------------------------------------------------------------
 * executing lua code from within the wrapper
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
#endif
/* Executes a C string in Lua which is a really simple way of calling lua from C
Unfortunately lua keeps changing its APIs, so we need a conditional compile
In lua 5.0.X it's lua_dostring()
In lua 5.1.X it's luaL_dostring()
*/
SWIGINTERN int 
SWIG_Lua_dostring(lua_State *L, const char *str) {
  int ok,top;
  if (str==0 || str[0]==0) return 0; /* nothing to do */
  top=lua_gettop(L); /* save stack */
#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
#else
  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
#endif
  if (ok!=0) {
    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
  }
  lua_settop(L,top); /* restore the stack */
  return ok;
}    

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Array swig_types[0]
#define SWIGTYPE_p_BezTriples swig_types[1]
#define SWIGTYPE_p_BrickList swig_types[2]
#define SWIGTYPE_p_CollisionMask swig_types[3]
#define SWIGTYPE_p_CurvePoints swig_types[4]
#define SWIGTYPE_p_Gorilla__Layer swig_types[5]
#define SWIGTYPE_p_Gorilla__LineList swig_types[6]
#define SWIGTYPE_p_Gorilla__MarkupText swig_types[7]
#define SWIGTYPE_p_Gorilla__Rectangle swig_types[8]
#define SWIGTYPE_p_Gorilla__Screen swig_types[9]
#define SWIGTYPE_p_Gorilla__ScreenRenderable swig_types[10]
#define SWIGTYPE_p_Gorilla__Sprite swig_types[11]
#define SWIGTYPE_p_Gorilla__TextureAtlas swig_types[12]
#define SWIGTYPE_p_Gui3D__Button swig_types[13]
#define SWIGTYPE_p_Gui3D__Caption swig_types[14]
#define SWIGTYPE_p_Gui3D__Checkbox swig_types[15]
#define SWIGTYPE_p_Gui3D__Combobox swig_types[16]
#define SWIGTYPE_p_Gui3D__Listbox swig_types[17]
#define SWIGTYPE_p_Gui3D__PanelColors swig_types[18]
#define SWIGTYPE_p_Gui3D__PanelContainer swig_types[19]
#define SWIGTYPE_p_Gui3D__PanelElement swig_types[20]
#define SWIGTYPE_p_Gui3D__ProgressBar swig_types[21]
#define SWIGTYPE_p_Gui3D__Rectangle swig_types[22]
#define SWIGTYPE_p_Gui3D__ScrollBar swig_types[23]
#define SWIGTYPE_p_Gui3D__TextZone swig_types[24]
#define SWIGTYPE_p_Iterator swig_types[25]
#define SWIGTYPE_p_MyVehicle swig_types[26]
#define SWIGTYPE_p_OIS__MultiTouchState swig_types[27]
#define SWIGTYPE_p_Ogre__ColourValue swig_types[28]
#define SWIGTYPE_p_Ogre__Entity swig_types[29]
#define SWIGTYPE_p_Ogre__PbsMaterial swig_types[30]
#define SWIGTYPE_p_Ogre__Real swig_types[31]
#define SWIGTYPE_p_OpenSteer__AVGroup swig_types[32]
#define SWIGTYPE_p_OpenSteer__AbstractVehicle swig_types[33]
#define SWIGTYPE_p_OpenSteer__ObstacleGroup swig_types[34]
#define SWIGTYPE_p_OpenSteer__Vec3 swig_types[35]
#define SWIGTYPE_p_Rocket__Core__Element swig_types[36]
#define SWIGTYPE_p_Rocket__Core__Event swig_types[37]
#define SWIGTYPE_p_Rocket__Core__String swig_types[38]
#define SWIGTYPE_p_Rocket__Core__StringList swig_types[39]
#define SWIGTYPE_p_UTsize swig_types[40]
#define SWIGTYPE_p_btManifoldPoint swig_types[41]
#define SWIGTYPE_p_float swig_types[42]
#define SWIGTYPE_p_gkAccelerometerAbstract swig_types[43]
#define SWIGTYPE_p_gkAdditionNodeAbstract swig_types[44]
#define SWIGTYPE_p_gkAnimationDefinitionAbstract swig_types[45]
#define SWIGTYPE_p_gkAnimationPlayer swig_types[46]
#define SWIGTYPE_p_gkAnimationPlayerAbstract swig_types[47]
#define SWIGTYPE_p_gkAnimationTriggerAbstract swig_types[48]
#define SWIGTYPE_p_gkBoolNodeAbstract swig_types[49]
#define SWIGTYPE_p_gkCameraNodeAbstract swig_types[50]
#define SWIGTYPE_p_gkCameraProperties swig_types[51]
#define SWIGTYPE_p_gkCharacter swig_types[52]
#define SWIGTYPE_p_gkCharacterNodeAbstract swig_types[53]
#define SWIGTYPE_p_gkCollisionNodeAbstract swig_types[54]
#define SWIGTYPE_p_gkColor swig_types[55]
#define SWIGTYPE_p_gkCurveProperties swig_types[56]
#define SWIGTYPE_p_gkDebugger swig_types[57]
#define SWIGTYPE_p_gkDeltaNodeAbstract swig_types[58]
#define SWIGTYPE_p_gkDynamicsWorld swig_types[59]
#define SWIGTYPE_p_gkElementAbstract swig_types[60]
#define SWIGTYPE_p_gkEngineNodeAbstract swig_types[61]
#define SWIGTYPE_p_gkEntityProperties swig_types[62]
#define SWIGTYPE_p_gkFileNodeAbstract swig_types[63]
#define SWIGTYPE_p_gkFogParams swig_types[64]
#define SWIGTYPE_p_gkGameObject swig_types[65]
#define SWIGTYPE_p_gkGameObjectInstance swig_types[66]
#define SWIGTYPE_p_gkGameObjectProperties swig_types[67]
#define SWIGTYPE_p_gkGorillaRectangle swig_types[68]
#define SWIGTYPE_p_gkILogicSocket swig_types[69]
#define SWIGTYPE_p_gkIfNodeAbstract swig_types[70]
#define SWIGTYPE_p_gkJoystickButtonAbstract swig_types[71]
#define SWIGTYPE_p_gkJoystickNodeAbstract swig_types[72]
#define SWIGTYPE_p_gkKeyNodeAbstract swig_types[73]
#define SWIGTYPE_p_gkLightProperties swig_types[74]
#define SWIGTYPE_p_gkLogicManager swig_types[75]
#define SWIGTYPE_p_gkLogicNode swig_types[76]
#define SWIGTYPE_p_gkLogicTree swig_types[77]
#define SWIGTYPE_p_gkLuaCurState swig_types[78]
#define SWIGTYPE_p_gkLuaEvent swig_types[79]
#define SWIGTYPE_p_gkLuaNodeAbstract swig_types[80]
#define SWIGTYPE_p_gkMaterialProperties swig_types[81]
#define SWIGTYPE_p_gkMathNodeAbstract swig_types[82]
#define SWIGTYPE_p_gkMesh swig_types[83]
#define SWIGTYPE_p_gkMessageGetAbstract swig_types[84]
#define SWIGTYPE_p_gkMessageManager__Message swig_types[85]
#define SWIGTYPE_p_gkMessageSendAbstract swig_types[86]
#define SWIGTYPE_p_gkMotionNodeAbstract swig_types[87]
#define SWIGTYPE_p_gkMouseButtonAbstract swig_types[88]
#define SWIGTYPE_p_gkMouseNodeAbstract swig_types[89]
#define SWIGTYPE_p_gkNavPath swig_types[90]
#define SWIGTYPE_p_gkNoOpAbstract swig_types[91]
#define SWIGTYPE_p_gkNodeTreeNodeAbstract swig_types[92]
#define SWIGTYPE_p_gkObjectDataAbstract swig_types[93]
#define SWIGTYPE_p_gkObjectManipulatorAbstract swig_types[94]
#define SWIGTYPE_p_gkObjectNodeAbstract swig_types[95]
#define SWIGTYPE_p_gkPBSMaterialAbstract swig_types[96]
#define SWIGTYPE_p_gkPBSSlotAbstract swig_types[97]
#define SWIGTYPE_p_gkPBSTex_AlbedoAbstract swig_types[98]
#define SWIGTYPE_p_gkPBSTex_EnvAbstract swig_types[99]
#define SWIGTYPE_p_gkPBSTex_F0Abstract swig_types[100]
#define SWIGTYPE_p_gkPBSTex_NormalAbstract swig_types[101]
#define SWIGTYPE_p_gkParticleSettingsProperties swig_types[102]
#define SWIGTYPE_p_gkParticleSystemProperties swig_types[103]
#define SWIGTYPE_p_gkPhysicsConstraintProperties swig_types[104]
#define SWIGTYPE_p_gkPhysicsProperties swig_types[105]
#define SWIGTYPE_p_gkPickRayNodeAbstract swig_types[106]
#define SWIGTYPE_p_gkPrintNodeAbstract swig_types[107]
#define SWIGTYPE_p_gkProcessManager swig_types[108]
#define SWIGTYPE_p_gkPropertyAbstract swig_types[109]
#define SWIGTYPE_p_gkPropertyGetAbstract swig_types[110]
#define SWIGTYPE_p_gkQuaternion swig_types[111]
#define SWIGTYPE_p_gkRecastDebugger swig_types[112]
#define SWIGTYPE_p_gkScanCode swig_types[113]
#define SWIGTYPE_p_gkScene swig_types[114]
#define SWIGTYPE_p_gkSceneMaterial swig_types[115]
#define SWIGTYPE_p_gkSceneProperties swig_types[116]
#define SWIGTYPE_p_gkSceneRayObstacle swig_types[117]
#define SWIGTYPE_p_gkSceneSweptObstacle swig_types[118]
#define SWIGTYPE_p_gkScreenActionAbstract swig_types[119]
#define SWIGTYPE_p_gkSeqFinishedAbstract swig_types[120]
#define SWIGTYPE_p_gkSeqTimeAbstract swig_types[121]
#define SWIGTYPE_p_gkSequenceAbstract swig_types[122]
#define SWIGTYPE_p_gkSoundNodeAbstract swig_types[123]
#define SWIGTYPE_p_gkSoundProperties swig_types[124]
#define SWIGTYPE_p_gkSoundSceneProperties swig_types[125]
#define SWIGTYPE_p_gkSource swig_types[126]
#define SWIGTYPE_p_gkStateAbstract swig_types[127]
#define SWIGTYPE_p_gkStateMachineAbstract swig_types[128]
#define SWIGTYPE_p_gkStateMachineRefAbstract swig_types[129]
#define SWIGTYPE_p_gkStateManipulatorAbstract swig_types[130]
#define SWIGTYPE_p_gkStateRefAbstract swig_types[131]
#define SWIGTYPE_p_gkStateTransitionAbstract swig_types[132]
#define SWIGTYPE_p_gkSubMesh swig_types[133]
#define SWIGTYPE_p_gkTemplaterNodeAbstract swig_types[134]
#define SWIGTYPE_p_gkTestNodeAbstract swig_types[135]
#define SWIGTYPE_p_gkTextureProperties swig_types[136]
#define SWIGTYPE_p_gkTimerNodeAbstract swig_types[137]
#define SWIGTYPE_p_gkTransformState swig_types[138]
#define SWIGTYPE_p_gkTriangle swig_types[139]
#define SWIGTYPE_p_gkTypeBoolAbstract swig_types[140]
#define SWIGTYPE_p_gkTypeColorAbstract swig_types[141]
#define SWIGTYPE_p_gkTypeFloatAbstract swig_types[142]
#define SWIGTYPE_p_gkTypeIntAbstract swig_types[143]
#define SWIGTYPE_p_gkVariable swig_types[144]
#define SWIGTYPE_p_gkVector2 swig_types[145]
#define SWIGTYPE_p_gkVector3 swig_types[146]
#define SWIGTYPE_p_gkVectorDecompAbstract swig_types[147]
#define SWIGTYPE_p_gkVehicle swig_types[148]
#define SWIGTYPE_p_gkVehicleGearAbstract swig_types[149]
#define SWIGTYPE_p_gkVehicleGearboxAbstract swig_types[150]
#define SWIGTYPE_p_gkVehicleNodeAbstract swig_types[151]
#define SWIGTYPE_p_gkVehicleWheelAbstract swig_types[152]
#define SWIGTYPE_p_gkVertex swig_types[153]
#define SWIGTYPE_p_gsAccelerometerAbstract swig_types[154]
#define SWIGTYPE_p_gsActionActuator swig_types[155]
#define SWIGTYPE_p_gsActuator swig_types[156]
#define SWIGTYPE_p_gsActuatorSensor swig_types[157]
#define SWIGTYPE_p_gsAdditionNodeAbstract swig_types[158]
#define SWIGTYPE_p_gsAlwaysSensor swig_types[159]
#define SWIGTYPE_p_gsAnimationDefinitionAbstract swig_types[160]
#define SWIGTYPE_p_gsAnimationPlayer swig_types[161]
#define SWIGTYPE_p_gsAnimationPlayerAbstract swig_types[162]
#define SWIGTYPE_p_gsAnimationTriggerAbstract swig_types[163]
#define SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t swig_types[164]
#define SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t swig_types[165]
#define SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t swig_types[166]
#define SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t swig_types[167]
#define SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t swig_types[168]
#define SWIGTYPE_p_gsArrayIteratorT_gkProcess_t swig_types[169]
#define SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t swig_types[170]
#define SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t swig_types[171]
#define SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t swig_types[172]
#define SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t swig_types[173]
#define SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t swig_types[174]
#define SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t swig_types[175]
#define SWIGTYPE_p_gsBoolNodeAbstract swig_types[176]
#define SWIGTYPE_p_gsBrick swig_types[177]
#define SWIGTYPE_p_gsCamera swig_types[178]
#define SWIGTYPE_p_gsCameraNodeAbstract swig_types[179]
#define SWIGTYPE_p_gsCharacter swig_types[180]
#define SWIGTYPE_p_gsCharacterNodeAbstract swig_types[181]
#define SWIGTYPE_p_gsCollisionNodeAbstract swig_types[182]
#define SWIGTYPE_p_gsCollisionSensor swig_types[183]
#define SWIGTYPE_p_gsContactInfo swig_types[184]
#define SWIGTYPE_p_gsController swig_types[185]
#define SWIGTYPE_p_gsCurve swig_types[186]
#define SWIGTYPE_p_gsDebugger swig_types[187]
#define SWIGTYPE_p_gsDelaySensor swig_types[188]
#define SWIGTYPE_p_gsDeltaNodeAbstract swig_types[189]
#define SWIGTYPE_p_gsDynamicsWorld swig_types[190]
#define SWIGTYPE_p_gsEditObjectActuator swig_types[191]
#define SWIGTYPE_p_gsElementAbstract swig_types[192]
#define SWIGTYPE_p_gsEngine swig_types[193]
#define SWIGTYPE_p_gsEngineNodeAbstract swig_types[194]
#define SWIGTYPE_p_gsEntity swig_types[195]
#define SWIGTYPE_p_gsExpressionController swig_types[196]
#define SWIGTYPE_p_gsFSM swig_types[197]
#define SWIGTYPE_p_gsFileNodeAbstract swig_types[198]
#define SWIGTYPE_p_gsGUI swig_types[199]
#define SWIGTYPE_p_gsGUI3D swig_types[200]
#define SWIGTYPE_p_gsGUI3DButton swig_types[201]
#define SWIGTYPE_p_gsGUI3DCaption swig_types[202]
#define SWIGTYPE_p_gsGUI3DCheckbox swig_types[203]
#define SWIGTYPE_p_gsGUI3DCombobox swig_types[204]
#define SWIGTYPE_p_gsGUI3DElement swig_types[205]
#define SWIGTYPE_p_gsGUI3DListbox swig_types[206]
#define SWIGTYPE_p_gsGUI3DProgressbar swig_types[207]
#define SWIGTYPE_p_gsGUI3DRectangle swig_types[208]
#define SWIGTYPE_p_gsGUI3DScriptCallback swig_types[209]
#define SWIGTYPE_p_gsGUI3DScrollbar swig_types[210]
#define SWIGTYPE_p_gsGUI3DTextField swig_types[211]
#define SWIGTYPE_p_gsGameActuator swig_types[212]
#define SWIGTYPE_p_gsGameObject swig_types[213]
#define SWIGTYPE_p_gsGameObjectInstance swig_types[214]
#define SWIGTYPE_p_gsGorilla swig_types[215]
#define SWIGTYPE_p_gsGorillaLineList swig_types[216]
#define SWIGTYPE_p_gsGorillaRectangle swig_types[217]
#define SWIGTYPE_p_gsGorillaScreen swig_types[218]
#define SWIGTYPE_p_gsGorillaScreen3D swig_types[219]
#define SWIGTYPE_p_gsGorillaScreenFunctions swig_types[220]
#define SWIGTYPE_p_gsGorillaText swig_types[221]
#define SWIGTYPE_p_gsGuiDataFormatter swig_types[222]
#define SWIGTYPE_p_gsGuiDataSource swig_types[223]
#define SWIGTYPE_p_gsGuiDocumentRocket swig_types[224]
#define SWIGTYPE_p_gsGuiElement swig_types[225]
#define SWIGTYPE_p_gsGuiElementEventListener swig_types[226]
#define SWIGTYPE_p_gsGuiElementQuery swig_types[227]
#define SWIGTYPE_p_gsHUD swig_types[228]
#define SWIGTYPE_p_gsHUDElement swig_types[229]
#define SWIGTYPE_p_gsILogicSocket swig_types[230]
#define SWIGTYPE_p_gsIfNodeAbstract swig_types[231]
#define SWIGTYPE_p_gsJoystick swig_types[232]
#define SWIGTYPE_p_gsJoystickButtonAbstract swig_types[233]
#define SWIGTYPE_p_gsJoystickNodeAbstract swig_types[234]
#define SWIGTYPE_p_gsKeyNodeAbstract swig_types[235]
#define SWIGTYPE_p_gsKeyboard swig_types[236]
#define SWIGTYPE_p_gsKeyboardSensor swig_types[237]
#define SWIGTYPE_p_gsLight swig_types[238]
#define SWIGTYPE_p_gsLogicManager swig_types[239]
#define SWIGTYPE_p_gsLogicNode swig_types[240]
#define SWIGTYPE_p_gsLogicObject swig_types[241]
#define SWIGTYPE_p_gsLogicOpController swig_types[242]
#define SWIGTYPE_p_gsLogicTree swig_types[243]
#define SWIGTYPE_p_gsLuaManager swig_types[244]
#define SWIGTYPE_p_gsLuaNodeAbstract swig_types[245]
#define SWIGTYPE_p_gsLuaScript swig_types[246]
#define SWIGTYPE_p_gsLuaStream swig_types[247]
#define SWIGTYPE_p_gsMathNodeAbstract swig_types[248]
#define SWIGTYPE_p_gsMatrix4 swig_types[249]
#define SWIGTYPE_p_gsMesh swig_types[250]
#define SWIGTYPE_p_gsMessageActuator swig_types[251]
#define SWIGTYPE_p_gsMessageGetAbstract swig_types[252]
#define SWIGTYPE_p_gsMessageListenerCallback swig_types[253]
#define SWIGTYPE_p_gsMessageManager swig_types[254]
#define SWIGTYPE_p_gsMessageSendAbstract swig_types[255]
#define SWIGTYPE_p_gsMessageSensor swig_types[256]
#define SWIGTYPE_p_gsMotionActuator swig_types[257]
#define SWIGTYPE_p_gsMotionNodeAbstract swig_types[258]
#define SWIGTYPE_p_gsMouse swig_types[259]
#define SWIGTYPE_p_gsMouseButtonAbstract swig_types[260]
#define SWIGTYPE_p_gsMouseNodeAbstract swig_types[261]
#define SWIGTYPE_p_gsMouseSensor swig_types[262]
#define SWIGTYPE_p_gsMultiTouchState swig_types[263]
#define SWIGTYPE_p_gsNavPath swig_types[264]
#define SWIGTYPE_p_gsNearSensor swig_types[265]
#define SWIGTYPE_p_gsNetwork swig_types[266]
#define SWIGTYPE_p_gsNoOpAbstract swig_types[267]
#define SWIGTYPE_p_gsNodeTreeNodeAbstract swig_types[268]
#define SWIGTYPE_p_gsObject swig_types[269]
#define SWIGTYPE_p_gsObjectDataAbstract swig_types[270]
#define SWIGTYPE_p_gsObjectManipulatorAbstract swig_types[271]
#define SWIGTYPE_p_gsObjectNodeAbstract swig_types[272]
#define SWIGTYPE_p_gsPBSMaterialAbstract swig_types[273]
#define SWIGTYPE_p_gsPBSSlotAbstract swig_types[274]
#define SWIGTYPE_p_gsPBSTex_AlbedoAbstract swig_types[275]
#define SWIGTYPE_p_gsPBSTex_EnvAbstract swig_types[276]
#define SWIGTYPE_p_gsPBSTex_F0Abstract swig_types[277]
#define SWIGTYPE_p_gsPBSTex_NormalAbstract swig_types[278]
#define SWIGTYPE_p_gsParentActuator swig_types[279]
#define SWIGTYPE_p_gsParticles swig_types[280]
#define SWIGTYPE_p_gsPickRayNodeAbstract swig_types[281]
#define SWIGTYPE_p_gsPrintNodeAbstract swig_types[282]
#define SWIGTYPE_p_gsProcedural swig_types[283]
#define SWIGTYPE_p_gsProcess swig_types[284]
#define SWIGTYPE_p_gsProcessManager swig_types[285]
#define SWIGTYPE_p_gsProperty swig_types[286]
#define SWIGTYPE_p_gsPropertyAbstract swig_types[287]
#define SWIGTYPE_p_gsPropertyActuator swig_types[288]
#define SWIGTYPE_p_gsPropertyGetAbstract swig_types[289]
#define SWIGTYPE_p_gsPropertySensor swig_types[290]
#define SWIGTYPE_p_gsQuaternion swig_types[291]
#define SWIGTYPE_p_gsRadarSensor swig_types[292]
#define SWIGTYPE_p_gsRandomActuator swig_types[293]
#define SWIGTYPE_p_gsRandomSensor swig_types[294]
#define SWIGTYPE_p_gsRay swig_types[295]
#define SWIGTYPE_p_gsRaySensor swig_types[296]
#define SWIGTYPE_p_gsRayTest swig_types[297]
#define SWIGTYPE_p_gsRecastDebugger swig_types[298]
#define SWIGTYPE_p_gsRectangleDesigned swig_types[299]
#define SWIGTYPE_p_gsScene swig_types[300]
#define SWIGTYPE_p_gsSceneActuator swig_types[301]
#define SWIGTYPE_p_gsScreenActionAbstract swig_types[302]
#define SWIGTYPE_p_gsScriptController swig_types[303]
#define SWIGTYPE_p_gsSensor swig_types[304]
#define SWIGTYPE_p_gsSeqFinishedAbstract swig_types[305]
#define SWIGTYPE_p_gsSeqTimeAbstract swig_types[306]
#define SWIGTYPE_p_gsSequenceAbstract swig_types[307]
#define SWIGTYPE_p_gsSkeleton swig_types[308]
#define SWIGTYPE_p_gsSoundActuator swig_types[309]
#define SWIGTYPE_p_gsSoundManager swig_types[310]
#define SWIGTYPE_p_gsSoundNodeAbstract swig_types[311]
#define SWIGTYPE_p_gsSource swig_types[312]
#define SWIGTYPE_p_gsSprite swig_types[313]
#define SWIGTYPE_p_gsStateAbstract swig_types[314]
#define SWIGTYPE_p_gsStateActuator swig_types[315]
#define SWIGTYPE_p_gsStateMachineAbstract swig_types[316]
#define SWIGTYPE_p_gsStateMachineRefAbstract swig_types[317]
#define SWIGTYPE_p_gsStateManipulatorAbstract swig_types[318]
#define SWIGTYPE_p_gsStateRefAbstract swig_types[319]
#define SWIGTYPE_p_gsStateTransitionAbstract swig_types[320]
#define SWIGTYPE_p_gsStaticBatch swig_types[321]
#define SWIGTYPE_p_gsSteerGroup swig_types[322]
#define SWIGTYPE_p_gsSteerObject swig_types[323]
#define SWIGTYPE_p_gsSteerObstacleGroup swig_types[324]
#define SWIGTYPE_p_gsSteerPathFollowing swig_types[325]
#define SWIGTYPE_p_gsSteerRayObstacle swig_types[326]
#define SWIGTYPE_p_gsSteerSweptObstacle swig_types[327]
#define SWIGTYPE_p_gsSubMesh swig_types[328]
#define SWIGTYPE_p_gsSweptTest swig_types[329]
#define SWIGTYPE_p_gsTemplaterNodeAbstract swig_types[330]
#define SWIGTYPE_p_gsTestNodeAbstract swig_types[331]
#define SWIGTYPE_p_gsTextureAtlas swig_types[332]
#define SWIGTYPE_p_gsTimerNodeAbstract swig_types[333]
#define SWIGTYPE_p_gsTouch swig_types[334]
#define SWIGTYPE_p_gsTouchSensor swig_types[335]
#define SWIGTYPE_p_gsTween swig_types[336]
#define SWIGTYPE_p_gsTypeBoolAbstract swig_types[337]
#define SWIGTYPE_p_gsTypeColorAbstract swig_types[338]
#define SWIGTYPE_p_gsTypeFloatAbstract swig_types[339]
#define SWIGTYPE_p_gsTypeIntAbstract swig_types[340]
#define SWIGTYPE_p_gsUserDefs swig_types[341]
#define SWIGTYPE_p_gsVariable swig_types[342]
#define SWIGTYPE_p_gsVector2 swig_types[343]
#define SWIGTYPE_p_gsVector3 swig_types[344]
#define SWIGTYPE_p_gsVector4 swig_types[345]
#define SWIGTYPE_p_gsVectorDecompAbstract swig_types[346]
#define SWIGTYPE_p_gsVehicle swig_types[347]
#define SWIGTYPE_p_gsVehicleGearAbstract swig_types[348]
#define SWIGTYPE_p_gsVehicleGearboxAbstract swig_types[349]
#define SWIGTYPE_p_gsVehicleNodeAbstract swig_types[350]
#define SWIGTYPE_p_gsVehicleWheelAbstract swig_types[351]
#define SWIGTYPE_p_gsVisibilityActuator swig_types[352]
#define SWIGTYPE_p_gsWhenEvent swig_types[353]
#define SWIGTYPE_p_int swig_types[354]
#define SWIGTYPE_p_std__string swig_types[355]
#define SWIGTYPE_p_tsPanel swig_types[356]
#define SWIGTYPE_p_tsScriptCallbackList swig_types[357]
#define SWIGTYPE_p_utArrayT_gkGameObject_p_t swig_types[358]
#define SWIGTYPE_p_utArrayT_gkLogicActuator_p_t swig_types[359]
#define SWIGTYPE_p_utArrayT_gkLogicController_p_t swig_types[360]
#define SWIGTYPE_p_utArrayT_gkLogicLink_p_t swig_types[361]
#define SWIGTYPE_p_utArrayT_gkLogicSensor_p_t swig_types[362]
#define SWIGTYPE_p_utArrayT_gkPhysicsConstraintProperties_t swig_types[363]
#define SWIGTYPE_p_utArrayT_gkProcess_p_t swig_types[364]
#define SWIGTYPE_p_utArrayT_gkString_t swig_types[365]
#define SWIGTYPE_p_utArrayT_gkVector3_t swig_types[366]
#define SWIGTYPE_p_utArrayT_utArrayT_gkVector3_t_t swig_types[367]
#define SWIGTYPE_p_utMemoryStream swig_types[368]
static swig_type_info *swig_types[370];
static swig_module_info swig_module = {swig_types, 369, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_name      "OgreKit"
#define SWIG_init      luaopen_OgreKit
#define SWIG_init_user luaopen_OgreKit_user

#define SWIG_LUACODE   luaopen_OgreKit_luacode

namespace swig {
typedef struct{} LANGUAGE_OBJ;
}


#include "gsCommon.h"


#include <string>


SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
  int ret = lua_isstring(L, idx);
  if (!ret)
   ret = lua_isnil(L, idx);
  return ret;
}


#include "gsUtils.h"


#include "gsMath.h"


#include "gsCore.h" 
#include "OISMultiTouch.h"


#include "gsGUI.h"


#include "gsAI.h"


#include "gsAnimation.h"


#include "gsBricks.h"


#include "gsNetwork.h"


#include "gsNodes.h"
#include "gsGamekit.h"
#include "gkGamekit.h"



#include "gsPhysics.h"


#include "gsSound.h"


static int gsGetProperty(lua_State *L, const gsProperty& prop)
{
	int SWIG_arg= 0;
	switch (prop.getType())
	{
	case PROP_BOOL:
		lua_pushboolean(L, prop.toBool()); 
		SWIG_arg++;
		break;
	case PROP_NUMBER:
		lua_pushnumber(L, prop.toNumber()); 
		SWIG_arg++;
		break;
	case PROP_STRING:
		{
			gkString str = prop.toString();
			lua_pushlstring(L, str.c_str(), str.size());
			SWIG_arg++;
			break;
		}
	}
	
	return SWIG_arg;
}

#define GS_TYPEOF(a, b)   ((a) && typeid(*a) == typeid(b))
#define GS_TYPE_RET(GK, GS, T) if (GS_TYPEOF(GK, gk##T)) { SWIG_NewPointerObj(L, GS, SWIGTYPE_p_##gs##T, 1); return 1; }

// ------------------------------------------------------------------------------
// Convert & store gk<Class> objects as gs<Class> with consistent userdata values
// ------------------------------------------------------------------------------
template <class GKTYPE, class GSTYPE>
static int gsLuaStoreAndReturnObject(lua_State *L, GKTYPE* obj, const char* className, swig_type_info* swigTypeInfo)
{
    // Early exit on nil
    if (!obj)
    {
        lua_pushnil(L);
        return 1;
    }
    
    // Create the storage name
    char tableName[256];
    sprintf(tableName, ".gsCache{%s}", className);
    
    // Try to get the table in which the objects would be stored
    lua_pushstring(L, tableName);
    lua_rawget(L,     LUA_REGISTRYINDEX);
    
    // If that did not work - create it and put it on top
    if (!lua_istable(L, -1))
    {
        lua_pushstring(L, tableName);
        lua_newtable(L);
        
        lua_createtable(L,  0, 1);
        lua_pushstring(L,   "v");
        lua_setfield(L,     -2, "__mode");
        lua_setmetatable(L, -2);
        
        lua_rawset(L, LUA_REGISTRYINDEX);
        
        // Try to get the table
        lua_pushstring(L, tableName);
        lua_rawget(L,     LUA_REGISTRYINDEX);
    }
    
    // We now have a table to get the user data from - so check if it's there
    lua_pushlightuserdata(L, obj);
    lua_gettable(L, -2);
    
    if (lua_isnil(L, -1))
    {
        // We no longer need the nil value
        lua_pop(L, 1);
        
        // Push the pointer value onto the stack (as the key)
        lua_pushlightuserdata(L, obj);
        
        // Create and push the value
        GSTYPE* wrappedObject = new GSTYPE(obj);
        SWIG_NewPointerObj(L, wrappedObject, swigTypeInfo, 1);
        
        // Store it in the table
        lua_settable(L, -3);
        
        // Reget the value from the table
        lua_pushlightuserdata(L, obj);
        lua_gettable(L, -2);
    }
    return 1;
}

#define GS_LUA_OBJECT_WRAP_STORE(OBJ, T, WT) gsLuaStoreAndReturnObject<gk##T, gs##WT>(L, (gk##T*)OBJ, #WT, SWIGTYPE_p_##gs##WT)
#define GS_LUA_OBJECT_STORE(OBJ, T) GS_LUA_OBJECT_WRAP_STORE(OBJ, T, T)
#define GS_LUA_OBJECT_RET(OBJ, T) if (GS_TYPEOF(OBJ, gk##T)) { return GS_LUA_OBJECT_STORE(OBJ, T); }
#define GS_LUA_OBJECT_WRAP_RET(OBJ, T, WT) if (GS_TYPEOF(OBJ, gk##T)) { return GS_LUA_OBJECT_WRAP_STORE(OBJ, T, WT); }

#define GS_LUA_OBJECT_WRAP_RET2(OBJ, T, WT) if (OBJ->getType()==gk##T::getStaticType()) { return GS_LUA_OBJECT_WRAP_STORE(OBJ, T, WT); }

static int gsWrapGameObject(lua_State *L, gkGameObject *obj)
{    
    //gkPrintf("Object Size: %d\n", (int)sizeof(gsParticles));
    GS_LUA_OBJECT_RET(obj, Camera);
    GS_LUA_OBJECT_RET(obj, Entity);
    GS_LUA_OBJECT_RET(obj, Light);
    GS_LUA_OBJECT_RET(obj, Skeleton);
    GS_LUA_OBJECT_RET(obj, Curve);
    GS_LUA_OBJECT_WRAP_RET(obj, ParticleObject, Particles);
    
    return GS_LUA_OBJECT_STORE(obj, GameObject);
}

static int gsWrapLogicNode(lua_State *L, gkLogicNode *obj)
{    
    //gkPrintf("Object Size: %d\n", (int)sizeof(gsParticles));
    GS_LUA_OBJECT_WRAP_RET2(obj, TestNodeAbstract,TestNodeAbstract);
    
    return GS_LUA_OBJECT_STORE(obj, LogicNode);
}


static int gsWrapSensor(lua_State *L, gkLogicSensor *obj)
{    
    GS_LUA_OBJECT_RET(obj, ActuatorSensor);
    GS_LUA_OBJECT_RET(obj, AlwaysSensor);
    GS_LUA_OBJECT_RET(obj, KeyboardSensor);
    GS_LUA_OBJECT_RET(obj, CollisionSensor);
    GS_LUA_OBJECT_RET(obj, DelaySensor);
    GS_LUA_OBJECT_RET(obj, MessageSensor);
    GS_LUA_OBJECT_RET(obj, MouseSensor);
    GS_LUA_OBJECT_RET(obj, NearSensor);
    GS_LUA_OBJECT_RET(obj, PropertySensor);
    GS_LUA_OBJECT_RET(obj, RaySensor);
    GS_LUA_OBJECT_RET(obj, RadarSensor);
    GS_LUA_OBJECT_RET(obj, RandomSensor);
    
    return GS_LUA_OBJECT_WRAP_STORE(obj, LogicSensor, Sensor);
}
    
static int gsWrapController(lua_State *L, gkLogicController *obj)
{    
    GS_LUA_OBJECT_RET(obj, LogicOpController);
    GS_LUA_OBJECT_RET(obj, ScriptController);
    GS_LUA_OBJECT_RET(obj, ExpressionController);
    
    return GS_LUA_OBJECT_WRAP_STORE(obj, LogicController, Controller);
}

static int gsWrapActuator(lua_State *L, gkLogicActuator *obj)
{    
    GS_LUA_OBJECT_RET(obj, ActionActuator);
    GS_LUA_OBJECT_RET(obj, EditObjectActuator);
    GS_LUA_OBJECT_RET(obj, GameActuator);
    GS_LUA_OBJECT_RET(obj, MessageActuator);
    GS_LUA_OBJECT_RET(obj, MotionActuator);
    GS_LUA_OBJECT_RET(obj, ParentActuator);
    GS_LUA_OBJECT_RET(obj, PropertyActuator);
    GS_LUA_OBJECT_RET(obj, RandomActuator);
    GS_LUA_OBJECT_RET(obj, SceneActuator);
    GS_LUA_OBJECT_RET(obj, SoundActuator);
    GS_LUA_OBJECT_RET(obj, StateActuator);
    GS_LUA_OBJECT_RET(obj, VisibilityActuator);

    return GS_LUA_OBJECT_WRAP_STORE(obj, LogicActuator, Actuator);
}


// ------------------------------------------------------------------------------



#include "gsScript.h"


#include "gsProcess.h"


#include "gsGUI3D.h"

#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_new_string__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  std::string *result = 0 ;
  
  SWIG_check_num_args("std::string::string",0,0)
  result = (std::string *)new std::string();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_string__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_num_args("std::string::string",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("std::string::string",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (std::string *)new std::string((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_string(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_string__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = SWIG_lua_isnilstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_string__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_string'\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::string::string()\n"
    "    std::string::string(char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_string_size(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::string::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::size",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_size",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_length(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::string::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::length",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_length",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_empty(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  bool result;
  
  SWIG_check_num_args("std::string::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::empty",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_empty",1,SWIGTYPE_p_std__string);
  }
  
  result = (bool)((std::string const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_c_str(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("std::string::c_str",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::c_str",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_c_str",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->c_str();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_data(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("std::string::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::data",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_data",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->data();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_assign(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("std::string::assign",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::assign",1,"std::string *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("std::string::assign",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_assign",1,SWIGTYPE_p_std__string);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->assign((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_string(void *obj) {
std::string *arg1 = (std::string *) obj;
delete arg1;
}
static int _proxy__wrap_new_string(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_string);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_string_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_string_methods[]= {
    { "size", _wrap_string_size},
    { "length", _wrap_string_length},
    { "empty", _wrap_string_empty},
    { "c_str", _wrap_string_c_str},
    { "data", _wrap_string_data},
    { "assign", _wrap_string_assign},
    {0,0}
};
static swig_lua_method swig_string_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_string_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_string_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_string_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_string_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_string_Sf_SwigStatic = {
    "string",
    swig_string_Sf_SwigStatic_methods,
    swig_string_Sf_SwigStatic_attributes,
    swig_string_Sf_SwigStatic_constants,
    swig_string_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_string_bases[] = {0};
static const char *swig_string_base_names[] = {0};
static swig_lua_class _wrap_class_string = { "string", "string", &SWIGTYPE_p_std__string,_proxy__wrap_new_string, swig_delete_string, swig_string_methods, swig_string_attributes, &swig_string_Sf_SwigStatic, swig_string_meta, swig_string_bases, swig_string_base_names };

static int _wrap_new_gkTextureProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *result = 0 ;
  
  SWIG_check_num_args("gkTextureProperties::gkTextureProperties",0,0)
  result = (gkTextureProperties *)new gkTextureProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkTextureProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_name_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_name",1,"gkTextureProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkTextureProperties::m_name",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_name_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_name_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkTextureProperties::m_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_name",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_name_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result =  ((arg1)->m_name);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_image_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_image",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_image",1,"gkTextureProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkTextureProperties::m_image",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_image_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_image = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_image_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkTextureProperties::m_image",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_image",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_image_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result =  ((arg1)->m_image);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_color_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkTextureProperties::m_color",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_color",1,"gkTextureProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkTextureProperties::m_color",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_color_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkTextureProperties_m_color_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_color = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_color_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkTextureProperties::m_color",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_color",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_color_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (gkColor *)& ((arg1)->m_color);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_layer_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_layer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_layer",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_layer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_layer_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_layer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_layer_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_layer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_layer",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_layer_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_layer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_type",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_type_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_type",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_type_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_blend_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_blend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_blend",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_blend",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_blend_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_blend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_blend_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_blend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_blend",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_blend_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_blend);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_mode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_mode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_mode",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_mode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_mode_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_mode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_mode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_mode",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_mode_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_mode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_texmode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_texmode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_texmode",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_texmode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_texmode_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_texmode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_texmode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_texmode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_texmode",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_texmode_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_texmode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_mix_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_mix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_mix",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_mix",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_mix_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mix = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_mix_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_mix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_mix",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_mix_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_mix);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_normalFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_normalFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_normalFactor",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_normalFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_normalFactor_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_normalFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_normalFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_normalFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_normalFactor",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_normalFactor_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_normalFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_diffuseColorFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_diffuseColorFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_diffuseColorFactor",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_diffuseColorFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_diffuseColorFactor_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_diffuseColorFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_diffuseColorFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_diffuseColorFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_diffuseColorFactor",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_diffuseColorFactor_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_diffuseColorFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_diffuseAlpahFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_diffuseAlpahFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_diffuseAlpahFactor",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_diffuseAlpahFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_diffuseAlpahFactor_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_diffuseAlpahFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_diffuseAlpahFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_diffuseAlpahFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_diffuseAlpahFactor",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_diffuseAlpahFactor_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_diffuseAlpahFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_speculaColorFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_speculaColorFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_speculaColorFactor",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_speculaColorFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_speculaColorFactor_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_speculaColorFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_speculaColorFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_speculaColorFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_speculaColorFactor",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_speculaColorFactor_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_speculaColorFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_speculaHardFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_speculaHardFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_speculaHardFactor",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_speculaHardFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_speculaHardFactor_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_speculaHardFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_speculaHardFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkTextureProperties::m_speculaHardFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_speculaHardFactor",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_speculaHardFactor_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (float) ((arg1)->m_speculaHardFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_scale_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkTextureProperties::m_scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_scale",1,"gkTextureProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkTextureProperties::m_scale",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_scale_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkTextureProperties_m_scale_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_scale = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_scale_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkTextureProperties::m_scale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_scale",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_scale_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_scale);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_isActive_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_isActive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_isActive",1,"gkTextureProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkTextureProperties::m_isActive",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_isActive_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_isActive = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_isActive_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkTextureProperties::m_isActive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_isActive",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_isActive_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (bool) ((arg1)->m_isActive);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_startFrame_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_startFrame",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_startFrame",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_startFrame",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_startFrame_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_startFrame = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_startFrame_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_startFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_startFrame",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_startFrame_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_startFrame);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_currentFrame_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_currentFrame",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_currentFrame",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_currentFrame",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_currentFrame_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_currentFrame = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_currentFrame_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_currentFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_currentFrame",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_currentFrame_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_currentFrame);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_framesToUse_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_framesToUse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_framesToUse",1,"gkTextureProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTextureProperties::m_framesToUse",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_framesToUse_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_framesToUse = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_framesToUse_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTextureProperties::m_framesToUse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_framesToUse",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_framesToUse_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (int) ((arg1)->m_framesToUse);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_isCyclic_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkTextureProperties::m_isCyclic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_isCyclic",1,"gkTextureProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkTextureProperties::m_isCyclic",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_isCyclic_set",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_isCyclic = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTextureProperties_m_isCyclic_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureProperties *arg1 = (gkTextureProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkTextureProperties::m_isCyclic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTextureProperties::m_isCyclic",1,"gkTextureProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkTextureProperties_m_isCyclic_get",1,SWIGTYPE_p_gkTextureProperties);
  }
  
  result = (bool) ((arg1)->m_isCyclic);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkTextureProperties(void *obj) {
gkTextureProperties *arg1 = (gkTextureProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkTextureProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkTextureProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkTextureProperties_attributes[] = {
    { "m_name", _wrap_gkTextureProperties_m_name_get, _wrap_gkTextureProperties_m_name_set },
    { "m_image", _wrap_gkTextureProperties_m_image_get, _wrap_gkTextureProperties_m_image_set },
    { "m_color", _wrap_gkTextureProperties_m_color_get, _wrap_gkTextureProperties_m_color_set },
    { "m_layer", _wrap_gkTextureProperties_m_layer_get, _wrap_gkTextureProperties_m_layer_set },
    { "m_type", _wrap_gkTextureProperties_m_type_get, _wrap_gkTextureProperties_m_type_set },
    { "m_blend", _wrap_gkTextureProperties_m_blend_get, _wrap_gkTextureProperties_m_blend_set },
    { "m_mode", _wrap_gkTextureProperties_m_mode_get, _wrap_gkTextureProperties_m_mode_set },
    { "m_texmode", _wrap_gkTextureProperties_m_texmode_get, _wrap_gkTextureProperties_m_texmode_set },
    { "m_mix", _wrap_gkTextureProperties_m_mix_get, _wrap_gkTextureProperties_m_mix_set },
    { "m_normalFactor", _wrap_gkTextureProperties_m_normalFactor_get, _wrap_gkTextureProperties_m_normalFactor_set },
    { "m_diffuseColorFactor", _wrap_gkTextureProperties_m_diffuseColorFactor_get, _wrap_gkTextureProperties_m_diffuseColorFactor_set },
    { "m_diffuseAlpahFactor", _wrap_gkTextureProperties_m_diffuseAlpahFactor_get, _wrap_gkTextureProperties_m_diffuseAlpahFactor_set },
    { "m_speculaColorFactor", _wrap_gkTextureProperties_m_speculaColorFactor_get, _wrap_gkTextureProperties_m_speculaColorFactor_set },
    { "m_speculaHardFactor", _wrap_gkTextureProperties_m_speculaHardFactor_get, _wrap_gkTextureProperties_m_speculaHardFactor_set },
    { "m_scale", _wrap_gkTextureProperties_m_scale_get, _wrap_gkTextureProperties_m_scale_set },
    { "m_isActive", _wrap_gkTextureProperties_m_isActive_get, _wrap_gkTextureProperties_m_isActive_set },
    { "m_startFrame", _wrap_gkTextureProperties_m_startFrame_get, _wrap_gkTextureProperties_m_startFrame_set },
    { "m_currentFrame", _wrap_gkTextureProperties_m_currentFrame_get, _wrap_gkTextureProperties_m_currentFrame_set },
    { "m_framesToUse", _wrap_gkTextureProperties_m_framesToUse_get, _wrap_gkTextureProperties_m_framesToUse_set },
    { "m_isCyclic", _wrap_gkTextureProperties_m_isCyclic_get, _wrap_gkTextureProperties_m_isCyclic_set },
    {0,0,0}
};
static swig_lua_method swig_gkTextureProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkTextureProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkTextureProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkTextureProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("TM_SPLAT", gkTextureProperties::TM_SPLAT)},
    {SWIG_LUA_CONSTTAB_INT("TM_INVERT", gkTextureProperties::TM_INVERT)},
    {SWIG_LUA_CONSTTAB_INT("TM_ALPHA", gkTextureProperties::TM_ALPHA)},
    {SWIG_LUA_CONSTTAB_INT("TM_SPECULAR", gkTextureProperties::TM_SPECULAR)},
    {SWIG_LUA_CONSTTAB_INT("TM_EMMISIVE", gkTextureProperties::TM_EMMISIVE)},
    {SWIG_LUA_CONSTTAB_INT("TM_AMBIENT", gkTextureProperties::TM_AMBIENT)},
    {SWIG_LUA_CONSTTAB_INT("TM_REFRACTION", gkTextureProperties::TM_REFRACTION)},
    {SWIG_LUA_CONSTTAB_INT("TM_MIRROR", gkTextureProperties::TM_MIRROR)},
    {SWIG_LUA_CONSTTAB_INT("TM_NORMAL", gkTextureProperties::TM_NORMAL)},
    {SWIG_LUA_CONSTTAB_INT("TX_NEGATIVE", gkTextureProperties::TX_NEGATIVE)},
    {SWIG_LUA_CONSTTAB_INT("TX_STENCIL", gkTextureProperties::TX_STENCIL)},
    {SWIG_LUA_CONSTTAB_INT("TX_RGBTOINTEN", gkTextureProperties::TX_RGBTOINTEN)},
    {SWIG_LUA_CONSTTAB_INT("TX_OBJ_SPACE", gkTextureProperties::TX_OBJ_SPACE)},
    {SWIG_LUA_CONSTTAB_INT("IMT_IMAGE", gkTextureProperties::IMT_IMAGE)},
    {SWIG_LUA_CONSTTAB_INT("IMT_CUBEMAP", gkTextureProperties::IMT_CUBEMAP)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkTextureProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkTextureProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkTextureProperties_Sf_SwigStatic = {
    "gkTextureProperties",
    swig_gkTextureProperties_Sf_SwigStatic_methods,
    swig_gkTextureProperties_Sf_SwigStatic_attributes,
    swig_gkTextureProperties_Sf_SwigStatic_constants,
    swig_gkTextureProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkTextureProperties_bases[] = {0};
static const char *swig_gkTextureProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkTextureProperties = { "gkTextureProperties", "gkTextureProperties", &SWIGTYPE_p_gkTextureProperties,_proxy__wrap_new_gkTextureProperties, swig_delete_gkTextureProperties, swig_gkTextureProperties_methods, swig_gkTextureProperties_attributes, &swig_gkTextureProperties_Sf_SwigStatic, swig_gkTextureProperties_meta, swig_gkTextureProperties_bases, swig_gkTextureProperties_base_names };

static int _wrap_new_gkMaterialProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *result = 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::gkMaterialProperties",0,0)
  result = (gkMaterialProperties *)new gkMaterialProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkMaterialProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_getTextureProp(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int arg2 ;
  gkTextureProperties *result = 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::getTextureProp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::getTextureProp",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::getTextureProp",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_getTextureProp",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkTextureProperties *) &(arg1)->getTextureProp(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkTextureProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_name_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_name",1,"gkMaterialProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkMaterialProperties::m_name",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_name_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_name_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkMaterialProperties::m_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_name",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_name_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result =  ((arg1)->m_name);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_vertexProgram_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_vertexProgram",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_vertexProgram",1,"gkMaterialProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkMaterialProperties::m_vertexProgram",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_vertexProgram_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_vertexProgram = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_vertexProgram_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkMaterialProperties::m_vertexProgram",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_vertexProgram",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_vertexProgram_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result =  ((arg1)->m_vertexProgram);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_fragmentProgram_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_fragmentProgram",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_fragmentProgram",1,"gkMaterialProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkMaterialProperties::m_fragmentProgram",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_fragmentProgram_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_fragmentProgram = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_fragmentProgram_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkMaterialProperties::m_fragmentProgram",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_fragmentProgram",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_fragmentProgram_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result =  ((arg1)->m_fragmentProgram);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_ignoreBlenderTextures_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_ignoreBlenderTextures",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_ignoreBlenderTextures",1,"gkMaterialProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkMaterialProperties::m_ignoreBlenderTextures",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_ignoreBlenderTextures_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_ignoreBlenderTextures = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_ignoreBlenderTextures_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkMaterialProperties::m_ignoreBlenderTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_ignoreBlenderTextures",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_ignoreBlenderTextures_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (bool) ((arg1)->m_ignoreBlenderTextures);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_mode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_mode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_mode",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_mode",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_mode_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_mode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("gkMaterialProperties::m_mode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_mode",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_mode_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (unsigned int) ((arg1)->m_mode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_rblend_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_rblend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_rblend",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_rblend",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_rblend_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_rblend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_rblend_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkMaterialProperties::m_rblend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_rblend",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_rblend_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (int) ((arg1)->m_rblend);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_diffuse_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_diffuse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_diffuse",1,"gkMaterialProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkMaterialProperties::m_diffuse",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_diffuse_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_diffuse_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_diffuse = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_diffuse_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_diffuse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_diffuse",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_diffuse_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (gkColor *)& ((arg1)->m_diffuse);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_specular_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_specular",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_specular",1,"gkMaterialProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkMaterialProperties::m_specular",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_specular_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_specular_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_specular = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_specular_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_specular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_specular",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_specular_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (gkColor *)& ((arg1)->m_specular);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_hardness_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_hardness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_hardness",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_hardness",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_hardness_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_hardness = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_hardness_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_hardness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_hardness",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_hardness_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_hardness);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_refraction_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_refraction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_refraction",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_refraction",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_refraction_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_refraction = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_refraction_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_refraction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_refraction",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_refraction_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_refraction);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_emissive_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_emissive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_emissive",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_emissive",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_emissive_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_emissive = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_emissive_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_emissive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_emissive",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_emissive_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_emissive);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_ambient_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_ambient",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_ambient",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_ambient",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_ambient_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_ambient = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_ambient_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_ambient",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_ambient",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_ambient_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_ambient);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_spec_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_spec",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_spec",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_spec",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_spec_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_spec = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_spec_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_spec",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_spec",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_spec_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_spec);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_alpha_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_alpha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_alpha",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_alpha",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_alpha_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_alpha = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_alpha_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_alpha",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_alpha",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_alpha_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_alpha);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_depthOffset_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_depthOffset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_depthOffset",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_depthOffset",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_depthOffset_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_depthOffset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_depthOffset_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkMaterialProperties::m_depthOffset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_depthOffset",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_depthOffset_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (float) ((arg1)->m_depthOffset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_totaltex_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_totaltex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_totaltex",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_totaltex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_totaltex_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_totaltex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_totaltex_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkMaterialProperties::m_totaltex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_totaltex",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_totaltex_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (int) ((arg1)->m_totaltex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_textures_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkTextureProperties *arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_textures",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_textures",1,"gkMaterialProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkMaterialProperties::m_textures",2,"gkTextureProperties [18]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_textures_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkTextureProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_textures_set",2,SWIGTYPE_p_gkTextureProperties);
  }
  
  {
    size_t ii;
    gkTextureProperties *b = (gkTextureProperties *) arg1->m_textures;
    for (ii = 0; ii < (size_t)18; ii++) b[ii] = *((gkTextureProperties *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_textures_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  gkTextureProperties *result = 0 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_textures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_textures",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_textures_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (gkTextureProperties *)(gkTextureProperties *) ((arg1)->m_textures);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkTextureProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_tangentLayer_set(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkMaterialProperties::m_tangentLayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_tangentLayer",1,"gkMaterialProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkMaterialProperties::m_tangentLayer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_tangentLayer_set",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_tangentLayer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkMaterialProperties_m_tangentLayer_get(lua_State* L) {
  int SWIG_arg = 0;
  gkMaterialProperties *arg1 = (gkMaterialProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkMaterialProperties::m_tangentLayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkMaterialProperties::m_tangentLayer",1,"gkMaterialProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMaterialProperties,0))){
    SWIG_fail_ptr("gkMaterialProperties_m_tangentLayer_get",1,SWIGTYPE_p_gkMaterialProperties);
  }
  
  result = (int) ((arg1)->m_tangentLayer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkMaterialProperties(void *obj) {
gkMaterialProperties *arg1 = (gkMaterialProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkMaterialProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkMaterialProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkMaterialProperties_attributes[] = {
    { "m_name", _wrap_gkMaterialProperties_m_name_get, _wrap_gkMaterialProperties_m_name_set },
    { "m_vertexProgram", _wrap_gkMaterialProperties_m_vertexProgram_get, _wrap_gkMaterialProperties_m_vertexProgram_set },
    { "m_fragmentProgram", _wrap_gkMaterialProperties_m_fragmentProgram_get, _wrap_gkMaterialProperties_m_fragmentProgram_set },
    { "m_ignoreBlenderTextures", _wrap_gkMaterialProperties_m_ignoreBlenderTextures_get, _wrap_gkMaterialProperties_m_ignoreBlenderTextures_set },
    { "m_mode", _wrap_gkMaterialProperties_m_mode_get, _wrap_gkMaterialProperties_m_mode_set },
    { "m_rblend", _wrap_gkMaterialProperties_m_rblend_get, _wrap_gkMaterialProperties_m_rblend_set },
    { "m_diffuse", _wrap_gkMaterialProperties_m_diffuse_get, _wrap_gkMaterialProperties_m_diffuse_set },
    { "m_specular", _wrap_gkMaterialProperties_m_specular_get, _wrap_gkMaterialProperties_m_specular_set },
    { "m_hardness", _wrap_gkMaterialProperties_m_hardness_get, _wrap_gkMaterialProperties_m_hardness_set },
    { "m_refraction", _wrap_gkMaterialProperties_m_refraction_get, _wrap_gkMaterialProperties_m_refraction_set },
    { "m_emissive", _wrap_gkMaterialProperties_m_emissive_get, _wrap_gkMaterialProperties_m_emissive_set },
    { "m_ambient", _wrap_gkMaterialProperties_m_ambient_get, _wrap_gkMaterialProperties_m_ambient_set },
    { "m_spec", _wrap_gkMaterialProperties_m_spec_get, _wrap_gkMaterialProperties_m_spec_set },
    { "m_alpha", _wrap_gkMaterialProperties_m_alpha_get, _wrap_gkMaterialProperties_m_alpha_set },
    { "m_depthOffset", _wrap_gkMaterialProperties_m_depthOffset_get, _wrap_gkMaterialProperties_m_depthOffset_set },
    { "m_totaltex", _wrap_gkMaterialProperties_m_totaltex_get, _wrap_gkMaterialProperties_m_totaltex_set },
    { "m_textures", _wrap_gkMaterialProperties_m_textures_get, _wrap_gkMaterialProperties_m_textures_set },
    { "m_tangentLayer", _wrap_gkMaterialProperties_m_tangentLayer_get, _wrap_gkMaterialProperties_m_tangentLayer_set },
    {0,0,0}
};
static swig_lua_method swig_gkMaterialProperties_methods[]= {
    { "getTextureProp", _wrap_gkMaterialProperties_getTextureProp},
    {0,0}
};
static swig_lua_method swig_gkMaterialProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkMaterialProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkMaterialProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("MA_RECEIVESHADOWS", gkMaterialProperties::MA_RECEIVESHADOWS)},
    {SWIG_LUA_CONSTTAB_INT("MA_LIGHTINGENABLED", gkMaterialProperties::MA_LIGHTINGENABLED)},
    {SWIG_LUA_CONSTTAB_INT("MA_WIREFRAME", gkMaterialProperties::MA_WIREFRAME)},
    {SWIG_LUA_CONSTTAB_INT("MA_DEPTHWRITE", gkMaterialProperties::MA_DEPTHWRITE)},
    {SWIG_LUA_CONSTTAB_INT("MA_INVISIBLE", gkMaterialProperties::MA_INVISIBLE)},
    {SWIG_LUA_CONSTTAB_INT("MA_TWOSIDE", gkMaterialProperties::MA_TWOSIDE)},
    {SWIG_LUA_CONSTTAB_INT("MA_ALPHABLEND", gkMaterialProperties::MA_ALPHABLEND)},
    {SWIG_LUA_CONSTTAB_INT("MA_ADDITIVEBLEND", gkMaterialProperties::MA_ADDITIVEBLEND)},
    {SWIG_LUA_CONSTTAB_INT("MA_HASFACETEX", gkMaterialProperties::MA_HASFACETEX)},
    {SWIG_LUA_CONSTTAB_INT("MA_HASRAMPBLEND", gkMaterialProperties::MA_HASRAMPBLEND)},
    {SWIG_LUA_CONSTTAB_INT("MA_ALPHACLIP", gkMaterialProperties::MA_ALPHACLIP)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkMaterialProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkMaterialProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkMaterialProperties_Sf_SwigStatic = {
    "gkMaterialProperties",
    swig_gkMaterialProperties_Sf_SwigStatic_methods,
    swig_gkMaterialProperties_Sf_SwigStatic_attributes,
    swig_gkMaterialProperties_Sf_SwigStatic_constants,
    swig_gkMaterialProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkMaterialProperties_bases[] = {0};
static const char *swig_gkMaterialProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkMaterialProperties = { "gkMaterialProperties", "gkMaterialProperties", &SWIGTYPE_p_gkMaterialProperties,_proxy__wrap_new_gkMaterialProperties, swig_delete_gkMaterialProperties, swig_gkMaterialProperties_methods, swig_gkMaterialProperties_attributes, &swig_gkMaterialProperties_Sf_SwigStatic, swig_gkMaterialProperties_meta, swig_gkMaterialProperties_bases, swig_gkMaterialProperties_base_names };

static int _wrap_new_gkCameraProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *result = 0 ;
  
  SWIG_check_num_args("gkCameraProperties::gkCameraProperties",0,0)
  result = (gkCameraProperties *)new gkCameraProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkCameraProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_clipstart_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_clipstart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_clipstart",1,"gkCameraProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCameraProperties::m_clipstart",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_clipstart_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_clipstart = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_clipstart_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkCameraProperties::m_clipstart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_clipstart",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_clipstart_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (float) ((arg1)->m_clipstart);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_clipend_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_clipend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_clipend",1,"gkCameraProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCameraProperties::m_clipend",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_clipend_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_clipend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_clipend_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkCameraProperties::m_clipend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_clipend",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_clipend_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (float) ((arg1)->m_clipend);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_fov_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_fov",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_fov",1,"gkCameraProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCameraProperties::m_fov",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_fov_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_fov = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_fov_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkCameraProperties::m_fov",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_fov",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_fov_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (float) ((arg1)->m_fov);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_orthoscale_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_orthoscale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_orthoscale",1,"gkCameraProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCameraProperties::m_orthoscale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_orthoscale_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_orthoscale = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_orthoscale_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkCameraProperties::m_orthoscale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_orthoscale",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_orthoscale_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (float) ((arg1)->m_orthoscale);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_start_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_start",1,"gkCameraProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkCameraProperties::m_start",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_start_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_start = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_start_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkCameraProperties::m_start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_start",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_start_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (bool) ((arg1)->m_start);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkCameraProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_type",1,"gkCameraProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCameraProperties::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_type_set",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCameraProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraProperties *arg1 = (gkCameraProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkCameraProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCameraProperties::m_type",1,"gkCameraProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraProperties,0))){
    SWIG_fail_ptr("gkCameraProperties_m_type_get",1,SWIGTYPE_p_gkCameraProperties);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkCameraProperties(void *obj) {
gkCameraProperties *arg1 = (gkCameraProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkCameraProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkCameraProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkCameraProperties_attributes[] = {
    { "m_clipstart", _wrap_gkCameraProperties_m_clipstart_get, _wrap_gkCameraProperties_m_clipstart_set },
    { "m_clipend", _wrap_gkCameraProperties_m_clipend_get, _wrap_gkCameraProperties_m_clipend_set },
    { "m_fov", _wrap_gkCameraProperties_m_fov_get, _wrap_gkCameraProperties_m_fov_set },
    { "m_orthoscale", _wrap_gkCameraProperties_m_orthoscale_get, _wrap_gkCameraProperties_m_orthoscale_set },
    { "m_start", _wrap_gkCameraProperties_m_start_get, _wrap_gkCameraProperties_m_start_set },
    { "m_type", _wrap_gkCameraProperties_m_type_get, _wrap_gkCameraProperties_m_type_set },
    {0,0,0}
};
static swig_lua_method swig_gkCameraProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkCameraProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkCameraProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkCameraProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("CA_PERSPECTIVE", gkCameraProperties::CA_PERSPECTIVE)},
    {SWIG_LUA_CONSTTAB_INT("CA_ORTHOGRAPHIC", gkCameraProperties::CA_ORTHOGRAPHIC)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkCameraProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkCameraProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkCameraProperties_Sf_SwigStatic = {
    "gkCameraProperties",
    swig_gkCameraProperties_Sf_SwigStatic_methods,
    swig_gkCameraProperties_Sf_SwigStatic_attributes,
    swig_gkCameraProperties_Sf_SwigStatic_constants,
    swig_gkCameraProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkCameraProperties_bases[] = {0};
static const char *swig_gkCameraProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkCameraProperties = { "gkCameraProperties", "gkCameraProperties", &SWIGTYPE_p_gkCameraProperties,_proxy__wrap_new_gkCameraProperties, swig_delete_gkCameraProperties, swig_gkCameraProperties_methods, swig_gkCameraProperties_attributes, &swig_gkCameraProperties_Sf_SwigStatic, swig_gkCameraProperties_meta, swig_gkCameraProperties_bases, swig_gkCameraProperties_base_names };

static int _wrap_new_gkEntityProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *result = 0 ;
  
  SWIG_check_num_args("gkEntityProperties::gkEntityProperties",0,0)
  result = (gkEntityProperties *)new gkEntityProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkEntityProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_mesh_set(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkMesh *arg2 = (gkMesh *) 0 ;
  
  SWIG_check_num_args("gkEntityProperties::m_mesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_mesh",1,"gkEntityProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkEntityProperties::m_mesh",2,"gkMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_mesh_set",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkMesh,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("gkEntityProperties_m_mesh_set",2,SWIGTYPE_p_gkMesh);
  }
  
  if (arg1) (arg1)->m_mesh = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_mesh_get(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkMesh *result = 0 ;
  
  SWIG_check_num_args("gkEntityProperties::m_mesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_mesh",1,"gkEntityProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_mesh_get",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  result = (gkMesh *) ((arg1)->m_mesh);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Mesh); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_casts_set(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkEntityProperties::m_casts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_casts",1,"gkEntityProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkEntityProperties::m_casts",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_casts_set",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_casts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_casts_get(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkEntityProperties::m_casts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_casts",1,"gkEntityProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_casts_get",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  result = (bool) ((arg1)->m_casts);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_source_set(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkEntityProperties::m_source",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_source",1,"gkEntityProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkEntityProperties::m_source",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_source_set",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_source = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_source_get(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkEntityProperties::m_source",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_source",1,"gkEntityProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_source_get",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  result =  ((arg1)->m_source);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_startPose_set(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkEntityProperties::m_startPose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_startPose",1,"gkEntityProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkEntityProperties::m_startPose",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_startPose_set",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_startPose = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkEntityProperties_m_startPose_get(lua_State* L) {
  int SWIG_arg = 0;
  gkEntityProperties *arg1 = (gkEntityProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkEntityProperties::m_startPose",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkEntityProperties::m_startPose",1,"gkEntityProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEntityProperties,0))){
    SWIG_fail_ptr("gkEntityProperties_m_startPose_get",1,SWIGTYPE_p_gkEntityProperties);
  }
  
  result =  ((arg1)->m_startPose);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkEntityProperties(void *obj) {
gkEntityProperties *arg1 = (gkEntityProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkEntityProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkEntityProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkEntityProperties_attributes[] = {
    { "m_mesh", _wrap_gkEntityProperties_m_mesh_get, _wrap_gkEntityProperties_m_mesh_set },
    { "m_casts", _wrap_gkEntityProperties_m_casts_get, _wrap_gkEntityProperties_m_casts_set },
    { "m_source", _wrap_gkEntityProperties_m_source_get, _wrap_gkEntityProperties_m_source_set },
    { "m_startPose", _wrap_gkEntityProperties_m_startPose_get, _wrap_gkEntityProperties_m_startPose_set },
    {0,0,0}
};
static swig_lua_method swig_gkEntityProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkEntityProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkEntityProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkEntityProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkEntityProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkEntityProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkEntityProperties_Sf_SwigStatic = {
    "gkEntityProperties",
    swig_gkEntityProperties_Sf_SwigStatic_methods,
    swig_gkEntityProperties_Sf_SwigStatic_attributes,
    swig_gkEntityProperties_Sf_SwigStatic_constants,
    swig_gkEntityProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkEntityProperties_bases[] = {0};
static const char *swig_gkEntityProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkEntityProperties = { "gkEntityProperties", "gkEntityProperties", &SWIGTYPE_p_gkEntityProperties,_proxy__wrap_new_gkEntityProperties, swig_delete_gkEntityProperties, swig_gkEntityProperties_methods, swig_gkEntityProperties_attributes, &swig_gkEntityProperties_Sf_SwigStatic, swig_gkEntityProperties_meta, swig_gkEntityProperties_bases, swig_gkEntityProperties_base_names };

static int _wrap_new_gkCurveProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *result = 0 ;
  
  SWIG_check_num_args("gkCurveProperties::gkCurveProperties",0,0)
  result = (gkCurveProperties *)new gkCurveProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkCurveProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::CurveType arg2 ;
  
  SWIG_check_num_args("gkCurveProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_type",1,"gkCurveProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkCurveProperties::m_type",2,"gkCurveProperties::CurveType");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_type_set",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  arg2 = (gkCurveProperties::CurveType)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::CurveType result;
  
  SWIG_check_num_args("gkCurveProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_type",1,"gkCurveProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_type_get",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  result = (gkCurveProperties::CurveType) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_points_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::CurvePoints *arg2 = (gkCurveProperties::CurvePoints *) 0 ;
  
  SWIG_check_num_args("gkCurveProperties::m_points",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_points",1,"gkCurveProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkCurveProperties::m_points",2,"gkCurveProperties::CurvePoints *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_points_set",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_utArrayT_gkVector3_t,0))){
    SWIG_fail_ptr("gkCurveProperties_m_points_set",2,SWIGTYPE_p_utArrayT_gkVector3_t);
  }
  
  if (arg1) (arg1)->m_points = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_points_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::CurvePoints *result = 0 ;
  
  SWIG_check_num_args("gkCurveProperties::m_points",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_points",1,"gkCurveProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_points_get",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  result = (gkCurveProperties::CurvePoints *)& ((arg1)->m_points);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_utArrayT_gkVector3_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_BezTriples_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::BezTriples *arg2 = (gkCurveProperties::BezTriples *) 0 ;
  
  SWIG_check_num_args("gkCurveProperties::m_BezTriples",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_BezTriples",1,"gkCurveProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkCurveProperties::m_BezTriples",2,"gkCurveProperties::BezTriples *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_BezTriples_set",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_utArrayT_utArrayT_gkVector3_t_t,0))){
    SWIG_fail_ptr("gkCurveProperties_m_BezTriples_set",2,SWIGTYPE_p_utArrayT_utArrayT_gkVector3_t_t);
  }
  
  if (arg1) (arg1)->m_BezTriples = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_BezTriples_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  gkCurveProperties::BezTriples *result = 0 ;
  
  SWIG_check_num_args("gkCurveProperties::m_BezTriples",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_BezTriples",1,"gkCurveProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_BezTriples_get",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  result = (gkCurveProperties::BezTriples *)& ((arg1)->m_BezTriples);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_utArrayT_utArrayT_gkVector3_t_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_isCyclic_set(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkCurveProperties::m_isCyclic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_isCyclic",1,"gkCurveProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkCurveProperties::m_isCyclic",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_isCyclic_set",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_isCyclic = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkCurveProperties_m_isCyclic_get(lua_State* L) {
  int SWIG_arg = 0;
  gkCurveProperties *arg1 = (gkCurveProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkCurveProperties::m_isCyclic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkCurveProperties::m_isCyclic",1,"gkCurveProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCurveProperties,0))){
    SWIG_fail_ptr("gkCurveProperties_m_isCyclic_get",1,SWIGTYPE_p_gkCurveProperties);
  }
  
  result = (bool) ((arg1)->m_isCyclic);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkCurveProperties(void *obj) {
gkCurveProperties *arg1 = (gkCurveProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkCurveProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkCurveProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkCurveProperties_attributes[] = {
    { "m_type", _wrap_gkCurveProperties_m_type_get, _wrap_gkCurveProperties_m_type_set },
    { "m_points", _wrap_gkCurveProperties_m_points_get, _wrap_gkCurveProperties_m_points_set },
    { "m_BezTriples", _wrap_gkCurveProperties_m_BezTriples_get, _wrap_gkCurveProperties_m_BezTriples_set },
    { "m_isCyclic", _wrap_gkCurveProperties_m_isCyclic_get, _wrap_gkCurveProperties_m_isCyclic_set },
    {0,0,0}
};
static swig_lua_method swig_gkCurveProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkCurveProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkCurveProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkCurveProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("CU_Bezier", gkCurveProperties::CU_Bezier)},
    {SWIG_LUA_CONSTTAB_INT("CU_Spline", gkCurveProperties::CU_Spline)},
    {SWIG_LUA_CONSTTAB_INT("CU_Points", gkCurveProperties::CU_Points)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkCurveProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkCurveProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkCurveProperties_Sf_SwigStatic = {
    "gkCurveProperties",
    swig_gkCurveProperties_Sf_SwigStatic_methods,
    swig_gkCurveProperties_Sf_SwigStatic_attributes,
    swig_gkCurveProperties_Sf_SwigStatic_constants,
    swig_gkCurveProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkCurveProperties_bases[] = {0};
static const char *swig_gkCurveProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkCurveProperties = { "gkCurveProperties", "gkCurveProperties", &SWIGTYPE_p_gkCurveProperties,_proxy__wrap_new_gkCurveProperties, swig_delete_gkCurveProperties, swig_gkCurveProperties_methods, swig_gkCurveProperties_attributes, &swig_gkCurveProperties_Sf_SwigStatic, swig_gkCurveProperties_meta, swig_gkCurveProperties_bases, swig_gkCurveProperties_base_names };

static int _wrap_new_gkLightProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::gkLightProperties",0,0)
  result = (gkLightProperties *)new gkLightProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkLightProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_diffuse_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_diffuse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_diffuse",1,"gkLightProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkLightProperties::m_diffuse",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_diffuse_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkLightProperties_m_diffuse_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_diffuse = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_diffuse_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_diffuse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_diffuse",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_diffuse_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (gkColor *)& ((arg1)->m_diffuse);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_specular_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_specular",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_specular",1,"gkLightProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkLightProperties::m_specular",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_specular_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkLightProperties_m_specular_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_specular = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_specular_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_specular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_specular",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_specular_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (gkColor *)& ((arg1)->m_specular);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_type",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_type_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkLightProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_type",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_type_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_spot_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkVector2 *arg2 = (gkVector2 *) 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_spot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_spot",1,"gkLightProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkLightProperties::m_spot",2,"gkVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_spot_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkLightProperties_m_spot_set",2,SWIGTYPE_p_gkVector2);
  }
  
  if (arg1) (arg1)->m_spot = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_spot_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_spot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_spot",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_spot_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (gkVector2 *)& ((arg1)->m_spot);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_direction_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_direction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_direction",1,"gkLightProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkLightProperties::m_direction",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_direction_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkLightProperties_m_direction_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_direction = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_direction_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_direction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_direction",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_direction_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_direction);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_power_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_power",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_power",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_power",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_power_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_power = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_power_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_power",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_power",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_power_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_power);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_falloff_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_falloff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_falloff",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_falloff",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_falloff_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_falloff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_falloff_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_falloff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_falloff",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_falloff_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_falloff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_range_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_range",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_range",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_range",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_range_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_range = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_range_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_range",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_range",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_range_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_range);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_constant_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_constant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_constant",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_constant",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_constant_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_constant = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_constant_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_constant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_constant",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_constant_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_constant);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_linear_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_linear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_linear",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_linear",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_linear_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_linear = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_linear_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_linear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_linear",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_linear_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_linear);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_quadratic_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_quadratic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_quadratic",1,"gkLightProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkLightProperties::m_quadratic",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_quadratic_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_quadratic = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_quadratic_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkLightProperties::m_quadratic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_quadratic",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_quadratic_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float) ((arg1)->m_quadratic);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_casts_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_casts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_casts",1,"gkLightProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkLightProperties::m_casts",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_casts_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_casts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_casts_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkLightProperties::m_casts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_casts",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_casts_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (bool) ((arg1)->m_casts);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_extra_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_extra",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_extra",1,"gkLightProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkLightProperties::m_extra",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_extra_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_extra = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_extra_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkLightProperties::m_extra",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_extra",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_extra_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (bool) ((arg1)->m_extra);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_param_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("gkLightProperties::m_param",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_param",1,"gkLightProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkLightProperties::m_param",2,"float [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_param_set",1,SWIGTYPE_p_gkLightProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("gkLightProperties_m_param_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->m_param;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkLightProperties_m_param_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLightProperties *arg1 = (gkLightProperties *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("gkLightProperties::m_param",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkLightProperties::m_param",1,"gkLightProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLightProperties,0))){
    SWIG_fail_ptr("gkLightProperties_m_param_get",1,SWIGTYPE_p_gkLightProperties);
  }
  
  result = (float *)(float *) ((arg1)->m_param);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkLightProperties(void *obj) {
gkLightProperties *arg1 = (gkLightProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkLightProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkLightProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkLightProperties_attributes[] = {
    { "m_diffuse", _wrap_gkLightProperties_m_diffuse_get, _wrap_gkLightProperties_m_diffuse_set },
    { "m_specular", _wrap_gkLightProperties_m_specular_get, _wrap_gkLightProperties_m_specular_set },
    { "m_type", _wrap_gkLightProperties_m_type_get, _wrap_gkLightProperties_m_type_set },
    { "m_spot", _wrap_gkLightProperties_m_spot_get, _wrap_gkLightProperties_m_spot_set },
    { "m_direction", _wrap_gkLightProperties_m_direction_get, _wrap_gkLightProperties_m_direction_set },
    { "m_power", _wrap_gkLightProperties_m_power_get, _wrap_gkLightProperties_m_power_set },
    { "m_falloff", _wrap_gkLightProperties_m_falloff_get, _wrap_gkLightProperties_m_falloff_set },
    { "m_range", _wrap_gkLightProperties_m_range_get, _wrap_gkLightProperties_m_range_set },
    { "m_constant", _wrap_gkLightProperties_m_constant_get, _wrap_gkLightProperties_m_constant_set },
    { "m_linear", _wrap_gkLightProperties_m_linear_get, _wrap_gkLightProperties_m_linear_set },
    { "m_quadratic", _wrap_gkLightProperties_m_quadratic_get, _wrap_gkLightProperties_m_quadratic_set },
    { "m_casts", _wrap_gkLightProperties_m_casts_get, _wrap_gkLightProperties_m_casts_set },
    { "m_extra", _wrap_gkLightProperties_m_extra_get, _wrap_gkLightProperties_m_extra_set },
    { "m_param", _wrap_gkLightProperties_m_param_get, _wrap_gkLightProperties_m_param_set },
    {0,0,0}
};
static swig_lua_method swig_gkLightProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkLightProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkLightProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkLightProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("LI_POINT", gkLightProperties::LI_POINT)},
    {SWIG_LUA_CONSTTAB_INT("LI_SPOT", gkLightProperties::LI_SPOT)},
    {SWIG_LUA_CONSTTAB_INT("LI_DIR", gkLightProperties::LI_DIR)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkLightProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkLightProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkLightProperties_Sf_SwigStatic = {
    "gkLightProperties",
    swig_gkLightProperties_Sf_SwigStatic_methods,
    swig_gkLightProperties_Sf_SwigStatic_attributes,
    swig_gkLightProperties_Sf_SwigStatic_constants,
    swig_gkLightProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkLightProperties_bases[] = {0};
static const char *swig_gkLightProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkLightProperties = { "gkLightProperties", "gkLightProperties", &SWIGTYPE_p_gkLightProperties,_proxy__wrap_new_gkLightProperties, swig_delete_gkLightProperties, swig_gkLightProperties_methods, swig_gkLightProperties_attributes, &swig_gkLightProperties_Sf_SwigStatic, swig_gkLightProperties_meta, swig_gkLightProperties_bases, swig_gkLightProperties_base_names };

static int _wrap_new_gkPhysicsConstraintProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::gkPhysicsConstraintProperties",0,0)
  result = (gkPhysicsConstraintProperties *)new gkPhysicsConstraintProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkPhysicsConstraintProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_target_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_target",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_target",1,"gkPhysicsConstraintProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_target",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_target_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_target = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_target_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_target",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_target",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_target_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result =  ((arg1)->m_target);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_type",1,"gkPhysicsConstraintProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_type_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_type",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_type_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_pivot_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_pivot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_pivot",1,"gkPhysicsConstraintProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_pivot",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_pivot_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_pivot_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_pivot = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_pivot_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_pivot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_pivot",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_pivot_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_pivot);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_axis_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_axis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_axis",1,"gkPhysicsConstraintProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_axis",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_axis_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_axis_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_axis = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_axis_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_axis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_axis",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_axis_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_axis);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_minLimit_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_minLimit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_minLimit",1,"gkPhysicsConstraintProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_minLimit",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_minLimit_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_minLimit_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->m_minLimit;
    for (ii = 0; ii < (size_t)6; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_minLimit_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_minLimit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_minLimit",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_minLimit_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (float *)(float *) ((arg1)->m_minLimit);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_maxLimit_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_maxLimit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_maxLimit",1,"gkPhysicsConstraintProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_maxLimit",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_maxLimit_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_maxLimit_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->m_maxLimit;
    for (ii = 0; ii < (size_t)6; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_maxLimit_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_maxLimit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_maxLimit",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_maxLimit_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (float *)(float *) ((arg1)->m_maxLimit);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_flag_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_flag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_flag",1,"gkPhysicsConstraintProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_flag",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_flag_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_flag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_flag_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_flag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_flag",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_flag_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (int) ((arg1)->m_flag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_disableLinkedCollision_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_disableLinkedCollision",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_disableLinkedCollision",1,"gkPhysicsConstraintProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_disableLinkedCollision",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_disableLinkedCollision_set",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_disableLinkedCollision = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsConstraintProperties_m_disableLinkedCollision_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsConstraintProperties::m_disableLinkedCollision",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsConstraintProperties::m_disableLinkedCollision",1,"gkPhysicsConstraintProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsConstraintProperties,0))){
    SWIG_fail_ptr("gkPhysicsConstraintProperties_m_disableLinkedCollision_get",1,SWIGTYPE_p_gkPhysicsConstraintProperties);
  }
  
  result = (bool) ((arg1)->m_disableLinkedCollision);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkPhysicsConstraintProperties(void *obj) {
gkPhysicsConstraintProperties *arg1 = (gkPhysicsConstraintProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkPhysicsConstraintProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkPhysicsConstraintProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkPhysicsConstraintProperties_attributes[] = {
    { "m_target", _wrap_gkPhysicsConstraintProperties_m_target_get, _wrap_gkPhysicsConstraintProperties_m_target_set },
    { "m_type", _wrap_gkPhysicsConstraintProperties_m_type_get, _wrap_gkPhysicsConstraintProperties_m_type_set },
    { "m_pivot", _wrap_gkPhysicsConstraintProperties_m_pivot_get, _wrap_gkPhysicsConstraintProperties_m_pivot_set },
    { "m_axis", _wrap_gkPhysicsConstraintProperties_m_axis_get, _wrap_gkPhysicsConstraintProperties_m_axis_set },
    { "m_minLimit", _wrap_gkPhysicsConstraintProperties_m_minLimit_get, _wrap_gkPhysicsConstraintProperties_m_minLimit_set },
    { "m_maxLimit", _wrap_gkPhysicsConstraintProperties_m_maxLimit_get, _wrap_gkPhysicsConstraintProperties_m_maxLimit_set },
    { "m_flag", _wrap_gkPhysicsConstraintProperties_m_flag_get, _wrap_gkPhysicsConstraintProperties_m_flag_set },
    { "m_disableLinkedCollision", _wrap_gkPhysicsConstraintProperties_m_disableLinkedCollision_get, _wrap_gkPhysicsConstraintProperties_m_disableLinkedCollision_set },
    {0,0,0}
};
static swig_lua_method swig_gkPhysicsConstraintProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkPhysicsConstraintProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkPhysicsConstraintProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkPhysicsConstraintProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkPhysicsConstraintProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkPhysicsConstraintProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkPhysicsConstraintProperties_Sf_SwigStatic = {
    "gkPhysicsConstraintProperties",
    swig_gkPhysicsConstraintProperties_Sf_SwigStatic_methods,
    swig_gkPhysicsConstraintProperties_Sf_SwigStatic_attributes,
    swig_gkPhysicsConstraintProperties_Sf_SwigStatic_constants,
    swig_gkPhysicsConstraintProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkPhysicsConstraintProperties_bases[] = {0};
static const char *swig_gkPhysicsConstraintProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkPhysicsConstraintProperties = { "gkPhysicsConstraintProperties", "gkPhysicsConstraintProperties", &SWIGTYPE_p_gkPhysicsConstraintProperties,_proxy__wrap_new_gkPhysicsConstraintProperties, swig_delete_gkPhysicsConstraintProperties, swig_gkPhysicsConstraintProperties_methods, swig_gkPhysicsConstraintProperties_attributes, &swig_gkPhysicsConstraintProperties_Sf_SwigStatic, swig_gkPhysicsConstraintProperties_meta, swig_gkPhysicsConstraintProperties_bases, swig_gkPhysicsConstraintProperties_base_names };

static int _wrap_new_gkPhysicsProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsProperties::gkPhysicsProperties",0,0)
  result = (gkPhysicsProperties *)new gkPhysicsProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkPhysicsProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_type",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_type_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_type",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_type_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_mode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_mode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_mode",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_mode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_mode_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_mode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_mode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_mode",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_mode_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (int) ((arg1)->m_mode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_shape_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_shape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_shape",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_shape",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_shape_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_shape = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_shape_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_shape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_shape",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_shape_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (int) ((arg1)->m_shape);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_margin_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_margin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_margin",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_margin",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_margin_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_margin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_margin_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_margin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_margin",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_margin_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_margin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_cpt_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_cpt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_cpt",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_cpt",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_cpt_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_cpt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_cpt_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_cpt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_cpt",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_cpt_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_cpt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_mass_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_mass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_mass",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_mass",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_mass_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mass = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_mass_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_mass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_mass",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_mass_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_mass);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_radius_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_radius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_radius",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_radius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_radius_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_radius = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_radius_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_radius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_radius",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_radius_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_radius);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_linearDamp_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_linearDamp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_linearDamp",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_linearDamp",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_linearDamp_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_linearDamp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_linearDamp_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_linearDamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_linearDamp",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_linearDamp_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_linearDamp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_angularDamp_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_angularDamp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_angularDamp",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_angularDamp",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_angularDamp_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_angularDamp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_angularDamp_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_angularDamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_angularDamp",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_angularDamp_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_angularDamp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_formFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_formFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_formFactor",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_formFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_formFactor_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_formFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_formFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_formFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_formFactor",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_formFactor_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_formFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_minVel_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_minVel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_minVel",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_minVel",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_minVel_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_minVel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_minVel_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_minVel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_minVel",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_minVel_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_minVel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_maxVel_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_maxVel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_maxVel",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_maxVel",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_maxVel_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_maxVel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_maxVel_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_maxVel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_maxVel",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_maxVel_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_maxVel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_restitution_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_restitution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_restitution",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_restitution",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_restitution_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_restitution = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_restitution_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_restitution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_restitution",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_restitution_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_restitution);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_friction_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_friction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_friction",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_friction",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_friction_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_friction = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_friction_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_friction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_friction",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_friction_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_friction);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_colMask_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  gkPhysicsProperties::CollisionMask arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_colMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_colMask",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_colMask",2,"gkPhysicsProperties::CollisionMask");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_colMask_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (gkPhysicsProperties::CollisionMask)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_colMask = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_colMask_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  gkPhysicsProperties::CollisionMask result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_colMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_colMask",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_colMask_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (gkPhysicsProperties::CollisionMask) ((arg1)->m_colMask);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_colGroupMask_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  gkPhysicsProperties::CollisionMask arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_colGroupMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_colGroupMask",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_colGroupMask",2,"gkPhysicsProperties::CollisionMask");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_colGroupMask_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (gkPhysicsProperties::CollisionMask)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_colGroupMask = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_colGroupMask_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  gkPhysicsProperties::CollisionMask result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_colGroupMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_colGroupMask",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_colGroupMask_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (gkPhysicsProperties::CollisionMask) ((arg1)->m_colGroupMask);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charStepHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charStepHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charStepHeight",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_charStepHeight",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charStepHeight_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_charStepHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charStepHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charStepHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charStepHeight",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charStepHeight_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_charStepHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charJumpSpeed_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charJumpSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charJumpSpeed",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_charJumpSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charJumpSpeed_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_charJumpSpeed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charJumpSpeed_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charJumpSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charJumpSpeed",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charJumpSpeed_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_charJumpSpeed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charFallSpeed_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charFallSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charFallSpeed",1,"gkPhysicsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_charFallSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charFallSpeed_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_charFallSpeed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_charFallSpeed_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkPhysicsProperties::m_charFallSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_charFallSpeed",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_charFallSpeed_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (float) ((arg1)->m_charFallSpeed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_constraints_set(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  utArray< gkPhysicsConstraintProperties > *arg2 = (utArray< gkPhysicsConstraintProperties > *) 0 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_constraints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_constraints",1,"gkPhysicsProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkPhysicsProperties::m_constraints",2,"utArray< gkPhysicsConstraintProperties > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_constraints_set",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_utArrayT_gkPhysicsConstraintProperties_t,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_constraints_set",2,SWIGTYPE_p_utArrayT_gkPhysicsConstraintProperties_t);
  }
  
  if (arg1) (arg1)->m_constraints = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_m_constraints_get(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  utArray< gkPhysicsConstraintProperties > *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsProperties::m_constraints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::m_constraints",1,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_m_constraints_get",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (utArray< gkPhysicsConstraintProperties > *)& ((arg1)->m_constraints);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_utArrayT_gkPhysicsConstraintProperties_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isContactListener(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isContactListener",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isContactListener",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isContactListener",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isContactListener();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isDosser(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isDosser",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isDosser",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isDosser",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isDosser();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isCompound(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isCompound",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isCompound",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isCompound",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isCompound();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isCompoundChild(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isCompoundChild",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isCompoundChild",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isCompoundChild",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isCompoundChild();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isSensor(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isSensor",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isSensor",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isSensor();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isRigidOrDynamic(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isRigidOrDynamic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isRigidOrDynamic",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isRigidOrDynamic",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isRigidOrDynamic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isRigidOrStatic(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isRigidOrStatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isRigidOrStatic",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isRigidOrStatic",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isRigidOrStatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isPhysicsObject(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isPhysicsObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isPhysicsObject",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isPhysicsObject",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isPhysicsObject();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isStatic(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isStatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isStatic",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isStatic",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isStatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isDynamic(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isDynamic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isDynamic",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isDynamic",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isDynamic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isRigid(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isRigid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isRigid",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isRigid",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isRigid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isSoft(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isSoft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isSoft",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isSoft",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isSoft();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isMeshShape(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isMeshShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isMeshShape",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isMeshShape",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isMeshShape();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_hasPhysicsConstraint(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::hasPhysicsConstraint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::hasPhysicsConstraint",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_hasPhysicsConstraint",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->hasPhysicsConstraint();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_isLinkedToOther(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkPhysicsProperties::isLinkedToOther",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::isLinkedToOther",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_isLinkedToOther",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = (bool)((gkPhysicsProperties const *)arg1)->isLinkedToOther();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_getConstraintCount(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  UTsize result;
  
  SWIG_check_num_args("gkPhysicsProperties::getConstraintCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::getConstraintCount",1,"gkPhysicsProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_getConstraintCount",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  result = ((gkPhysicsProperties const *)arg1)->getConstraintCount();
  {
    UTsize * resultptr = new UTsize((const UTsize &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_UTsize,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkPhysicsProperties_getConstraint(lua_State* L) {
  int SWIG_arg = 0;
  gkPhysicsProperties *arg1 = (gkPhysicsProperties *) 0 ;
  UTsize arg2 ;
  UTsize *argp2 ;
  gkPhysicsConstraintProperties *result = 0 ;
  
  SWIG_check_num_args("gkPhysicsProperties::getConstraint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkPhysicsProperties::getConstraint",1,"gkPhysicsProperties const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gkPhysicsProperties::getConstraint",2,"UTsize");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkPhysicsProperties_getConstraint",1,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_UTsize,0))){
    SWIG_fail_ptr("gkPhysicsProperties_getConstraint",2,SWIGTYPE_p_UTsize);
  }
  arg2 = *argp2;
  
  result = (gkPhysicsConstraintProperties *) &((gkPhysicsProperties const *)arg1)->getConstraint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkPhysicsConstraintProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkPhysicsProperties(void *obj) {
gkPhysicsProperties *arg1 = (gkPhysicsProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkPhysicsProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkPhysicsProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkPhysicsProperties_attributes[] = {
    { "m_type", _wrap_gkPhysicsProperties_m_type_get, _wrap_gkPhysicsProperties_m_type_set },
    { "m_mode", _wrap_gkPhysicsProperties_m_mode_get, _wrap_gkPhysicsProperties_m_mode_set },
    { "m_shape", _wrap_gkPhysicsProperties_m_shape_get, _wrap_gkPhysicsProperties_m_shape_set },
    { "m_margin", _wrap_gkPhysicsProperties_m_margin_get, _wrap_gkPhysicsProperties_m_margin_set },
    { "m_cpt", _wrap_gkPhysicsProperties_m_cpt_get, _wrap_gkPhysicsProperties_m_cpt_set },
    { "m_mass", _wrap_gkPhysicsProperties_m_mass_get, _wrap_gkPhysicsProperties_m_mass_set },
    { "m_radius", _wrap_gkPhysicsProperties_m_radius_get, _wrap_gkPhysicsProperties_m_radius_set },
    { "m_linearDamp", _wrap_gkPhysicsProperties_m_linearDamp_get, _wrap_gkPhysicsProperties_m_linearDamp_set },
    { "m_angularDamp", _wrap_gkPhysicsProperties_m_angularDamp_get, _wrap_gkPhysicsProperties_m_angularDamp_set },
    { "m_formFactor", _wrap_gkPhysicsProperties_m_formFactor_get, _wrap_gkPhysicsProperties_m_formFactor_set },
    { "m_minVel", _wrap_gkPhysicsProperties_m_minVel_get, _wrap_gkPhysicsProperties_m_minVel_set },
    { "m_maxVel", _wrap_gkPhysicsProperties_m_maxVel_get, _wrap_gkPhysicsProperties_m_maxVel_set },
    { "m_restitution", _wrap_gkPhysicsProperties_m_restitution_get, _wrap_gkPhysicsProperties_m_restitution_set },
    { "m_friction", _wrap_gkPhysicsProperties_m_friction_get, _wrap_gkPhysicsProperties_m_friction_set },
    { "m_colMask", _wrap_gkPhysicsProperties_m_colMask_get, _wrap_gkPhysicsProperties_m_colMask_set },
    { "m_colGroupMask", _wrap_gkPhysicsProperties_m_colGroupMask_get, _wrap_gkPhysicsProperties_m_colGroupMask_set },
    { "m_charStepHeight", _wrap_gkPhysicsProperties_m_charStepHeight_get, _wrap_gkPhysicsProperties_m_charStepHeight_set },
    { "m_charJumpSpeed", _wrap_gkPhysicsProperties_m_charJumpSpeed_get, _wrap_gkPhysicsProperties_m_charJumpSpeed_set },
    { "m_charFallSpeed", _wrap_gkPhysicsProperties_m_charFallSpeed_get, _wrap_gkPhysicsProperties_m_charFallSpeed_set },
    { "m_constraints", _wrap_gkPhysicsProperties_m_constraints_get, _wrap_gkPhysicsProperties_m_constraints_set },
    {0,0,0}
};
static swig_lua_method swig_gkPhysicsProperties_methods[]= {
    { "isContactListener", _wrap_gkPhysicsProperties_isContactListener},
    { "isDosser", _wrap_gkPhysicsProperties_isDosser},
    { "isCompound", _wrap_gkPhysicsProperties_isCompound},
    { "isCompoundChild", _wrap_gkPhysicsProperties_isCompoundChild},
    { "isSensor", _wrap_gkPhysicsProperties_isSensor},
    { "isRigidOrDynamic", _wrap_gkPhysicsProperties_isRigidOrDynamic},
    { "isRigidOrStatic", _wrap_gkPhysicsProperties_isRigidOrStatic},
    { "isPhysicsObject", _wrap_gkPhysicsProperties_isPhysicsObject},
    { "isStatic", _wrap_gkPhysicsProperties_isStatic},
    { "isDynamic", _wrap_gkPhysicsProperties_isDynamic},
    { "isRigid", _wrap_gkPhysicsProperties_isRigid},
    { "isSoft", _wrap_gkPhysicsProperties_isSoft},
    { "isMeshShape", _wrap_gkPhysicsProperties_isMeshShape},
    { "hasPhysicsConstraint", _wrap_gkPhysicsProperties_hasPhysicsConstraint},
    { "isLinkedToOther", _wrap_gkPhysicsProperties_isLinkedToOther},
    { "getConstraintCount", _wrap_gkPhysicsProperties_getConstraintCount},
    { "getConstraint", _wrap_gkPhysicsProperties_getConstraint},
    {0,0}
};
static swig_lua_method swig_gkPhysicsProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkPhysicsProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkPhysicsProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkPhysicsProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkPhysicsProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkPhysicsProperties_Sf_SwigStatic = {
    "gkPhysicsProperties",
    swig_gkPhysicsProperties_Sf_SwigStatic_methods,
    swig_gkPhysicsProperties_Sf_SwigStatic_attributes,
    swig_gkPhysicsProperties_Sf_SwigStatic_constants,
    swig_gkPhysicsProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkPhysicsProperties_bases[] = {0};
static const char *swig_gkPhysicsProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkPhysicsProperties = { "gkPhysicsProperties", "gkPhysicsProperties", &SWIGTYPE_p_gkPhysicsProperties,_proxy__wrap_new_gkPhysicsProperties, swig_delete_gkPhysicsProperties, swig_gkPhysicsProperties_methods, swig_gkPhysicsProperties_attributes, &swig_gkPhysicsProperties_Sf_SwigStatic, swig_gkPhysicsProperties_meta, swig_gkPhysicsProperties_bases, swig_gkPhysicsProperties_base_names };

static int _wrap_new_gkGameObjectProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *result = 0 ;
  
  SWIG_check_num_args("gkGameObjectProperties::gkGameObjectProperties",0,0)
  result = (gkGameObjectProperties *)new gkGameObjectProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkGameObjectProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_transform_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkTransformState arg2 ;
  gkTransformState *argp2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_transform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_transform",1,"gkGameObjectProperties *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_transform",2,"gkTransformState");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_transform_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gkTransformState,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_transform_set",2,SWIGTYPE_p_gkTransformState);
  }
  arg2 = *argp2;
  
  if (arg1) (arg1)->m_transform = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_transform_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkTransformState result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_transform",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_transform",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_transform_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result =  ((arg1)->m_transform);
  {
    gkTransformState * resultptr = new gkTransformState((const gkTransformState &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkTransformState,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_mode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_mode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_mode",1,"gkGameObjectProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_mode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_mode_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_mode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_mode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_mode",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_mode_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (int) ((arg1)->m_mode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_state_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_state",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_state",1,"gkGameObjectProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_state",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_state_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_state = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_state_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_state",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_state_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (int) ((arg1)->m_state);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_physics_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkPhysicsProperties *arg2 = (gkPhysicsProperties *) 0 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_physics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_physics",1,"gkGameObjectProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_physics",2,"gkPhysicsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_physics_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkPhysicsProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_physics_set",2,SWIGTYPE_p_gkPhysicsProperties);
  }
  
  if (arg1) (arg1)->m_physics = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_physics_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkPhysicsProperties *result = 0 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_physics",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_physics",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_physics_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (gkPhysicsProperties *)& ((arg1)->m_physics);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkPhysicsProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_findPathFlag_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  unsigned char arg2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_findPathFlag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_findPathFlag",1,"gkGameObjectProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_findPathFlag",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_findPathFlag_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_findPathFlag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_findPathFlag_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  unsigned char result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_findPathFlag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_findPathFlag",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_findPathFlag_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (unsigned char) ((arg1)->m_findPathFlag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_parent_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_parent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_parent",1,"gkGameObjectProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_parent",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_parent_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_parent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_parent_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_parent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_parent",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_parent_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result =  ((arg1)->m_parent);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_boneParent_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_boneParent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_boneParent",1,"gkGameObjectProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_boneParent",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_boneParent_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_boneParent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_boneParent_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_boneParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_boneParent",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_boneParent_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result =  ((arg1)->m_boneParent);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_particleObjs_set(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  utArray< gkString > arg2 ;
  utArray< gkString > *argp2 ;
  
  SWIG_check_num_args("gkGameObjectProperties::m_particleObjs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_particleObjs",1,"gkGameObjectProperties *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gkGameObjectProperties::m_particleObjs",2,"utArray< gkString >");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_particleObjs_set",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_utArrayT_gkString_t,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_particleObjs_set",2,SWIGTYPE_p_utArrayT_gkString_t);
  }
  arg2 = *argp2;
  
  if (arg1) (arg1)->m_particleObjs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_m_particleObjs_get(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  utArray< gkString > result;
  
  SWIG_check_num_args("gkGameObjectProperties::m_particleObjs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::m_particleObjs",1,"gkGameObjectProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_m_particleObjs_get",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result =  ((arg1)->m_particleObjs);
  {
    utArray< gkString > * resultptr = new utArray< gkString >((const utArray< gkString > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_utArrayT_gkString_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isContactListener(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isContactListener",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isContactListener",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isContactListener",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isContactListener();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isDosser(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isDosser",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isDosser",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isDosser",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isDosser();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isRigidOrDynamic(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isRigidOrDynamic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isRigidOrDynamic",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isRigidOrDynamic",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isRigidOrDynamic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isRigidOrStatic(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isRigidOrStatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isRigidOrStatic",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isRigidOrStatic",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isRigidOrStatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_hasBoneParent(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::hasBoneParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::hasBoneParent",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_hasBoneParent",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->hasBoneParent();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isPhysicsObject(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isPhysicsObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isPhysicsObject",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isPhysicsObject",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isPhysicsObject();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isStatic(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isStatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isStatic",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isStatic",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isStatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isDynamic(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isDynamic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isDynamic",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isDynamic",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isDynamic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isRigid(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isRigid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isRigid",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isRigid",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isRigid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isSoft(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isSoft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isSoft",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isSoft",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isSoft();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isMeshShape(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isMeshShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isMeshShape",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isMeshShape",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isMeshShape();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isActor(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isActor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isActor",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isActor",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isActor();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isInvisible(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isInvisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isInvisible",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isInvisible",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isInvisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isOccluder(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isOccluder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isOccluder",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isOccluder",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isOccluder();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_isGhost(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::isGhost",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::isGhost",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_isGhost",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->isGhost();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGameObjectProperties_hasParticles(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectProperties *arg1 = (gkGameObjectProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkGameObjectProperties::hasParticles",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGameObjectProperties::hasParticles",1,"gkGameObjectProperties const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectProperties,0))){
    SWIG_fail_ptr("gkGameObjectProperties_hasParticles",1,SWIGTYPE_p_gkGameObjectProperties);
  }
  
  result = (bool)((gkGameObjectProperties const *)arg1)->hasParticles();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkGameObjectProperties(void *obj) {
gkGameObjectProperties *arg1 = (gkGameObjectProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkGameObjectProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkGameObjectProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkGameObjectProperties_attributes[] = {
    { "m_transform", _wrap_gkGameObjectProperties_m_transform_get, _wrap_gkGameObjectProperties_m_transform_set },
    { "m_mode", _wrap_gkGameObjectProperties_m_mode_get, _wrap_gkGameObjectProperties_m_mode_set },
    { "m_state", _wrap_gkGameObjectProperties_m_state_get, _wrap_gkGameObjectProperties_m_state_set },
    { "m_physics", _wrap_gkGameObjectProperties_m_physics_get, _wrap_gkGameObjectProperties_m_physics_set },
    { "m_findPathFlag", _wrap_gkGameObjectProperties_m_findPathFlag_get, _wrap_gkGameObjectProperties_m_findPathFlag_set },
    { "m_parent", _wrap_gkGameObjectProperties_m_parent_get, _wrap_gkGameObjectProperties_m_parent_set },
    { "m_boneParent", _wrap_gkGameObjectProperties_m_boneParent_get, _wrap_gkGameObjectProperties_m_boneParent_set },
    { "m_particleObjs", _wrap_gkGameObjectProperties_m_particleObjs_get, _wrap_gkGameObjectProperties_m_particleObjs_set },
    {0,0,0}
};
static swig_lua_method swig_gkGameObjectProperties_methods[]= {
    { "isContactListener", _wrap_gkGameObjectProperties_isContactListener},
    { "isDosser", _wrap_gkGameObjectProperties_isDosser},
    { "isRigidOrDynamic", _wrap_gkGameObjectProperties_isRigidOrDynamic},
    { "isRigidOrStatic", _wrap_gkGameObjectProperties_isRigidOrStatic},
    { "hasBoneParent", _wrap_gkGameObjectProperties_hasBoneParent},
    { "isPhysicsObject", _wrap_gkGameObjectProperties_isPhysicsObject},
    { "isStatic", _wrap_gkGameObjectProperties_isStatic},
    { "isDynamic", _wrap_gkGameObjectProperties_isDynamic},
    { "isRigid", _wrap_gkGameObjectProperties_isRigid},
    { "isSoft", _wrap_gkGameObjectProperties_isSoft},
    { "isMeshShape", _wrap_gkGameObjectProperties_isMeshShape},
    { "isActor", _wrap_gkGameObjectProperties_isActor},
    { "isInvisible", _wrap_gkGameObjectProperties_isInvisible},
    { "isOccluder", _wrap_gkGameObjectProperties_isOccluder},
    { "isGhost", _wrap_gkGameObjectProperties_isGhost},
    { "hasParticles", _wrap_gkGameObjectProperties_hasParticles},
    {0,0}
};
static swig_lua_method swig_gkGameObjectProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkGameObjectProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkGameObjectProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkGameObjectProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkGameObjectProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkGameObjectProperties_Sf_SwigStatic = {
    "gkGameObjectProperties",
    swig_gkGameObjectProperties_Sf_SwigStatic_methods,
    swig_gkGameObjectProperties_Sf_SwigStatic_attributes,
    swig_gkGameObjectProperties_Sf_SwigStatic_constants,
    swig_gkGameObjectProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkGameObjectProperties_bases[] = {0};
static const char *swig_gkGameObjectProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkGameObjectProperties = { "gkGameObjectProperties", "gkGameObjectProperties", &SWIGTYPE_p_gkGameObjectProperties,_proxy__wrap_new_gkGameObjectProperties, swig_delete_gkGameObjectProperties, swig_gkGameObjectProperties_methods, swig_gkGameObjectProperties_attributes, &swig_gkGameObjectProperties_Sf_SwigStatic, swig_gkGameObjectProperties_meta, swig_gkGameObjectProperties_bases, swig_gkGameObjectProperties_base_names };

static int _wrap_new_gkFogParams(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *result = 0 ;
  
  SWIG_check_num_args("gkFogParams::gkFogParams",0,0)
  result = (gkFogParams *)new gkFogParams();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkFogParams,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_mode_set(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkFogParams::m_mode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_mode",1,"gkFogParams *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkFogParams::m_mode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_mode_set",1,SWIGTYPE_p_gkFogParams);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_mode_get(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  int result;
  
  SWIG_check_num_args("gkFogParams::m_mode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_mode",1,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_mode_get",1,SWIGTYPE_p_gkFogParams);
  }
  
  result = (int) ((arg1)->m_mode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_start_set(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkFogParams::m_start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_start",1,"gkFogParams *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkFogParams::m_start",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_start_set",1,SWIGTYPE_p_gkFogParams);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_start = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_start_get(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float result;
  
  SWIG_check_num_args("gkFogParams::m_start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_start",1,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_start_get",1,SWIGTYPE_p_gkFogParams);
  }
  
  result = (float) ((arg1)->m_start);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_end_set(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkFogParams::m_end",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_end",1,"gkFogParams *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkFogParams::m_end",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_end_set",1,SWIGTYPE_p_gkFogParams);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_end = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_end_get(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float result;
  
  SWIG_check_num_args("gkFogParams::m_end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_end",1,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_end_get",1,SWIGTYPE_p_gkFogParams);
  }
  
  result = (float) ((arg1)->m_end);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_intensity_set(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkFogParams::m_intensity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_intensity",1,"gkFogParams *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkFogParams::m_intensity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_intensity_set",1,SWIGTYPE_p_gkFogParams);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_intensity = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_intensity_get(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  float result;
  
  SWIG_check_num_args("gkFogParams::m_intensity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_intensity",1,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_intensity_get",1,SWIGTYPE_p_gkFogParams);
  }
  
  result = (float) ((arg1)->m_intensity);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_color_set(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkFogParams::m_color",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_color",1,"gkFogParams *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkFogParams::m_color",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_color_set",1,SWIGTYPE_p_gkFogParams);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkFogParams_m_color_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_color = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkFogParams_m_color_get(lua_State* L) {
  int SWIG_arg = 0;
  gkFogParams *arg1 = (gkFogParams *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkFogParams::m_color",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkFogParams::m_color",1,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkFogParams_m_color_get",1,SWIGTYPE_p_gkFogParams);
  }
  
  result = (gkColor *)& ((arg1)->m_color);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkFogParams(void *obj) {
gkFogParams *arg1 = (gkFogParams *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkFogParams(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkFogParams);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkFogParams_attributes[] = {
    { "m_mode", _wrap_gkFogParams_m_mode_get, _wrap_gkFogParams_m_mode_set },
    { "m_start", _wrap_gkFogParams_m_start_get, _wrap_gkFogParams_m_start_set },
    { "m_end", _wrap_gkFogParams_m_end_get, _wrap_gkFogParams_m_end_set },
    { "m_intensity", _wrap_gkFogParams_m_intensity_get, _wrap_gkFogParams_m_intensity_set },
    { "m_color", _wrap_gkFogParams_m_color_get, _wrap_gkFogParams_m_color_set },
    {0,0,0}
};
static swig_lua_method swig_gkFogParams_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkFogParams_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkFogParams_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkFogParams_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("FM_NONE", gkFogParams::FM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("FM_LIN", gkFogParams::FM_LIN)},
    {SWIG_LUA_CONSTTAB_INT("FM_EXP", gkFogParams::FM_EXP)},
    {SWIG_LUA_CONSTTAB_INT("FM_QUAD", gkFogParams::FM_QUAD)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkFogParams_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkFogParams_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkFogParams_Sf_SwigStatic = {
    "gkFogParams",
    swig_gkFogParams_Sf_SwigStatic_methods,
    swig_gkFogParams_Sf_SwigStatic_attributes,
    swig_gkFogParams_Sf_SwigStatic_constants,
    swig_gkFogParams_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkFogParams_bases[] = {0};
static const char *swig_gkFogParams_base_names[] = {0};
static swig_lua_class _wrap_class_gkFogParams = { "gkFogParams", "gkFogParams", &SWIGTYPE_p_gkFogParams,_proxy__wrap_new_gkFogParams, swig_delete_gkFogParams, swig_gkFogParams_methods, swig_gkFogParams_attributes, &swig_gkFogParams_Sf_SwigStatic, swig_gkFogParams_meta, swig_gkFogParams_bases, swig_gkFogParams_base_names };

static int _wrap_new_gkSoundSceneProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *result = 0 ;
  
  SWIG_check_num_args("gkSoundSceneProperties::gkSoundSceneProperties",0,0)
  result = (gkSoundSceneProperties *)new gkSoundSceneProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSoundSceneProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_distModel_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_distModel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_distModel",1,"gkSoundSceneProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundSceneProperties::m_distModel",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_distModel_set",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_distModel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_distModel_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_distModel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_distModel",1,"gkSoundSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_distModel_get",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  result = (int) ((arg1)->m_distModel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_dopplerFactor_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_dopplerFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_dopplerFactor",1,"gkSoundSceneProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundSceneProperties::m_dopplerFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_dopplerFactor_set",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_dopplerFactor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_dopplerFactor_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_dopplerFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_dopplerFactor",1,"gkSoundSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_dopplerFactor_get",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  result = (float) ((arg1)->m_dopplerFactor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_sndSpeed_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_sndSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_sndSpeed",1,"gkSoundSceneProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundSceneProperties::m_sndSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_sndSpeed_set",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_sndSpeed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_sndSpeed_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_sndSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_sndSpeed",1,"gkSoundSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_sndSpeed_get",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  result = (float) ((arg1)->m_sndSpeed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_globalVolume_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_globalVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_globalVolume",1,"gkSoundSceneProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundSceneProperties::m_globalVolume",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_globalVolume_set",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_globalVolume = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundSceneProperties_m_globalVolume_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundSceneProperties::m_globalVolume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundSceneProperties::m_globalVolume",1,"gkSoundSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundSceneProperties,0))){
    SWIG_fail_ptr("gkSoundSceneProperties_m_globalVolume_get",1,SWIGTYPE_p_gkSoundSceneProperties);
  }
  
  result = (float) ((arg1)->m_globalVolume);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkSoundSceneProperties(void *obj) {
gkSoundSceneProperties *arg1 = (gkSoundSceneProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkSoundSceneProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkSoundSceneProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkSoundSceneProperties_attributes[] = {
    { "m_distModel", _wrap_gkSoundSceneProperties_m_distModel_get, _wrap_gkSoundSceneProperties_m_distModel_set },
    { "m_dopplerFactor", _wrap_gkSoundSceneProperties_m_dopplerFactor_get, _wrap_gkSoundSceneProperties_m_dopplerFactor_set },
    { "m_sndSpeed", _wrap_gkSoundSceneProperties_m_sndSpeed_get, _wrap_gkSoundSceneProperties_m_sndSpeed_set },
    { "m_globalVolume", _wrap_gkSoundSceneProperties_m_globalVolume_get, _wrap_gkSoundSceneProperties_m_globalVolume_set },
    {0,0,0}
};
static swig_lua_method swig_gkSoundSceneProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkSoundSceneProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkSoundSceneProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkSoundSceneProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("DM_NONE", gkSoundSceneProperties::DM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("DM_INVERSE", gkSoundSceneProperties::DM_INVERSE)},
    {SWIG_LUA_CONSTTAB_INT("DM_LINEAR", gkSoundSceneProperties::DM_LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("DM_EXPONENT", gkSoundSceneProperties::DM_EXPONENT)},
    {SWIG_LUA_CONSTTAB_INT("DM_INVERSE_CLAMP", gkSoundSceneProperties::DM_INVERSE_CLAMP)},
    {SWIG_LUA_CONSTTAB_INT("DM_LINEAR_CLAMP", gkSoundSceneProperties::DM_LINEAR_CLAMP)},
    {SWIG_LUA_CONSTTAB_INT("DM_EXPONENT_CLAMP", gkSoundSceneProperties::DM_EXPONENT_CLAMP)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkSoundSceneProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkSoundSceneProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkSoundSceneProperties_Sf_SwigStatic = {
    "gkSoundSceneProperties",
    swig_gkSoundSceneProperties_Sf_SwigStatic_methods,
    swig_gkSoundSceneProperties_Sf_SwigStatic_attributes,
    swig_gkSoundSceneProperties_Sf_SwigStatic_constants,
    swig_gkSoundSceneProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkSoundSceneProperties_bases[] = {0};
static const char *swig_gkSoundSceneProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkSoundSceneProperties = { "gkSoundSceneProperties", "gkSoundSceneProperties", &SWIGTYPE_p_gkSoundSceneProperties,_proxy__wrap_new_gkSoundSceneProperties, swig_delete_gkSoundSceneProperties, swig_gkSoundSceneProperties_methods, swig_gkSoundSceneProperties_attributes, &swig_gkSoundSceneProperties_Sf_SwigStatic, swig_gkSoundSceneProperties_meta, swig_gkSoundSceneProperties_bases, swig_gkSoundSceneProperties_base_names };

static int _wrap_new_gkSceneMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *result = 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::gkSceneMaterial",0,0)
  result = (gkSceneMaterial *)new gkSceneMaterial();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSceneMaterial,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_type_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_type",1,"gkSceneMaterial *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSceneMaterial::m_type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_type_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_type_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  int result;
  
  SWIG_check_num_args("gkSceneMaterial::m_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_type",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_type_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result = (int) ((arg1)->m_type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_name_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_name",1,"gkSceneMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkSceneMaterial::m_name",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_name_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_name_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkSceneMaterial::m_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_name",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_name_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result =  ((arg1)->m_name);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_horizon_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_horizon",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_horizon",1,"gkSceneMaterial *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneMaterial::m_horizon",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_horizon_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_horizon_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_horizon = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_horizon_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_horizon",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_horizon",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_horizon_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result = (gkColor *)& ((arg1)->m_horizon);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_zenith_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_zenith",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_zenith",1,"gkSceneMaterial *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneMaterial::m_zenith",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_zenith_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_zenith_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_zenith = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_zenith_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_zenith",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_zenith",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_zenith_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result = (gkColor *)& ((arg1)->m_zenith);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_ambient_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *arg2 = (gkColor *) 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_ambient",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_ambient",1,"gkSceneMaterial *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneMaterial::m_ambient",2,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_ambient_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_ambient_set",2,SWIGTYPE_p_gkColor);
  }
  
  if (arg1) (arg1)->m_ambient = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_ambient_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_ambient",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_ambient",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_ambient_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result = (gkColor *)& ((arg1)->m_ambient);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_distance_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSceneMaterial::m_distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_distance",1,"gkSceneMaterial *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSceneMaterial::m_distance",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_distance_set",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_distance = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneMaterial_m_distance_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneMaterial *arg1 = (gkSceneMaterial *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSceneMaterial::m_distance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneMaterial::m_distance",1,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneMaterial_m_distance_get",1,SWIGTYPE_p_gkSceneMaterial);
  }
  
  result = (float) ((arg1)->m_distance);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkSceneMaterial(void *obj) {
gkSceneMaterial *arg1 = (gkSceneMaterial *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkSceneMaterial(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkSceneMaterial);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkSceneMaterial_attributes[] = {
    { "m_type", _wrap_gkSceneMaterial_m_type_get, _wrap_gkSceneMaterial_m_type_set },
    { "m_name", _wrap_gkSceneMaterial_m_name_get, _wrap_gkSceneMaterial_m_name_set },
    { "m_horizon", _wrap_gkSceneMaterial_m_horizon_get, _wrap_gkSceneMaterial_m_horizon_set },
    { "m_zenith", _wrap_gkSceneMaterial_m_zenith_get, _wrap_gkSceneMaterial_m_zenith_set },
    { "m_ambient", _wrap_gkSceneMaterial_m_ambient_get, _wrap_gkSceneMaterial_m_ambient_set },
    { "m_distance", _wrap_gkSceneMaterial_m_distance_get, _wrap_gkSceneMaterial_m_distance_set },
    {0,0,0}
};
static swig_lua_method swig_gkSceneMaterial_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkSceneMaterial_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkSceneMaterial_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkSceneMaterial_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("FLAT", gkSceneMaterial::FLAT)},
    {SWIG_LUA_CONSTTAB_INT("LINEAR", gkSceneMaterial::LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("RADIAL", gkSceneMaterial::RADIAL)},
    {SWIG_LUA_CONSTTAB_INT("REFLECTED", gkSceneMaterial::REFLECTED)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkSceneMaterial_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkSceneMaterial_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkSceneMaterial_Sf_SwigStatic = {
    "gkSceneMaterial",
    swig_gkSceneMaterial_Sf_SwigStatic_methods,
    swig_gkSceneMaterial_Sf_SwigStatic_attributes,
    swig_gkSceneMaterial_Sf_SwigStatic_constants,
    swig_gkSceneMaterial_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkSceneMaterial_bases[] = {0};
static const char *swig_gkSceneMaterial_base_names[] = {0};
static swig_lua_class _wrap_class_gkSceneMaterial = { "gkSceneMaterial", "gkSceneMaterial", &SWIGTYPE_p_gkSceneMaterial,_proxy__wrap_new_gkSceneMaterial, swig_delete_gkSceneMaterial, swig_gkSceneMaterial_methods, swig_gkSceneMaterial_attributes, &swig_gkSceneMaterial_Sf_SwigStatic, swig_gkSceneMaterial_meta, swig_gkSceneMaterial_bases, swig_gkSceneMaterial_base_names };

static int _wrap_new_gkSceneProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *result = 0 ;
  
  SWIG_check_num_args("gkSceneProperties::gkSceneProperties",0,0)
  result = (gkSceneProperties *)new gkSceneProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSceneProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_manager_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkSceneProperties::m_manager",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_manager",1,"gkSceneProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSceneProperties::m_manager",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_manager_set",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_manager = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_manager_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkSceneProperties::m_manager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_manager",1,"gkSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_manager_get",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  result = (int) ((arg1)->m_manager);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_gravity_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_gravity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_gravity",1,"gkSceneProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneProperties::m_gravity",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_gravity_set",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkSceneProperties_m_gravity_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_gravity_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_gravity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_gravity",1,"gkSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_gravity_get",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_gravity);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_material_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkSceneMaterial *arg2 = (gkSceneMaterial *) 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_material",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_material",1,"gkSceneProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneProperties::m_material",2,"gkSceneMaterial *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_material_set",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkSceneMaterial,0))){
    SWIG_fail_ptr("gkSceneProperties_m_material_set",2,SWIGTYPE_p_gkSceneMaterial);
  }
  
  if (arg1) (arg1)->m_material = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_material_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkSceneMaterial *result = 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_material",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_material",1,"gkSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_material_get",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  result = (gkSceneMaterial *)& ((arg1)->m_material);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSceneMaterial,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_fog_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkFogParams *arg2 = (gkFogParams *) 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_fog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_fog",1,"gkSceneProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSceneProperties::m_fog",2,"gkFogParams *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_fog_set",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkFogParams,0))){
    SWIG_fail_ptr("gkSceneProperties_m_fog_set",2,SWIGTYPE_p_gkFogParams);
  }
  
  if (arg1) (arg1)->m_fog = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_fog_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  gkFogParams *result = 0 ;
  
  SWIG_check_num_args("gkSceneProperties::m_fog",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_fog",1,"gkSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_fog_get",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  result = (gkFogParams *)& ((arg1)->m_fog);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkFogParams,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_pbsRequested_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkSceneProperties::m_pbsRequested",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_pbsRequested",1,"gkSceneProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkSceneProperties::m_pbsRequested",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_pbsRequested_set",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_pbsRequested = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSceneProperties_m_pbsRequested_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSceneProperties *arg1 = (gkSceneProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkSceneProperties::m_pbsRequested",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSceneProperties::m_pbsRequested",1,"gkSceneProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSceneProperties,0))){
    SWIG_fail_ptr("gkSceneProperties_m_pbsRequested_get",1,SWIGTYPE_p_gkSceneProperties);
  }
  
  result = (bool) ((arg1)->m_pbsRequested);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkSceneProperties(void *obj) {
gkSceneProperties *arg1 = (gkSceneProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkSceneProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkSceneProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkSceneProperties_attributes[] = {
    { "m_manager", _wrap_gkSceneProperties_m_manager_get, _wrap_gkSceneProperties_m_manager_set },
    { "m_gravity", _wrap_gkSceneProperties_m_gravity_get, _wrap_gkSceneProperties_m_gravity_set },
    { "m_material", _wrap_gkSceneProperties_m_material_get, _wrap_gkSceneProperties_m_material_set },
    { "m_fog", _wrap_gkSceneProperties_m_fog_get, _wrap_gkSceneProperties_m_fog_set },
    { "m_pbsRequested", _wrap_gkSceneProperties_m_pbsRequested_get, _wrap_gkSceneProperties_m_pbsRequested_set },
    {0,0,0}
};
static swig_lua_method swig_gkSceneProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkSceneProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkSceneProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkSceneProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("MA_GENERIC", gkSceneProperties::MA_GENERIC)},
    {SWIG_LUA_CONSTTAB_INT("MA_OCTREE", gkSceneProperties::MA_OCTREE)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkSceneProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkSceneProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkSceneProperties_Sf_SwigStatic = {
    "gkSceneProperties",
    swig_gkSceneProperties_Sf_SwigStatic_methods,
    swig_gkSceneProperties_Sf_SwigStatic_attributes,
    swig_gkSceneProperties_Sf_SwigStatic_constants,
    swig_gkSceneProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkSceneProperties_bases[] = {0};
static const char *swig_gkSceneProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkSceneProperties = { "gkSceneProperties", "gkSceneProperties", &SWIGTYPE_p_gkSceneProperties,_proxy__wrap_new_gkSceneProperties, swig_delete_gkSceneProperties, swig_gkSceneProperties_methods, swig_gkSceneProperties_attributes, &swig_gkSceneProperties_Sf_SwigStatic, swig_gkSceneProperties_meta, swig_gkSceneProperties_bases, swig_gkSceneProperties_base_names };

static int _wrap_gkParticleSettingsProperties_m_name_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_name",1,"gkParticleSettingsProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_name",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_name_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_name_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_name",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_name_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result =  ((arg1)->m_name);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_amount_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_amount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_amount",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_amount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_amount_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_amount = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_amount_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_amount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_amount",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_amount_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_amount);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_emitfrom_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_emitfrom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_emitfrom",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_emitfrom",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_emitfrom_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_emitfrom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_emitfrom_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_emitfrom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_emitfrom",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_emitfrom_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_emitfrom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_lifetime_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_lifetime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_lifetime",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_lifetime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_lifetime_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_lifetime = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_lifetime_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_lifetime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_lifetime",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_lifetime_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_lifetime);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_start_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_start",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_start",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_start_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_start = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_start_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_start",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_start_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_start);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_end_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_end",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_end",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_end",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_end_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_end = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_end_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_end",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_end_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_end);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_random_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_random",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_random",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_random",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_random_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_random = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_random_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_random",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_random",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_random_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_random);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_jitter_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_jitter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_jitter",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_jitter",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_jitter_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_jitter = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_jitter_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_jitter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_jitter",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_jitter_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_jitter);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_render_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_render",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_render",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_render",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_render_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_render = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_render_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_render",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_render",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_render_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_render);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velocity_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velocity",1,"gkParticleSettingsProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_velocity",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velocity_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velocity_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_velocity = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velocity_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velocity",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velocity_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_velocity);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velNormal_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velNormal",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_velNormal",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velNormal_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_velNormal = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velNormal_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velNormal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velNormal",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velNormal_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_velNormal);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velTanget_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velTanget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velTanget",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_velTanget",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velTanget_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_velTanget = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_velTanget_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_velTanget",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_velTanget",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_velTanget_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_velTanget);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_phyType_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_phyType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_phyType",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_phyType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_phyType_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_phyType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_phyType_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_phyType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_phyType",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_phyType_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_phyType);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_size_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_size",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_size",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_size",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_size_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_size = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_size_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_size",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_size_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_size);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_mass_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_mass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_mass",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_mass",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_mass_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_mass = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_mass_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_mass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_mass",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_mass_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_mass);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_sizeRandom_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_sizeRandom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_sizeRandom",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_sizeRandom",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_sizeRandom_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_sizeRandom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_sizeRandom_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_sizeRandom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_sizeRandom",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_sizeRandom_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_sizeRandom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_material_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_material",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_material",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_material",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_material_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_material = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_material_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_material",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_material",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_material_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_material);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_trailCount_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_trailCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_trailCount",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_trailCount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_trailCount_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_trailCount = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_trailCount_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_trailCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_trailCount",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_trailCount_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (int) ((arg1)->m_trailCount);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_drawEmitter_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_drawEmitter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_drawEmitter",1,"gkParticleSettingsProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_drawEmitter",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_drawEmitter_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_drawEmitter = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_drawEmitter_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_drawEmitter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_drawEmitter",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_drawEmitter_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (bool) ((arg1)->m_drawEmitter);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_gravity_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_gravity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_gravity",1,"gkParticleSettingsProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSettingsProperties::m_gravity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_gravity_set",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_gravity = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSettingsProperties_m_gravity_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkParticleSettingsProperties::m_gravity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSettingsProperties::m_gravity",1,"gkParticleSettingsProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSettingsProperties,0))){
    SWIG_fail_ptr("gkParticleSettingsProperties_m_gravity_get",1,SWIGTYPE_p_gkParticleSettingsProperties);
  }
  
  result = (float) ((arg1)->m_gravity);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkParticleSettingsProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSettingsProperties *result = 0 ;
  
  SWIG_check_num_args("gkParticleSettingsProperties::gkParticleSettingsProperties",0,0)
  result = (gkParticleSettingsProperties *)new gkParticleSettingsProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkParticleSettingsProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkParticleSettingsProperties(void *obj) {
gkParticleSettingsProperties *arg1 = (gkParticleSettingsProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkParticleSettingsProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkParticleSettingsProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkParticleSettingsProperties_attributes[] = {
    { "m_name", _wrap_gkParticleSettingsProperties_m_name_get, _wrap_gkParticleSettingsProperties_m_name_set },
    { "m_amount", _wrap_gkParticleSettingsProperties_m_amount_get, _wrap_gkParticleSettingsProperties_m_amount_set },
    { "m_emitfrom", _wrap_gkParticleSettingsProperties_m_emitfrom_get, _wrap_gkParticleSettingsProperties_m_emitfrom_set },
    { "m_lifetime", _wrap_gkParticleSettingsProperties_m_lifetime_get, _wrap_gkParticleSettingsProperties_m_lifetime_set },
    { "m_start", _wrap_gkParticleSettingsProperties_m_start_get, _wrap_gkParticleSettingsProperties_m_start_set },
    { "m_end", _wrap_gkParticleSettingsProperties_m_end_get, _wrap_gkParticleSettingsProperties_m_end_set },
    { "m_random", _wrap_gkParticleSettingsProperties_m_random_get, _wrap_gkParticleSettingsProperties_m_random_set },
    { "m_jitter", _wrap_gkParticleSettingsProperties_m_jitter_get, _wrap_gkParticleSettingsProperties_m_jitter_set },
    { "m_render", _wrap_gkParticleSettingsProperties_m_render_get, _wrap_gkParticleSettingsProperties_m_render_set },
    { "m_velocity", _wrap_gkParticleSettingsProperties_m_velocity_get, _wrap_gkParticleSettingsProperties_m_velocity_set },
    { "m_velNormal", _wrap_gkParticleSettingsProperties_m_velNormal_get, _wrap_gkParticleSettingsProperties_m_velNormal_set },
    { "m_velTanget", _wrap_gkParticleSettingsProperties_m_velTanget_get, _wrap_gkParticleSettingsProperties_m_velTanget_set },
    { "m_phyType", _wrap_gkParticleSettingsProperties_m_phyType_get, _wrap_gkParticleSettingsProperties_m_phyType_set },
    { "m_size", _wrap_gkParticleSettingsProperties_m_size_get, _wrap_gkParticleSettingsProperties_m_size_set },
    { "m_mass", _wrap_gkParticleSettingsProperties_m_mass_get, _wrap_gkParticleSettingsProperties_m_mass_set },
    { "m_sizeRandom", _wrap_gkParticleSettingsProperties_m_sizeRandom_get, _wrap_gkParticleSettingsProperties_m_sizeRandom_set },
    { "m_material", _wrap_gkParticleSettingsProperties_m_material_get, _wrap_gkParticleSettingsProperties_m_material_set },
    { "m_trailCount", _wrap_gkParticleSettingsProperties_m_trailCount_get, _wrap_gkParticleSettingsProperties_m_trailCount_set },
    { "m_drawEmitter", _wrap_gkParticleSettingsProperties_m_drawEmitter_get, _wrap_gkParticleSettingsProperties_m_drawEmitter_set },
    { "m_gravity", _wrap_gkParticleSettingsProperties_m_gravity_get, _wrap_gkParticleSettingsProperties_m_gravity_set },
    {0,0,0}
};
static swig_lua_method swig_gkParticleSettingsProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkParticleSettingsProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkParticleSettingsProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkParticleSettingsProperties_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("PHY_NONE", gkParticleSettingsProperties::PHY_NONE)},
    {SWIG_LUA_CONSTTAB_INT("PHY_NEWTON", gkParticleSettingsProperties::PHY_NEWTON)},
    {SWIG_LUA_CONSTTAB_INT("PHY_KEYED", gkParticleSettingsProperties::PHY_KEYED)},
    {SWIG_LUA_CONSTTAB_INT("PHY_BOIDS", gkParticleSettingsProperties::PHY_BOIDS)},
    {SWIG_LUA_CONSTTAB_INT("PHY_FLUID", gkParticleSettingsProperties::PHY_FLUID)},
    {SWIG_LUA_CONSTTAB_INT("EF_VERTS", gkParticleSettingsProperties::EF_VERTS)},
    {SWIG_LUA_CONSTTAB_INT("EF_FACES", gkParticleSettingsProperties::EF_FACES)},
    {SWIG_LUA_CONSTTAB_INT("EF_VOLUME", gkParticleSettingsProperties::EF_VOLUME)},
    {SWIG_LUA_CONSTTAB_INT("EF_PARTICLES", gkParticleSettingsProperties::EF_PARTICLES)},
    {SWIG_LUA_CONSTTAB_INT("R_NONE", gkParticleSettingsProperties::R_NONE)},
    {SWIG_LUA_CONSTTAB_INT("R_HALO", gkParticleSettingsProperties::R_HALO)},
    {SWIG_LUA_CONSTTAB_INT("R_LINE", gkParticleSettingsProperties::R_LINE)},
    {SWIG_LUA_CONSTTAB_INT("R_PATH", gkParticleSettingsProperties::R_PATH)},
    {SWIG_LUA_CONSTTAB_INT("R_OBJECT", gkParticleSettingsProperties::R_OBJECT)},
    {SWIG_LUA_CONSTTAB_INT("R_GROUP", gkParticleSettingsProperties::R_GROUP)},
    {SWIG_LUA_CONSTTAB_INT("R_BILLBOARD", gkParticleSettingsProperties::R_BILLBOARD)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkParticleSettingsProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkParticleSettingsProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkParticleSettingsProperties_Sf_SwigStatic = {
    "gkParticleSettingsProperties",
    swig_gkParticleSettingsProperties_Sf_SwigStatic_methods,
    swig_gkParticleSettingsProperties_Sf_SwigStatic_attributes,
    swig_gkParticleSettingsProperties_Sf_SwigStatic_constants,
    swig_gkParticleSettingsProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkParticleSettingsProperties_bases[] = {0};
static const char *swig_gkParticleSettingsProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkParticleSettingsProperties = { "gkParticleSettingsProperties", "gkParticleSettingsProperties", &SWIGTYPE_p_gkParticleSettingsProperties,_proxy__wrap_new_gkParticleSettingsProperties, swig_delete_gkParticleSettingsProperties, swig_gkParticleSettingsProperties_methods, swig_gkParticleSettingsProperties_attributes, &swig_gkParticleSettingsProperties_Sf_SwigStatic, swig_gkParticleSettingsProperties_meta, swig_gkParticleSettingsProperties_bases, swig_gkParticleSettingsProperties_base_names };

static int _wrap_gkParticleSystemProperties_m_name_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_name",1,"gkParticleSystemProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkParticleSystemProperties::m_name",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_name_set",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_name_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_name",1,"gkParticleSystemProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_name_get",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  result =  ((arg1)->m_name);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_seed_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_seed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_seed",1,"gkParticleSystemProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkParticleSystemProperties::m_seed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_seed_set",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_seed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_seed_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  int result;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_seed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_seed",1,"gkParticleSystemProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_seed_get",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  result = (int) ((arg1)->m_seed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_settings_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_settings",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_settings",1,"gkParticleSystemProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkParticleSystemProperties::m_settings",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_settings_set",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_settings = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_settings_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_settings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_settings",1,"gkParticleSystemProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_settings_get",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  result =  ((arg1)->m_settings);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_material_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_material",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_material",1,"gkParticleSystemProperties *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkParticleSystemProperties::m_material",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_material_set",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->m_material = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_material_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_material",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_material",1,"gkParticleSystemProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_material_get",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  result =  ((arg1)->m_material);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_mesh_set(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkMesh *arg2 = (gkMesh *) 0 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_mesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_mesh",1,"gkParticleSystemProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkParticleSystemProperties::m_mesh",2,"gkMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_mesh_set",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkMesh,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_mesh_set",2,SWIGTYPE_p_gkMesh);
  }
  
  if (arg1) (arg1)->m_mesh = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkParticleSystemProperties_m_mesh_get(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) 0 ;
  gkMesh *result = 0 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::m_mesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkParticleSystemProperties::m_mesh",1,"gkParticleSystemProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkParticleSystemProperties,0))){
    SWIG_fail_ptr("gkParticleSystemProperties_m_mesh_get",1,SWIGTYPE_p_gkParticleSystemProperties);
  }
  
  result = (gkMesh *) ((arg1)->m_mesh);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Mesh); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkParticleSystemProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkParticleSystemProperties *result = 0 ;
  
  SWIG_check_num_args("gkParticleSystemProperties::gkParticleSystemProperties",0,0)
  result = (gkParticleSystemProperties *)new gkParticleSystemProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkParticleSystemProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkParticleSystemProperties(void *obj) {
gkParticleSystemProperties *arg1 = (gkParticleSystemProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkParticleSystemProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkParticleSystemProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkParticleSystemProperties_attributes[] = {
    { "m_name", _wrap_gkParticleSystemProperties_m_name_get, _wrap_gkParticleSystemProperties_m_name_set },
    { "m_seed", _wrap_gkParticleSystemProperties_m_seed_get, _wrap_gkParticleSystemProperties_m_seed_set },
    { "m_settings", _wrap_gkParticleSystemProperties_m_settings_get, _wrap_gkParticleSystemProperties_m_settings_set },
    { "m_material", _wrap_gkParticleSystemProperties_m_material_get, _wrap_gkParticleSystemProperties_m_material_set },
    { "m_mesh", _wrap_gkParticleSystemProperties_m_mesh_get, _wrap_gkParticleSystemProperties_m_mesh_set },
    {0,0,0}
};
static swig_lua_method swig_gkParticleSystemProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkParticleSystemProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkParticleSystemProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkParticleSystemProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkParticleSystemProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkParticleSystemProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkParticleSystemProperties_Sf_SwigStatic = {
    "gkParticleSystemProperties",
    swig_gkParticleSystemProperties_Sf_SwigStatic_methods,
    swig_gkParticleSystemProperties_Sf_SwigStatic_attributes,
    swig_gkParticleSystemProperties_Sf_SwigStatic_constants,
    swig_gkParticleSystemProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkParticleSystemProperties_bases[] = {0};
static const char *swig_gkParticleSystemProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkParticleSystemProperties = { "gkParticleSystemProperties", "gkParticleSystemProperties", &SWIGTYPE_p_gkParticleSystemProperties,_proxy__wrap_new_gkParticleSystemProperties, swig_delete_gkParticleSystemProperties, swig_gkParticleSystemProperties_methods, swig_gkParticleSystemProperties_attributes, &swig_gkParticleSystemProperties_Sf_SwigStatic, swig_gkParticleSystemProperties_meta, swig_gkParticleSystemProperties_bases, swig_gkParticleSystemProperties_base_names };

static int _wrap_new_gkSoundProperties(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::gkSoundProperties",0,0)
  result = (gkSoundProperties *)new gkSoundProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSoundProperties,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_volume_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_volume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_volume",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_volume",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_volume_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_volume = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_volume_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_volume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_volume",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_volume_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_volume);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_pitch_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_pitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_pitch",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_pitch",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_pitch_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_pitch = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_pitch_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_pitch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_pitch",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_pitch_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_pitch);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_loop_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_loop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_loop",1,"gkSoundProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkSoundProperties::m_loop",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_loop_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_loop = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_loop_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkSoundProperties::m_loop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_loop",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_loop_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (bool) ((arg1)->m_loop);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_3dSound_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_3dSound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_3dSound",1,"gkSoundProperties *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gkSoundProperties::m_3dSound",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_3dSound_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->m_3dSound = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_3dSound_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  bool result;
  
  SWIG_check_num_args("gkSoundProperties::m_3dSound",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_3dSound",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_3dSound_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (bool) ((arg1)->m_3dSound);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_refDistance_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_refDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_refDistance",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_refDistance",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_refDistance_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_refDistance = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_refDistance_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_refDistance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_refDistance",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_refDistance_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_refDistance);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_maxDistance_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_maxDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_maxDistance",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_maxDistance",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_maxDistance_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_maxDistance = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_maxDistance_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_maxDistance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_maxDistance",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_maxDistance_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_maxDistance);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_gainClamp_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector2 *arg2 = (gkVector2 *) 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_gainClamp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_gainClamp",1,"gkSoundProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSoundProperties::m_gainClamp",2,"gkVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_gainClamp_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkSoundProperties_m_gainClamp_set",2,SWIGTYPE_p_gkVector2);
  }
  
  if (arg1) (arg1)->m_gainClamp = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_gainClamp_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_gainClamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_gainClamp",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_gainClamp_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (gkVector2 *)& ((arg1)->m_gainClamp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_rolloff_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_rolloff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_rolloff",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_rolloff",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_rolloff_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_rolloff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_rolloff_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_rolloff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_rolloff",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_rolloff_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_rolloff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_coneOuterGain_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_coneOuterGain",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_coneOuterGain",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_coneOuterGain",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_coneOuterGain_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_coneOuterGain = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_coneOuterGain_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_coneOuterGain",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_coneOuterGain",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_coneOuterGain_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_coneOuterGain);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_coneAngle_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector2 *arg2 = (gkVector2 *) 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_coneAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_coneAngle",1,"gkSoundProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSoundProperties::m_coneAngle",2,"gkVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_coneAngle_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkSoundProperties_m_coneAngle_set",2,SWIGTYPE_p_gkVector2);
  }
  
  if (arg1) (arg1)->m_coneAngle = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_coneAngle_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_coneAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_coneAngle",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_coneAngle_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (gkVector2 *)& ((arg1)->m_coneAngle);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_position_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_position",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_position",1,"gkSoundProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSoundProperties::m_position",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_position_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkSoundProperties_m_position_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_position = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_position_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_position",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_position",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_position_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_position);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_velocity_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_velocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_velocity",1,"gkSoundProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSoundProperties::m_velocity",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_velocity_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkSoundProperties_m_velocity_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_velocity = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_velocity_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_velocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_velocity",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_velocity_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_velocity);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_direction_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_direction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_direction",1,"gkSoundProperties *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkSoundProperties::m_direction",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_direction_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkSoundProperties_m_direction_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->m_direction = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_direction_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkSoundProperties::m_direction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_direction",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_direction_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (gkVector3 *)& ((arg1)->m_direction);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_orientation_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkQuaternion arg2 ;
  gkQuaternion *argp2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_orientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_orientation",1,"gkSoundProperties *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gkSoundProperties::m_orientation",2,"gkQuaternion");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_orientation_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gkQuaternion,0))){
    SWIG_fail_ptr("gkSoundProperties_m_orientation_set",2,SWIGTYPE_p_gkQuaternion);
  }
  arg2 = *argp2;
  
  if (arg1) (arg1)->m_orientation = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_orientation_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  gkQuaternion result;
  
  SWIG_check_num_args("gkSoundProperties::m_orientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_orientation",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_orientation_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result =  ((arg1)->m_orientation);
  {
    gkQuaternion * resultptr = new gkQuaternion((const gkQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_height_set(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkSoundProperties::m_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_height",1,"gkSoundProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkSoundProperties::m_height",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_height_set",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->m_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkSoundProperties_m_height_get(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundProperties *arg1 = (gkSoundProperties *) 0 ;
  float result;
  
  SWIG_check_num_args("gkSoundProperties::m_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkSoundProperties::m_height",1,"gkSoundProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundProperties,0))){
    SWIG_fail_ptr("gkSoundProperties_m_height_get",1,SWIGTYPE_p_gkSoundProperties);
  }
  
  result = (float) ((arg1)->m_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkSoundProperties(void *obj) {
gkSoundProperties *arg1 = (gkSoundProperties *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkSoundProperties(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkSoundProperties);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkSoundProperties_attributes[] = {
    { "m_volume", _wrap_gkSoundProperties_m_volume_get, _wrap_gkSoundProperties_m_volume_set },
    { "m_pitch", _wrap_gkSoundProperties_m_pitch_get, _wrap_gkSoundProperties_m_pitch_set },
    { "m_loop", _wrap_gkSoundProperties_m_loop_get, _wrap_gkSoundProperties_m_loop_set },
    { "m_3dSound", _wrap_gkSoundProperties_m_3dSound_get, _wrap_gkSoundProperties_m_3dSound_set },
    { "m_refDistance", _wrap_gkSoundProperties_m_refDistance_get, _wrap_gkSoundProperties_m_refDistance_set },
    { "m_maxDistance", _wrap_gkSoundProperties_m_maxDistance_get, _wrap_gkSoundProperties_m_maxDistance_set },
    { "m_gainClamp", _wrap_gkSoundProperties_m_gainClamp_get, _wrap_gkSoundProperties_m_gainClamp_set },
    { "m_rolloff", _wrap_gkSoundProperties_m_rolloff_get, _wrap_gkSoundProperties_m_rolloff_set },
    { "m_coneOuterGain", _wrap_gkSoundProperties_m_coneOuterGain_get, _wrap_gkSoundProperties_m_coneOuterGain_set },
    { "m_coneAngle", _wrap_gkSoundProperties_m_coneAngle_get, _wrap_gkSoundProperties_m_coneAngle_set },
    { "m_position", _wrap_gkSoundProperties_m_position_get, _wrap_gkSoundProperties_m_position_set },
    { "m_velocity", _wrap_gkSoundProperties_m_velocity_get, _wrap_gkSoundProperties_m_velocity_set },
    { "m_direction", _wrap_gkSoundProperties_m_direction_get, _wrap_gkSoundProperties_m_direction_set },
    { "m_orientation", _wrap_gkSoundProperties_m_orientation_get, _wrap_gkSoundProperties_m_orientation_set },
    { "m_height", _wrap_gkSoundProperties_m_height_get, _wrap_gkSoundProperties_m_height_set },
    {0,0,0}
};
static swig_lua_method swig_gkSoundProperties_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkSoundProperties_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkSoundProperties_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkSoundProperties_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkSoundProperties_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkSoundProperties_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkSoundProperties_Sf_SwigStatic = {
    "gkSoundProperties",
    swig_gkSoundProperties_Sf_SwigStatic_methods,
    swig_gkSoundProperties_Sf_SwigStatic_attributes,
    swig_gkSoundProperties_Sf_SwigStatic_constants,
    swig_gkSoundProperties_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkSoundProperties_bases[] = {0};
static const char *swig_gkSoundProperties_base_names[] = {0};
static swig_lua_class _wrap_class_gkSoundProperties = { "gkSoundProperties", "gkSoundProperties", &SWIGTYPE_p_gkSoundProperties,_proxy__wrap_new_gkSoundProperties, swig_delete_gkSoundProperties, swig_gkSoundProperties_methods, swig_gkSoundProperties_attributes, &swig_gkSoundProperties_Sf_SwigStatic, swig_gkSoundProperties_meta, swig_gkSoundProperties_bases, swig_gkSoundProperties_base_names };

static int _wrap_gsVector2_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = (gsVector2 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector2::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector2::x",1,"gsVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector2::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("gsVector2_x_set",1,SWIGTYPE_p_gsVector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVector2_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = (gsVector2 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector2::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector2::x",1,"gsVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("gsVector2_x_get",1,SWIGTYPE_p_gsVector2);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVector2_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = (gsVector2 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector2::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector2::y",1,"gsVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector2::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("gsVector2_y_set",1,SWIGTYPE_p_gsVector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVector2_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = (gsVector2 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector2::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector2::y",1,"gsVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("gsVector2_y_get",1,SWIGTYPE_p_gsVector2);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsVector2__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *result = 0 ;
  
  SWIG_check_num_args("gsVector2::gsVector2",0,0)
  result = (gsVector2 *)new gsVector2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsVector2__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  gsVector2 *result = 0 ;
  
  SWIG_check_num_args("gsVector2::gsVector2",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsVector2::gsVector2",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector2::gsVector2",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (gsVector2 *)new gsVector2(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsVector2__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = 0 ;
  gsVector2 *result = 0 ;
  
  SWIG_check_num_args("gsVector2::gsVector2",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVector2::gsVector2",1,"gsVector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("new_gsVector2",1,SWIGTYPE_p_gsVector2);
  }
  
  result = (gsVector2 *)new gsVector2((gsVector2 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsVector2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_gsVector2__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsVector2__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_gsVector2__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsVector2'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector2::gsVector2()\n"
    "    gsVector2::gsVector2(float,float)\n"
    "    gsVector2::gsVector2(gsVector2 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsVector2___tostring(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 *arg1 = (gsVector2 *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("gsVector2::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector2::__str__",1,"gsVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector2,0))){
    SWIG_fail_ptr("gsVector2___tostring",1,SWIGTYPE_p_gsVector2);
  }
  
  result = (char *)(arg1)->__str__();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVector2(void *obj) {
gsVector2 *arg1 = (gsVector2 *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVector2(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVector2);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVector2_attributes[] = {
    { "x", _wrap_gsVector2_x_get, _wrap_gsVector2_x_set },
    { "y", _wrap_gsVector2_y_get, _wrap_gsVector2_y_set },
    {0,0,0}
};
static swig_lua_method swig_gsVector2_methods[]= {
    { "__tostring", _wrap_gsVector2___tostring},
    {0,0}
};
static swig_lua_method swig_gsVector2_meta[] = {
    { "__tostring", _wrap_gsVector2___tostring},
    {0,0}
};

static swig_lua_attribute swig_gsVector2_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVector2_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVector2_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVector2_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVector2_Sf_SwigStatic = {
    "gsVector2",
    swig_gsVector2_Sf_SwigStatic_methods,
    swig_gsVector2_Sf_SwigStatic_attributes,
    swig_gsVector2_Sf_SwigStatic_constants,
    swig_gsVector2_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVector2_bases[] = {0};
static const char *swig_gsVector2_base_names[] = {0};
static swig_lua_class _wrap_class_gsVector2 = { "gsVector2", "gsVector2", &SWIGTYPE_p_gsVector2,_proxy__wrap_new_gsVector2, swig_delete_gsVector2, swig_gsVector2_methods, swig_gsVector2_attributes, &swig_gsVector2_Sf_SwigStatic, swig_gsVector2_meta, swig_gsVector2_bases, swig_gsVector2_base_names };

static int _wrap_Vector3_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector3::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::x",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_x_set",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::x",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_x_get",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector3::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::y",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_y_set",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::y",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_y_get",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector3::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::z",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::z",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_z_set",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::z",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_z_get",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *result = 0 ;
  
  SWIG_check_num_args("gsVector3::gsVector3",0,0)
  result = (gsVector3 *)new gsVector3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  gsVector3 *result = 0 ;
  
  SWIG_check_num_args("gsVector3::gsVector3",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsVector3::gsVector3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::gsVector3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsVector3::gsVector3",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (gsVector3 *)new gsVector3(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *result = 0 ;
  
  SWIG_check_num_args("gsVector3::gsVector3",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVector3::gsVector3",1,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_Vector3",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (gsVector3 *)new gsVector3((gsVector3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  OpenSteer::Vec3 arg1 ;
  OpenSteer::Vec3 *argp1 ;
  gsVector3 *result = 0 ;
  
  SWIG_check_num_args("gsVector3::gsVector3",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVector3::gsVector3",1,"OpenSteer::Vec3 const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_OpenSteer__Vec3,0))){
    SWIG_fail_ptr("new_Vector3",1,SWIGTYPE_p_OpenSteer__Vec3);
  }
  arg1 = *argp1;
  
  result = (gsVector3 *)new gsVector3(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector3__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_OpenSteer__Vec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_3(L);
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_Vector3__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vector3'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector3::gsVector3()\n"
    "    gsVector3::gsVector3(float,float,float)\n"
    "    gsVector3::gsVector3(gsVector3 const &)\n"
    "    gsVector3::gsVector3(OpenSteer::Vec3 const)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___tostring(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("gsVector3::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::__str__",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___tostring",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (char *)(arg1)->__str__();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsVector3::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::set",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsVector3::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsVector3::set",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_set",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->set(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_normalize(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::normalize",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_normalize",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->normalize();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_dot(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::dot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::dot",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::dot",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_dot",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_dot",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->dot((gsVector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_cross(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::cross",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::cross",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::cross",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_cross",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_cross",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->cross((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_length(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::length",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_length",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_length2(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::length2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::length2",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_length2",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->length2();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_distance(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::distance",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::distance",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_distance",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_distance",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->distance((gsVector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_distance2(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("gsVector3::distance2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::distance2",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::distance2",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_distance2",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_distance2",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (float)(arg1)->distance2((gsVector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_isNull__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("gsVector3::isNull",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::isNull",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::isNull",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_isNull",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)(arg1)->isNull(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_isNull__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsVector3::isNull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::isNull",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_isNull",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (bool)(arg1)->isNull();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_isNull(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector3_isNull__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3_isNull__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vector3_isNull'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector3::isNull(float)\n"
    "    gsVector3::isNull()\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_getRotationTo(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsVector3::getRotationTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::getRotationTo",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::getRotationTo",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->getRotationTo((gsVector3 const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___unm(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator -",1,"gsVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___unm",1,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator -();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___add(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator +",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::operator +",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___add",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___add",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator +((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___sub(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator -",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::operator -",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___sub",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___sub",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator -((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator *",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::operator *",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___mul",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator *((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator *",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::operator *",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator *(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vector3___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector3::operator *(gsVector3 const &)\n"
    "    gsVector3::operator *(float)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator /",1,"gsVector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector3::operator /",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___div",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___div",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator /((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = (gsVector3 *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVector3::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector3::operator /",1,"gsVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector3::operator /",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vector3___div",1,SWIGTYPE_p_gsVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator /(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___div__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3___div__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vector3___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector3::operator /(gsVector3 const &)\n"
    "    gsVector3::operator /(float)\n");
  lua_error(L);return 0;
}


static void swig_delete_Vector3(void *obj) {
gsVector3 *arg1 = (gsVector3 *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vector3(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vector3);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vector3_attributes[] = {
    { "x", _wrap_Vector3_x_get, _wrap_Vector3_x_set },
    { "y", _wrap_Vector3_y_get, _wrap_Vector3_y_set },
    { "z", _wrap_Vector3_z_get, _wrap_Vector3_z_set },
    {0,0,0}
};
static swig_lua_method swig_Vector3_methods[]= {
    { "__tostring", _wrap_Vector3___tostring},
    { "set", _wrap_Vector3_set},
    { "normalize", _wrap_Vector3_normalize},
    { "dot", _wrap_Vector3_dot},
    { "cross", _wrap_Vector3_cross},
    { "length", _wrap_Vector3_length},
    { "length2", _wrap_Vector3_length2},
    { "distance", _wrap_Vector3_distance},
    { "distance2", _wrap_Vector3_distance2},
    { "isNull", _wrap_Vector3_isNull},
    { "getRotationTo", _wrap_Vector3_getRotationTo},
    { "__unm", _wrap_Vector3___unm},
    { "__add", _wrap_Vector3___add},
    { "__sub", _wrap_Vector3___sub},
    { "__mul", _wrap_Vector3___mul},
    { "__div", _wrap_Vector3___div},
    {0,0}
};
static swig_lua_method swig_Vector3_meta[] = {
    { "__tostring", _wrap_Vector3___tostring},
    { "__unm", _wrap_Vector3___unm},
    { "__add", _wrap_Vector3___add},
    { "__sub", _wrap_Vector3___sub},
    { "__mul", _wrap_Vector3___mul},
    { "__div", _wrap_Vector3___div},
    {0,0}
};

static swig_lua_attribute swig_Vector3_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vector3_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vector3_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Vector3_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vector3_Sf_SwigStatic = {
    "Vector3",
    swig_Vector3_Sf_SwigStatic_methods,
    swig_Vector3_Sf_SwigStatic_attributes,
    swig_Vector3_Sf_SwigStatic_constants,
    swig_Vector3_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vector3_bases[] = {0};
static const char *swig_Vector3_base_names[] = {0};
static swig_lua_class _wrap_class_Vector3 = { "Vector3", "Vector3", &SWIGTYPE_p_gsVector3,_proxy__wrap_new_Vector3, swig_delete_Vector3, swig_Vector3_methods, swig_Vector3_attributes, &swig_Vector3_Sf_SwigStatic, swig_Vector3_meta, swig_Vector3_bases, swig_Vector3_base_names };

static int _wrap_Vector4_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector4::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::x",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_x_set",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector4::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::x",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_x_get",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector4::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::y",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_y_set",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector4::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::y",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_y_get",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector4::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::z",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::z",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_z_set",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector4::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::z",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_z_get",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (float) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVector4::w",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::w",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::w",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_w_set",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_get(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVector4::w",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::w",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_w_get",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (float) ((arg1)->w);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *result = 0 ;
  
  SWIG_check_num_args("gsVector4::gsVector4",0,0)
  result = (gsVector4 *)new gsVector4();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsVector4 *result = 0 ;
  
  SWIG_check_num_args("gsVector4::gsVector4",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsVector4::gsVector4",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::gsVector4",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsVector4::gsVector4",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsVector4::gsVector4",4,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (gsVector4 *)new gsVector4(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = 0 ;
  gsVector4 *result = 0 ;
  
  SWIG_check_num_args("gsVector4::gsVector4",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVector4::gsVector4",1,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("new_Vector4",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (gsVector4 *)new gsVector4((gsVector4 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector4__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_2(L);
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Vector4__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vector4'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector4::gsVector4()\n"
    "    gsVector4::gsVector4(float,float,float,float)\n"
    "    gsVector4::gsVector4(gsVector4 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___tostring(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("gsVector4::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::__str__",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___tostring",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (char *)(arg1)->__str__();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_dot(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("gsVector4::dot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::dot",1,"gsVector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector4::dot",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_dot",1,SWIGTYPE_p_gsVector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_dot",2,SWIGTYPE_p_gsVector4);
  }
  
  result = (float)(arg1)->dot((gsVector4 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsVector4::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::set",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsVector4::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsVector4::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsVector4::set",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4_set",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___unm(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator -",1,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___unm",1,SWIGTYPE_p_gsVector4);
  }
  
  result = (arg1)->operator -();
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___add(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 *arg2 = 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator +",1,"gsVector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector4::operator +",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___add",1,SWIGTYPE_p_gsVector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___add",2,SWIGTYPE_p_gsVector4);
  }
  
  result = (arg1)->operator +((gsVector4 const &)*arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___sub(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 *arg2 = 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator -",1,"gsVector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector4::operator -",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___sub",1,SWIGTYPE_p_gsVector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___sub",2,SWIGTYPE_p_gsVector4);
  }
  
  result = (arg1)->operator -((gsVector4 const &)*arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 *arg2 = 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator *",1,"gsVector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector4::operator *",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___mul",1,SWIGTYPE_p_gsVector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___mul",2,SWIGTYPE_p_gsVector4);
  }
  
  result = (arg1)->operator *((gsVector4 const &)*arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator *",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::operator *",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___mul",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator *(arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector4___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector4___mul__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vector4___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector4::operator *(gsVector4 const &)\n"
    "    gsVector4::operator *(float)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  gsVector4 *arg2 = 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator /",1,"gsVector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVector4::operator /",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___div",1,SWIGTYPE_p_gsVector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___div",2,SWIGTYPE_p_gsVector4);
  }
  
  result = (arg1)->operator /((gsVector4 const &)*arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 *arg1 = (gsVector4 *) 0 ;
  float arg2 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVector4::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVector4::operator /",1,"gsVector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVector4::operator /",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Vector4___div",1,SWIGTYPE_p_gsVector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator /(arg2);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector4___div__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector4___div__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vector4___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVector4::operator /(gsVector4 const &)\n"
    "    gsVector4::operator /(float)\n");
  lua_error(L);return 0;
}


static void swig_delete_Vector4(void *obj) {
gsVector4 *arg1 = (gsVector4 *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vector4(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vector4);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vector4_attributes[] = {
    { "x", _wrap_Vector4_x_get, _wrap_Vector4_x_set },
    { "y", _wrap_Vector4_y_get, _wrap_Vector4_y_set },
    { "z", _wrap_Vector4_z_get, _wrap_Vector4_z_set },
    { "w", _wrap_Vector4_w_get, _wrap_Vector4_w_set },
    {0,0,0}
};
static swig_lua_method swig_Vector4_methods[]= {
    { "__tostring", _wrap_Vector4___tostring},
    { "dot", _wrap_Vector4_dot},
    { "set", _wrap_Vector4_set},
    { "__unm", _wrap_Vector4___unm},
    { "__add", _wrap_Vector4___add},
    { "__sub", _wrap_Vector4___sub},
    { "__mul", _wrap_Vector4___mul},
    { "__div", _wrap_Vector4___div},
    {0,0}
};
static swig_lua_method swig_Vector4_meta[] = {
    { "__tostring", _wrap_Vector4___tostring},
    { "__unm", _wrap_Vector4___unm},
    { "__add", _wrap_Vector4___add},
    { "__sub", _wrap_Vector4___sub},
    { "__mul", _wrap_Vector4___mul},
    { "__div", _wrap_Vector4___div},
    {0,0}
};

static swig_lua_attribute swig_Vector4_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vector4_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vector4_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Vector4_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vector4_Sf_SwigStatic = {
    "Vector4",
    swig_Vector4_Sf_SwigStatic_methods,
    swig_Vector4_Sf_SwigStatic_attributes,
    swig_Vector4_Sf_SwigStatic_constants,
    swig_Vector4_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vector4_bases[] = {0};
static const char *swig_Vector4_base_names[] = {0};
static swig_lua_class _wrap_class_Vector4 = { "Vector4", "Vector4", &SWIGTYPE_p_gsVector4,_proxy__wrap_new_Vector4, swig_delete_Vector4, swig_Vector4_methods, swig_Vector4_attributes, &swig_Vector4_Sf_SwigStatic, swig_Vector4_meta, swig_Vector4_bases, swig_Vector4_base_names };

static int _wrap_Quaternion_w_set(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsQuaternion::w",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::w",1,"gsQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::w",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_w_set",1,SWIGTYPE_p_gsQuaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_w_get(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::w",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::w",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_w_get",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float) ((arg1)->w);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsQuaternion::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::x",1,"gsQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_x_set",1,SWIGTYPE_p_gsQuaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::x",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_x_get",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsQuaternion::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::y",1,"gsQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_y_set",1,SWIGTYPE_p_gsQuaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::y",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_y_get",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_set(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsQuaternion::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::z",1,"gsQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::z",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_z_set",1,SWIGTYPE_p_gsQuaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_get(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::z",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_z_get",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *result = 0 ;
  
  SWIG_check_num_args("gsQuaternion::gsQuaternion",0,0)
  result = (gsQuaternion *)new gsQuaternion();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsQuaternion *result = 0 ;
  
  SWIG_check_num_args("gsQuaternion::gsQuaternion",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsQuaternion::gsQuaternion",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::gsQuaternion",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsQuaternion::gsQuaternion",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsQuaternion::gsQuaternion",4,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (gsQuaternion *)new gsQuaternion(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion *result = 0 ;
  
  SWIG_check_num_args("gsQuaternion::gsQuaternion",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuaternion::gsQuaternion",1,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (gsQuaternion *)new gsQuaternion((gsQuaternion const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Quaternion__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Quaternion__SWIG_2(L);
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Quaternion__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Quaternion'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsQuaternion::gsQuaternion()\n"
    "    gsQuaternion::gsQuaternion(float,float,float,float)\n"
    "    gsQuaternion::gsQuaternion(gsQuaternion const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion___tostring(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("gsQuaternion::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::__str__",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___tostring",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (char *)(arg1)->__str__();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_normalize(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::normalize",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_normalize",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float)(arg1)->normalize();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_length2(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::length2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::length2",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_length2",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float)(arg1)->length2();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_dot(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("gsQuaternion::dot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::dot",1,"gsQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuaternion::dot",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_dot",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_dot",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (float)(arg1)->dot((gsQuaternion const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_inverse(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::inverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::inverse",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_inverse",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->inverse();
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___unm(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator -",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___unm",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->operator -();
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___add(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator +",1,"gsQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuaternion::operator +",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___add",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___add",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->operator +((gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___sub(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator -",1,"gsQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuaternion::operator -",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->operator -((gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator *",1,"gsQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuaternion::operator *",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->operator *((gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  float arg2 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator *",1,"gsQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuaternion::operator *",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_gsQuaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator *(arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::operator *",1,"gsQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuaternion::operator *",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->operator *((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsQuaternion::operator *(gsQuaternion const &)\n"
    "    gsQuaternion::operator *(float)\n"
    "    gsQuaternion::operator *(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_xAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsQuaternion::xAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::xAxis",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_xAxis",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->xAxis();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_yAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsQuaternion::yAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::yAxis",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_yAxis",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->yAxis();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_zAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = (gsQuaternion *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsQuaternion::zAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsQuaternion::zAxis",1,"gsQuaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("Quaternion_zAxis",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = (arg1)->zAxis();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Quaternion(void *obj) {
gsQuaternion *arg1 = (gsQuaternion *) obj;
delete arg1;
}
static int _proxy__wrap_new_Quaternion(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Quaternion);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Quaternion_attributes[] = {
    { "w", _wrap_Quaternion_w_get, _wrap_Quaternion_w_set },
    { "x", _wrap_Quaternion_x_get, _wrap_Quaternion_x_set },
    { "y", _wrap_Quaternion_y_get, _wrap_Quaternion_y_set },
    { "z", _wrap_Quaternion_z_get, _wrap_Quaternion_z_set },
    {0,0,0}
};
static swig_lua_method swig_Quaternion_methods[]= {
    { "__tostring", _wrap_Quaternion___tostring},
    { "normalize", _wrap_Quaternion_normalize},
    { "length2", _wrap_Quaternion_length2},
    { "dot", _wrap_Quaternion_dot},
    { "inverse", _wrap_Quaternion_inverse},
    { "__unm", _wrap_Quaternion___unm},
    { "__add", _wrap_Quaternion___add},
    { "__sub", _wrap_Quaternion___sub},
    { "__mul", _wrap_Quaternion___mul},
    { "xAxis", _wrap_Quaternion_xAxis},
    { "yAxis", _wrap_Quaternion_yAxis},
    { "zAxis", _wrap_Quaternion_zAxis},
    {0,0}
};
static swig_lua_method swig_Quaternion_meta[] = {
    { "__tostring", _wrap_Quaternion___tostring},
    { "__unm", _wrap_Quaternion___unm},
    { "__add", _wrap_Quaternion___add},
    { "__sub", _wrap_Quaternion___sub},
    { "__mul", _wrap_Quaternion___mul},
    {0,0}
};

static swig_lua_attribute swig_Quaternion_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Quaternion_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Quaternion_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Quaternion_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Quaternion_Sf_SwigStatic = {
    "Quaternion",
    swig_Quaternion_Sf_SwigStatic_methods,
    swig_Quaternion_Sf_SwigStatic_attributes,
    swig_Quaternion_Sf_SwigStatic_constants,
    swig_Quaternion_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Quaternion_bases[] = {0};
static const char *swig_Quaternion_base_names[] = {0};
static swig_lua_class _wrap_class_Quaternion = { "Quaternion", "Quaternion", &SWIGTYPE_p_gsQuaternion,_proxy__wrap_new_Quaternion, swig_delete_Quaternion, swig_Quaternion_methods, swig_Quaternion_attributes, &swig_Quaternion_Sf_SwigStatic, swig_Quaternion_meta, swig_Quaternion_bases, swig_Quaternion_base_names };

static int _wrap_new_Matrix4(lua_State* L) {
  int SWIG_arg = 0;
  gsVector4 arg1 ;
  gsVector4 arg2 ;
  gsVector4 arg3 ;
  gsVector4 arg4 ;
  gsVector4 *argp1 ;
  gsVector4 *argp2 ;
  gsVector4 *argp3 ;
  gsVector4 *argp4 ;
  gsMatrix4 *result = 0 ;
  
  SWIG_check_num_args("gsMatrix4::gsMatrix4",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsMatrix4::gsMatrix4",1,"gsVector4");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMatrix4::gsMatrix4",2,"gsVector4");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsMatrix4::gsMatrix4",3,"gsVector4");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsMatrix4::gsMatrix4",4,"gsVector4");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("new_Matrix4",1,SWIGTYPE_p_gsVector4);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("new_Matrix4",2,SWIGTYPE_p_gsVector4);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("new_Matrix4",3,SWIGTYPE_p_gsVector4);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("new_Matrix4",4,SWIGTYPE_p_gsVector4);
  }
  arg4 = *argp4;
  
  result = (gsMatrix4 *)new gsMatrix4(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMatrix4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix4_inverse(lua_State* L) {
  int SWIG_arg = 0;
  gsMatrix4 *arg1 = (gsMatrix4 *) 0 ;
  
  SWIG_check_num_args("gsMatrix4::inverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMatrix4::inverse",1,"gsMatrix4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMatrix4,0))){
    SWIG_fail_ptr("Matrix4_inverse",1,SWIGTYPE_p_gsMatrix4);
  }
  
  (arg1)->inverse();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Matrix4(void *obj) {
gsMatrix4 *arg1 = (gsMatrix4 *) obj;
delete arg1;
}
static int _proxy__wrap_new_Matrix4(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Matrix4);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Matrix4_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Matrix4_methods[]= {
    { "inverse", _wrap_Matrix4_inverse},
    {0,0}
};
static swig_lua_method swig_Matrix4_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Matrix4_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Matrix4_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Matrix4_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Matrix4_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Matrix4_Sf_SwigStatic = {
    "Matrix4",
    swig_Matrix4_Sf_SwigStatic_methods,
    swig_Matrix4_Sf_SwigStatic_attributes,
    swig_Matrix4_Sf_SwigStatic_constants,
    swig_Matrix4_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Matrix4_bases[] = {0};
static const char *swig_Matrix4_base_names[] = {0};
static swig_lua_class _wrap_class_Matrix4 = { "Matrix4", "Matrix4", &SWIGTYPE_p_gsMatrix4,_proxy__wrap_new_Matrix4, swig_delete_Matrix4, swig_Matrix4_methods, swig_Matrix4_attributes, &swig_Matrix4_Sf_SwigStatic, swig_Matrix4_meta, swig_Matrix4_bases, swig_Matrix4_base_names };

static int _wrap_lerp__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion *arg2 = 0 ;
  float arg3 ;
  bool arg4 ;
  gsQuaternion result;
  
  SWIG_check_num_args("lerp",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("lerp",1,"gsQuaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("lerp",2,"gsQuaternion const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("lerp",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("lerp",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("lerp",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("lerp",2,SWIGTYPE_p_gsQuaternion);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = lerp((gsQuaternion const &)*arg1,(gsQuaternion const &)*arg2,arg3,arg4);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_lerp__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("lerp",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("lerp",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("lerp",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("lerp",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("lerp",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("lerp",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = lerp((gsVector3 const &)*arg1,(gsVector3 const &)*arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_lerp(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_lerp__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_lerp__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'lerp'\n"
    "  Possible C/C++ prototypes are:\n"
    "    lerp(gsQuaternion const &,gsQuaternion const &,float,bool)\n"
    "    lerp(gsVector3 const &,gsVector3 const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_getTriNormal(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = 0 ;
  gkVertex *arg2 = 0 ;
  gkVertex *arg3 = 0 ;
  gkVector3 result;
  
  SWIG_check_num_args("getTriNormal",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("getTriNormal",1,"gkVertex const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getTriNormal",2,"gkVertex const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("getTriNormal",3,"gkVertex const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("getTriNormal",1,SWIGTYPE_p_gkVertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("getTriNormal",2,SWIGTYPE_p_gkVertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("getTriNormal",3,SWIGTYPE_p_gkVertex);
  }
  
  result = getTriNormal((gkVertex const &)*arg1,(gkVertex const &)*arg2,(gkVertex const &)*arg3);
  {
    gkVector3 * resultptr = new gkVector3((const gkVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_str2vec3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gsVector3 result;
  
  SWIG_check_num_args("str2vec3",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("str2vec3",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = str2vec3((gkString const &)*arg1);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_str2vec4(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gsVector4 result;
  
  SWIG_check_num_args("str2vec4",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("str2vec4",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = str2vec4((gkString const &)*arg1);
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_str2mat4(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  SwigValueWrapper< gsMatrix4 > result;
  
  SWIG_check_num_args("str2mat4",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("str2mat4",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = str2mat4((gkString const &)*arg1);
  {
    gsMatrix4 * resultptr = new gsMatrix4((const gsMatrix4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsMatrix4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Ray__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRay *result = 0 ;
  
  SWIG_check_num_args("gsRay::gsRay",0,0)
  result = (gsRay *)new gsRay();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRay,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Ray__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsRay *result = 0 ;
  
  SWIG_check_num_args("gsRay::gsRay",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsRay::gsRay",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRay::gsRay",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_Ray",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_Ray",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (gsRay *)new gsRay((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRay,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Ray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Ray__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Ray__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Ray'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRay::gsRay()\n"
    "    gsRay::gsRay(gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Ray_setOrigin(lua_State* L) {
  int SWIG_arg = 0;
  gsRay *arg1 = (gsRay *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsRay::setOrigin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRay::setOrigin",1,"gsRay *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRay::setOrigin",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("Ray_setOrigin",1,SWIGTYPE_p_gsRay);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Ray_setOrigin",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setOrigin((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Ray_setDirection(lua_State* L) {
  int SWIG_arg = 0;
  gsRay *arg1 = (gsRay *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsRay::setDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRay::setDirection",1,"gsRay *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRay::setDirection",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("Ray_setDirection",1,SWIGTYPE_p_gsRay);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Ray_setDirection",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setDirection((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Ray_getOrigin(lua_State* L) {
  int SWIG_arg = 0;
  gsRay *arg1 = (gsRay *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRay::getOrigin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRay::getOrigin",1,"gsRay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("Ray_getOrigin",1,SWIGTYPE_p_gsRay);
  }
  
  result = (arg1)->getOrigin();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Ray_getDirection(lua_State* L) {
  int SWIG_arg = 0;
  gsRay *arg1 = (gsRay *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRay::getDirection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRay::getDirection",1,"gsRay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("Ray_getDirection",1,SWIGTYPE_p_gsRay);
  }
  
  result = (arg1)->getDirection();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Ray(void *obj) {
gsRay *arg1 = (gsRay *) obj;
delete arg1;
}
static int _proxy__wrap_new_Ray(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Ray);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Ray_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Ray_methods[]= {
    { "setOrigin", _wrap_Ray_setOrigin},
    { "setDirection", _wrap_Ray_setDirection},
    { "getOrigin", _wrap_Ray_getOrigin},
    { "getDirection", _wrap_Ray_getDirection},
    {0,0}
};
static swig_lua_method swig_Ray_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Ray_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Ray_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Ray_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Ray_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Ray_Sf_SwigStatic = {
    "Ray",
    swig_Ray_Sf_SwigStatic_methods,
    swig_Ray_Sf_SwigStatic_attributes,
    swig_Ray_Sf_SwigStatic_constants,
    swig_Ray_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Ray_bases[] = {0};
static const char *swig_Ray_base_names[] = {0};
static swig_lua_class _wrap_class_Ray = { "Ray", "Ray", &SWIGTYPE_p_gsRay,_proxy__wrap_new_Ray, swig_delete_Ray, swig_Ray_methods, swig_Ray_attributes, &swig_Ray_Sf_SwigStatic, swig_Ray_meta, swig_Ray_bases, swig_Ray_base_names };

static int _wrap_Vec3Negate(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3Negate",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3Negate",1,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3Negate",1,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3Negate((gsVector3 const &)*arg1);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3AddVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3AddVec3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3AddVec3",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVec3AddVec3",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3AddVec3",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3AddVec3",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3AddVec3((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3SubVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3SubVec3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3SubVec3",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVec3SubVec3",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3SubVec3",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3SubVec3",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3SubVec3((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3MulVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3MulVec3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3MulVec3",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVec3MulVec3",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3MulVec3",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3MulVec3",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3MulVec3((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3DivVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3DivVec3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3DivVec3",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVec3DivVec3",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3DivVec3",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3DivVec3",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3DivVec3((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3Mulf(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3Mulf",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3Mulf",1,"gsVector3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVec3Mulf",2,"float const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3Mulf",1,SWIGTYPE_p_gsVector3);
  }
  
  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  result = gsVec3Mulf((gsVector3 const &)*arg1,(float const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3Divf(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVec3Divf",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3Divf",1,"gsVector3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVec3Divf",2,"float const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3Divf",1,SWIGTYPE_p_gsVector3);
  }
  
  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  result = gsVec3Divf((gsVector3 const &)*arg1,(float const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatNegate(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuatNegate",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatNegate",1,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatNegate",1,SWIGTYPE_p_gsQuaternion);
  }
  
  result = gsQuatNegate((gsQuaternion const &)*arg1);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatAddQuat(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuatAddQuat",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatAddQuat",1,"gsQuaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuatAddQuat",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatAddQuat",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatAddQuat",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = gsQuatAddQuat((gsQuaternion const &)*arg1,(gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatSubQuat(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuatSubQuat",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatSubQuat",1,"gsQuaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuatSubQuat",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatSubQuat",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatSubQuat",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = gsQuatSubQuat((gsQuaternion const &)*arg1,(gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatMulQuat(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsQuaternion *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuatMulQuat",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatMulQuat",1,"gsQuaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuatMulQuat",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatMulQuat",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatMulQuat",2,SWIGTYPE_p_gsQuaternion);
  }
  
  result = gsQuatMulQuat((gsQuaternion const &)*arg1,(gsQuaternion const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatMulf(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsQuatMulf",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatMulf",1,"gsQuaternion const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsQuatMulf",2,"float const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatMulf",1,SWIGTYPE_p_gsQuaternion);
  }
  
  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  result = gsQuatMulf((gsQuaternion const &)*arg1,(float const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuatMulVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsQuaternion *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsQuatMulVec3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsQuatMulVec3",1,"gsQuaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsQuatMulVec3",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("QuatMulVec3",1,SWIGTYPE_p_gsQuaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("QuatMulVec3",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsQuatMulVec3((gsQuaternion const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vec3RotationTo(lua_State* L) {
  int SWIG_arg = 0;
  gsVector3 *arg1 = 0 ;
  gsVector3 *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsVec3RotationTo",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsVec3RotationTo",1,"gsVector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVec3RotationTo",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3RotationTo",1,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Vec3RotationTo",2,SWIGTYPE_p_gsVector3);
  }
  
  result = gsVec3RotationTo((gsVector3 const &)*arg1,(gsVector3 const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector2_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVector2 *arg1 = (gkVector2 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkVector2::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector2::x",1,"gkVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVector2::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkVector2_x_set",1,SWIGTYPE_p_gkVector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector2_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVector2 *arg1 = (gkVector2 *) 0 ;
  float result;
  
  SWIG_check_num_args("gkVector2::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector2::x",1,"gkVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkVector2_x_get",1,SWIGTYPE_p_gkVector2);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector2_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVector2 *arg1 = (gkVector2 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkVector2::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector2::y",1,"gkVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVector2::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkVector2_y_set",1,SWIGTYPE_p_gkVector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector2_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVector2 *arg1 = (gkVector2 *) 0 ;
  float result;
  
  SWIG_check_num_args("gkVector2::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector2::y",1,"gkVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkVector2_y_get",1,SWIGTYPE_p_gkVector2);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkVector2(lua_State* L) {
  int SWIG_arg = 0;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkVector2::gkVector2",0,0)
  result = (gkVector2 *)new gkVector2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkVector2(void *obj) {
gkVector2 *arg1 = (gkVector2 *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkVector2(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkVector2);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkVector2_attributes[] = {
    { "x", _wrap_gkVector2_x_get, _wrap_gkVector2_x_set },
    { "y", _wrap_gkVector2_y_get, _wrap_gkVector2_y_set },
    {0,0,0}
};
static swig_lua_method swig_gkVector2_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkVector2_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkVector2_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkVector2_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkVector2_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkVector2_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkVector2_Sf_SwigStatic = {
    "gkVector2",
    swig_gkVector2_Sf_SwigStatic_methods,
    swig_gkVector2_Sf_SwigStatic_attributes,
    swig_gkVector2_Sf_SwigStatic_constants,
    swig_gkVector2_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkVector2_bases[] = {0};
static const char *swig_gkVector2_base_names[] = {0};
static swig_lua_class _wrap_class_gkVector2 = { "gkVector2", "gkVector2", &SWIGTYPE_p_gkVector2,_proxy__wrap_new_gkVector2, swig_delete_gkVector2, swig_gkVector2_methods, swig_gkVector2_attributes, &swig_gkVector2_Sf_SwigStatic, swig_gkVector2_meta, swig_gkVector2_bases, swig_gkVector2_base_names };

static int _wrap_new_gkVector3(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkVector3::gkVector3",0,0)
  result = (gkVector3 *)new gkVector3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_x_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkVector3::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::x",1,"gkVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVector3::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_x_set",1,SWIGTYPE_p_gkVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_x_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gkVector3::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::x",1,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_x_get",1,SWIGTYPE_p_gkVector3);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_y_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkVector3::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::y",1,"gkVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVector3::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_y_set",1,SWIGTYPE_p_gkVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_y_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gkVector3::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::y",1,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_y_get",1,SWIGTYPE_p_gkVector3);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_z_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkVector3::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::z",1,"gkVector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVector3::z",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_z_set",1,SWIGTYPE_p_gkVector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVector3_z_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVector3 *arg1 = (gkVector3 *) 0 ;
  float result;
  
  SWIG_check_num_args("gkVector3::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVector3::z",1,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVector3_z_get",1,SWIGTYPE_p_gkVector3);
  }
  
  result = (float) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkVector3(void *obj) {
gkVector3 *arg1 = (gkVector3 *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkVector3(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkVector3);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkVector3_attributes[] = {
    { "x", _wrap_gkVector3_x_get, _wrap_gkVector3_x_set },
    { "y", _wrap_gkVector3_y_get, _wrap_gkVector3_y_set },
    { "z", _wrap_gkVector3_z_get, _wrap_gkVector3_z_set },
    {0,0,0}
};
static swig_lua_method swig_gkVector3_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkVector3_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkVector3_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkVector3_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkVector3_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkVector3_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkVector3_Sf_SwigStatic = {
    "gkVector3",
    swig_gkVector3_Sf_SwigStatic_methods,
    swig_gkVector3_Sf_SwigStatic_attributes,
    swig_gkVector3_Sf_SwigStatic_constants,
    swig_gkVector3_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkVector3_bases[] = {0};
static const char *swig_gkVector3_base_names[] = {0};
static swig_lua_class _wrap_class_gkVector3 = { "gkVector3", "gkVector3", &SWIGTYPE_p_gkVector3,_proxy__wrap_new_gkVector3, swig_delete_gkVector3, swig_gkVector3_methods, swig_gkVector3_attributes, &swig_gkVector3_Sf_SwigStatic, swig_gkVector3_meta, swig_gkVector3_bases, swig_gkVector3_base_names };

static int _wrap_gkVertex_co_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkVertex::co",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::co",1,"gkVertex *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkVertex::co",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_co_set",1,SWIGTYPE_p_gkVertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVertex_co_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->co = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_co_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkVertex::co",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::co",1,"gkVertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_co_get",1,SWIGTYPE_p_gkVertex);
  }
  
  result = (gkVector3 *)& ((arg1)->co);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_no_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector3 *arg2 = (gkVector3 *) 0 ;
  
  SWIG_check_num_args("gkVertex::no",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::no",1,"gkVertex *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkVertex::no",2,"gkVector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_no_set",1,SWIGTYPE_p_gkVertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gkVertex_no_set",2,SWIGTYPE_p_gkVector3);
  }
  
  if (arg1) (arg1)->no = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_no_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector3 *result = 0 ;
  
  SWIG_check_num_args("gkVertex::no",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::no",1,"gkVertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_no_get",1,SWIGTYPE_p_gkVertex);
  }
  
  result = (gkVector3 *)& ((arg1)->no);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_vcol_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gkVertex::vcol",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::vcol",1,"gkVertex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVertex::vcol",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_vcol_set",1,SWIGTYPE_p_gkVertex);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vcol = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_vcol_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("gkVertex::vcol",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::vcol",1,"gkVertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_vcol_get",1,SWIGTYPE_p_gkVertex);
  }
  
  result = (unsigned int) ((arg1)->vcol);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_uv_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector2 *arg2 ;
  
  SWIG_check_num_args("gkVertex::uv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::uv",1,"gkVertex *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gkVertex::uv",2,"gkVector2 [GK_UV_MAX]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_uv_set",1,SWIGTYPE_p_gkVertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gkVertex_uv_set",2,SWIGTYPE_p_gkVector2);
  }
  
  {
    size_t ii;
    gkVector2 *b = (gkVector2 *) arg1->uv;
    for (ii = 0; ii < (size_t)GK_UV_MAX; ii++) b[ii] = *((gkVector2 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_uv_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkVertex::uv",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::uv",1,"gkVertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_uv_get",1,SWIGTYPE_p_gkVertex);
  }
  
  result = (gkVector2 *)(gkVector2 *) ((arg1)->uv);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_vba_set(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkVertex::vba",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::vba",1,"gkVertex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVertex::vba",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_vba_set",1,SWIGTYPE_p_gkVertex);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vba = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_vba_get(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  int result;
  
  SWIG_check_num_args("gkVertex::vba",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::vba",1,"gkVertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_vba_get",1,SWIGTYPE_p_gkVertex);
  }
  
  result = (int) ((arg1)->vba);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkVertex_getUV(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *arg1 = (gkVertex *) 0 ;
  int arg2 ;
  gkVector2 *result = 0 ;
  
  SWIG_check_num_args("gkVertex::getUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkVertex::getUV",1,"gkVertex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkVertex::getUV",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gkVertex_getUV",1,SWIGTYPE_p_gkVertex);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkVector2 *) &(arg1)->getUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkVertex(lua_State* L) {
  int SWIG_arg = 0;
  gkVertex *result = 0 ;
  
  SWIG_check_num_args("gkVertex::gkVertex",0,0)
  result = (gkVertex *)new gkVertex();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVertex,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkVertex(void *obj) {
gkVertex *arg1 = (gkVertex *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkVertex(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkVertex);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkVertex_attributes[] = {
    { "co", _wrap_gkVertex_co_get, _wrap_gkVertex_co_set },
    { "no", _wrap_gkVertex_no_get, _wrap_gkVertex_no_set },
    { "vcol", _wrap_gkVertex_vcol_get, _wrap_gkVertex_vcol_set },
    { "uv", _wrap_gkVertex_uv_get, _wrap_gkVertex_uv_set },
    { "vba", _wrap_gkVertex_vba_get, _wrap_gkVertex_vba_set },
    {0,0,0}
};
static swig_lua_method swig_gkVertex_methods[]= {
    { "getUV", _wrap_gkVertex_getUV},
    {0,0}
};
static swig_lua_method swig_gkVertex_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkVertex_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkVertex_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkVertex_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkVertex_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkVertex_Sf_SwigStatic = {
    "gkVertex",
    swig_gkVertex_Sf_SwigStatic_methods,
    swig_gkVertex_Sf_SwigStatic_attributes,
    swig_gkVertex_Sf_SwigStatic_constants,
    swig_gkVertex_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkVertex_bases[] = {0};
static const char *swig_gkVertex_base_names[] = {0};
static swig_lua_class _wrap_class_gkVertex = { "gkVertex", "gkVertex", &SWIGTYPE_p_gkVertex,_proxy__wrap_new_gkVertex, swig_delete_gkVertex, swig_gkVertex_methods, swig_gkVertex_attributes, &swig_gkVertex_Sf_SwigStatic, swig_gkVertex_meta, swig_gkVertex_bases, swig_gkVertex_base_names };

static int _wrap_new_gkColor(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gkColor *result = 0 ;
  
  SWIG_check_num_args("gkColor::gkColor",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gkColor::gkColor",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkColor::gkColor",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gkColor::gkColor",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gkColor::gkColor",4,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (gkColor *)new gkColor(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkColor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_r_set(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkColor::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::r",1,"gkColor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkColor::r",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_r_set",1,SWIGTYPE_p_gkColor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->r = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_r_get(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float result;
  
  SWIG_check_num_args("gkColor::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::r",1,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_r_get",1,SWIGTYPE_p_gkColor);
  }
  
  result = (float) ((arg1)->r);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_g_set(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkColor::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::g",1,"gkColor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkColor::g",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_g_set",1,SWIGTYPE_p_gkColor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->g = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_g_get(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float result;
  
  SWIG_check_num_args("gkColor::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::g",1,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_g_get",1,SWIGTYPE_p_gkColor);
  }
  
  result = (float) ((arg1)->g);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_b_set(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkColor::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::b",1,"gkColor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkColor::b",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_b_set",1,SWIGTYPE_p_gkColor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_b_get(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float result;
  
  SWIG_check_num_args("gkColor::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::b",1,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_b_get",1,SWIGTYPE_p_gkColor);
  }
  
  result = (float) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_a_set(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkColor::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::a",1,"gkColor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkColor::a",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_a_set",1,SWIGTYPE_p_gkColor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkColor_a_get(lua_State* L) {
  int SWIG_arg = 0;
  gkColor *arg1 = (gkColor *) 0 ;
  float result;
  
  SWIG_check_num_args("gkColor::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkColor::a",1,"gkColor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkColor,0))){
    SWIG_fail_ptr("gkColor_a_get",1,SWIGTYPE_p_gkColor);
  }
  
  result = (float) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkColor(void *obj) {
gkColor *arg1 = (gkColor *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkColor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkColor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkColor_attributes[] = {
    { "r", _wrap_gkColor_r_get, _wrap_gkColor_r_set },
    { "g", _wrap_gkColor_g_get, _wrap_gkColor_g_set },
    { "b", _wrap_gkColor_b_get, _wrap_gkColor_b_set },
    { "a", _wrap_gkColor_a_get, _wrap_gkColor_a_set },
    {0,0,0}
};
static swig_lua_method swig_gkColor_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkColor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkColor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkColor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkColor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkColor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkColor_Sf_SwigStatic = {
    "gkColor",
    swig_gkColor_Sf_SwigStatic_methods,
    swig_gkColor_Sf_SwigStatic_attributes,
    swig_gkColor_Sf_SwigStatic_constants,
    swig_gkColor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkColor_bases[] = {0};
static const char *swig_gkColor_base_names[] = {0};
static swig_lua_class _wrap_class_gkColor = { "gkColor", "gkColor", &SWIGTYPE_p_gkColor,_proxy__wrap_new_gkColor, swig_delete_gkColor, swig_gkColor_methods, swig_gkColor_attributes, &swig_gkColor_Sf_SwigStatic, swig_gkColor_meta, swig_gkColor_bases, swig_gkColor_base_names };

static int _wrap_new_ColourValue__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",4,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",0,0)
  result = (Ogre::ColourValue *)new Ogre::ColourValue();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ColourValue__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_ColourValue__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ColourValue__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_ColourValue__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_ColourValue__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ColourValue'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::ColourValue::ColourValue(float,float,float,float)\n"
    "    Ogre::ColourValue::ColourValue(float,float,float)\n"
    "    Ogre::ColourValue::ColourValue(float,float)\n"
    "    Ogre::ColourValue::ColourValue(float)\n"
    "    Ogre::ColourValue::ColourValue()\n");
  lua_error(L);return 0;
}


static int _wrap_ColourValue_r_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::r",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::r",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_r_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->r = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_r_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::r",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_r_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->r);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_g_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::g",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::g",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_g_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->g = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_g_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::g",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_g_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->g);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_b_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::b",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::b",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_b_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_b_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::b",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_b_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_a_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::a",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::a",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_a_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_a_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::a",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_a_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ColourValue(void *obj) {
Ogre::ColourValue *arg1 = (Ogre::ColourValue *) obj;
delete arg1;
}
static int _proxy__wrap_new_ColourValue(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ColourValue);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ColourValue_attributes[] = {
    { "r", _wrap_ColourValue_r_get, _wrap_ColourValue_r_set },
    { "g", _wrap_ColourValue_g_get, _wrap_ColourValue_g_set },
    { "b", _wrap_ColourValue_b_get, _wrap_ColourValue_b_set },
    { "a", _wrap_ColourValue_a_get, _wrap_ColourValue_a_set },
    {0,0,0}
};
static swig_lua_method swig_ColourValue_methods[]= {
    {0,0}
};
static swig_lua_method swig_ColourValue_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ColourValue_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ColourValue_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ColourValue_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ColourValue_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ColourValue_Sf_SwigStatic = {
    "ColourValue",
    swig_ColourValue_Sf_SwigStatic_methods,
    swig_ColourValue_Sf_SwigStatic_attributes,
    swig_ColourValue_Sf_SwigStatic_constants,
    swig_ColourValue_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ColourValue_bases[] = {0};
static const char *swig_ColourValue_base_names[] = {0};
static swig_lua_class _wrap_class_ColourValue = { "ColourValue", "ColourValue", &SWIGTYPE_p_Ogre__ColourValue,_proxy__wrap_new_ColourValue, swig_delete_ColourValue, swig_ColourValue_methods, swig_ColourValue_attributes, &swig_ColourValue_Sf_SwigStatic, swig_ColourValue_meta, swig_ColourValue_bases, swig_ColourValue_base_names };

static int _wrap_gkTriangle_i0_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gkTriangle::i0",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i0",1,"gkTriangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTriangle::i0",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i0_set",1,SWIGTYPE_p_gkTriangle);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->i0 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_i0_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("gkTriangle::i0",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i0",1,"gkTriangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i0_get",1,SWIGTYPE_p_gkTriangle);
  }
  
  result = (unsigned int) ((arg1)->i0);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_i1_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gkTriangle::i1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i1",1,"gkTriangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTriangle::i1",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i1_set",1,SWIGTYPE_p_gkTriangle);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->i1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_i1_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("gkTriangle::i1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i1",1,"gkTriangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i1_get",1,SWIGTYPE_p_gkTriangle);
  }
  
  result = (unsigned int) ((arg1)->i1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_i2_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gkTriangle::i2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i2",1,"gkTriangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTriangle::i2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i2_set",1,SWIGTYPE_p_gkTriangle);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->i2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_i2_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("gkTriangle::i2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::i2",1,"gkTriangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_i2_get",1,SWIGTYPE_p_gkTriangle);
  }
  
  result = (unsigned int) ((arg1)->i2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_flag_set(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gkTriangle::flag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::flag",1,"gkTriangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkTriangle::flag",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_flag_set",1,SWIGTYPE_p_gkTriangle);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->flag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkTriangle_flag_get(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *arg1 = (gkTriangle *) 0 ;
  int result;
  
  SWIG_check_num_args("gkTriangle::flag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkTriangle::flag",1,"gkTriangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTriangle,0))){
    SWIG_fail_ptr("gkTriangle_flag_get",1,SWIGTYPE_p_gkTriangle);
  }
  
  result = (int) ((arg1)->flag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkTriangle(lua_State* L) {
  int SWIG_arg = 0;
  gkTriangle *result = 0 ;
  
  SWIG_check_num_args("gkTriangle::gkTriangle",0,0)
  result = (gkTriangle *)new gkTriangle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkTriangle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkTriangle(void *obj) {
gkTriangle *arg1 = (gkTriangle *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkTriangle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkTriangle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkTriangle_attributes[] = {
    { "i0", _wrap_gkTriangle_i0_get, _wrap_gkTriangle_i0_set },
    { "i1", _wrap_gkTriangle_i1_get, _wrap_gkTriangle_i1_set },
    { "i2", _wrap_gkTriangle_i2_get, _wrap_gkTriangle_i2_set },
    { "flag", _wrap_gkTriangle_flag_get, _wrap_gkTriangle_flag_set },
    {0,0,0}
};
static swig_lua_method swig_gkTriangle_methods[]= {
    {0,0}
};
static swig_lua_method swig_gkTriangle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkTriangle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkTriangle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkTriangle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkTriangle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkTriangle_Sf_SwigStatic = {
    "gkTriangle",
    swig_gkTriangle_Sf_SwigStatic_methods,
    swig_gkTriangle_Sf_SwigStatic_attributes,
    swig_gkTriangle_Sf_SwigStatic_constants,
    swig_gkTriangle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkTriangle_bases[] = {0};
static const char *swig_gkTriangle_base_names[] = {0};
static swig_lua_class _wrap_class_gkTriangle = { "gkTriangle", "gkTriangle", &SWIGTYPE_p_gkTriangle,_proxy__wrap_new_gkTriangle, swig_delete_gkTriangle, swig_gkTriangle_methods, swig_gkTriangle_attributes, &swig_gkTriangle_Sf_SwigStatic, swig_gkTriangle_meta, swig_gkTriangle_bases, swig_gkTriangle_base_names };

static int _wrap_new_ObjectList__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::gsArray",0,0)
  result = (gsArray< gsGameObject,gkGameObject > *)new gsArray< gsGameObject,gkGameObject >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectList__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject >::Array *arg1 = 0 ;
  gsArray< gsGameObject,gkGameObject > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::gsArray",1,"gsArray< gsGameObject,gkGameObject >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkGameObject_p_t,0))){
    SWIG_fail_ptr("new_ObjectList",1,SWIGTYPE_p_utArrayT_gkGameObject_p_t);
  }
  
  result = (gsArray< gsGameObject,gkGameObject > *)new gsArray< gsGameObject,gkGameObject >((gsArray< gsGameObject,gkGameObject >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectList(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ObjectList__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkGameObject_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ObjectList__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ObjectList'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsGameObject,gkGameObject >::gsArray()\n"
    "    gsArray< gsGameObject,gkGameObject >::gsArray(gsArray< gsGameObject,gkGameObject >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_ObjectList_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::clear",1,"gsArray< gsGameObject,gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_clear",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::size",1,"gsArray< gsGameObject,gkGameObject > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_size",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  result = (int)((gsArray< gsGameObject,gkGameObject > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::empty",1,"gsArray< gsGameObject,gkGameObject > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_empty",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  result = (bool)((gsArray< gsGameObject,gkGameObject > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::__getitem__",1,"gsArray< gsGameObject,gkGameObject > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList___getitem",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::at",1,"gsArray< gsGameObject,gkGameObject > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_at",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::push",1,"gsArray< gsGameObject,gkGameObject > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::push",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_push",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ObjectList_push",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::erase",1,"gsArray< gsGameObject,gkGameObject > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::erase",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_erase",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ObjectList_erase",2,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectList_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) 0 ;
  gsArrayIterator< gkGameObject > result;
  
  SWIG_check_num_args("gsArray< gsGameObject,gkGameObject >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsGameObject,gkGameObject >::iterator",1,"gsArray< gsGameObject,gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectList_iterator",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkGameObject > * resultptr = new gsArrayIterator< gkGameObject >((const gsArrayIterator< gkGameObject > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ObjectList(void *obj) {
gsArray< gsGameObject,gkGameObject > *arg1 = (gsArray< gsGameObject,gkGameObject > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ObjectList(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ObjectList);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ObjectList_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ObjectList_methods[]= {
    { "clear", _wrap_ObjectList_clear},
    { "size", _wrap_ObjectList_size},
    { "empty", _wrap_ObjectList_empty},
    { "__getitem", _wrap_ObjectList___getitem},
    { "at", _wrap_ObjectList_at},
    { "push", _wrap_ObjectList_push},
    { "erase", _wrap_ObjectList_erase},
    { "iterator", _wrap_ObjectList_iterator},
    {0,0}
};
static swig_lua_method swig_ObjectList_meta[] = {
    { "__getitem", _wrap_ObjectList___getitem},
    {0,0}
};

static swig_lua_attribute swig_ObjectList_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ObjectList_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ObjectList_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ObjectList_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ObjectList_Sf_SwigStatic = {
    "ObjectList",
    swig_ObjectList_Sf_SwigStatic_methods,
    swig_ObjectList_Sf_SwigStatic_attributes,
    swig_ObjectList_Sf_SwigStatic_constants,
    swig_ObjectList_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ObjectList_bases[] = {0};
static const char *swig_ObjectList_base_names[] = {0};
static swig_lua_class _wrap_class_ObjectList = { "ObjectList", "ObjectList", &SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,_proxy__wrap_new_ObjectList, swig_delete_ObjectList, swig_ObjectList_methods, swig_ObjectList_attributes, &swig_ObjectList_Sf_SwigStatic, swig_ObjectList_meta, swig_ObjectList_bases, swig_ObjectList_base_names };

static int _wrap_new_ObjectIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkGameObject > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkGameObject >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkGameObject > *)new gsArrayIterator< gkGameObject >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkGameObject > *arg1 = (gsArrayIterator< gkGameObject > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkGameObject >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkGameObject >::hasMoreElements",1,"gsArrayIterator< gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkGameObject > *arg1 = (gsArrayIterator< gkGameObject > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkGameObject >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkGameObject >::moveNext",1,"gsArrayIterator< gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkGameObject > *arg1 = (gsArrayIterator< gkGameObject > *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkGameObject >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkGameObject >::peekNext",1,"gsArrayIterator< gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t);
  }
  
  result = (gkGameObject *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkGameObject > *arg1 = (gsArrayIterator< gkGameObject > *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkGameObject >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkGameObject >::getNext",1,"gsArrayIterator< gkGameObject > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,0))){
    SWIG_fail_ptr("ObjectIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t);
  }
  
  result = (gkGameObject *)(arg1)->getNext();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ObjectIterator(void *obj) {
gsArrayIterator< gkGameObject > *arg1 = (gsArrayIterator< gkGameObject > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ObjectIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ObjectIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ObjectIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ObjectIterator_methods[]= {
    { "hasMoreElements", _wrap_ObjectIterator_hasMoreElements},
    { "moveNext", _wrap_ObjectIterator_moveNext},
    { "peekNext", _wrap_ObjectIterator_peekNext},
    { "getNext", _wrap_ObjectIterator_getNext},
    {0,0}
};
static swig_lua_method swig_ObjectIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ObjectIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ObjectIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ObjectIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ObjectIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ObjectIterator_Sf_SwigStatic = {
    "ObjectIterator",
    swig_ObjectIterator_Sf_SwigStatic_methods,
    swig_ObjectIterator_Sf_SwigStatic_attributes,
    swig_ObjectIterator_Sf_SwigStatic_constants,
    swig_ObjectIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ObjectIterator_bases[] = {0};
static const char *swig_ObjectIterator_base_names[] = {0};
static swig_lua_class _wrap_class_ObjectIterator = { "ObjectIterator", "ObjectIterator", &SWIGTYPE_p_gsArrayIteratorT_gkGameObject_t,_proxy__wrap_new_ObjectIterator, swig_delete_ObjectIterator, swig_ObjectIterator_methods, swig_ObjectIterator_attributes, &swig_ObjectIterator_Sf_SwigStatic, swig_ObjectIterator_meta, swig_ObjectIterator_bases, swig_ObjectIterator_base_names };

static int _wrap_new_ProcessList__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::gsArray",0,0)
  result = (gsArray< gsProcess,gkProcess > *)new gsArray< gsProcess,gkProcess >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ProcessList__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess >::Array *arg1 = 0 ;
  gsArray< gsProcess,gkProcess > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::gsArray",1,"gsArray< gsProcess,gkProcess >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkProcess_p_t,0))){
    SWIG_fail_ptr("new_ProcessList",1,SWIGTYPE_p_utArrayT_gkProcess_p_t);
  }
  
  result = (gsArray< gsProcess,gkProcess > *)new gsArray< gsProcess,gkProcess >((gsArray< gsProcess,gkProcess >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ProcessList(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ProcessList__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkProcess_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ProcessList__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ProcessList'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsProcess,gkProcess >::gsArray()\n"
    "    gsArray< gsProcess,gkProcess >::gsArray(gsArray< gsProcess,gkProcess >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_ProcessList_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::clear",1,"gsArray< gsProcess,gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_clear",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::size",1,"gsArray< gsProcess,gkProcess > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_size",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  result = (int)((gsArray< gsProcess,gkProcess > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::empty",1,"gsArray< gsProcess,gkProcess > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_empty",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  result = (bool)((gsArray< gsProcess,gkProcess > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  int arg2 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::__getitem__",1,"gsArray< gsProcess,gkProcess > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList___getitem",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkProcess *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  int arg2 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::at",1,"gsArray< gsProcess,gkProcess > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_at",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkProcess *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  gsProcess *arg2 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::push",1,"gsArray< gsProcess,gkProcess > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::push",2,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_push",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("ProcessList_push",2,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  gsProcess *arg2 = (gsProcess *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::erase",1,"gsArray< gsProcess,gkProcess > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::erase",2,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_erase",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("ProcessList_erase",2,SWIGTYPE_p_gsProcess);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessList_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) 0 ;
  gsArrayIterator< gkProcess > result;
  
  SWIG_check_num_args("gsArray< gsProcess,gkProcess >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsProcess,gkProcess >::iterator",1,"gsArray< gsProcess,gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessList_iterator",1,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkProcess > * resultptr = new gsArrayIterator< gkProcess >((const gsArrayIterator< gkProcess > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ProcessList(void *obj) {
gsArray< gsProcess,gkProcess > *arg1 = (gsArray< gsProcess,gkProcess > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ProcessList(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ProcessList);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ProcessList_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ProcessList_methods[]= {
    { "clear", _wrap_ProcessList_clear},
    { "size", _wrap_ProcessList_size},
    { "empty", _wrap_ProcessList_empty},
    { "__getitem", _wrap_ProcessList___getitem},
    { "at", _wrap_ProcessList_at},
    { "push", _wrap_ProcessList_push},
    { "erase", _wrap_ProcessList_erase},
    { "iterator", _wrap_ProcessList_iterator},
    {0,0}
};
static swig_lua_method swig_ProcessList_meta[] = {
    { "__getitem", _wrap_ProcessList___getitem},
    {0,0}
};

static swig_lua_attribute swig_ProcessList_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ProcessList_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ProcessList_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ProcessList_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ProcessList_Sf_SwigStatic = {
    "ProcessList",
    swig_ProcessList_Sf_SwigStatic_methods,
    swig_ProcessList_Sf_SwigStatic_attributes,
    swig_ProcessList_Sf_SwigStatic_constants,
    swig_ProcessList_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ProcessList_bases[] = {0};
static const char *swig_ProcessList_base_names[] = {0};
static swig_lua_class _wrap_class_ProcessList = { "ProcessList", "ProcessList", &SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,_proxy__wrap_new_ProcessList, swig_delete_ProcessList, swig_ProcessList_methods, swig_ProcessList_attributes, &swig_ProcessList_Sf_SwigStatic, swig_ProcessList_meta, swig_ProcessList_bases, swig_ProcessList_base_names };

static int _wrap_new_ProcessIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkProcess > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkProcess >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkProcess > *)new gsArrayIterator< gkProcess >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkProcess > *arg1 = (gsArrayIterator< gkProcess > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkProcess >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkProcess >::hasMoreElements",1,"gsArrayIterator< gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkProcess > *arg1 = (gsArrayIterator< gkProcess > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkProcess >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkProcess >::moveNext",1,"gsArrayIterator< gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkProcess > *arg1 = (gsArrayIterator< gkProcess > *) 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkProcess >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkProcess >::peekNext",1,"gsArrayIterator< gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t);
  }
  
  result = (gkProcess *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkProcess > *arg1 = (gsArrayIterator< gkProcess > *) 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkProcess >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkProcess >::getNext",1,"gsArrayIterator< gkProcess > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkProcess_t);
  }
  
  result = (gkProcess *)(arg1)->getNext();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ProcessIterator(void *obj) {
gsArrayIterator< gkProcess > *arg1 = (gsArrayIterator< gkProcess > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ProcessIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ProcessIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ProcessIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ProcessIterator_methods[]= {
    { "hasMoreElements", _wrap_ProcessIterator_hasMoreElements},
    { "moveNext", _wrap_ProcessIterator_moveNext},
    { "peekNext", _wrap_ProcessIterator_peekNext},
    { "getNext", _wrap_ProcessIterator_getNext},
    {0,0}
};
static swig_lua_method swig_ProcessIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ProcessIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ProcessIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ProcessIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ProcessIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ProcessIterator_Sf_SwigStatic = {
    "ProcessIterator",
    swig_ProcessIterator_Sf_SwigStatic_methods,
    swig_ProcessIterator_Sf_SwigStatic_attributes,
    swig_ProcessIterator_Sf_SwigStatic_constants,
    swig_ProcessIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ProcessIterator_bases[] = {0};
static const char *swig_ProcessIterator_base_names[] = {0};
static swig_lua_class _wrap_class_ProcessIterator = { "ProcessIterator", "ProcessIterator", &SWIGTYPE_p_gsArrayIteratorT_gkProcess_t,_proxy__wrap_new_ProcessIterator, swig_delete_ProcessIterator, swig_ProcessIterator_methods, swig_ProcessIterator_attributes, &swig_ProcessIterator_Sf_SwigStatic, swig_ProcessIterator_meta, swig_ProcessIterator_bases, swig_ProcessIterator_base_names };

static int _wrap_new_Property__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsProperty::gsProperty",0,0)
  result = (gsProperty *)new gsProperty();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Property__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  bool arg2 ;
  gkString temp1 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsProperty::gsProperty",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsProperty::gsProperty",1,"gkString const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsProperty::gsProperty",2,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (gsProperty *)new gsProperty((gkString const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Property__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  double arg2 ;
  gkString temp1 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsProperty::gsProperty",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsProperty::gsProperty",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsProperty::gsProperty",2,"double");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (gsProperty *)new gsProperty((gkString const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Property__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsProperty::gsProperty",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsProperty::gsProperty",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProperty::gsProperty",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsProperty *)new gsProperty((gkString const &)*arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Property__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = 0 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsProperty::gsProperty",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsProperty::gsProperty",1,"gsProperty const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("new_Property",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (gsProperty *)new gsProperty((gsProperty const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Property(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Property__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProperty, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Property__SWIG_4(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Property__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Property__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Property__SWIG_3(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Property'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProperty::gsProperty()\n"
    "    gsProperty::gsProperty(gkString const &,bool)\n"
    "    gsProperty::gsProperty(gkString const &,double)\n"
    "    gsProperty::gsProperty(gkString const &,gkString const &)\n"
    "    gsProperty::gsProperty(gsProperty const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Property_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gkString *result = 0 ;
  
  SWIG_check_num_args("gsProperty::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::getName",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_getName",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (gkString *) &((gsProperty const *)arg1)->getName();
  
  lua_pushlstring(L, result->data(),result->size()); SWIG_arg++;
  //    lua_pushstring(L, result->c_str()); SWIG_arg++;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gkString *result = 0 ;
  
  SWIG_check_num_args("gsProperty::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::getValue",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_getValue",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (gkString *) &((gsProperty const *)arg1)->getValue();
  
  lua_pushlstring(L, result->data(),result->size()); SWIG_arg++;
  //    lua_pushstring(L, result->c_str()); SWIG_arg++;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_makeDebug(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsProperty::makeDebug",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::makeDebug",1,"gsProperty *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsProperty::makeDebug",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_makeDebug",1,SWIGTYPE_p_gsProperty);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->makeDebug(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gsPropertyType result;
  
  SWIG_check_num_args("gsProperty::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::getType",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_getType",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (gsPropertyType)((gsProperty const *)arg1)->getType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_toBool(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsProperty::toBool",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::toBool",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_toBool",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (bool)((gsProperty const *)arg1)->toBool();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_toNumber(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  double result;
  
  SWIG_check_num_args("gsProperty::toNumber",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::toNumber",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_toNumber",1,SWIGTYPE_p_gsProperty);
  }
  
  result = (double)((gsProperty const *)arg1)->toNumber();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_toString(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsProperty::toString",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::toString",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_toString",1,SWIGTYPE_p_gsProperty);
  }
  
  result = ((gsProperty const *)arg1)->toString();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_toVec3(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsProperty::toVec3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::toVec3",1,"gsProperty const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_toVec3",1,SWIGTYPE_p_gsProperty);
  }
  
  result = ((gsProperty const *)arg1)->toVec3();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_fromBool(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsProperty::fromBool",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::fromBool",1,"gsProperty *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsProperty::fromBool",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_fromBool",1,SWIGTYPE_p_gsProperty);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->fromBool(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_fromNumber(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("gsProperty::fromNumber",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::fromNumber",1,"gsProperty *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsProperty::fromNumber",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_fromNumber",1,SWIGTYPE_p_gsProperty);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  (arg1)->fromNumber(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_fromString(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsProperty::fromString",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::fromString",1,"gsProperty *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProperty::fromString",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_fromString",1,SWIGTYPE_p_gsProperty);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->fromString((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Property_fromVector3(lua_State* L) {
  int SWIG_arg = 0;
  gsProperty *arg1 = (gsProperty *) 0 ;
  gsVector3 arg2 ;
  gsVector3 *argp2 ;
  
  SWIG_check_num_args("gsProperty::fromVector3",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProperty::fromVector3",1,"gsProperty *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsProperty::fromVector3",2,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("Property_fromVector3",1,SWIGTYPE_p_gsProperty);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Property_fromVector3",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  (arg1)->fromVector3(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Property(void *obj) {
gsProperty *arg1 = (gsProperty *) obj;
delete arg1;
}
static int _proxy__wrap_new_Property(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Property);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Property_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Property_methods[]= {
    { "getName", _wrap_Property_getName},
    { "getValue", _wrap_Property_getValue},
    { "makeDebug", _wrap_Property_makeDebug},
    { "getType", _wrap_Property_getType},
    { "toBool", _wrap_Property_toBool},
    { "toNumber", _wrap_Property_toNumber},
    { "toString", _wrap_Property_toString},
    { "toVec3", _wrap_Property_toVec3},
    { "fromBool", _wrap_Property_fromBool},
    { "fromNumber", _wrap_Property_fromNumber},
    { "fromString", _wrap_Property_fromString},
    { "fromVector3", _wrap_Property_fromVector3},
    {0,0}
};
static swig_lua_method swig_Property_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Property_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Property_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Property_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Property_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Property_Sf_SwigStatic = {
    "Property",
    swig_Property_Sf_SwigStatic_methods,
    swig_Property_Sf_SwigStatic_attributes,
    swig_Property_Sf_SwigStatic_constants,
    swig_Property_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Property_bases[] = {0};
static const char *swig_Property_base_names[] = {0};
static swig_lua_class _wrap_class_Property = { "Property", "Property", &SWIGTYPE_p_gsProperty,_proxy__wrap_new_Property, swig_delete_Property, swig_Property_methods, swig_Property_attributes, &swig_Property_Sf_SwigStatic, swig_Property_meta, swig_Property_bases, swig_Property_base_names };

static int _wrap_UserDefs_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsUserDefs::getProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::getProperty",1,"gsUserDefs *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsUserDefs::getProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs_getProperty",1,SWIGTYPE_p_gsUserDefs);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsProperty *) &(arg1)->getProperty((gkString const &)*arg2);
  SWIG_arg += gsGetProperty(L, (*result)); 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs_addProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  gsProperty *arg2 = 0 ;
  
  SWIG_check_num_args("gsUserDefs::addProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::addProperty",1,"gsUserDefs *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsUserDefs::addProperty",2,"gsProperty const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs_addProperty",1,SWIGTYPE_p_gsUserDefs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsProperty,0))){
    SWIG_fail_ptr("UserDefs_addProperty",2,SWIGTYPE_p_gsProperty);
  }
  
  (arg1)->addProperty((gsProperty const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs_hasProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsUserDefs::hasProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::hasProperty",1,"gsUserDefs *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsUserDefs::hasProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs_hasProperty",1,SWIGTYPE_p_gsUserDefs);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->hasProperty((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  char *arg2 = (char *) 0 ;
  gsProperty *result = 0 ;
  
  SWIG_check_num_args("gsUserDefs::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::__getitem__",1,"gsUserDefs *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("gsUserDefs::__getitem__",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs___getitem",1,SWIGTYPE_p_gsUserDefs);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (gsProperty *) &(arg1)->__getitem__((char const *)arg2);
  SWIG_arg += gsGetProperty(L, (*result)); 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs___setitem__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsUserDefs::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::__setitem__",1,"gsUserDefs *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("gsUserDefs::__setitem__",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsUserDefs::__setitem__",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs___setitem",1,SWIGTYPE_p_gsUserDefs);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->__setitem__((char const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs___setitem__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  
  SWIG_check_num_args("gsUserDefs::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::__setitem__",1,"gsUserDefs *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("gsUserDefs::__setitem__",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsUserDefs::__setitem__",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs___setitem",1,SWIGTYPE_p_gsUserDefs);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  (arg1)->__setitem__((char const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs___setitem__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsUserDefs *arg1 = (gsUserDefs *) 0 ;
  char *arg2 = (char *) 0 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsUserDefs::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsUserDefs::__setitem__",1,"gsUserDefs *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("gsUserDefs::__setitem__",2,"char const *");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsUserDefs::__setitem__",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsUserDefs,0))){
    SWIG_fail_ptr("UserDefs___setitem",1,SWIGTYPE_p_gsUserDefs);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->__setitem__((char const *)arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UserDefs___setitem(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsUserDefs, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_UserDefs___setitem__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsUserDefs, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_UserDefs___setitem__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsUserDefs, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_UserDefs___setitem__SWIG_2(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'UserDefs___setitem'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsUserDefs::__setitem__(char const *,bool)\n"
    "    gsUserDefs::__setitem__(char const *,double)\n"
    "    gsUserDefs::__setitem__(char const *,gkString const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_UserDefs(void *obj) {
gsUserDefs *arg1 = (gsUserDefs *) obj;
delete arg1;
}
static swig_lua_attribute swig_UserDefs_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_UserDefs_methods[]= {
    { "getProperty", _wrap_UserDefs_getProperty},
    { "addProperty", _wrap_UserDefs_addProperty},
    { "hasProperty", _wrap_UserDefs_hasProperty},
    { "__getitem", _wrap_UserDefs___getitem},
    { "__setitem", _wrap_UserDefs___setitem},
    {0,0}
};
static swig_lua_method swig_UserDefs_meta[] = {
    { "__getitem", _wrap_UserDefs___getitem},
    { "__setitem", _wrap_UserDefs___setitem},
    {0,0}
};

static swig_lua_attribute swig_UserDefs_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_UserDefs_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_UserDefs_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_UserDefs_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_UserDefs_Sf_SwigStatic = {
    "UserDefs",
    swig_UserDefs_Sf_SwigStatic_methods,
    swig_UserDefs_Sf_SwigStatic_attributes,
    swig_UserDefs_Sf_SwigStatic_constants,
    swig_UserDefs_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_UserDefs_bases[] = {0};
static const char *swig_UserDefs_base_names[] = {0};
static swig_lua_class _wrap_class_UserDefs = { "UserDefs", "UserDefs", &SWIGTYPE_p_gsUserDefs,0, swig_delete_UserDefs, swig_UserDefs_methods, swig_UserDefs_attributes, &swig_UserDefs_Sf_SwigStatic, swig_UserDefs_meta, swig_UserDefs_bases, swig_UserDefs_base_names };

static int _wrap_new_gsMultiTouchState(lua_State* L) {
  int SWIG_arg = 0;
  OIS::MultiTouchState *arg1 = (OIS::MultiTouchState *) 0 ;
  gsMultiTouchState *result = 0 ;
  
  SWIG_check_num_args("gsMultiTouchState::gsMultiTouchState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::gsMultiTouchState",1,"OIS::MultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OIS__MultiTouchState,0))){
    SWIG_fail_ptr("new_gsMultiTouchState",1,SWIGTYPE_p_OIS__MultiTouchState);
  }
  
  result = (gsMultiTouchState *)new gsMultiTouchState(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMultiTouchState,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getPointerId(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMultiTouchState::getPointerId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getPointerId",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getPointerId",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (int)(arg1)->getPointerId();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMultiTouchState::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getType",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getType",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getX(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMultiTouchState::getX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getX",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getX",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (int)(arg1)->getX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getY(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMultiTouchState::getY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getY",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getY",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (int)(arg1)->getY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getPressure(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMultiTouchState::getPressure",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getPressure",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getPressure",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (float)(arg1)->getPressure();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMultiTouchState_getSize(lua_State* L) {
  int SWIG_arg = 0;
  gsMultiTouchState *arg1 = (gsMultiTouchState *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMultiTouchState::getSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMultiTouchState::getSize",1,"gsMultiTouchState *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMultiTouchState,0))){
    SWIG_fail_ptr("gsMultiTouchState_getSize",1,SWIGTYPE_p_gsMultiTouchState);
  }
  
  result = (float)(arg1)->getSize();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMultiTouchState(void *obj) {
gsMultiTouchState *arg1 = (gsMultiTouchState *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMultiTouchState(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMultiTouchState);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMultiTouchState_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMultiTouchState_methods[]= {
    { "getPointerId", _wrap_gsMultiTouchState_getPointerId},
    { "getType", _wrap_gsMultiTouchState_getType},
    { "getX", _wrap_gsMultiTouchState_getX},
    { "getY", _wrap_gsMultiTouchState_getY},
    { "getPressure", _wrap_gsMultiTouchState_getPressure},
    { "getSize", _wrap_gsMultiTouchState_getSize},
    {0,0}
};
static swig_lua_method swig_gsMultiTouchState_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMultiTouchState_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMultiTouchState_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMultiTouchState_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMultiTouchState_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMultiTouchState_Sf_SwigStatic = {
    "gsMultiTouchState",
    swig_gsMultiTouchState_Sf_SwigStatic_methods,
    swig_gsMultiTouchState_Sf_SwigStatic_attributes,
    swig_gsMultiTouchState_Sf_SwigStatic_constants,
    swig_gsMultiTouchState_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMultiTouchState_bases[] = {0};
static const char *swig_gsMultiTouchState_base_names[] = {0};
static swig_lua_class _wrap_class_gsMultiTouchState = { "gsMultiTouchState", "gsMultiTouchState", &SWIGTYPE_p_gsMultiTouchState,_proxy__wrap_new_gsMultiTouchState, swig_delete_gsMultiTouchState, swig_gsMultiTouchState_methods, swig_gsMultiTouchState_attributes, &swig_gsMultiTouchState_Sf_SwigStatic, swig_gsMultiTouchState_meta, swig_gsMultiTouchState_bases, swig_gsMultiTouchState_base_names };

static int _wrap_new_Touch(lua_State* L) {
  int SWIG_arg = 0;
  gsTouch *result = 0 ;
  
  SWIG_check_num_args("gsTouch::gsTouch",0,0)
  result = (gsTouch *)new gsTouch();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTouch,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Touch_addListener__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsTouch *arg1 = (gsTouch *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsTouch::addListener",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouch::addListener",1,"gsTouch *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsTouch::addListener",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsTouch::addListener",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouch,0))){
    SWIG_fail_ptr("Touch_addListener",1,SWIGTYPE_p_gsTouch);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->addListener(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Touch_addListener__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsTouch *arg1 = (gsTouch *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsTouch::addListener",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouch::addListener",1,"gsTouch *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsTouch::addListener",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouch,0))){
    SWIG_fail_ptr("Touch_addListener",1,SWIGTYPE_p_gsTouch);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->addListener(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Touch_addListener(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsTouch, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Touch_addListener__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsTouch, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Touch_addListener__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Touch_addListener'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsTouch::addListener(gsSelf,gsFunction)\n"
    "    gsTouch::addListener(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Touch_getNumStates(lua_State* L) {
  int SWIG_arg = 0;
  gsTouch *arg1 = (gsTouch *) 0 ;
  int result;
  
  SWIG_check_num_args("gsTouch::getNumStates",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouch::getNumStates",1,"gsTouch *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouch,0))){
    SWIG_fail_ptr("Touch_getNumStates",1,SWIGTYPE_p_gsTouch);
  }
  
  result = (int)(arg1)->getNumStates();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Touch_getState(lua_State* L) {
  int SWIG_arg = 0;
  gsTouch *arg1 = (gsTouch *) 0 ;
  int arg2 ;
  gkMultiTouchState *result = 0 ;
  
  SWIG_check_num_args("gsTouch::getState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouch::getState",1,"gsTouch *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTouch::getState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouch,0))){
    SWIG_fail_ptr("Touch_getState",1,SWIGTYPE_p_gsTouch);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkMultiTouchState *)(arg1)->getState(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, MultiTouchState); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Touch(void *obj) {
gsTouch *arg1 = (gsTouch *) obj;
delete arg1;
}
static int _proxy__wrap_new_Touch(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Touch);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Touch_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Touch_methods[]= {
    { "addListener", _wrap_Touch_addListener},
    { "getNumStates", _wrap_Touch_getNumStates},
    { "getState", _wrap_Touch_getState},
    {0,0}
};
static swig_lua_method swig_Touch_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Touch_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Touch_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Touch_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Touch_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Touch_Sf_SwigStatic = {
    "Touch",
    swig_Touch_Sf_SwigStatic_methods,
    swig_Touch_Sf_SwigStatic_attributes,
    swig_Touch_Sf_SwigStatic_constants,
    swig_Touch_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Touch_bases[] = {0};
static const char *swig_Touch_base_names[] = {0};
static swig_lua_class _wrap_class_Touch = { "Touch", "Touch", &SWIGTYPE_p_gsTouch,_proxy__wrap_new_Touch, swig_delete_Touch, swig_Touch_methods, swig_Touch_attributes, &swig_Touch_Sf_SwigStatic, swig_Touch_meta, swig_Touch_bases, swig_Touch_base_names };

static int _wrap_new_Mouse(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *result = 0 ;
  
  SWIG_check_num_args("gsMouse::gsMouse",0,0)
  result = (gsMouse *)new gsMouse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouse,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_xpos_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::xpos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::xpos",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::xpos",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_xpos_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xpos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_xpos_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::xpos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::xpos",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_xpos_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->xpos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_ypos_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::ypos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::ypos",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::ypos",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_ypos_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->ypos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_ypos_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::ypos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::ypos",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_ypos_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->ypos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_xrel_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::xrel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::xrel",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::xrel",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_xrel_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xrel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_xrel_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::xrel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::xrel",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_xrel_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->xrel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_yrel_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::yrel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::yrel",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::yrel",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_yrel_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->yrel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_yrel_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::yrel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::yrel",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_yrel_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->yrel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_winx_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::winx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::winx",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::winx",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_winx_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->winx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_winx_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::winx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::winx",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_winx_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->winx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_winy_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::winy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::winy",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::winy",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_winy_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->winy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_winy_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::winy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::winy",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_winy_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->winy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_wheel_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouse::wheel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::wheel",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::wheel",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_wheel_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->wheel = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_wheel_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouse::wheel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::wheel",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_wheel_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (float) ((arg1)->wheel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_moved_set(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsMouse::moved",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::moved",1,"gsMouse *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsMouse::moved",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_moved_set",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->moved = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_moved_get(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsMouse::moved",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::moved",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_moved_get",1,SWIGTYPE_p_gsMouse);
  }
  
  result = (bool) ((arg1)->moved);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_capture(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  
  SWIG_check_num_args("gsMouse::capture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::capture",1,"gsMouse *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_capture",1,SWIGTYPE_p_gsMouse);
  }
  
  (arg1)->capture();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Mouse_isButtonDown(lua_State* L) {
  int SWIG_arg = 0;
  gsMouse *arg1 = (gsMouse *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsMouse::isButtonDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouse::isButtonDown",1,"gsMouse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouse::isButtonDown",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouse,0))){
    SWIG_fail_ptr("Mouse_isButtonDown",1,SWIGTYPE_p_gsMouse);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isButtonDown(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Mouse(void *obj) {
gsMouse *arg1 = (gsMouse *) obj;
delete arg1;
}
static int _proxy__wrap_new_Mouse(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Mouse);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Mouse_attributes[] = {
    { "xpos", _wrap_Mouse_xpos_get, _wrap_Mouse_xpos_set },
    { "ypos", _wrap_Mouse_ypos_get, _wrap_Mouse_ypos_set },
    { "xrel", _wrap_Mouse_xrel_get, _wrap_Mouse_xrel_set },
    { "yrel", _wrap_Mouse_yrel_get, _wrap_Mouse_yrel_set },
    { "winx", _wrap_Mouse_winx_get, _wrap_Mouse_winx_set },
    { "winy", _wrap_Mouse_winy_get, _wrap_Mouse_winy_set },
    { "wheel", _wrap_Mouse_wheel_get, _wrap_Mouse_wheel_set },
    { "moved", _wrap_Mouse_moved_get, _wrap_Mouse_moved_set },
    {0,0,0}
};
static swig_lua_method swig_Mouse_methods[]= {
    { "capture", _wrap_Mouse_capture},
    { "isButtonDown", _wrap_Mouse_isButtonDown},
    {0,0}
};
static swig_lua_method swig_Mouse_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Mouse_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Mouse_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Mouse_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Mouse_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Mouse_Sf_SwigStatic = {
    "Mouse",
    swig_Mouse_Sf_SwigStatic_methods,
    swig_Mouse_Sf_SwigStatic_attributes,
    swig_Mouse_Sf_SwigStatic_constants,
    swig_Mouse_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Mouse_bases[] = {0};
static const char *swig_Mouse_base_names[] = {0};
static swig_lua_class _wrap_class_Mouse = { "Mouse", "Mouse", &SWIGTYPE_p_gsMouse,_proxy__wrap_new_Mouse, swig_delete_Mouse, swig_Mouse_methods, swig_Mouse_attributes, &swig_Mouse_Sf_SwigStatic, swig_Mouse_meta, swig_Mouse_bases, swig_Mouse_base_names };

static int _wrap_getNumJoysticks(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("getNumJoysticks",0,0)
  result = (int)getNumJoysticks();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Joystick(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  gsJoystick *result = 0 ;
  
  SWIG_check_num_args("gsJoystick::gsJoystick",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsJoystick::gsJoystick",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (gsJoystick *)new gsJoystick(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsJoystick,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_capture(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  
  SWIG_check_num_args("gsJoystick::capture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::capture",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_capture",1,SWIGTYPE_p_gsJoystick);
  }
  
  (arg1)->capture();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getNumAxes(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getNumAxes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getNumAxes",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getNumAxes",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (int)(arg1)->getNumAxes();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getAxis",1,"gsJoystick *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystick::getAxis",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getAxis",1,SWIGTYPE_p_gsJoystick);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->getAxis(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getRelAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getRelAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getRelAxis",1,"gsJoystick *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystick::getRelAxis",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getRelAxis",1,SWIGTYPE_p_gsJoystick);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->getRelAxis(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getAccel(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsJoystick::getAccel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getAccel",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getAccel",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (arg1)->getAccel();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getNumButtons(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getNumButtons",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getNumButtons",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getNumButtons",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (int)(arg1)->getNumButtons();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getButtonCount(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getButtonCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getButtonCount",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getButtonCount",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (int)(arg1)->getButtonCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_isButtonDown(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsJoystick::isButtonDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::isButtonDown",1,"gsJoystick *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystick::isButtonDown",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_isButtonDown",1,SWIGTYPE_p_gsJoystick);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isButtonDown(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_wasButtonPressed(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsJoystick::wasButtonPressed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::wasButtonPressed",1,"gsJoystick *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystick::wasButtonPressed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_wasButtonPressed",1,SWIGTYPE_p_gsJoystick);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->wasButtonPressed(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getWinWidth(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getWinWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getWinWidth",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getWinWidth",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (int)(arg1)->getWinWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Joystick_getWinHeight(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystick *arg1 = (gsJoystick *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystick::getWinHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystick::getWinHeight",1,"gsJoystick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystick,0))){
    SWIG_fail_ptr("Joystick_getWinHeight",1,SWIGTYPE_p_gsJoystick);
  }
  
  result = (int)(arg1)->getWinHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Joystick(void *obj) {
gsJoystick *arg1 = (gsJoystick *) obj;
delete arg1;
}
static int _proxy__wrap_new_Joystick(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Joystick);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Joystick_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Joystick_methods[]= {
    { "capture", _wrap_Joystick_capture},
    { "getNumAxes", _wrap_Joystick_getNumAxes},
    { "getAxis", _wrap_Joystick_getAxis},
    { "getRelAxis", _wrap_Joystick_getRelAxis},
    { "getAccel", _wrap_Joystick_getAccel},
    { "getNumButtons", _wrap_Joystick_getNumButtons},
    { "getButtonCount", _wrap_Joystick_getButtonCount},
    { "isButtonDown", _wrap_Joystick_isButtonDown},
    { "wasButtonPressed", _wrap_Joystick_wasButtonPressed},
    { "getWinWidth", _wrap_Joystick_getWinWidth},
    { "getWinHeight", _wrap_Joystick_getWinHeight},
    {0,0}
};
static swig_lua_method swig_Joystick_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Joystick_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Joystick_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Joystick_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Joystick_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Joystick_Sf_SwigStatic = {
    "Joystick",
    swig_Joystick_Sf_SwigStatic_methods,
    swig_Joystick_Sf_SwigStatic_attributes,
    swig_Joystick_Sf_SwigStatic_constants,
    swig_Joystick_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Joystick_bases[] = {0};
static const char *swig_Joystick_base_names[] = {0};
static swig_lua_class _wrap_class_Joystick = { "Joystick", "Joystick", &SWIGTYPE_p_gsJoystick,_proxy__wrap_new_Joystick, swig_delete_Joystick, swig_Joystick_methods, swig_Joystick_attributes, &swig_Joystick_Sf_SwigStatic, swig_Joystick_meta, swig_Joystick_bases, swig_Joystick_base_names };

static int _wrap_new_Keyboard(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *result = 0 ;
  
  SWIG_check_num_args("gsKeyboard::gsKeyboard",0,0)
  result = (gsKeyboard *)new gsKeyboard();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsKeyboard,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_capture(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  
  SWIG_check_num_args("gsKeyboard::capture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::capture",1,"gsKeyboard *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_capture",1,SWIGTYPE_p_gsKeyboard);
  }
  
  (arg1)->capture();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_clearKey(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsKeyboard::clearKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::clearKey",1,"gsKeyboard *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboard::clearKey",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_clearKey",1,SWIGTYPE_p_gsKeyboard);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->clearKey(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_isKeyDown(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsKeyboard::isKeyDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::isKeyDown",1,"gsKeyboard *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboard::isKeyDown",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_isKeyDown",1,SWIGTYPE_p_gsKeyboard);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isKeyDown(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_isKeyUp(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsKeyboard::isKeyUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::isKeyUp",1,"gsKeyboard *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboard::isKeyUp",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_isKeyUp",1,SWIGTYPE_p_gsKeyboard);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isKeyUp(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_setCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsKeyboard::setCallback",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::setCallback",1,"gsKeyboard *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsKeyboard::setCallback",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsKeyboard::setCallback",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_setCallback",1,SWIGTYPE_p_gsKeyboard);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setCallback(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_setCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboard *arg1 = (gsKeyboard *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsKeyboard::setCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboard::setCallback",1,"gsKeyboard *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsKeyboard::setCallback",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboard,0))){
    SWIG_fail_ptr("Keyboard_setCallback",1,SWIGTYPE_p_gsKeyboard);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setCallback(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Keyboard_setCallback(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsKeyboard, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Keyboard_setCallback__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsKeyboard, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Keyboard_setCallback__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Keyboard_setCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsKeyboard::setCallback(gsSelf,gsFunction)\n"
    "    gsKeyboard::setCallback(gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_Keyboard(void *obj) {
gsKeyboard *arg1 = (gsKeyboard *) obj;
delete arg1;
}
static int _proxy__wrap_new_Keyboard(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Keyboard);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Keyboard_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Keyboard_methods[]= {
    { "capture", _wrap_Keyboard_capture},
    { "clearKey", _wrap_Keyboard_clearKey},
    { "isKeyDown", _wrap_Keyboard_isKeyDown},
    { "isKeyUp", _wrap_Keyboard_isKeyUp},
    { "setCallback", _wrap_Keyboard_setCallback},
    {0,0}
};
static swig_lua_method swig_Keyboard_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Keyboard_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Keyboard_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Keyboard_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Keyboard_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Keyboard_Sf_SwigStatic = {
    "Keyboard",
    swig_Keyboard_Sf_SwigStatic_methods,
    swig_Keyboard_Sf_SwigStatic_attributes,
    swig_Keyboard_Sf_SwigStatic_constants,
    swig_Keyboard_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Keyboard_bases[] = {0};
static const char *swig_Keyboard_base_names[] = {0};
static swig_lua_class _wrap_class_Keyboard = { "Keyboard", "Keyboard", &SWIGTYPE_p_gsKeyboard,_proxy__wrap_new_Keyboard, swig_delete_Keyboard, swig_Keyboard_methods, swig_Keyboard_attributes, &swig_Keyboard_Sf_SwigStatic, swig_Keyboard_meta, swig_Keyboard_bases, swig_Keyboard_base_names };

static int _wrap_new_Engine(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *result = 0 ;
  
  SWIG_check_num_args("gsEngine::gsEngine",0,0)
  result = (gsEngine *)new gsEngine();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEngine,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_initialize(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  
  SWIG_check_num_args("gsEngine::initialize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::initialize",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_initialize",1,SWIGTYPE_p_gsEngine);
  }
  
  (arg1)->initialize();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_run(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  
  SWIG_check_num_args("gsEngine::run",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::run",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_run",1,SWIGTYPE_p_gsEngine);
  }
  
  (arg1)->run();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_requestExit(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  
  SWIG_check_num_args("gsEngine::requestExit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::requestExit",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_requestExit",1,SWIGTYPE_p_gsEngine);
  }
  
  (arg1)->requestExit();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_saveTimestampedScreenShot(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsEngine::saveTimestampedScreenShot",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::saveTimestampedScreenShot",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::saveTimestampedScreenShot",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::saveTimestampedScreenShot",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_saveTimestampedScreenShot",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->saveTimestampedScreenShot((gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_connect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  int arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsEngine::connect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::connect",1,"gsEngine *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEngine::connect",2,"int");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsEngine::connect",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_connect",1,SWIGTYPE_p_gsEngine);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->connect(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_connect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  int arg2 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  
  SWIG_check_num_args("gsEngine::connect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::connect",1,"gsEngine *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEngine::connect",2,"int");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsEngine::connect",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsEngine::connect",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_connect",1,SWIGTYPE_p_gsEngine);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->connect(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_connect(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Engine_connect__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        _v = lua_istable(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_Engine_connect__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_connect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::connect(int,gsFunction)\n"
    "    gsEngine::connect(int,gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_loadBlendFile__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  bool arg5 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsEngine::loadBlendFile",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::loadBlendFile",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::loadBlendFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::loadBlendFile",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsEngine::loadBlendFile",4,"gkString const &");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsEngine::loadBlendFile",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_loadBlendFile",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->loadBlendFile((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_loadBlendFile__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsEngine::loadBlendFile",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::loadBlendFile",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::loadBlendFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::loadBlendFile",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsEngine::loadBlendFile",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_loadBlendFile",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->loadBlendFile((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_loadBlendFile__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsEngine::loadBlendFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::loadBlendFile",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::loadBlendFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::loadBlendFile",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_loadBlendFile",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->loadBlendFile((gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_loadBlendFile__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEngine::loadBlendFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::loadBlendFile",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::loadBlendFile",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_loadBlendFile",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->loadBlendFile((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_loadBlendFile(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Engine_loadBlendFile__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_Engine_loadBlendFile__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_Engine_loadBlendFile__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_Engine_loadBlendFile__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_loadBlendFile'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::loadBlendFile(gkString const &,gkString const &,gkString const &,bool)\n"
    "    gsEngine::loadBlendFile(gkString const &,gkString const &,gkString const &)\n"
    "    gsEngine::loadBlendFile(gkString const &,gkString const &)\n"
    "    gsEngine::loadBlendFile(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_getActiveScene(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::getActiveScene",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::getActiveScene",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_getActiveScene",1,SWIGTYPE_p_gsEngine);
  }
  
  result = (gkScene *)(arg1)->getActiveScene();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_getScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::getScene",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::getScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::getScene",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::getScene",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_getScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (gkScene *)(arg1)->getScene((gkString const &)*arg2,(gkString const &)*arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_getScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::getScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::getScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::getScene",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_getScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkScene *)(arg1)->getScene((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_getScene(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Engine_getScene__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_Engine_getScene__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_getScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::getScene(gkString const &,gkString const &)\n"
    "    gsEngine::getScene(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_createEmptyScene(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::createEmptyScene",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::createEmptyScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::createEmptyScene",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsEngine::createEmptyScene",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsEngine::createEmptyScene",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_createEmptyScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  result = (gkScene *)(arg1)->createEmptyScene((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_addOverlayScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::addOverlayScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::addOverlayScene",1,"gsEngine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsEngine::addOverlayScene",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_addOverlayScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Engine_addOverlayScene",2,SWIGTYPE_p_gsScene);
  }
  
  result = (gkScene *)(arg1)->addOverlayScene(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_addOverlayScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::addOverlayScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::addOverlayScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::addOverlayScene",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_addOverlayScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkScene *)(arg1)->addOverlayScene((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_addOverlayScene(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Engine_addOverlayScene__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Engine_addOverlayScene__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_addOverlayScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::addOverlayScene(gsScene *)\n"
    "    gsEngine::addOverlayScene(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_addBackgroundScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::addBackgroundScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::addBackgroundScene",1,"gsEngine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsEngine::addBackgroundScene",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_addBackgroundScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Engine_addBackgroundScene",2,SWIGTYPE_p_gsScene);
  }
  
  result = (gkScene *)(arg1)->addBackgroundScene(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_addBackgroundScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsEngine::addBackgroundScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::addBackgroundScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::addBackgroundScene",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_addBackgroundScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkScene *)(arg1)->addBackgroundScene((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_addBackgroundScene(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Engine_addBackgroundScene__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Engine_addBackgroundScene__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_addBackgroundScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::addBackgroundScene(gsScene *)\n"
    "    gsEngine::addBackgroundScene(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_removeScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  
  SWIG_check_num_args("gsEngine::removeScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::removeScene",1,"gsEngine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsEngine::removeScene",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_removeScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Engine_removeScene",2,SWIGTYPE_p_gsScene);
  }
  
  (arg1)->removeScene(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_removeScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEngine::removeScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::removeScene",1,"gsEngine *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEngine::removeScene",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_removeScene",1,SWIGTYPE_p_gsEngine);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->removeScene((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_removeScene(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Engine_removeScene__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEngine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Engine_removeScene__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Engine_removeScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEngine::removeScene(gsScene *)\n"
    "    gsEngine::removeScene(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Engine_setSystemMode(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsEngine::setSystemMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::setSystemMode",1,"gsEngine *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsEngine::setSystemMode",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_setSystemMode",1,SWIGTYPE_p_gsEngine);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setSystemMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_isSystemMode(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsEngine::isSystemMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::isSystemMode",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_isSystemMode",1,SWIGTYPE_p_gsEngine);
  }
  
  result = (bool)(arg1)->isSystemMode();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Engine_getUserDefs(lua_State* L) {
  int SWIG_arg = 0;
  gsEngine *arg1 = (gsEngine *) 0 ;
  gsUserDefs *result = 0 ;
  
  SWIG_check_num_args("gsEngine::getUserDefs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngine::getUserDefs",1,"gsEngine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEngine,0))){
    SWIG_fail_ptr("Engine_getUserDefs",1,SWIGTYPE_p_gsEngine);
  }
  
  result = (gsUserDefs *) &(arg1)->getUserDefs();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsUserDefs,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Engine(void *obj) {
gsEngine *arg1 = (gsEngine *) obj;
delete arg1;
}
static int _proxy__wrap_new_Engine(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Engine);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Engine_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Engine_methods[]= {
    { "initialize", _wrap_Engine_initialize},
    { "run", _wrap_Engine_run},
    { "requestExit", _wrap_Engine_requestExit},
    { "saveTimestampedScreenShot", _wrap_Engine_saveTimestampedScreenShot},
    { "connect", _wrap_Engine_connect},
    { "loadBlendFile", _wrap_Engine_loadBlendFile},
    { "getActiveScene", _wrap_Engine_getActiveScene},
    { "getScene", _wrap_Engine_getScene},
    { "createEmptyScene", _wrap_Engine_createEmptyScene},
    { "addOverlayScene", _wrap_Engine_addOverlayScene},
    { "addBackgroundScene", _wrap_Engine_addBackgroundScene},
    { "removeScene", _wrap_Engine_removeScene},
    { "setSystemMode", _wrap_Engine_setSystemMode},
    { "isSystemMode", _wrap_Engine_isSystemMode},
    { "getUserDefs", _wrap_Engine_getUserDefs},
    {0,0}
};
static swig_lua_method swig_Engine_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Engine_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Engine_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Engine_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Engine_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Engine_Sf_SwigStatic = {
    "Engine",
    swig_Engine_Sf_SwigStatic_methods,
    swig_Engine_Sf_SwigStatic_attributes,
    swig_Engine_Sf_SwigStatic_constants,
    swig_Engine_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Engine_bases[] = {0};
static const char *swig_Engine_base_names[] = {0};
static swig_lua_class _wrap_class_Engine = { "Engine", "Engine", &SWIGTYPE_p_gsEngine,_proxy__wrap_new_Engine, swig_delete_Engine, swig_Engine_methods, swig_Engine_attributes, &swig_Engine_Sf_SwigStatic, swig_Engine_meta, swig_Engine_bases, swig_Engine_base_names };

static int _wrap_new_Object(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *result = 0 ;
  
  SWIG_check_num_args("gsObject::gsObject",0,0)
  result = (gsObject *)new gsObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsObject,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_createInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  
  SWIG_check_num_args("gsObject::createInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::createInstance",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_createInstance",1,SWIGTYPE_p_gsObject);
  }
  
  (arg1)->createInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_destroyInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  
  SWIG_check_num_args("gsObject::destroyInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::destroyInstance",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_destroyInstance",1,SWIGTYPE_p_gsObject);
  }
  
  (arg1)->destroyInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_reinstance(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  
  SWIG_check_num_args("gsObject::reinstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::reinstance",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_reinstance",1,SWIGTYPE_p_gsObject);
  }
  
  (arg1)->reinstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_isInstanced(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsObject::isInstanced",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::isInstanced",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_isInstanced",1,SWIGTYPE_p_gsObject);
  }
  
  result = (bool)(arg1)->isInstanced();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsObject::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::getName",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_getName",1,SWIGTYPE_p_gsObject);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Object_getGroupName(lua_State* L) {
  int SWIG_arg = 0;
  gsObject *arg1 = (gsObject *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsObject::getGroupName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObject::getGroupName",1,"gsObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObject,0))){
    SWIG_fail_ptr("Object_getGroupName",1,SWIGTYPE_p_gsObject);
  }
  
  result = (arg1)->getGroupName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Object(void *obj) {
gsObject *arg1 = (gsObject *) obj;
delete arg1;
}
static int _proxy__wrap_new_Object(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Object);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Object_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Object_methods[]= {
    { "createInstance", _wrap_Object_createInstance},
    { "destroyInstance", _wrap_Object_destroyInstance},
    { "reinstance", _wrap_Object_reinstance},
    { "isInstanced", _wrap_Object_isInstanced},
    { "getName", _wrap_Object_getName},
    { "getGroupName", _wrap_Object_getGroupName},
    {0,0}
};
static swig_lua_method swig_Object_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Object_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Object_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Object_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Object_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Object_Sf_SwigStatic = {
    "Object",
    swig_Object_Sf_SwigStatic_methods,
    swig_Object_Sf_SwigStatic_attributes,
    swig_Object_Sf_SwigStatic_constants,
    swig_Object_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Object_bases[] = {0};
static const char *swig_Object_base_names[] = {0};
static swig_lua_class _wrap_class_Object = { "Object", "Object", &SWIGTYPE_p_gsObject,_proxy__wrap_new_Object, swig_delete_Object, swig_Object_methods, swig_Object_attributes, &swig_Object_Sf_SwigStatic, swig_Object_meta, swig_Object_bases, swig_Object_base_names };

static int _wrap_new_HUD(lua_State* L) {
  int SWIG_arg = 0;
  gsHUD *result = 0 ;
  
  SWIG_check_num_args("gsHUD::gsHUD",0,0)
  result = (gsHUD *)new gsHUD();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsHUD,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUD_show(lua_State* L) {
  int SWIG_arg = 0;
  gsHUD *arg1 = (gsHUD *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsHUD::show",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUD::show",1,"gsHUD *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsHUD::show",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUD,0))){
    SWIG_fail_ptr("HUD_show",1,SWIGTYPE_p_gsHUD);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->show(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUD_getChild(lua_State* L) {
  int SWIG_arg = 0;
  gsHUD *arg1 = (gsHUD *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkHUDElement *result = 0 ;
  
  SWIG_check_num_args("gsHUD::getChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUD::getChild",1,"gsHUD *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsHUD::getChild",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUD,0))){
    SWIG_fail_ptr("HUD_getChild",1,SWIGTYPE_p_gsHUD);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkHUDElement *)(arg1)->getChild((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, HUDElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_HUD(void *obj) {
gsHUD *arg1 = (gsHUD *) obj;
delete arg1;
}
static int _proxy__wrap_new_HUD(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_HUD);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_HUD_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_HUD_methods[]= {
    { "show", _wrap_HUD_show},
    { "getChild", _wrap_HUD_getChild},
    {0,0}
};
static swig_lua_method swig_HUD_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_HUD_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_HUD_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_HUD_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_HUD_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_HUD_Sf_SwigStatic = {
    "HUD",
    swig_HUD_Sf_SwigStatic_methods,
    swig_HUD_Sf_SwigStatic_attributes,
    swig_HUD_Sf_SwigStatic_constants,
    swig_HUD_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_HUD_bases[] = {0};
static const char *swig_HUD_base_names[] = {0};
static swig_lua_class _wrap_class_HUD = { "HUD", "HUD", &SWIGTYPE_p_gsHUD,_proxy__wrap_new_HUD, swig_delete_HUD, swig_HUD_methods, swig_HUD_attributes, &swig_HUD_Sf_SwigStatic, swig_HUD_meta, swig_HUD_bases, swig_HUD_base_names };

static int _wrap_new_HUDElement(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *result = 0 ;
  
  SWIG_check_num_args("gsHUDElement::gsHUDElement",0,0)
  result = (gsHUDElement *)new gsHUDElement();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsHUDElement,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_show(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsHUDElement::show",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::show",1,"gsHUDElement *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsHUDElement::show",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_show",1,SWIGTYPE_p_gsHUDElement);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->show(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsHUDElement::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getValue",1,"gsHUDElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getValue",1,SWIGTYPE_p_gsHUDElement);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsHUDElement::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setValue",1,"gsHUDElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsHUDElement::setValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setValue",1,SWIGTYPE_p_gsHUDElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setUvCoords(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsHUDElement::setUvCoords",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setUvCoords",1,"gsHUDElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsHUDElement::setUvCoords",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsHUDElement::setUvCoords",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsHUDElement::setUvCoords",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsHUDElement::setUvCoords",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setUvCoords",1,SWIGTYPE_p_gsHUDElement);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setUvCoords(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getParameter(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("gsHUDElement::getParameter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getParameter",1,"gsHUDElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsHUDElement::getParameter",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getParameter",1,SWIGTYPE_p_gsHUDElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->getParameter((gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setParameter(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsHUDElement::setParameter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setParameter",1,"gsHUDElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsHUDElement::setParameter",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsHUDElement::setParameter",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setParameter",1,SWIGTYPE_p_gsHUDElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->setParameter((gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsHUDElement::getMaterialName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getMaterialName",1,"gsHUDElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getMaterialName",1,SWIGTYPE_p_gsHUDElement);
  }
  
  result = (arg1)->getMaterialName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsHUDElement::setMaterialName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setMaterialName",1,"gsHUDElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsHUDElement::setMaterialName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setMaterialName",1,SWIGTYPE_p_gsHUDElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterialName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getMaterialAlpha(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  float result;
  
  SWIG_check_num_args("gsHUDElement::getMaterialAlpha",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getMaterialAlpha",1,"gsHUDElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getMaterialAlpha",1,SWIGTYPE_p_gsHUDElement);
  }
  
  result = (float)(arg1)->getMaterialAlpha();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setMaterialAlpha(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsHUDElement::setMaterialAlpha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setMaterialAlpha",1,"gsHUDElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsHUDElement::setMaterialAlpha",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setMaterialAlpha",1,SWIGTYPE_p_gsHUDElement);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMaterialAlpha(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getMaterialAlphaRejectValue(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  int result;
  
  SWIG_check_num_args("gsHUDElement::getMaterialAlphaRejectValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getMaterialAlphaRejectValue",1,"gsHUDElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getMaterialAlphaRejectValue",1,SWIGTYPE_p_gsHUDElement);
  }
  
  result = (int)(arg1)->getMaterialAlphaRejectValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setMaterialAlphaRejectValue(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsHUDElement::setMaterialAlphaRejectValue",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setMaterialAlphaRejectValue",1,"gsHUDElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsHUDElement::setMaterialAlphaRejectValue",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsHUDElement::setMaterialAlphaRejectValue",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setMaterialAlphaRejectValue",1,SWIGTYPE_p_gsHUDElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setMaterialAlphaRejectValue(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_getPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsHUDElement::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::getPosition",1,"gsHUDElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_getPosition",1,SWIGTYPE_p_gsHUDElement);
  }
  
  result = (arg1)->getPosition();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  gsVector3 arg2 ;
  gsVector3 *argp2 ;
  
  SWIG_check_num_args("gsHUDElement::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setPosition",1,"gsHUDElement *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsHUDElement::setPosition",2,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setPosition",1,SWIGTYPE_p_gsHUDElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("HUDElement_setPosition",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  (arg1)->setPosition(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsHUDElement *arg1 = (gsHUDElement *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsHUDElement::setPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsHUDElement::setPosition",1,"gsHUDElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsHUDElement::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsHUDElement::setPosition",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsHUDElement,0))){
    SWIG_fail_ptr("HUDElement_setPosition",1,SWIGTYPE_p_gsHUDElement);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setPosition(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HUDElement_setPosition(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsHUDElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_HUDElement_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsHUDElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_HUDElement_setPosition__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'HUDElement_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsHUDElement::setPosition(gsVector3)\n"
    "    gsHUDElement::setPosition(float,float)\n");
  lua_error(L);return 0;
}


static void swig_delete_HUDElement(void *obj) {
gsHUDElement *arg1 = (gsHUDElement *) obj;
delete arg1;
}
static int _proxy__wrap_new_HUDElement(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_HUDElement);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_HUDElement_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_HUDElement_methods[]= {
    { "show", _wrap_HUDElement_show},
    { "getValue", _wrap_HUDElement_getValue},
    { "setValue", _wrap_HUDElement_setValue},
    { "setUvCoords", _wrap_HUDElement_setUvCoords},
    { "getParameter", _wrap_HUDElement_getParameter},
    { "setParameter", _wrap_HUDElement_setParameter},
    { "getMaterialName", _wrap_HUDElement_getMaterialName},
    { "setMaterialName", _wrap_HUDElement_setMaterialName},
    { "getMaterialAlpha", _wrap_HUDElement_getMaterialAlpha},
    { "setMaterialAlpha", _wrap_HUDElement_setMaterialAlpha},
    { "getMaterialAlphaRejectValue", _wrap_HUDElement_getMaterialAlphaRejectValue},
    { "setMaterialAlphaRejectValue", _wrap_HUDElement_setMaterialAlphaRejectValue},
    { "getPosition", _wrap_HUDElement_getPosition},
    { "setPosition", _wrap_HUDElement_setPosition},
    {0,0}
};
static swig_lua_method swig_HUDElement_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_HUDElement_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_HUDElement_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_HUDElement_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_HUDElement_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_HUDElement_Sf_SwigStatic = {
    "HUDElement",
    swig_HUDElement_Sf_SwigStatic_methods,
    swig_HUDElement_Sf_SwigStatic_attributes,
    swig_HUDElement_Sf_SwigStatic_constants,
    swig_HUDElement_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_HUDElement_bases[] = {0};
static const char *swig_HUDElement_base_names[] = {0};
static swig_lua_class _wrap_class_HUDElement = { "HUDElement", "HUDElement", &SWIGTYPE_p_gsHUDElement,_proxy__wrap_new_HUDElement, swig_delete_HUDElement, swig_HUDElement_methods, swig_HUDElement_attributes, &swig_HUDElement_Sf_SwigStatic, swig_HUDElement_meta, swig_HUDElement_bases, swig_HUDElement_base_names };

static int _wrap_getHUD(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkHUD *result = 0 ;
  
  SWIG_check_num_args("getHUD",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getHUD",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (gkHUD *)getHUD((gkString const &)*arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, HUD); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsStaticBatch(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gsStaticBatch *result = 0 ;
  
  SWIG_check_num_args("gsStaticBatch::gsStaticBatch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStaticBatch::gsStaticBatch",1,"gkScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("new_gsStaticBatch",1,SWIGTYPE_p_gkScene);
  }
  
  result = (gsStaticBatch *)new gsStaticBatch(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStaticBatch,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStaticBatch_addEntity(lua_State* L) {
  int SWIG_arg = 0;
  gsStaticBatch *arg1 = (gsStaticBatch *) 0 ;
  gsEntity *arg2 = (gsEntity *) 0 ;
  
  SWIG_check_num_args("gsStaticBatch::addEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStaticBatch::addEntity",1,"gsStaticBatch *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsStaticBatch::addEntity",2,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStaticBatch,0))){
    SWIG_fail_ptr("gsStaticBatch_addEntity",1,SWIGTYPE_p_gsStaticBatch);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("gsStaticBatch_addEntity",2,SWIGTYPE_p_gsEntity);
  }
  
  (arg1)->addEntity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStaticBatch_removeEntity(lua_State* L) {
  int SWIG_arg = 0;
  gsStaticBatch *arg1 = (gsStaticBatch *) 0 ;
  gsEntity *arg2 = (gsEntity *) 0 ;
  
  SWIG_check_num_args("gsStaticBatch::removeEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStaticBatch::removeEntity",1,"gsStaticBatch *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsStaticBatch::removeEntity",2,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStaticBatch,0))){
    SWIG_fail_ptr("gsStaticBatch_removeEntity",1,SWIGTYPE_p_gsStaticBatch);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("gsStaticBatch_removeEntity",2,SWIGTYPE_p_gsEntity);
  }
  
  (arg1)->removeEntity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStaticBatch_build(lua_State* L) {
  int SWIG_arg = 0;
  gsStaticBatch *arg1 = (gsStaticBatch *) 0 ;
  
  SWIG_check_num_args("gsStaticBatch::build",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStaticBatch::build",1,"gsStaticBatch *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStaticBatch,0))){
    SWIG_fail_ptr("gsStaticBatch_build",1,SWIGTYPE_p_gsStaticBatch);
  }
  
  (arg1)->build();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStaticBatch(void *obj) {
gsStaticBatch *arg1 = (gsStaticBatch *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStaticBatch(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStaticBatch);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStaticBatch_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStaticBatch_methods[]= {
    { "addEntity", _wrap_gsStaticBatch_addEntity},
    { "removeEntity", _wrap_gsStaticBatch_removeEntity},
    { "build", _wrap_gsStaticBatch_build},
    {0,0}
};
static swig_lua_method swig_gsStaticBatch_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStaticBatch_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStaticBatch_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStaticBatch_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStaticBatch_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStaticBatch_Sf_SwigStatic = {
    "gsStaticBatch",
    swig_gsStaticBatch_Sf_SwigStatic_methods,
    swig_gsStaticBatch_Sf_SwigStatic_attributes,
    swig_gsStaticBatch_Sf_SwigStatic_constants,
    swig_gsStaticBatch_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStaticBatch_bases[] = {0};
static const char *swig_gsStaticBatch_base_names[] = {0};
static swig_lua_class _wrap_class_gsStaticBatch = { "gsStaticBatch", "gsStaticBatch", &SWIGTYPE_p_gsStaticBatch,_proxy__wrap_new_gsStaticBatch, swig_delete_gsStaticBatch, swig_gsStaticBatch_methods, swig_gsStaticBatch_attributes, &swig_gsStaticBatch_Sf_SwigStatic, swig_gsStaticBatch_meta, swig_gsStaticBatch_bases, swig_gsStaticBatch_base_names };

static int _wrap_new_Scene(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *result = 0 ;
  
  SWIG_check_num_args("gsScene::gsScene",0,0)
  result = (gsScene *)new gsScene();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsScene,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_hasObject(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsScene::hasObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::hasObject",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::hasObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_hasObject",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->hasObject((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getObject(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsScene::getObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getObject",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::getObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getObject",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->getObject((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_createEmpty(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsScene::createEmpty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createEmpty",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::createEmpty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createEmpty",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->createEmpty((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_createEntity(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsScene::createEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createEntity",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::createEntity",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createEntity",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->createEntity((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_createCamera(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsScene::createCamera",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createCamera",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::createCamera",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createCamera",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->createCamera((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_createLight(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gsLightType arg3 ;
  gkString temp2 ;
  gkLight *result = 0 ;
  
  SWIG_check_num_args("gsScene::createLight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createLight",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScene::createLight",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::createLight",3,"gsLightType");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createLight",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (gsLightType)(int)lua_tonumber(L, 3);
  result = (gkLight *)(arg1)->createLight((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Light); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_cloneObject(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  int arg3 ;
  bool arg4 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsScene::cloneObject",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::cloneObject",1,"gsScene *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsScene::cloneObject",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::cloneObject",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsScene::cloneObject",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_cloneObject",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Scene_cloneObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (gkGameObject *)(arg1)->cloneObject(arg2,arg3,arg4);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_destroyObject(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsScene::destroyObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::destroyObject",1,"gsScene *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsScene::destroyObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_destroyObject",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Scene_destroyObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->destroyObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getObjectList(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsArray< gsGameObject,gkGameObject > *result = 0 ;
  
  SWIG_check_num_args("gsScene::getObjectList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getObjectList",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getObjectList",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsArray< gsGameObject,gkGameObject > *) &(arg1)->getObjectList();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getDynamicsWorld(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkDynamicsWorld *result = 0 ;
  
  SWIG_check_num_args("gsScene::getDynamicsWorld",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getDynamicsWorld",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getDynamicsWorld",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkDynamicsWorld *)(arg1)->getDynamicsWorld();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, DynamicsWorld); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getMainCamera(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkCamera *result = 0 ;
  
  SWIG_check_num_args("gsScene::getMainCamera",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getMainCamera",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getMainCamera",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkCamera *)(arg1)->getMainCamera();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Camera); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getPickRay__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  gsRay *result = 0 ;
  
  SWIG_check_num_args("gsScene::getPickRay",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getPickRay",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::getPickRay",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::getPickRay",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getPickRay",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (gsRay *)(arg1)->getPickRay(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRay,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getPickRay__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  gsRay *result = 0 ;
  
  SWIG_check_num_args("gsScene::getPickRay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getPickRay",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::getPickRay",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getPickRay",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (gsRay *)(arg1)->getPickRay(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRay,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getPickRay__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsRay *result = 0 ;
  
  SWIG_check_num_args("gsScene::getPickRay",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getPickRay",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getPickRay",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsRay *)(arg1)->getPickRay();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRay,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getPickRay(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Scene_getPickRay__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Scene_getPickRay__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Scene_getPickRay__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_getPickRay'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::getPickRay(float,float)\n"
    "    gsScene::getPickRay(float)\n"
    "    gsScene::getPickRay()\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_setUpdateFlags(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("gsScene::setUpdateFlags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setUpdateFlags",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setUpdateFlags",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setUpdateFlags",1,SWIGTYPE_p_gsScene);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  (arg1)->setUpdateFlags(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setLayer(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsScene::setLayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setLayer",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setLayer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setLayer",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setLayer(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getLayer(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  int result;
  
  SWIG_check_num_args("gsScene::getLayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getLayer",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getLayer",1,SWIGTYPE_p_gsScene);
  }
  
  result = (int)(arg1)->getLayer();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setBackgroundColor(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector4 arg2 ;
  gsVector4 *argp2 ;
  
  SWIG_check_num_args("gsScene::setBackgroundColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setBackgroundColor",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::setBackgroundColor",2,"gsVector4");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setBackgroundColor",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("Scene_setBackgroundColor",2,SWIGTYPE_p_gsVector4);
  }
  arg2 = *argp2;
  
  (arg1)->setBackgroundColor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getRecastDebugger(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkRecastDebugger *result = 0 ;
  
  SWIG_check_num_args("gsScene::getRecastDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getRecastDebugger",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getRecastDebugger",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkRecastDebugger *)(arg1)->getRecastDebugger();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, RecastDebugger); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getDebugger(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkDebugger *result = 0 ;
  
  SWIG_check_num_args("gsScene::getDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getDebugger",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getDebugger",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkDebugger *)(arg1)->getDebugger();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Debugger); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getScreenPos__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  bool arg4 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsScene::getScreenPos",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getScreenPos",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::getScreenPos",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsScene::getScreenPos",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsScene::getScreenPos",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getScreenPos",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getScreenPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (arg1)->getScreenPos((gsVector3 const &)*arg2,arg3,arg4);
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getScreenPos__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsScene::getScreenPos",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getScreenPos",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::getScreenPos",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsScene::getScreenPos",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getScreenPos",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getScreenPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (arg1)->getScreenPos((gsVector3 const &)*arg2,arg3);
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getScreenPos__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsScene::getScreenPos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getScreenPos",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::getScreenPos",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getScreenPos",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getScreenPos",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->getScreenPos((gsVector3 const &)*arg2);
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getScreenPos(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Scene_getScreenPos__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Scene_getScreenPos__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Scene_getScreenPos__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_getScreenPos'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::getScreenPos(gsVector3 const &,bool,bool)\n"
    "    gsScene::getScreenPos(gsVector3 const &,bool)\n"
    "    gsScene::getScreenPos(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_createStaticBatch(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsStaticBatch *result = 0 ;
  
  SWIG_check_num_args("gsScene::createStaticBatch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createStaticBatch",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createStaticBatch",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsStaticBatch *)(arg1)->createStaticBatch();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStaticBatch,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getProcessManager(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkProcessManager *result = 0 ;
  
  SWIG_check_num_args("gsScene::getProcessManager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getProcessManager",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getProcessManager",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkProcessManager *)(arg1)->getProcessManager();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ProcessManager); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getLogicBrickManager(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkLogicManager *result = 0 ;
  
  SWIG_check_num_args("gsScene::getLogicBrickManager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getLogicBrickManager",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getLogicBrickManager",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkLogicManager *)(arg1)->getLogicBrickManager();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkLogicManager,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getOwner(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsScene::getOwner",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getOwner",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getOwner",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gkScene *)(arg1)->getOwner();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_asyncCreateNavMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsScene::asyncCreateNavMesh",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_asyncCreateNavMesh",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->asyncCreateNavMesh(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_asyncCreateNavMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsScene::asyncCreateNavMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_asyncCreateNavMesh",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->asyncCreateNavMesh(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_asyncCreateNavMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsScene::asyncCreateNavMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_asyncCreateNavMesh",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->asyncCreateNavMesh(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_asyncCreateNavMesh__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  
  SWIG_check_num_args("gsScene::asyncCreateNavMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::asyncCreateNavMesh",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_asyncCreateNavMesh",1,SWIGTYPE_p_gsScene);
  }
  
  (arg1)->asyncCreateNavMesh();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_asyncCreateNavMesh(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Scene_asyncCreateNavMesh__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Scene_asyncCreateNavMesh__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Scene_asyncCreateNavMesh__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Scene_asyncCreateNavMesh__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_asyncCreateNavMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::asyncCreateNavMesh(float,float,float)\n"
    "    gsScene::asyncCreateNavMesh(float,float)\n"
    "    gsScene::asyncCreateNavMesh(float)\n"
    "    gsScene::asyncCreateNavMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_hasNavMesh(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsScene::hasNavMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::hasNavMesh",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_hasNavMesh",1,SWIGTYPE_p_gsScene);
  }
  
  result = (bool)(arg1)->hasNavMesh();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setNavMeshCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsScene::setNavMeshCallback",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setNavMeshCallback",1,"gsScene *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsScene::setNavMeshCallback",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsScene::setNavMeshCallback",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setNavMeshCallback",1,SWIGTYPE_p_gsScene);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setNavMeshCallback(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setNavMeshCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsScene::setNavMeshCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setNavMeshCallback",1,"gsScene *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsScene::setNavMeshCallback",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setNavMeshCallback",1,SWIGTYPE_p_gsScene);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setNavMeshCallback(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setNavMeshCallback(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Scene_setNavMeshCallback__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Scene_setNavMeshCallback__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_setNavMeshCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::setNavMeshCallback(gsSelf,gsFunction)\n"
    "    gsScene::setNavMeshCallback(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_getNextPointOnNavmesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 *argp3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsScene::getNextPointOnNavmesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getNextPointOnNavmesh",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::getNextPointOnNavmesh",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsScene::getNextPointOnNavmesh",3,"gsVector3 const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getNextPointOnNavmesh",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getNextPointOnNavmesh",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getNextPointOnNavmesh",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  result = (arg1)->getNextPointOnNavmesh((gsVector3 const &)*arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getNextPointOnNavmesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsScene::getNextPointOnNavmesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::getNextPointOnNavmesh",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsScene::getNextPointOnNavmesh",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_getNextPointOnNavmesh",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Scene_getNextPointOnNavmesh",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->getNextPointOnNavmesh((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_getNextPointOnNavmesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Scene_getNextPointOnNavmesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Scene_getNextPointOnNavmesh__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_getNextPointOnNavmesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::getNextPointOnNavmesh(gsVector3 const &,gsVector3 const)\n"
    "    gsScene::getNextPointOnNavmesh(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_setPBS__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gkString *arg5 = 0 ;
  gkString *arg6 = 0 ;
  gkString *arg7 = 0 ;
  gkString *arg8 = 0 ;
  gkString temp5 ;
  gkString temp6 ;
  gkString temp7 ;
  gkString temp8 ;
  
  SWIG_check_num_args("gsScene::setPBS",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setPBS",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setPBS",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::setPBS",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsScene::setPBS",4,"float");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsScene::setPBS",5,"gkString const &");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsScene::setPBS",6,"gkString const &");
  if(!lua_isstring(L,7)) SWIG_fail_arg("gsScene::setPBS",7,"gkString const &");
  if(!lua_isstring(L,8)) SWIG_fail_arg("gsScene::setPBS",8,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setPBS",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  temp7 = gkString((const char*)lua_tostring(L, 7));
  arg7 = &temp7;
  
  
  temp8 = gkString((const char*)lua_tostring(L, 8));
  arg8 = &temp8;
  
  (arg1)->setPBS(arg2,arg3,arg4,(gkString const &)*arg5,(gkString const &)*arg6,(gkString const &)*arg7,(gkString const &)*arg8);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setPBS__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gkString *arg5 = 0 ;
  gkString *arg6 = 0 ;
  gkString *arg7 = 0 ;
  gkString temp5 ;
  gkString temp6 ;
  gkString temp7 ;
  
  SWIG_check_num_args("gsScene::setPBS",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setPBS",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setPBS",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::setPBS",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsScene::setPBS",4,"float");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsScene::setPBS",5,"gkString const &");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsScene::setPBS",6,"gkString const &");
  if(!lua_isstring(L,7)) SWIG_fail_arg("gsScene::setPBS",7,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setPBS",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  temp7 = gkString((const char*)lua_tostring(L, 7));
  arg7 = &temp7;
  
  (arg1)->setPBS(arg2,arg3,arg4,(gkString const &)*arg5,(gkString const &)*arg6,(gkString const &)*arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setPBS__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gkString *arg5 = 0 ;
  gkString *arg6 = 0 ;
  gkString temp5 ;
  gkString temp6 ;
  
  SWIG_check_num_args("gsScene::setPBS",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setPBS",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setPBS",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::setPBS",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsScene::setPBS",4,"float");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsScene::setPBS",5,"gkString const &");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsScene::setPBS",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setPBS",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  (arg1)->setPBS(arg2,arg3,arg4,(gkString const &)*arg5,(gkString const &)*arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setPBS__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gkString *arg5 = 0 ;
  gkString temp5 ;
  
  SWIG_check_num_args("gsScene::setPBS",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::setPBS",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScene::setPBS",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsScene::setPBS",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsScene::setPBS",4,"float");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsScene::setPBS",5,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_setPBS",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  (arg1)->setPBS(arg2,arg3,arg4,(gkString const &)*arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Scene_setPBS(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_Scene_setPBS__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_Scene_setPBS__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isstring(L,argv[6]);
                }
                if (_v) {
                  return _wrap_Scene_setPBS__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isstring(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isstring(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_Scene_setPBS__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Scene_setPBS'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScene::setPBS(float,float,float,gkString const &,gkString const &,gkString const &,gkString const &)\n"
    "    gsScene::setPBS(float,float,float,gkString const &,gkString const &,gkString const &)\n"
    "    gsScene::setPBS(float,float,float,gkString const &,gkString const &)\n"
    "    gsScene::setPBS(float,float,float,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Scene_createHLMSMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  Ogre::Entity *arg2 = (Ogre::Entity *) 0 ;
  Ogre::PbsMaterial *arg3 = (Ogre::PbsMaterial *) 0 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsScene::createHLMSMaterial",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScene::createHLMSMaterial",1,"gsScene *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsScene::createHLMSMaterial",2,"Ogre::Entity *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsScene::createHLMSMaterial",3,"Ogre::PbsMaterial *");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsScene::createHLMSMaterial",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("Scene_createHLMSMaterial",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Entity,0))){
    SWIG_fail_ptr("Scene_createHLMSMaterial",2,SWIGTYPE_p_Ogre__Entity);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__PbsMaterial,0))){
    SWIG_fail_ptr("Scene_createHLMSMaterial",3,SWIGTYPE_p_Ogre__PbsMaterial);
  }
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->createHLMSMaterial(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Scene(void *obj) {
gsScene *arg1 = (gsScene *) obj;
delete arg1;
}
static int _proxy__wrap_new_Scene(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Scene);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Scene_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Scene_methods[]= {
    { "hasObject", _wrap_Scene_hasObject},
    { "getObject", _wrap_Scene_getObject},
    { "createEmpty", _wrap_Scene_createEmpty},
    { "createEntity", _wrap_Scene_createEntity},
    { "createCamera", _wrap_Scene_createCamera},
    { "createLight", _wrap_Scene_createLight},
    { "cloneObject", _wrap_Scene_cloneObject},
    { "destroyObject", _wrap_Scene_destroyObject},
    { "getObjectList", _wrap_Scene_getObjectList},
    { "getDynamicsWorld", _wrap_Scene_getDynamicsWorld},
    { "getMainCamera", _wrap_Scene_getMainCamera},
    { "getPickRay", _wrap_Scene_getPickRay},
    { "setUpdateFlags", _wrap_Scene_setUpdateFlags},
    { "setLayer", _wrap_Scene_setLayer},
    { "getLayer", _wrap_Scene_getLayer},
    { "setBackgroundColor", _wrap_Scene_setBackgroundColor},
    { "getRecastDebugger", _wrap_Scene_getRecastDebugger},
    { "getDebugger", _wrap_Scene_getDebugger},
    { "getScreenPos", _wrap_Scene_getScreenPos},
    { "createStaticBatch", _wrap_Scene_createStaticBatch},
    { "getProcessManager", _wrap_Scene_getProcessManager},
    { "getLogicBrickManager", _wrap_Scene_getLogicBrickManager},
    { "getOwner", _wrap_Scene_getOwner},
    { "asyncCreateNavMesh", _wrap_Scene_asyncCreateNavMesh},
    { "hasNavMesh", _wrap_Scene_hasNavMesh},
    { "setNavMeshCallback", _wrap_Scene_setNavMeshCallback},
    { "getNextPointOnNavmesh", _wrap_Scene_getNextPointOnNavmesh},
    { "setPBS", _wrap_Scene_setPBS},
    { "createHLMSMaterial", _wrap_Scene_createHLMSMaterial},
    {0,0}
};
static swig_lua_method swig_Scene_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Scene_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Scene_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Scene_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Scene_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Scene_Sf_SwigStatic = {
    "Scene",
    swig_Scene_Sf_SwigStatic_methods,
    swig_Scene_Sf_SwigStatic_attributes,
    swig_Scene_Sf_SwigStatic_constants,
    swig_Scene_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Scene_bases[] = {0,0};
static const char *swig_Scene_base_names[] = {"gsObject *",0};
static swig_lua_class _wrap_class_Scene = { "Scene", "Scene", &SWIGTYPE_p_gsScene,_proxy__wrap_new_Scene, swig_delete_Scene, swig_Scene_methods, swig_Scene_attributes, &swig_Scene_Sf_SwigStatic, swig_Scene_meta, swig_Scene_bases, swig_Scene_base_names };

static int _wrap_getActiveScene(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("getActiveScene",0,0)
  result = (gkScene *)getActiveScene();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("getScene",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getScene",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("getScene",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkScene *)getScene((gkString const &)*arg1,(gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("getScene",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getScene",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (gkScene *)getScene((gkString const &)*arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getScene(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_getScene__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_getScene__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getScene(gkString const &,gkString const &)\n"
    "    getScene(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_addScene__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  int arg2 ;
  gkString temp1 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("addScene",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("addScene",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("addScene",2,"int");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkScene *)addScene((gkString const &)*arg1,arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_addScene__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  int arg2 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("addScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("addScene",1,"gsScene *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("addScene",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("addScene",1,SWIGTYPE_p_gsScene);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkScene *)addScene(arg1,arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_addScene(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_addScene__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_addScene__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'addScene'\n"
    "  Possible C/C++ prototypes are:\n"
    "    addScene(gkString const &,int)\n"
    "    addScene(gsScene *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_new_gsGameObjectInstance(lua_State* L) {
  int SWIG_arg = 0;
  gkGameObjectInstance *arg1 = (gkGameObjectInstance *) 0 ;
  gsGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::gsGameObjectInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::gsGameObjectInstance",1,"gkGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGameObjectInstance,0))){
    SWIG_fail_ptr("new_gsGameObjectInstance",1,SWIGTYPE_p_gkGameObjectInstance);
  }
  
  result = (gsGameObjectInstance *)new gsGameObjectInstance(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGameObjectInstance,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getElementCount(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObjectInstance::getElementCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getElementCount",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getElementCount",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  result = (int)(arg1)->getElementCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getElementAt(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::getElementAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getElementAt",1,"gsGameObjectInstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObjectInstance::getElementAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getElementAt",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getElementAt(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getElementByName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  gkString arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::getElementByName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getElementByName",1,"gsGameObjectInstance *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObjectInstance::getElementByName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getElementByName",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  result = (gkGameObject *)(arg1)->getElementByName(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getRoot(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::getRoot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getRoot",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getRoot",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  result = (gkGameObject *)(arg1)->getRoot();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_isInstanced(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObjectInstance::isInstanced",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::isInstanced",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_isInstanced",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  result = (bool)(arg1)->isInstanced();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_destroyInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::destroyInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::destroyInstance",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_destroyInstance",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  (arg1)->destroyInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_kill(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::kill",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::kill",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_kill",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  (arg1)->kill();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_createInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::createInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::createInstance",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_createInstance",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  (arg1)->createInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_reinstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  
  SWIG_check_num_args("gsGameObjectInstance::reinstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::reinstance",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_reinstance",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  (arg1)->reinstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGameObjectInstance::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getName",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getName",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGameObjectInstance_getGroupName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObjectInstance *arg1 = (gsGameObjectInstance *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGameObjectInstance::getGroupName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObjectInstance::getGroupName",1,"gsGameObjectInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObjectInstance,0))){
    SWIG_fail_ptr("gsGameObjectInstance_getGroupName",1,SWIGTYPE_p_gsGameObjectInstance);
  }
  
  result = (arg1)->getGroupName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGameObjectInstance(void *obj) {
gsGameObjectInstance *arg1 = (gsGameObjectInstance *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGameObjectInstance(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGameObjectInstance);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGameObjectInstance_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGameObjectInstance_methods[]= {
    { "getElementCount", _wrap_gsGameObjectInstance_getElementCount},
    { "getElementAt", _wrap_gsGameObjectInstance_getElementAt},
    { "getElementByName", _wrap_gsGameObjectInstance_getElementByName},
    { "getRoot", _wrap_gsGameObjectInstance_getRoot},
    { "isInstanced", _wrap_gsGameObjectInstance_isInstanced},
    { "destroyInstance", _wrap_gsGameObjectInstance_destroyInstance},
    { "kill", _wrap_gsGameObjectInstance_kill},
    { "createInstance", _wrap_gsGameObjectInstance_createInstance},
    { "reinstance", _wrap_gsGameObjectInstance_reinstance},
    { "getName", _wrap_gsGameObjectInstance_getName},
    { "getGroupName", _wrap_gsGameObjectInstance_getGroupName},
    {0,0}
};
static swig_lua_method swig_gsGameObjectInstance_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGameObjectInstance_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGameObjectInstance_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGameObjectInstance_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGameObjectInstance_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGameObjectInstance_Sf_SwigStatic = {
    "gsGameObjectInstance",
    swig_gsGameObjectInstance_Sf_SwigStatic_methods,
    swig_gsGameObjectInstance_Sf_SwigStatic_attributes,
    swig_gsGameObjectInstance_Sf_SwigStatic_constants,
    swig_gsGameObjectInstance_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGameObjectInstance_bases[] = {0};
static const char *swig_gsGameObjectInstance_base_names[] = {0};
static swig_lua_class _wrap_class_gsGameObjectInstance = { "gsGameObjectInstance", "gsGameObjectInstance", &SWIGTYPE_p_gsGameObjectInstance,_proxy__wrap_new_gsGameObjectInstance, swig_delete_gsGameObjectInstance, swig_gsGameObjectInstance_methods, swig_gsGameObjectInstance_attributes, &swig_gsGameObjectInstance_Sf_SwigStatic, swig_gsGameObjectInstance_meta, swig_gsGameObjectInstance_bases, swig_gsGameObjectInstance_base_names };

static int _wrap_createGroupInstance__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsVector3 arg2 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gkString *arg5 = 0 ;
  gkString temp1 ;
  gsVector3 *argp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gkString temp5 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",5,5)
  if(!lua_isstring(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkString const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("createGroupInstance",2,"gsVector3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  if(!lua_isstring(L,5)) SWIG_fail_arg("createGroupInstance",5,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  result = (gkGameObjectInstance *)createGroupInstance((gkString const &)*arg1,arg2,arg3,arg4,(gkString const &)*arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsVector3 arg2 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gkString temp1 ;
  gsVector3 *argp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkString const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("createGroupInstance",2,"gsVector3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  result = (gkGameObjectInstance *)createGroupInstance((gkString const &)*arg1,arg2,arg3,arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsVector3 arg2 ;
  gsVector3 arg3 ;
  gkString temp1 ;
  gsVector3 *argp2 ;
  gsVector3 *argp3 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkString const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("createGroupInstance",2,"gsVector3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  result = (gkGameObjectInstance *)createGroupInstance((gkString const &)*arg1,arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsVector3 arg2 ;
  gkString temp1 ;
  gsVector3 *argp2 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkString const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("createGroupInstance",2,"gsVector3");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  result = (gkGameObjectInstance *)createGroupInstance((gkString const &)*arg1,arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (gkGameObjectInstance *)createGroupInstance((gkString const &)*arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString *arg6 = 0 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  gkString temp6 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("createGroupInstance",5,"gsVector3");
  if(!lua_isstring(L,6)) SWIG_fail_arg("createGroupInstance",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("createGroupInstance",5,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_7(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_8(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_9(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_10(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString *arg6 = 0 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  gkString temp6 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("createGroupInstance",5,"gsVector3");
  if(!lua_isstring(L,6)) SWIG_fail_arg("createGroupInstance",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gkScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_11(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("createGroupInstance",5,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gkScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_12(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("createGroupInstance",4,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gkScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3,arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_13(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("createGroupInstance",3,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gkScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("createGroupInstance",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_14(lua_State* L) {
  int SWIG_arg = 0;
  gkScene *arg1 = (gkScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gkScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gkScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance__SWIG_15(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("createGroupInstance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("createGroupInstance",1,"gsScene *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("createGroupInstance",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("createGroupInstance",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("createGroupInstance",1,SWIGTYPE_p_gsScene);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (gkGameObjectInstance *)createGroupInstance(arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_createGroupInstance(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_createGroupInstance__SWIG_4(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_createGroupInstance__SWIG_9(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_createGroupInstance__SWIG_14(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_createGroupInstance__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_createGroupInstance__SWIG_13(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_createGroupInstance__SWIG_8(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_createGroupInstance__SWIG_15(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_createGroupInstance__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_createGroupInstance__SWIG_7(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_createGroupInstance__SWIG_12(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_createGroupInstance__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_createGroupInstance__SWIG_11(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_createGroupInstance__SWIG_6(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_createGroupInstance__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_createGroupInstance__SWIG_10(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_createGroupInstance__SWIG_5(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'createGroupInstance'\n"
    "  Possible C/C++ prototypes are:\n"
    "    createGroupInstance(gkString const &,gsVector3,gsVector3,gsVector3,gkString const &)\n"
    "    createGroupInstance(gkString const &,gsVector3,gsVector3,gsVector3)\n"
    "    createGroupInstance(gkString const &,gsVector3,gsVector3)\n"
    "    createGroupInstance(gkString const &,gsVector3)\n"
    "    createGroupInstance(gkString const &)\n"
    "    createGroupInstance(gsScene *,gkString const &,gsVector3,gsVector3,gsVector3,gkString const &)\n"
    "    createGroupInstance(gsScene *,gkString const &,gsVector3,gsVector3,gsVector3)\n"
    "    createGroupInstance(gsScene *,gkString const &,gsVector3,gsVector3)\n"
    "    createGroupInstance(gsScene *,gkString const &,gsVector3)\n"
    "    createGroupInstance(gsScene *,gkString const &)\n"
    "    createGroupInstance(gkScene *,gkString const &,gsVector3,gsVector3,gsVector3,gkString const &)\n"
    "    createGroupInstance(gkScene *,gkString const &,gsVector3,gsVector3,gsVector3)\n"
    "    createGroupInstance(gkScene *,gkString const &,gsVector3,gsVector3)\n"
    "    createGroupInstance(gkScene *,gkString const &,gsVector3)\n"
    "    createGroupInstance(gkScene *,gkString const &)\n"
    "    createGroupInstance(gsScene *,gkString const &,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_updateStaticBatch__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString arg1 ;
  gsScene *arg2 = (gsScene *) 0 ;
  
  SWIG_check_num_args("updateStaticBatch",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("updateStaticBatch",1,"gkString");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("updateStaticBatch",2,"gsScene *");
  
  arg1 = gkString((const char*)lua_tostring(L, 1));
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("updateStaticBatch",2,SWIGTYPE_p_gsScene);
  }
  
  updateStaticBatch(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_updateStaticBatch__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString arg1 ;
  
  SWIG_check_num_args("updateStaticBatch",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("updateStaticBatch",1,"gkString");
  
  arg1 = gkString((const char*)lua_tostring(L, 1));
  
  updateStaticBatch(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_updateStaticBatch__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("updateStaticBatch",0,0)
  updateStaticBatch();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_updateStaticBatch(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_updateStaticBatch__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_updateStaticBatch__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_updateStaticBatch__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'updateStaticBatch'\n"
    "  Possible C/C++ prototypes are:\n"
    "    updateStaticBatch(gkString,gsScene *)\n"
    "    updateStaticBatch(gkString)\n"
    "    updateStaticBatch()\n");
  lua_error(L);return 0;
}


static int _wrap_groupExists(lua_State* L) {
  int SWIG_arg = 0;
  gkString arg1 ;
  bool result;
  
  SWIG_check_num_args("groupExists",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("groupExists",1,"gkString");
  
  arg1 = gkString((const char*)lua_tostring(L, 1));
  
  result = (bool)groupExists(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGroupCount__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  int result;
  
  SWIG_check_num_args("getGroupCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getGroupCount",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("getGroupCount",1,SWIGTYPE_p_gsScene);
  }
  
  result = (int)getGroupCount(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGroupCount__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("getGroupCount",0,0)
  result = (int)getGroupCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGroupCount(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_getGroupCount__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_getGroupCount__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getGroupCount'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getGroupCount(gsScene *)\n"
    "    getGroupCount()\n");
  lua_error(L);return 0;
}


static int _wrap_getGroupNameAt__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkString result;
  
  SWIG_check_num_args("getGroupNameAt",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("getGroupNameAt",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("getGroupNameAt",2,"gsScene *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("getGroupNameAt",2,SWIGTYPE_p_gsScene);
  }
  
  result = getGroupNameAt(arg1,arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGroupNameAt__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  gkString result;
  
  SWIG_check_num_args("getGroupNameAt",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("getGroupNameAt",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = getGroupNameAt(arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGroupNameAt(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_getGroupNameAt__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_getGroupNameAt__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getGroupNameAt'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getGroupNameAt(int,gsScene *)\n"
    "    getGroupNameAt(int)\n");
  lua_error(L);return 0;
}


static int _wrap_destroyResourceGroup(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("destroyResourceGroup",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("destroyResourceGroup",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  destroyResourceGroup((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsContactInfo__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *result = 0 ;
  
  SWIG_check_num_args("gsContactInfo::gsContactInfo",0,0)
  result = (gsContactInfo *)new gsContactInfo();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsContactInfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsContactInfo__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  btManifoldPoint *arg1 = 0 ;
  gsContactInfo *result = 0 ;
  
  SWIG_check_num_args("gsContactInfo::gsContactInfo",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsContactInfo::gsContactInfo",1,"btManifoldPoint const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_btManifoldPoint,0))){
    SWIG_fail_ptr("new_gsContactInfo",1,SWIGTYPE_p_btManifoldPoint);
  }
  
  result = (gsContactInfo *)new gsContactInfo((btManifoldPoint const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsContactInfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsContactInfo(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_gsContactInfo__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_btManifoldPoint, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsContactInfo__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsContactInfo'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsContactInfo::gsContactInfo()\n"
    "    gsContactInfo::gsContactInfo(btManifoldPoint const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsContactInfo_appliedImpulse_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulse",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::appliedImpulse",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulse_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->appliedImpulse = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_appliedImpulse_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulse",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulse_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->appliedImpulse);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_appliedImpulseLateral1_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulseLateral1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral1",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral1",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulseLateral1_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->appliedImpulseLateral1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_appliedImpulseLateral1_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulseLateral1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral1",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulseLateral1_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->appliedImpulseLateral1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_appliedImpulseLateral2_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulseLateral2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral2",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral2",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulseLateral2_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->appliedImpulseLateral2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_appliedImpulseLateral2_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::appliedImpulseLateral2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::appliedImpulseLateral2",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_appliedImpulseLateral2_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->appliedImpulseLateral2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactMotion1_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::contactMotion1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactMotion1",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::contactMotion1",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactMotion1_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->contactMotion1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactMotion1_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::contactMotion1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactMotion1",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactMotion1_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->contactMotion1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactMotion2_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::contactMotion2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactMotion2",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::contactMotion2",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactMotion2_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->contactMotion2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactMotion2_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::contactMotion2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactMotion2",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactMotion2_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->contactMotion2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactCFM1_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::contactCFM1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactCFM1",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::contactCFM1",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactCFM1_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->contactCFM1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactCFM1_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::contactCFM1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactCFM1",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactCFM1_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->contactCFM1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactCFM2_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::contactCFM2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactCFM2",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::contactCFM2",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactCFM2_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->contactCFM2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_contactCFM2_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::contactCFM2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::contactCFM2",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_contactCFM2_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->contactCFM2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_lifeTime_set(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsContactInfo::lifeTime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::lifeTime",1,"gsContactInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsContactInfo::lifeTime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_lifeTime_set",1,SWIGTYPE_p_gsContactInfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->lifeTime = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsContactInfo_lifeTime_get(lua_State* L) {
  int SWIG_arg = 0;
  gsContactInfo *arg1 = (gsContactInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("gsContactInfo::lifeTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsContactInfo::lifeTime",1,"gsContactInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsContactInfo,0))){
    SWIG_fail_ptr("gsContactInfo_lifeTime_get",1,SWIGTYPE_p_gsContactInfo);
  }
  
  result = (float) ((arg1)->lifeTime);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsContactInfo(void *obj) {
gsContactInfo *arg1 = (gsContactInfo *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsContactInfo(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsContactInfo);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsContactInfo_attributes[] = {
    { "appliedImpulse", _wrap_gsContactInfo_appliedImpulse_get, _wrap_gsContactInfo_appliedImpulse_set },
    { "appliedImpulseLateral1", _wrap_gsContactInfo_appliedImpulseLateral1_get, _wrap_gsContactInfo_appliedImpulseLateral1_set },
    { "appliedImpulseLateral2", _wrap_gsContactInfo_appliedImpulseLateral2_get, _wrap_gsContactInfo_appliedImpulseLateral2_set },
    { "contactMotion1", _wrap_gsContactInfo_contactMotion1_get, _wrap_gsContactInfo_contactMotion1_set },
    { "contactMotion2", _wrap_gsContactInfo_contactMotion2_get, _wrap_gsContactInfo_contactMotion2_set },
    { "contactCFM1", _wrap_gsContactInfo_contactCFM1_get, _wrap_gsContactInfo_contactCFM1_set },
    { "contactCFM2", _wrap_gsContactInfo_contactCFM2_get, _wrap_gsContactInfo_contactCFM2_set },
    { "lifeTime", _wrap_gsContactInfo_lifeTime_get, _wrap_gsContactInfo_lifeTime_set },
    {0,0,0}
};
static swig_lua_method swig_gsContactInfo_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsContactInfo_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsContactInfo_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsContactInfo_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsContactInfo_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsContactInfo_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsContactInfo_Sf_SwigStatic = {
    "gsContactInfo",
    swig_gsContactInfo_Sf_SwigStatic_methods,
    swig_gsContactInfo_Sf_SwigStatic_attributes,
    swig_gsContactInfo_Sf_SwigStatic_constants,
    swig_gsContactInfo_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsContactInfo_bases[] = {0};
static const char *swig_gsContactInfo_base_names[] = {0};
static swig_lua_class _wrap_class_gsContactInfo = { "gsContactInfo", "gsContactInfo", &SWIGTYPE_p_gsContactInfo,_proxy__wrap_new_gsContactInfo, swig_delete_gsContactInfo, swig_gsContactInfo_methods, swig_gsContactInfo_attributes, &swig_gsContactInfo_Sf_SwigStatic, swig_gsContactInfo_meta, swig_gsContactInfo_bases, swig_gsContactInfo_base_names };

static int _wrap_new_GameObject(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::gsGameObject",0,0)
  result = (gsGameObject *)new gsGameObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGameObject,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getOriginalName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGameObject::getOriginalName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getOriginalName",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getOriginalName",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getOriginalName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getPosition",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getPosition",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getPosition();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getRotation(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getRotation",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getRotation",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getRotation();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getOrientation(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsGameObject::getOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getOrientation",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getOrientation",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getOrientation();
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getScale(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getScale",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getScale",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getScale();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getWorldPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getWorldPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getWorldPosition",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getWorldPosition",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getWorldPosition();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getWorldRotation(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getWorldRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getWorldRotation",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getWorldRotation",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getWorldRotation();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getWorldScale(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getWorldScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getWorldScale",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getWorldScale",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getWorldScale();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setTransform(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsMatrix4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setTransform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setTransform",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setTransform",2,"gsMatrix4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setTransform",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsMatrix4,0))){
    SWIG_fail_ptr("GameObject_setTransform",2,SWIGTYPE_p_gsMatrix4);
  }
  
  (arg1)->setTransform((gsMatrix4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_bakeTransform(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::bakeTransform",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::bakeTransform",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_bakeTransform",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->bakeTransform();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getFilterMask(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getFilterMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getFilterMask",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getFilterMask",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getFilterMask();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getFilterGroup(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getFilterGroup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getFilterGroup",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getFilterGroup",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getFilterGroup();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getScreenPos__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool arg2 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsGameObject::getScreenPos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getScreenPos",1,"gsGameObject *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGameObject::getScreenPos",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getScreenPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (arg1)->getScreenPos(arg2);
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getScreenPos__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsGameObject::getScreenPos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getScreenPos",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getScreenPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getScreenPos();
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getScreenPos(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_GameObject_getScreenPos__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_GameObject_getScreenPos__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_getScreenPos'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::getScreenPos(bool)\n"
    "    gsGameObject::getScreenPos()\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_getWorldOrientation(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsGameObject::getWorldOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getWorldOrientation",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getWorldOrientation",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getWorldOrientation();
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getLinearVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getLinearVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getLinearVelocity",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getLinearVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getLinearVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAngularVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getAngularVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAngularVelocity",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAngularVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getAngularVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getLinearFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getLinearFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getLinearFactor",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getLinearFactor",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getLinearFactor();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setLinearFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setLinearFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setLinearFactor",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setLinearFactor",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setLinearFactor",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setLinearFactor",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setLinearFactor((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAngularFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getAngularFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAngularFactor",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAngularFactor",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getAngularFactor();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setAngularFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setAngularFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setAngularFactor",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setAngularFactor",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setAngularFactor",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setAngularFactor",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setAngularFactor((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setGravity(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setGravity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setGravity",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setGravity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setGravity",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setGravity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setGravity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getGravity(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getGravity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getGravity",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getGravity",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getGravity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_clearForces(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::clearForces",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::clearForces",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_clearForces",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->clearForces();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setMass(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGameObject::setMass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setMass",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setMass",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setMass",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMass(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_applyForce__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::applyForce",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::applyForce",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::applyForce",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::applyForce",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_applyForce",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_applyForce",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->applyForce((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_applyForce__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::applyForce",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::applyForce",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::applyForce",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_applyForce",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_applyForce",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->applyForce((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_applyForce__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsTransformSpace arg5 ;
  
  SWIG_check_num_args("gsGameObject::applyForce",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::applyForce",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::applyForce",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::applyForce",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::applyForce",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::applyForce",5,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_applyForce",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (gsTransformSpace)(int)lua_tonumber(L, 5);
  (arg1)->applyForce(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_applyForce__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::applyForce",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::applyForce",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::applyForce",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::applyForce",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::applyForce",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_applyForce",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->applyForce(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_applyForce(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_applyForce__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_applyForce__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_applyForce__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_applyForce__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_applyForce'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::applyForce(gsVector3 const &,gsTransformSpace)\n"
    "    gsGameObject::applyForce(gsVector3 const &)\n"
    "    gsGameObject::applyForce(float,float,float,gsTransformSpace)\n"
    "    gsGameObject::applyForce(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_setLinearVelocity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::setLinearVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setLinearVelocity",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setLinearVelocity",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setLinearVelocity",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->setLinearVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setLinearVelocity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setLinearVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setLinearVelocity",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setLinearVelocity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setLinearVelocity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setLinearVelocity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsTransformSpace arg5 ;
  
  SWIG_check_num_args("gsGameObject::setLinearVelocity",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setLinearVelocity",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setLinearVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setLinearVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setLinearVelocity",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::setLinearVelocity",5,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (gsTransformSpace)(int)lua_tonumber(L, 5);
  (arg1)->setLinearVelocity(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setLinearVelocity__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::setLinearVelocity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setLinearVelocity",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setLinearVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setLinearVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setLinearVelocity",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setLinearVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setLinearVelocity(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setLinearVelocity(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setLinearVelocity__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_setLinearVelocity__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_setLinearVelocity__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_setLinearVelocity__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setLinearVelocity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setLinearVelocity(gsVector3 const &,gsTransformSpace)\n"
    "    gsGameObject::setLinearVelocity(gsVector3 const &)\n"
    "    gsGameObject::setLinearVelocity(float,float,float,gsTransformSpace)\n"
    "    gsGameObject::setLinearVelocity(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_setAngularVelocity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::setAngularVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setAngularVelocity",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setAngularVelocity",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setAngularVelocity",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->setAngularVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setAngularVelocity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setAngularVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setAngularVelocity",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setAngularVelocity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setAngularVelocity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setAngularVelocity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsTransformSpace arg5 ;
  
  SWIG_check_num_args("gsGameObject::setAngularVelocity",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setAngularVelocity",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setAngularVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setAngularVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setAngularVelocity",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::setAngularVelocity",5,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (gsTransformSpace)(int)lua_tonumber(L, 5);
  (arg1)->setAngularVelocity(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setAngularVelocity__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::setAngularVelocity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setAngularVelocity",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setAngularVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setAngularVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setAngularVelocity",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setAngularVelocity",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setAngularVelocity(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setAngularVelocity(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setAngularVelocity__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_setAngularVelocity__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_setAngularVelocity__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_setAngularVelocity__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setAngularVelocity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setAngularVelocity(gsVector3 const &,gsTransformSpace)\n"
    "    gsGameObject::setAngularVelocity(gsVector3 const &)\n"
    "    gsGameObject::setAngularVelocity(float,float,float,gsTransformSpace)\n"
    "    gsGameObject::setAngularVelocity(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_suspendPhysics(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGameObject::suspendPhysics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::suspendPhysics",1,"gsGameObject *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGameObject::suspendPhysics",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_suspendPhysics",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->suspendPhysics(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setPosition",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setPosition",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setPosition",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setPosition",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setPosition((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setPosition",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setPosition",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setPosition",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setPosition(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setPosition(gsVector3 const &)\n"
    "    gsGameObject::setPosition(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_setRotation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setRotation",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setRotation",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setRotation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setRotation",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setRotation((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setRotation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::setRotation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setRotation",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setRotation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setRotation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setRotation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setRotation",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setRotation(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setRotation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setRotation__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_setRotation__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setRotation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setRotation(gsVector3 const &)\n"
    "    gsGameObject::setRotation(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_lookAt__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::lookAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::lookAt",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::lookAt",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_lookAt",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_lookAt",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->lookAt((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_lookAt__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::lookAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::lookAt",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::lookAt",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_lookAt",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_lookAt",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->lookAt(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_lookAt(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_lookAt__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_lookAt__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_lookAt'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::lookAt(gsVector3 const &)\n"
    "    gsGameObject::lookAt(gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_fakeLookAt(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsQuaternion result;
  
  SWIG_check_num_args("gsGameObject::fakeLookAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::fakeLookAt",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::fakeLookAt",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_fakeLookAt",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_fakeLookAt",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->fakeLookAt((gsVector3 const &)*arg2);
  {
    gsQuaternion * resultptr = new gsQuaternion((const gsQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsQuaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setOrientation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsQuaternion *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setOrientation",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setOrientation",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setOrientation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("GameObject_setOrientation",2,SWIGTYPE_p_gsQuaternion);
  }
  
  (arg1)->setOrientation((gsQuaternion const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setOrientation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGameObject::setOrientation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setOrientation",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setOrientation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setOrientation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setOrientation",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::setOrientation",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setOrientation",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setOrientation(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setOrientation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setOrientation__SWIG_0(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_setOrientation__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setOrientation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setOrientation(gsQuaternion const &)\n"
    "    gsGameObject::setOrientation(float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setScale",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::setScale",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setScale",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setScale",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setScale((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setScale",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::setScale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setScale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::setScale",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setScale",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setScale(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_setScale__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setScale(gsVector3 const &)\n"
    "    gsGameObject::setScale(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObjectTypes result;
  
  SWIG_check_num_args("gsGameObject::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getType",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getType",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gsGameObjectTypes)(arg1)->getType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::rotate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::rotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::rotate",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->rotate(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_rotate",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->rotate((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsQuaternion *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"gsQuaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("GameObject_rotate",2,SWIGTYPE_p_gsQuaternion);
  }
  
  (arg1)->rotate((gsQuaternion const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsTransformSpace arg5 ;
  
  SWIG_check_num_args("gsGameObject::rotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::rotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::rotate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::rotate",5,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (gsTransformSpace)(int)lua_tonumber(L, 5);
  (arg1)->rotate(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::rotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::rotate",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_rotate",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->rotate((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsQuaternion *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::rotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::rotate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::rotate",2,"gsQuaternion const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::rotate",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_rotate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsQuaternion,0))){
    SWIG_fail_ptr("GameObject_rotate",2,SWIGTYPE_p_gsQuaternion);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->rotate((gsQuaternion const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_rotate(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_rotate__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_rotate__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_rotate__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsQuaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_rotate__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_rotate__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_rotate__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_rotate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::rotate(float,float,float)\n"
    "    gsGameObject::rotate(gsVector3 const &)\n"
    "    gsGameObject::rotate(gsQuaternion const &)\n"
    "    gsGameObject::rotate(float,float,float,gsTransformSpace)\n"
    "    gsGameObject::rotate(gsVector3 const &,gsTransformSpace)\n"
    "    gsGameObject::rotate(gsQuaternion const &,gsTransformSpace)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_tweenToPos__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  TweenTransition arg4 ;
  TweenEq arg5 ;
  float arg6 ;
  
  SWIG_check_num_args("gsGameObject::tweenToPos",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::tweenToPos",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::tweenToPos",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::tweenToPos",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::tweenToPos",4,"TweenTransition");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::tweenToPos",5,"TweenEq");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsGameObject::tweenToPos",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (TweenTransition)(int)lua_tonumber(L, 4);
  arg5 = (TweenEq)(int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->tweenToPos((gsVector3 const &)*arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_tweenToPos__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  TweenTransition arg4 ;
  TweenEq arg5 ;
  
  SWIG_check_num_args("gsGameObject::tweenToPos",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::tweenToPos",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::tweenToPos",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::tweenToPos",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::tweenToPos",4,"TweenTransition");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::tweenToPos",5,"TweenEq");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (TweenTransition)(int)lua_tonumber(L, 4);
  arg5 = (TweenEq)(int)lua_tonumber(L, 5);
  (arg1)->tweenToPos((gsVector3 const &)*arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_tweenToPos__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  TweenTransition arg4 ;
  
  SWIG_check_num_args("gsGameObject::tweenToPos",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::tweenToPos",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::tweenToPos",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::tweenToPos",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::tweenToPos",4,"TweenTransition");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (TweenTransition)(int)lua_tonumber(L, 4);
  (arg1)->tweenToPos((gsVector3 const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_tweenToPos__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGameObject::tweenToPos",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::tweenToPos",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::tweenToPos",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::tweenToPos",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_tweenToPos",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->tweenToPos((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_tweenToPos(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_tweenToPos__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_tweenToPos__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_tweenToPos__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_GameObject_tweenToPos__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_tweenToPos'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::tweenToPos(gsVector3 const &,float,TweenTransition,TweenEq,float)\n"
    "    gsGameObject::tweenToPos(gsVector3 const &,float,TweenTransition,TweenEq)\n"
    "    gsGameObject::tweenToPos(gsVector3 const &,float,TweenTransition)\n"
    "    gsGameObject::tweenToPos(gsVector3 const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_translate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::translate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::translate",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::translate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::translate",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_translate",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->translate(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_translate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::translate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::translate",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_translate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_translate",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->translate((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_translate__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  gsTransformSpace arg5 ;
  
  SWIG_check_num_args("gsGameObject::translate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::translate",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::translate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::translate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGameObject::translate",5,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_translate",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (gsTransformSpace)(int)lua_tonumber(L, 5);
  (arg1)->translate(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_translate__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::translate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::translate",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::translate",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::translate",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_translate",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_translate",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->translate((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_translate(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_translate__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_translate__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_translate__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_translate__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_translate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::translate(float,float,float)\n"
    "    gsGameObject::translate(gsVector3 const &)\n"
    "    gsGameObject::translate(float,float,float,gsTransformSpace)\n"
    "    gsGameObject::translate(gsVector3 const &,gsTransformSpace)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_scale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGameObject::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::scale",1,"gsGameObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGameObject::scale",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_scale",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_scale",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->scale((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_scale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsGameObject::scale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::scale",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::scale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::scale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGameObject::scale",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_scale",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->scale(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_scale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_scale__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_scale__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_scale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::scale(gsVector3 const &)\n"
    "    gsGameObject::scale(float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_getDimension(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGameObject::getDimension",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getDimension",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getDimension",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (arg1)->getDimension();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_yaw__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGameObject::yaw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::yaw",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::yaw",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_yaw",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->yaw(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_yaw__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::yaw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::yaw",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::yaw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::yaw",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_yaw",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->yaw(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_yaw(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_GameObject_yaw__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_yaw__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_yaw'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::yaw(float)\n"
    "    gsGameObject::yaw(float,gsTransformSpace)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_pitch__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGameObject::pitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::pitch",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::pitch",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_pitch",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->pitch(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_pitch__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::pitch",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::pitch",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::pitch",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::pitch",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_pitch",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->pitch(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_pitch(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_GameObject_pitch__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_pitch__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_pitch'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::pitch(float)\n"
    "    gsGameObject::pitch(float,gsTransformSpace)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_roll__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGameObject::roll",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::roll",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::roll",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_roll",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->roll(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_roll__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  gsTransformSpace arg3 ;
  
  SWIG_check_num_args("gsGameObject::roll",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::roll",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::roll",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::roll",3,"gsTransformSpace");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_roll",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (gsTransformSpace)(int)lua_tonumber(L, 3);
  (arg1)->roll(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_roll(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_GameObject_roll__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_roll__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_roll'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::roll(float)\n"
    "    gsGameObject::roll(float,gsTransformSpace)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_getState(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getState",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getState",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getState();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_changeState(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGameObject::changeState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::changeState",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::changeState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_changeState",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->changeState(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_hasParent(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::hasParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::hasParent",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_hasParent",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->hasParent();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setParent(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::setParent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setParent",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::setParent",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setParent",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setParent",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->setParent(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setParentInPlace(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::setParentInPlace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setParentInPlace",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::setParentInPlace",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setParentInPlace",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setParentInPlace",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->setParentInPlace(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_clearParent(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::clearParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::clearParent",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_clearParent",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->clearParent();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_clearParentInPlace(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::clearParentInPlace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::clearParentInPlace",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_clearParentInPlace",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->clearParentInPlace();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_addChild(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::addChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::addChild",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::addChild",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_addChild",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_addChild",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->addChild(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_removeChild(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::removeChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::removeChild",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::removeChild",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_removeChild",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_removeChild",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->removeChild(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getChildAt(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getChildAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getChildAt",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::getChildAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getChildAt",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getChildAt(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getChildCount(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getChildCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getChildCount",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getChildCount",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getChildCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getChildByName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getChildByName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getChildByName",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::getChildByName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getChildByName",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->getChildByName((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getParent(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getParent",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getParent",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkGameObject *)(arg1)->getParent();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_enableContacts(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGameObject::enableContacts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::enableContacts",1,"gsGameObject *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGameObject::enableContacts",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_enableContacts",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->enableContacts(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_hasContacts(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::hasContacts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::hasContacts",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_hasContacts",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->hasContacts();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_hasContact(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::hasContact",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::hasContact",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::hasContact",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_hasContact",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->hasContact((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getContactCount(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getContactCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getContactCount",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getContactCount",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getContactCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getContact(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getContact",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getContact",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::getContact",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getContact",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getContact(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getContactInfo(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int arg2 ;
  gsContactInfo result;
  
  SWIG_check_num_args("gsGameObject::getContactInfo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getContactInfo",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::getContactInfo",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getContactInfo",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getContactInfo(arg2);
  {
    gsContactInfo * resultptr = new gsContactInfo((const gsContactInfo &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsContactInfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_isVehicle(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::isVehicle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::isVehicle",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_isVehicle",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->isVehicle();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getVehicle(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkVehicle *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getVehicle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getVehicle",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getVehicle",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkVehicle *)(arg1)->getVehicle();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Vehicle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getLogicTree(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkLogicTree *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getLogicTree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getLogicTree",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getLogicTree",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkLogicTree *)(arg1)->getLogicTree();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LogicTree); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getScene(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkScene *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getScene",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getScene",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getScene",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkScene *)(arg1)->getScene();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Scene); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAnimation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getAnimation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::getAnimation",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsGameObject::getAnimation",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (gkAnimationPlayer *)(arg1)->getAnimation((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAnimation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::getAnimation",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkAnimationPlayer *)(arg1)->getAnimation((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAnimation(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_GameObject_getAnimation__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_getAnimation__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_getAnimation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::getAnimation(gkString const &,bool)\n"
    "    gsGameObject::getAnimation(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_playAnimation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsAnimationPlayer *arg2 = (gsAnimationPlayer *) 0 ;
  float arg3 ;
  bool arg4 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gsAnimationPlayer *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::playAnimation",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsGameObject::playAnimation",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("GameObject_playAnimation",2,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  (arg1)->playAnimation(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsAnimationPlayer *arg2 = (gsAnimationPlayer *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gsAnimationPlayer *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::playAnimation",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("GameObject_playAnimation",2,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->playAnimation(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsAnimationPlayer *arg2 = (gsAnimationPlayer *) 0 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("GameObject_playAnimation",2,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  (arg1)->playAnimation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  bool arg4 ;
  bool arg5 ;
  gkString temp2 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::playAnimation",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsGameObject::playAnimation",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsGameObject::playAnimation",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (gkAnimationPlayer *)(arg1)->playAnimation((gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  bool arg4 ;
  gkString temp2 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::playAnimation",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsGameObject::playAnimation",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (gkAnimationPlayer *)(arg1)->playAnimation((gkString const &)*arg2,arg3,arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  gkString temp2 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::playAnimation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::playAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::playAnimation",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::playAnimation",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_playAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (gkAnimationPlayer *)(arg1)->playAnimation((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_playAnimation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsAnimationPlayer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_GameObject_playAnimation__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsAnimationPlayer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_playAnimation__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_playAnimation__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsAnimationPlayer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_playAnimation__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_GameObject_playAnimation__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_GameObject_playAnimation__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_playAnimation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::playAnimation(gsAnimationPlayer *,float,bool)\n"
    "    gsGameObject::playAnimation(gsAnimationPlayer *,float)\n"
    "    gsGameObject::playAnimation(gsAnimationPlayer *)\n"
    "    gsGameObject::playAnimation(gkString const &,float,bool,bool)\n"
    "    gsGameObject::playAnimation(gkString const &,float,bool)\n"
    "    gsGameObject::playAnimation(gkString const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_stopAnimation(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::stopAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::stopAnimation",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::stopAnimation",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_stopAnimation",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->stopAnimation((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_pauseAnimations(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::pauseAnimations",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::pauseAnimations",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_pauseAnimations",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->pauseAnimations();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_resumeAnimations(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::resumeAnimations",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::resumeAnimations",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_resumeAnimations",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->resumeAnimations();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAnimationCount(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameObject::getAnimationCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAnimationCount",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAnimationCount",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (int)(arg1)->getAnimationCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getAnimationName(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsGameObject::getAnimationName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getAnimationName",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameObject::getAnimationName",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getAnimationName",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getAnimationName(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setVisible(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGameObject::setVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setVisible",1,"gsGameObject *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGameObject::setVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setVisible",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setVisible(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_isVisible(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::isVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::isVisible",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_isVisible",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->isVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsProperty result;
  
  SWIG_check_num_args("gsGameObject::getProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::getProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->getProperty((gkString const &)*arg2);
  SWIG_arg += gsGetProperty(L, result); 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_hasProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::hasProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::hasProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::hasProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_hasProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->hasProperty((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getPropertyRaw(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkVariable *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getPropertyRaw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getPropertyRaw",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::getPropertyRaw",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getPropertyRaw",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkVariable *)(arg1)->getPropertyRaw((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Variable); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setProperty__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  
  SWIG_check_num_args("gsGameObject::setProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::setProperty",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGameObject::setProperty",3,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject_setProperty",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  (arg1)->setProperty((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setProperty__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::setProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::setProperty",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsGameObject::setProperty",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setProperty((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setProperty__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::setProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::setProperty",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::setProperty",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setProperty((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setProperty__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::setProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::setProperty",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::setProperty",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGameObject::setProperty",3,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_setProperty",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  arg3 = gkString((const char*)lua_tostring(L, 3));
  
  (arg1)->setProperty((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_setProperty(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_GameObject_setProperty__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_setProperty__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_setProperty__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject_setProperty__SWIG_3(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_setProperty'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::setProperty(gkString const &,gsVector3)\n"
    "    gsGameObject::setProperty(gkString const &,bool)\n"
    "    gsGameObject::setProperty(gkString const &,float)\n"
    "    gsGameObject::setProperty(gkString const &,gkString)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsProperty result;
  
  SWIG_check_num_args("gsGameObject::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::__getitem__",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::__getitem__",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject___getitem",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->__getitem__((gkString const &)*arg2);
  SWIG_arg += gsGetProperty(L, result); 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject___setitem__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::__setitem__",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::__setitem__",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsGameObject::__setitem__",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject___setitem",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->__setitem__((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject___setitem__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::__setitem__",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::__setitem__",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGameObject::__setitem__",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject___setitem",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->__setitem__((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject___setitem__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGameObject::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::__setitem__",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::__setitem__",2,"gkString const &");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("gsGameObject::__setitem__",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject___setitem",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (char *)lua_tostring(L, 3);
  (arg1)->__setitem__((gkString const &)*arg2,(char const *)arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject___setitem__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  
  SWIG_check_num_args("gsGameObject::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::__setitem__",1,"gsGameObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameObject::__setitem__",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGameObject::__setitem__",3,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject___setitem",1,SWIGTYPE_p_gsGameObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("GameObject___setitem",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  (arg1)->__setitem__((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject___setitem(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_GameObject___setitem__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject___setitem__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject___setitem__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_GameObject___setitem__SWIG_2(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject___setitem'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::__setitem__(gkString const &,bool)\n"
    "    gsGameObject::__setitem__(gkString const &,float)\n"
    "    gsGameObject::__setitem__(gkString const &,char const *)\n"
    "    gsGameObject::__setitem__(gkString const &,gsVector3)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_addCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGameObject::addCallback",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::addCallback",1,"gsGameObject *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGameObject::addCallback",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGameObject::addCallback",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_addCallback",1,SWIGTYPE_p_gsGameObject);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->addCallback(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_addCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGameObject::addCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::addCallback",1,"gsGameObject *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGameObject::addCallback",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_addCallback",1,SWIGTYPE_p_gsGameObject);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->addCallback(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_addCallback(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_GameObject_addCallback__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_GameObject_addCallback__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'GameObject_addCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameObject::addCallback(gsSelf,gsFunction)\n"
    "    gsGameObject::addCallback(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_GameObject_removeCallback(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsGameObject::removeCallback",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::removeCallback",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_removeCallback",1,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->removeCallback();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_getGroupInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gkGameObjectInstance *result = 0 ;
  
  SWIG_check_num_args("gsGameObject::getGroupInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::getGroupInstance",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_getGroupInstance",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkGameObjectInstance *)(arg1)->getGroupInstance();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GameObjectInstance); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameObject_isGroupInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGameObject::isGroupInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameObject::isGroupInstance",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("GameObject_isGroupInstance",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->isGroupInstance();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_GameObject(void *obj) {
gsGameObject *arg1 = (gsGameObject *) obj;
delete arg1;
}
static int _proxy__wrap_new_GameObject(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_GameObject);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_GameObject_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_GameObject_methods[]= {
    { "getOriginalName", _wrap_GameObject_getOriginalName},
    { "getPosition", _wrap_GameObject_getPosition},
    { "getRotation", _wrap_GameObject_getRotation},
    { "getOrientation", _wrap_GameObject_getOrientation},
    { "getScale", _wrap_GameObject_getScale},
    { "getWorldPosition", _wrap_GameObject_getWorldPosition},
    { "getWorldRotation", _wrap_GameObject_getWorldRotation},
    { "getWorldScale", _wrap_GameObject_getWorldScale},
    { "setTransform", _wrap_GameObject_setTransform},
    { "bakeTransform", _wrap_GameObject_bakeTransform},
    { "getFilterMask", _wrap_GameObject_getFilterMask},
    { "getFilterGroup", _wrap_GameObject_getFilterGroup},
    { "getScreenPos", _wrap_GameObject_getScreenPos},
    { "getWorldOrientation", _wrap_GameObject_getWorldOrientation},
    { "getLinearVelocity", _wrap_GameObject_getLinearVelocity},
    { "getAngularVelocity", _wrap_GameObject_getAngularVelocity},
    { "getLinearFactor", _wrap_GameObject_getLinearFactor},
    { "setLinearFactor", _wrap_GameObject_setLinearFactor},
    { "getAngularFactor", _wrap_GameObject_getAngularFactor},
    { "setAngularFactor", _wrap_GameObject_setAngularFactor},
    { "setGravity", _wrap_GameObject_setGravity},
    { "getGravity", _wrap_GameObject_getGravity},
    { "clearForces", _wrap_GameObject_clearForces},
    { "setMass", _wrap_GameObject_setMass},
    { "applyForce", _wrap_GameObject_applyForce},
    { "setLinearVelocity", _wrap_GameObject_setLinearVelocity},
    { "setAngularVelocity", _wrap_GameObject_setAngularVelocity},
    { "suspendPhysics", _wrap_GameObject_suspendPhysics},
    { "setPosition", _wrap_GameObject_setPosition},
    { "setRotation", _wrap_GameObject_setRotation},
    { "lookAt", _wrap_GameObject_lookAt},
    { "fakeLookAt", _wrap_GameObject_fakeLookAt},
    { "setOrientation", _wrap_GameObject_setOrientation},
    { "setScale", _wrap_GameObject_setScale},
    { "getType", _wrap_GameObject_getType},
    { "rotate", _wrap_GameObject_rotate},
    { "tweenToPos", _wrap_GameObject_tweenToPos},
    { "translate", _wrap_GameObject_translate},
    { "scale", _wrap_GameObject_scale},
    { "getDimension", _wrap_GameObject_getDimension},
    { "yaw", _wrap_GameObject_yaw},
    { "pitch", _wrap_GameObject_pitch},
    { "roll", _wrap_GameObject_roll},
    { "getState", _wrap_GameObject_getState},
    { "changeState", _wrap_GameObject_changeState},
    { "hasParent", _wrap_GameObject_hasParent},
    { "setParent", _wrap_GameObject_setParent},
    { "setParentInPlace", _wrap_GameObject_setParentInPlace},
    { "clearParent", _wrap_GameObject_clearParent},
    { "clearParentInPlace", _wrap_GameObject_clearParentInPlace},
    { "addChild", _wrap_GameObject_addChild},
    { "removeChild", _wrap_GameObject_removeChild},
    { "getChildAt", _wrap_GameObject_getChildAt},
    { "getChildCount", _wrap_GameObject_getChildCount},
    { "getChildByName", _wrap_GameObject_getChildByName},
    { "getParent", _wrap_GameObject_getParent},
    { "enableContacts", _wrap_GameObject_enableContacts},
    { "hasContacts", _wrap_GameObject_hasContacts},
    { "hasContact", _wrap_GameObject_hasContact},
    { "getContactCount", _wrap_GameObject_getContactCount},
    { "getContact", _wrap_GameObject_getContact},
    { "getContactInfo", _wrap_GameObject_getContactInfo},
    { "isVehicle", _wrap_GameObject_isVehicle},
    { "getVehicle", _wrap_GameObject_getVehicle},
    { "getLogicTree", _wrap_GameObject_getLogicTree},
    { "getScene", _wrap_GameObject_getScene},
    { "getAnimation", _wrap_GameObject_getAnimation},
    { "playAnimation", _wrap_GameObject_playAnimation},
    { "stopAnimation", _wrap_GameObject_stopAnimation},
    { "pauseAnimations", _wrap_GameObject_pauseAnimations},
    { "resumeAnimations", _wrap_GameObject_resumeAnimations},
    { "getAnimationCount", _wrap_GameObject_getAnimationCount},
    { "getAnimationName", _wrap_GameObject_getAnimationName},
    { "setVisible", _wrap_GameObject_setVisible},
    { "isVisible", _wrap_GameObject_isVisible},
    { "getProperty", _wrap_GameObject_getProperty},
    { "hasProperty", _wrap_GameObject_hasProperty},
    { "getPropertyRaw", _wrap_GameObject_getPropertyRaw},
    { "setProperty", _wrap_GameObject_setProperty},
    { "__getitem", _wrap_GameObject___getitem},
    { "__setitem", _wrap_GameObject___setitem},
    { "addCallback", _wrap_GameObject_addCallback},
    { "removeCallback", _wrap_GameObject_removeCallback},
    { "getGroupInstance", _wrap_GameObject_getGroupInstance},
    { "isGroupInstance", _wrap_GameObject_isGroupInstance},
    {0,0}
};
static swig_lua_method swig_GameObject_meta[] = {
    { "__getitem", _wrap_GameObject___getitem},
    { "__setitem", _wrap_GameObject___setitem},
    {0,0}
};

static swig_lua_attribute swig_GameObject_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_GameObject_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_GameObject_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_GameObject_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_GameObject_Sf_SwigStatic = {
    "GameObject",
    swig_GameObject_Sf_SwigStatic_methods,
    swig_GameObject_Sf_SwigStatic_attributes,
    swig_GameObject_Sf_SwigStatic_constants,
    swig_GameObject_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_GameObject_bases[] = {0,0};
static const char *swig_GameObject_base_names[] = {"gsObject *",0};
static swig_lua_class _wrap_class_GameObject = { "GameObject", "GameObject", &SWIGTYPE_p_gsGameObject,_proxy__wrap_new_GameObject, swig_delete_GameObject, swig_GameObject_methods, swig_GameObject_attributes, &swig_GameObject_Sf_SwigStatic, swig_GameObject_meta, swig_GameObject_bases, swig_GameObject_base_names };

static int _wrap_new_gsMessageListenerCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gsSelf arg4 ;
  gsFunction arg5 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  gsMessageListenerCallback *result = 0 ;
  
  SWIG_check_num_args("gsMessageListenerCallback::gsMessageListenerCallback",5,5)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",3,"gkString const &");
  if(!lua_istable(L,4)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",4,"gsSelf");
  if(!lua_isfunction(L,5)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",5,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  result = (gsMessageListenerCallback *)new gsMessageListenerCallback((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageListenerCallback,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsMessageListenerCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gsFunction arg4 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  gsMessageListenerCallback *result = 0 ;
  
  SWIG_check_num_args("gsMessageListenerCallback::gsMessageListenerCallback",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",3,"gkString const &");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsMessageListenerCallback::gsMessageListenerCallback",4,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  result = (gsMessageListenerCallback *)new gsMessageListenerCallback((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageListenerCallback,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsMessageListenerCallback(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_new_gsMessageListenerCallback__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          _v = lua_istable(L, argv[3]); 
          if (_v) {
            _v = lua_isfunction(L, argv[4]); 
            if (_v) {
              return _wrap_new_gsMessageListenerCallback__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsMessageListenerCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMessageListenerCallback::gsMessageListenerCallback(gkString const &,gkString const &,gkString const &,gsSelf,gsFunction)\n"
    "    gsMessageListenerCallback::gsMessageListenerCallback(gkString const &,gkString const &,gkString const &,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsMessageListenerCallback_handleMessage(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageListenerCallback *arg1 = (gsMessageListenerCallback *) 0 ;
  gkMessageManager::Message *arg2 = (gkMessageManager::Message *) 0 ;
  
  SWIG_check_num_args("gsMessageListenerCallback::handleMessage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageListenerCallback::handleMessage",1,"gsMessageListenerCallback *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsMessageListenerCallback::handleMessage",2,"gkMessageManager::Message *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageListenerCallback,0))){
    SWIG_fail_ptr("gsMessageListenerCallback_handleMessage",1,SWIGTYPE_p_gsMessageListenerCallback);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkMessageManager__Message,0))){
    SWIG_fail_ptr("gsMessageListenerCallback_handleMessage",2,SWIGTYPE_p_gkMessageManager__Message);
  }
  
  (arg1)->handleMessage(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMessageListenerCallback(void *obj) {
gsMessageListenerCallback *arg1 = (gsMessageListenerCallback *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMessageListenerCallback(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMessageListenerCallback);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMessageListenerCallback_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMessageListenerCallback_methods[]= {
    { "handleMessage", _wrap_gsMessageListenerCallback_handleMessage},
    {0,0}
};
static swig_lua_method swig_gsMessageListenerCallback_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMessageListenerCallback_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMessageListenerCallback_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMessageListenerCallback_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMessageListenerCallback_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMessageListenerCallback_Sf_SwigStatic = {
    "gsMessageListenerCallback",
    swig_gsMessageListenerCallback_Sf_SwigStatic_methods,
    swig_gsMessageListenerCallback_Sf_SwigStatic_attributes,
    swig_gsMessageListenerCallback_Sf_SwigStatic_constants,
    swig_gsMessageListenerCallback_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMessageListenerCallback_bases[] = {0};
static const char *swig_gsMessageListenerCallback_base_names[] = {0};
static swig_lua_class _wrap_class_gsMessageListenerCallback = { "gsMessageListenerCallback", "gsMessageListenerCallback", &SWIGTYPE_p_gsMessageListenerCallback,_proxy__wrap_new_gsMessageListenerCallback, swig_delete_gsMessageListenerCallback, swig_gsMessageListenerCallback_methods, swig_gsMessageListenerCallback_attributes, &swig_gsMessageListenerCallback_Sf_SwigStatic, swig_gsMessageListenerCallback_meta, swig_gsMessageListenerCallback_bases, swig_gsMessageListenerCallback_base_names };

static int _wrap_new_MessageManager(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageManager *result = 0 ;
  
  SWIG_check_num_args("gsMessageManager::gsMessageManager",0,0)
  result = (gsMessageManager *)new gsMessageManager();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageManager_addListener__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageManager *arg1 = (gsMessageManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gsSelf arg5 ;
  gsFunction arg6 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  gsMessageListenerCallback *result = 0 ;
  
  SWIG_check_num_args("gsMessageManager::addListener",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageManager::addListener",1,"gsMessageManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageManager::addListener",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsMessageManager::addListener",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsMessageManager::addListener",4,"gkString const &");
  if(!lua_istable(L,5)) SWIG_fail_arg("gsMessageManager::addListener",5,"gsSelf");
  if(!lua_isfunction(L,6)) SWIG_fail_arg("gsMessageManager::addListener",6,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageManager,0))){
    SWIG_fail_ptr("MessageManager_addListener",1,SWIGTYPE_p_gsMessageManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  (&arg6)->m_id = 6; (&arg6)->L = L; 
  result = (gsMessageListenerCallback *)(arg1)->addListener((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageListenerCallback,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageManager_addListener__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageManager *arg1 = (gsMessageManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gsFunction arg5 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  gsMessageListenerCallback *result = 0 ;
  
  SWIG_check_num_args("gsMessageManager::addListener",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageManager::addListener",1,"gsMessageManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageManager::addListener",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsMessageManager::addListener",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsMessageManager::addListener",4,"gkString const &");
  if(!lua_isfunction(L,5)) SWIG_fail_arg("gsMessageManager::addListener",5,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageManager,0))){
    SWIG_fail_ptr("MessageManager_addListener",1,SWIGTYPE_p_gsMessageManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  result = (gsMessageListenerCallback *)(arg1)->addListener((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageListenerCallback,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageManager_addListener(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMessageManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            _v = lua_isfunction(L, argv[4]); 
            if (_v) {
              return _wrap_MessageManager_addListener__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMessageManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            _v = lua_istable(L, argv[4]); 
            if (_v) {
              _v = lua_isfunction(L, argv[5]); 
              if (_v) {
                return _wrap_MessageManager_addListener__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MessageManager_addListener'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMessageManager::addListener(gkString const &,gkString const &,gkString const &,gsSelf,gsFunction)\n"
    "    gsMessageManager::addListener(gkString const &,gkString const &,gkString const &,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_MessageManager_removeListener(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageManager *arg1 = (gsMessageManager *) 0 ;
  gsMessageListenerCallback *arg2 = (gsMessageListenerCallback *) 0 ;
  
  SWIG_check_num_args("gsMessageManager::removeListener",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageManager::removeListener",1,"gsMessageManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsMessageManager::removeListener",2,"gsMessageListenerCallback *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageManager,0))){
    SWIG_fail_ptr("MessageManager_removeListener",1,SWIGTYPE_p_gsMessageManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsMessageListenerCallback,0))){
    SWIG_fail_ptr("MessageManager_removeListener",2,SWIGTYPE_p_gsMessageListenerCallback);
  }
  
  (arg1)->removeListener(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MessageManager(void *obj) {
gsMessageManager *arg1 = (gsMessageManager *) obj;
delete arg1;
}
static int _proxy__wrap_new_MessageManager(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MessageManager);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MessageManager_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MessageManager_methods[]= {
    { "addListener", _wrap_MessageManager_addListener},
    { "removeListener", _wrap_MessageManager_removeListener},
    {0,0}
};
static swig_lua_method swig_MessageManager_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MessageManager_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MessageManager_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MessageManager_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MessageManager_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MessageManager_Sf_SwigStatic = {
    "MessageManager",
    swig_MessageManager_Sf_SwigStatic_methods,
    swig_MessageManager_Sf_SwigStatic_attributes,
    swig_MessageManager_Sf_SwigStatic_constants,
    swig_MessageManager_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MessageManager_bases[] = {0};
static const char *swig_MessageManager_base_names[] = {0};
static swig_lua_class _wrap_class_MessageManager = { "MessageManager", "MessageManager", &SWIGTYPE_p_gsMessageManager,_proxy__wrap_new_MessageManager, swig_delete_MessageManager, swig_MessageManager_methods, swig_MessageManager_attributes, &swig_MessageManager_Sf_SwigStatic, swig_MessageManager_meta, swig_MessageManager_bases, swig_MessageManager_base_names };

static int _wrap_new_Curve(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *result = 0 ;
  
  SWIG_check_num_args("gsCurve::gsCurve",0,0)
  result = (gsCurve *)new gsCurve();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCurve,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_generateBezierPoints(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsCurve::generateBezierPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::generateBezierPoints",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::generateBezierPoints",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_generateBezierPoints",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->generateBezierPoints(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int arg2 ;
  int arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsCurve::getPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getPoint",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::getPoint",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsCurve::getPoint",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getPoint",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (arg1)->getPoint(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsCurve::getPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getPoint",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::getPoint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getPoint",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getPoint(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Curve_getPoint__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Curve_getPoint__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Curve_getPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCurve::getPoint(int,int)\n"
    "    gsCurve::getPoint(int)\n");
  lua_error(L);return 0;
}


static int _wrap_Curve_getPointCount__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("gsCurve::getPointCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getPointCount",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::getPointCount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getPointCount",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->getPointCount(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getPointCount__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int result;
  
  SWIG_check_num_args("gsCurve::getPointCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getPointCount",1,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getPointCount",1,SWIGTYPE_p_gsCurve);
  }
  
  result = (int)(arg1)->getPointCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getPointCount(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Curve_getPointCount__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Curve_getPointCount__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Curve_getPointCount'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCurve::getPointCount(int)\n"
    "    gsCurve::getPointCount()\n");
  lua_error(L);return 0;
}


static int _wrap_Curve_isCyclic__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsCurve::isCyclic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::isCyclic",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::isCyclic",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_isCyclic",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isCyclic(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_isCyclic__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsCurve::isCyclic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::isCyclic",1,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_isCyclic",1,SWIGTYPE_p_gsCurve);
  }
  
  result = (bool)(arg1)->isCyclic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_isCyclic(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Curve_isCyclic__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Curve_isCyclic__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Curve_isCyclic'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCurve::isCyclic(int)\n"
    "    gsCurve::isCyclic()\n");
  lua_error(L);return 0;
}


static int _wrap_Curve_isBezier__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("gsCurve::isBezier",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::isBezier",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::isBezier",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_isBezier",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->isBezier(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_isBezier__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsCurve::isBezier",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::isBezier",1,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_isBezier",1,SWIGTYPE_p_gsCurve);
  }
  
  result = (bool)(arg1)->isBezier();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_isBezier(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Curve_isBezier__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Curve_isBezier__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Curve_isBezier'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCurve::isBezier(int)\n"
    "    gsCurve::isBezier()\n");
  lua_error(L);return 0;
}


static int _wrap_Curve_getDeltaPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  float arg2 ;
  int arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsCurve::getDeltaPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getDeltaPoint",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::getDeltaPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsCurve::getDeltaPoint",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getDeltaPoint",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (arg1)->getDeltaPoint(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getDeltaPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsCurve::getDeltaPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getDeltaPoint",1,"gsCurve *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCurve::getDeltaPoint",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getDeltaPoint",1,SWIGTYPE_p_gsCurve);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->getDeltaPoint(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Curve_getDeltaPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Curve_getDeltaPoint__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Curve_getDeltaPoint__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Curve_getDeltaPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCurve::getDeltaPoint(float,int)\n"
    "    gsCurve::getDeltaPoint(float)\n");
  lua_error(L);return 0;
}


static int _wrap_Curve_getSubCurveAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsCurve *arg1 = (gsCurve *) 0 ;
  int result;
  
  SWIG_check_num_args("gsCurve::getSubCurveAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCurve::getSubCurveAmount",1,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Curve_getSubCurveAmount",1,SWIGTYPE_p_gsCurve);
  }
  
  result = (int)(arg1)->getSubCurveAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Curve(void *obj) {
gsCurve *arg1 = (gsCurve *) obj;
delete arg1;
}
static int _proxy__wrap_new_Curve(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Curve);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Curve_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Curve_methods[]= {
    { "generateBezierPoints", _wrap_Curve_generateBezierPoints},
    { "getPoint", _wrap_Curve_getPoint},
    { "getPointCount", _wrap_Curve_getPointCount},
    { "isCyclic", _wrap_Curve_isCyclic},
    { "isBezier", _wrap_Curve_isBezier},
    { "getDeltaPoint", _wrap_Curve_getDeltaPoint},
    { "getSubCurveAmount", _wrap_Curve_getSubCurveAmount},
    {0,0}
};
static swig_lua_method swig_Curve_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Curve_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Curve_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Curve_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Curve_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Curve_Sf_SwigStatic = {
    "Curve",
    swig_Curve_Sf_SwigStatic_methods,
    swig_Curve_Sf_SwigStatic_attributes,
    swig_Curve_Sf_SwigStatic_constants,
    swig_Curve_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Curve_bases[] = {0,0};
static const char *swig_Curve_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Curve = { "Curve", "Curve", &SWIGTYPE_p_gsCurve,_proxy__wrap_new_Curve, swig_delete_Curve, swig_Curve_methods, swig_Curve_attributes, &swig_Curve_Sf_SwigStatic, swig_Curve_meta, swig_Curve_bases, swig_Curve_base_names };

static int _wrap_new_Light(lua_State* L) {
  int SWIG_arg = 0;
  gsLight *result = 0 ;
  
  SWIG_check_num_args("gsLight::gsLight",0,0)
  result = (gsLight *)new gsLight();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLight,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_getPowerScale(lua_State* L) {
  int SWIG_arg = 0;
  gsLight *arg1 = (gsLight *) 0 ;
  float result;
  
  SWIG_check_num_args("gsLight::getPowerScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLight::getPowerScale",1,"gsLight *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLight,0))){
    SWIG_fail_ptr("Light_getPowerScale",1,SWIGTYPE_p_gsLight);
  }
  
  result = (float)(arg1)->getPowerScale();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setPowerScale(lua_State* L) {
  int SWIG_arg = 0;
  gsLight *arg1 = (gsLight *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsLight::setPowerScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLight::setPowerScale",1,"gsLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLight::setPowerScale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLight,0))){
    SWIG_fail_ptr("Light_setPowerScale",1,SWIGTYPE_p_gsLight);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPowerScale(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Light(void *obj) {
gsLight *arg1 = (gsLight *) obj;
delete arg1;
}
static int _proxy__wrap_new_Light(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Light);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Light_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Light_methods[]= {
    { "getPowerScale", _wrap_Light_getPowerScale},
    { "setPowerScale", _wrap_Light_setPowerScale},
    {0,0}
};
static swig_lua_method swig_Light_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Light_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Light_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Light_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Light_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Light_Sf_SwigStatic = {
    "Light",
    swig_Light_Sf_SwigStatic_methods,
    swig_Light_Sf_SwigStatic_attributes,
    swig_Light_Sf_SwigStatic_constants,
    swig_Light_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Light_bases[] = {0,0};
static const char *swig_Light_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Light = { "Light", "Light", &SWIGTYPE_p_gsLight,_proxy__wrap_new_Light, swig_delete_Light, swig_Light_methods, swig_Light_attributes, &swig_Light_Sf_SwigStatic, swig_Light_meta, swig_Light_bases, swig_Light_base_names };

static int _wrap_new_Camera(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *result = 0 ;
  
  SWIG_check_num_args("gsCamera::gsCamera",0,0)
  result = (gsCamera *)new gsCamera();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCamera,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_setClipping(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsCamera::setClipping",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::setClipping",1,"gsCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCamera::setClipping",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsCamera::setClipping",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_setClipping",1,SWIGTYPE_p_gsCamera);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setClipping(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_getClipStart(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float result;
  
  SWIG_check_num_args("gsCamera::getClipStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::getClipStart",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_getClipStart",1,SWIGTYPE_p_gsCamera);
  }
  
  result = (float)(arg1)->getClipStart();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_getClipEnd(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float result;
  
  SWIG_check_num_args("gsCamera::getClipEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::getClipEnd",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_getClipEnd",1,SWIGTYPE_p_gsCamera);
  }
  
  result = (float)(arg1)->getClipEnd();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_setProjection(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  gsMatrix4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsCamera::setProjection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::setProjection",1,"gsCamera *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsCamera::setProjection",2,"gsMatrix4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_setProjection",1,SWIGTYPE_p_gsCamera);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsMatrix4,0))){
    SWIG_fail_ptr("Camera_setProjection",2,SWIGTYPE_p_gsMatrix4);
  }
  
  (arg1)->setProjection((gsMatrix4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_setFov(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsCamera::setFov",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::setFov",1,"gsCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCamera::setFov",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_setFov",1,SWIGTYPE_p_gsCamera);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setFov(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_getFov(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float result;
  
  SWIG_check_num_args("gsCamera::getFov",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::getFov",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_getFov",1,SWIGTYPE_p_gsCamera);
  }
  
  result = (float)(arg1)->getFov();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_makeCurrent(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  
  SWIG_check_num_args("gsCamera::makeCurrent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::makeCurrent",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_makeCurrent",1,SWIGTYPE_p_gsCamera);
  }
  
  (arg1)->makeCurrent();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_isOrtho(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsCamera::isOrtho",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::isOrtho",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_isOrtho",1,SWIGTYPE_p_gsCamera);
  }
  
  result = (bool)(arg1)->isOrtho();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_setOrthoScale(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsCamera::setOrthoScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::setOrthoScale",1,"gsCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCamera::setOrthoScale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_setOrthoScale",1,SWIGTYPE_p_gsCamera);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setOrthoScale(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Camera_getOrthoScale(lua_State* L) {
  int SWIG_arg = 0;
  gsCamera *arg1 = (gsCamera *) 0 ;
  float result;
  
  SWIG_check_num_args("gsCamera::getOrthoScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCamera::getOrthoScale",1,"gsCamera *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCamera,0))){
    SWIG_fail_ptr("Camera_getOrthoScale",1,SWIGTYPE_p_gsCamera);
  }
  
  result = (float)(arg1)->getOrthoScale();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Camera(void *obj) {
gsCamera *arg1 = (gsCamera *) obj;
delete arg1;
}
static int _proxy__wrap_new_Camera(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Camera);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Camera_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Camera_methods[]= {
    { "setClipping", _wrap_Camera_setClipping},
    { "getClipStart", _wrap_Camera_getClipStart},
    { "getClipEnd", _wrap_Camera_getClipEnd},
    { "setProjection", _wrap_Camera_setProjection},
    { "setFov", _wrap_Camera_setFov},
    { "getFov", _wrap_Camera_getFov},
    { "makeCurrent", _wrap_Camera_makeCurrent},
    { "isOrtho", _wrap_Camera_isOrtho},
    { "setOrthoScale", _wrap_Camera_setOrthoScale},
    { "getOrthoScale", _wrap_Camera_getOrthoScale},
    {0,0}
};
static swig_lua_method swig_Camera_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Camera_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Camera_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Camera_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Camera_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Camera_Sf_SwigStatic = {
    "Camera",
    swig_Camera_Sf_SwigStatic_methods,
    swig_Camera_Sf_SwigStatic_attributes,
    swig_Camera_Sf_SwigStatic_constants,
    swig_Camera_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Camera_bases[] = {0,0};
static const char *swig_Camera_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Camera = { "Camera", "Camera", &SWIGTYPE_p_gsCamera,_proxy__wrap_new_Camera, swig_delete_Camera, swig_Camera_methods, swig_Camera_attributes, &swig_Camera_Sf_SwigStatic, swig_Camera_meta, swig_Camera_bases, swig_Camera_base_names };

static int _wrap_new_Entity(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *result = 0 ;
  
  SWIG_check_num_args("gsEntity::gsEntity",0,0)
  result = (gsEntity *)new gsEntity();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEntity,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_hasCharacter(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsEntity::hasCharacter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::hasCharacter",1,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_hasCharacter",1,SWIGTYPE_p_gsEntity);
  }
  
  result = (bool)(arg1)->hasCharacter();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_getCharacter(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkCharacter *result = 0 ;
  
  SWIG_check_num_args("gsEntity::getCharacter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::getCharacter",1,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_getCharacter",1,SWIGTYPE_p_gsEntity);
  }
  
  result = (gkCharacter *)(arg1)->getCharacter();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Character); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_setMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEntity::setMaterialName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::setMaterialName",1,"gsEntity *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEntity::setMaterialName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_setMaterialName",1,SWIGTYPE_p_gsEntity);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterialName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_setOgreMeshName(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEntity::setOgreMeshName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::setOgreMeshName",1,"gsEntity *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEntity::setOgreMeshName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_setOgreMeshName",1,SWIGTYPE_p_gsEntity);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setOgreMeshName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_playOgreAnimation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEntity::playOgreAnimation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::playOgreAnimation",1,"gsEntity *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEntity::playOgreAnimation",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsEntity::playOgreAnimation",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_playOgreAnimation",1,SWIGTYPE_p_gsEntity);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->playOgreAnimation((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_playOgreAnimation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEntity::playOgreAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::playOgreAnimation",1,"gsEntity *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEntity::playOgreAnimation",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_playOgreAnimation",1,SWIGTYPE_p_gsEntity);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->playOgreAnimation((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_playOgreAnimation(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEntity, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Entity_playOgreAnimation__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsEntity, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Entity_playOgreAnimation__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Entity_playOgreAnimation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEntity::playOgreAnimation(gkString const &,bool)\n"
    "    gsEntity::playOgreAnimation(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Entity_updateOgreAnimation(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsEntity::updateOgreAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::updateOgreAnimation",1,"gsEntity *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEntity::updateOgreAnimation",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_updateOgreAnimation",1,SWIGTYPE_p_gsEntity);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->updateOgreAnimation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_getMesh(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  gkMesh *result = 0 ;
  
  SWIG_check_num_args("gsEntity::getMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::getMesh",1,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_getMesh",1,SWIGTYPE_p_gsEntity);
  }
  
  result = (gkMesh *)(arg1)->getMesh();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Mesh); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Entity_hasHardwareSkinning(lua_State* L) {
  int SWIG_arg = 0;
  gsEntity *arg1 = (gsEntity *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsEntity::hasHardwareSkinning",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEntity::hasHardwareSkinning",1,"gsEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEntity,0))){
    SWIG_fail_ptr("Entity_hasHardwareSkinning",1,SWIGTYPE_p_gsEntity);
  }
  
  result = (bool)(arg1)->hasHardwareSkinning();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Entity(void *obj) {
gsEntity *arg1 = (gsEntity *) obj;
delete arg1;
}
static int _proxy__wrap_new_Entity(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Entity);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Entity_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Entity_methods[]= {
    { "hasCharacter", _wrap_Entity_hasCharacter},
    { "getCharacter", _wrap_Entity_getCharacter},
    { "setMaterialName", _wrap_Entity_setMaterialName},
    { "setOgreMeshName", _wrap_Entity_setOgreMeshName},
    { "playOgreAnimation", _wrap_Entity_playOgreAnimation},
    { "updateOgreAnimation", _wrap_Entity_updateOgreAnimation},
    { "getMesh", _wrap_Entity_getMesh},
    { "hasHardwareSkinning", _wrap_Entity_hasHardwareSkinning},
    {0,0}
};
static swig_lua_method swig_Entity_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Entity_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Entity_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Entity_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Entity_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Entity_Sf_SwigStatic = {
    "Entity",
    swig_Entity_Sf_SwigStatic_methods,
    swig_Entity_Sf_SwigStatic_attributes,
    swig_Entity_Sf_SwigStatic_constants,
    swig_Entity_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Entity_bases[] = {0,0};
static const char *swig_Entity_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Entity = { "Entity", "Entity", &SWIGTYPE_p_gsEntity,_proxy__wrap_new_Entity, swig_delete_Entity, swig_Entity_methods, swig_Entity_attributes, &swig_Entity_Sf_SwigStatic, swig_Entity_meta, swig_Entity_bases, swig_Entity_base_names };

static int _wrap_new_Skeleton(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *result = 0 ;
  
  SWIG_check_num_args("gsSkeleton::gsSkeleton",0,0)
  result = (gsSkeleton *)new gsSkeleton();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSkeleton,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_attachObjectToBone__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsGameObject *arg3 = (gsGameObject *) 0 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gsVector3 arg6 ;
  gkString temp2 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  gsVector3 *argp6 ;
  
  SWIG_check_num_args("gsSkeleton::attachObjectToBone",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",2,"gkString const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",3,"gsGameObject *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",5,"gsVector3");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",6,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",3,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&argp6,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",6,SWIGTYPE_p_gsVector3);
  }
  arg6 = *argp6;
  
  (arg1)->attachObjectToBone((gkString const &)*arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_attachObjectToBone__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsGameObject *arg3 = (gsGameObject *) 0 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString temp2 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  
  SWIG_check_num_args("gsSkeleton::attachObjectToBone",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",2,"gkString const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",3,"gsGameObject *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",5,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",3,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  (arg1)->attachObjectToBone((gkString const &)*arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_attachObjectToBone__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsGameObject *arg3 = (gsGameObject *) 0 ;
  gsVector3 arg4 ;
  gkString temp2 ;
  gsVector3 *argp4 ;
  
  SWIG_check_num_args("gsSkeleton::attachObjectToBone",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",2,"gkString const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",3,"gsGameObject *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",4,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",3,SWIGTYPE_p_gsGameObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  (arg1)->attachObjectToBone((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_attachObjectToBone__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsGameObject *arg3 = (gsGameObject *) 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSkeleton::attachObjectToBone",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",2,"gkString const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSkeleton::attachObjectToBone",3,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBone",3,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->attachObjectToBone((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_attachObjectToBone(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Skeleton_attachObjectToBone__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Skeleton_attachObjectToBone__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_Skeleton_attachObjectToBone__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                return _wrap_Skeleton_attachObjectToBone__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Skeleton_attachObjectToBone'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSkeleton::attachObjectToBone(gkString const &,gsGameObject *,gsVector3,gsVector3,gsVector3)\n"
    "    gsSkeleton::attachObjectToBone(gkString const &,gsGameObject *,gsVector3,gsVector3)\n"
    "    gsSkeleton::attachObjectToBone(gkString const &,gsGameObject *,gsVector3)\n"
    "    gsSkeleton::attachObjectToBone(gkString const &,gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_Skeleton_attachObjectToBoneInPlace(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsGameObject *arg3 = (gsGameObject *) 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSkeleton::attachObjectToBoneInPlace",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::attachObjectToBoneInPlace",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::attachObjectToBoneInPlace",2,"gkString const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSkeleton::attachObjectToBoneInPlace",3,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBoneInPlace",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Skeleton_attachObjectToBoneInPlace",3,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->attachObjectToBoneInPlace((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_setBoneManual(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSkeleton::setBoneManual",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::setBoneManual",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::setBoneManual",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsSkeleton::setBoneManual",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_setBoneManual",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setBoneManual((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_isBoneManual(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsSkeleton::isBoneManual",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::isBoneManual",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::isBoneManual",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_isBoneManual",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->isBoneManual((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  float arg6 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  
  SWIG_check_num_args("gsSkeleton::applyBoneChannelTransform",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",5,"gsVector3");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->applyBoneChannelTransform((gkString const &)*arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gsVector3 arg5 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  gsVector3 *argp5 ;
  
  SWIG_check_num_args("gsSkeleton::applyBoneChannelTransform",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",4,"gsVector3");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",5,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",5,SWIGTYPE_p_gsVector3);
  }
  arg5 = *argp5;
  
  (arg1)->applyBoneChannelTransform((gkString const &)*arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gsVector3 arg4 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  gsVector3 *argp4 ;
  
  SWIG_check_num_args("gsSkeleton::applyBoneChannelTransform",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",3,"gsVector3");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",4,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",4,SWIGTYPE_p_gsVector3);
  }
  arg4 = *argp4;
  
  (arg1)->applyBoneChannelTransform((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gsVector3 arg3 ;
  gkString temp2 ;
  gsVector3 *argp3 ;
  
  SWIG_check_num_args("gsSkeleton::applyBoneChannelTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",3,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",3,SWIGTYPE_p_gsVector3);
  }
  arg3 = *argp3;
  
  (arg1)->applyBoneChannelTransform((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSkeleton::applyBoneChannelTransform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::applyBoneChannelTransform",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_applyBoneChannelTransform",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->applyBoneChannelTransform((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Skeleton_applyBoneChannelTransform(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Skeleton_applyBoneChannelTransform__SWIG_4(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Skeleton_applyBoneChannelTransform__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Skeleton_applyBoneChannelTransform__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_Skeleton_applyBoneChannelTransform__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSkeleton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_Skeleton_applyBoneChannelTransform__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Skeleton_applyBoneChannelTransform'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSkeleton::applyBoneChannelTransform(gkString const &,gsVector3,gsVector3,gsVector3,float)\n"
    "    gsSkeleton::applyBoneChannelTransform(gkString const &,gsVector3,gsVector3,gsVector3)\n"
    "    gsSkeleton::applyBoneChannelTransform(gkString const &,gsVector3,gsVector3)\n"
    "    gsSkeleton::applyBoneChannelTransform(gkString const &,gsVector3)\n"
    "    gsSkeleton::applyBoneChannelTransform(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Skeleton_getBonePosition(lua_State* L) {
  int SWIG_arg = 0;
  gsSkeleton *arg1 = (gsSkeleton *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSkeleton::getBonePosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSkeleton::getBonePosition",1,"gsSkeleton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSkeleton::getBonePosition",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSkeleton,0))){
    SWIG_fail_ptr("Skeleton_getBonePosition",1,SWIGTYPE_p_gsSkeleton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->getBonePosition((gkString const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Skeleton(void *obj) {
gsSkeleton *arg1 = (gsSkeleton *) obj;
delete arg1;
}
static int _proxy__wrap_new_Skeleton(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Skeleton);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Skeleton_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Skeleton_methods[]= {
    { "attachObjectToBone", _wrap_Skeleton_attachObjectToBone},
    { "attachObjectToBoneInPlace", _wrap_Skeleton_attachObjectToBoneInPlace},
    { "setBoneManual", _wrap_Skeleton_setBoneManual},
    { "isBoneManual", _wrap_Skeleton_isBoneManual},
    { "applyBoneChannelTransform", _wrap_Skeleton_applyBoneChannelTransform},
    { "getBonePosition", _wrap_Skeleton_getBonePosition},
    {0,0}
};
static swig_lua_method swig_Skeleton_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Skeleton_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Skeleton_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Skeleton_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Skeleton_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Skeleton_Sf_SwigStatic = {
    "Skeleton",
    swig_Skeleton_Sf_SwigStatic_methods,
    swig_Skeleton_Sf_SwigStatic_attributes,
    swig_Skeleton_Sf_SwigStatic_constants,
    swig_Skeleton_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Skeleton_bases[] = {0,0};
static const char *swig_Skeleton_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Skeleton = { "Skeleton", "Skeleton", &SWIGTYPE_p_gsSkeleton,_proxy__wrap_new_Skeleton, swig_delete_Skeleton, swig_Skeleton_methods, swig_Skeleton_attributes, &swig_Skeleton_Sf_SwigStatic, swig_Skeleton_meta, swig_Skeleton_bases, swig_Skeleton_base_names };

static int _wrap_new_Particles(lua_State* L) {
  int SWIG_arg = 0;
  gsParticles *result = 0 ;
  
  SWIG_check_num_args("gsParticles::gsParticles",0,0)
  result = (gsParticles *)new gsParticles();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsParticles,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Particles(void *obj) {
gsParticles *arg1 = (gsParticles *) obj;
delete arg1;
}
static int _proxy__wrap_new_Particles(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Particles);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Particles_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Particles_methods[]= {
    {0,0}
};
static swig_lua_method swig_Particles_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Particles_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Particles_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Particles_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Particles_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Particles_Sf_SwigStatic = {
    "Particles",
    swig_Particles_Sf_SwigStatic_methods,
    swig_Particles_Sf_SwigStatic_attributes,
    swig_Particles_Sf_SwigStatic_constants,
    swig_Particles_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Particles_bases[] = {0,0};
static const char *swig_Particles_base_names[] = {"gsGameObject *",0};
static swig_lua_class _wrap_class_Particles = { "Particles", "Particles", &SWIGTYPE_p_gsParticles,_proxy__wrap_new_Particles, swig_delete_Particles, swig_Particles_methods, swig_Particles_attributes, &swig_Particles_Sf_SwigStatic, swig_Particles_meta, swig_Particles_bases, swig_Particles_base_names };

static int _wrap_new_Debugger__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkDebugger *arg1 = (gkDebugger *) 0 ;
  gsDebugger *result = 0 ;
  
  SWIG_check_num_args("gsDebugger::gsDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::gsDebugger",1,"gkDebugger *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkDebugger,0))){
    SWIG_fail_ptr("new_Debugger",1,SWIGTYPE_p_gkDebugger);
  }
  
  result = (gsDebugger *)new gsDebugger(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Debugger__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsDebugger *result = 0 ;
  
  SWIG_check_num_args("gsDebugger::gsDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::gsDebugger",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_Debugger",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsDebugger *)new gsDebugger(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Debugger(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Debugger__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Debugger__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Debugger'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDebugger::gsDebugger(gkDebugger *)\n"
    "    gsDebugger::gsDebugger(gsScene *)\n");
  lua_error(L);return 0;
}


static int _wrap_Debugger_drawLine__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  
  SWIG_check_num_args("gsDebugger::drawLine",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawLine",1,"gsDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsDebugger::drawLine",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsDebugger::drawLine",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsDebugger::drawLine",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawLine",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawLine",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawLine",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawLine",4,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawLine((gsVector3 const &)*arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawLine__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  
  SWIG_check_num_args("gsDebugger::drawLine",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawLine",1,"gsDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsDebugger::drawLine",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsDebugger::drawLine",3,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawLine",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawLine",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawLine",3,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawLine((gsVector3 const &)*arg2,(gsVector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawLine(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Debugger_drawLine__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Debugger_drawLine__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Debugger_drawLine'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDebugger::drawLine(gsVector3 const &,gsVector3 const &,gsVector3 const &)\n"
    "    gsDebugger::drawLine(gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Debugger_drawObjectAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsDebugger::drawObjectAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawObjectAxis",1,"gsDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsDebugger::drawObjectAxis",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsDebugger::drawObjectAxis",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawObjectAxis",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("Debugger_drawObjectAxis",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->drawObjectAxis(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawCurve__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsCurve *arg2 = (gsCurve *) 0 ;
  gsVector3 *arg3 = 0 ;
  
  SWIG_check_num_args("gsDebugger::drawCurve",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawCurve",1,"gsDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsDebugger::drawCurve",2,"gsCurve *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsDebugger::drawCurve",3,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawCurve",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Debugger_drawCurve",2,SWIGTYPE_p_gsCurve);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawCurve",3,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawCurve(arg2,(gsVector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawCurve__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsCurve *arg2 = (gsCurve *) 0 ;
  
  SWIG_check_num_args("gsDebugger::drawCurve",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawCurve",1,"gsDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsDebugger::drawCurve",2,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawCurve",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("Debugger_drawCurve",2,SWIGTYPE_p_gsCurve);
  }
  
  (arg1)->drawCurve(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawCurve(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Debugger_drawCurve__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Debugger_drawCurve__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Debugger_drawCurve'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDebugger::drawCurve(gsCurve *,gsVector3 const &)\n"
    "    gsDebugger::drawCurve(gsCurve *)\n");
  lua_error(L);return 0;
}


static int _wrap_Debugger_drawCircle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  gsVector3 *arg4 = 0 ;
  
  SWIG_check_num_args("gsDebugger::drawCircle",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawCircle",1,"gsDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsDebugger::drawCircle",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsDebugger::drawCircle",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsDebugger::drawCircle",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawCircle",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawCircle",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawCircle",4,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawCircle((gsVector3 const &)*arg2,arg3,(gsVector3 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawCircle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsDebugger::drawCircle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawCircle",1,"gsDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsDebugger::drawCircle",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsDebugger::drawCircle",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawCircle",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawCircle",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->drawCircle((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawCircle(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Debugger_drawCircle__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Debugger_drawCircle__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Debugger_drawCircle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDebugger::drawCircle(gsVector3 const &,float,gsVector3 const &)\n"
    "    gsDebugger::drawCircle(gsVector3 const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_Debugger_drawPath__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsNavPath *arg2 = (gsNavPath *) 0 ;
  gsVector3 *arg3 = 0 ;
  
  SWIG_check_num_args("gsDebugger::drawPath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawPath",1,"gsDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsDebugger::drawPath",2,"gsNavPath *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsDebugger::drawPath",3,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawPath",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("Debugger_drawPath",2,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Debugger_drawPath",3,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawPath(arg2,(gsVector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawPath__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  gsNavPath *arg2 = (gsNavPath *) 0 ;
  
  SWIG_check_num_args("gsDebugger::drawPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::drawPath",1,"gsDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsDebugger::drawPath",2,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_drawPath",1,SWIGTYPE_p_gsDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("Debugger_drawPath",2,SWIGTYPE_p_gsNavPath);
  }
  
  (arg1)->drawPath(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Debugger_drawPath(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Debugger_drawPath__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Debugger_drawPath__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Debugger_drawPath'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDebugger::drawPath(gsNavPath *,gsVector3 const &)\n"
    "    gsDebugger::drawPath(gsNavPath *)\n");
  lua_error(L);return 0;
}


static int _wrap_Debugger_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsDebugger *arg1 = (gsDebugger *) 0 ;
  
  SWIG_check_num_args("gsDebugger::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDebugger::clear",1,"gsDebugger *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDebugger,0))){
    SWIG_fail_ptr("Debugger_clear",1,SWIGTYPE_p_gsDebugger);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Debugger(void *obj) {
gsDebugger *arg1 = (gsDebugger *) obj;
delete arg1;
}
static int _proxy__wrap_new_Debugger(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Debugger);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Debugger_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Debugger_methods[]= {
    { "drawLine", _wrap_Debugger_drawLine},
    { "drawObjectAxis", _wrap_Debugger_drawObjectAxis},
    { "drawCurve", _wrap_Debugger_drawCurve},
    { "drawCircle", _wrap_Debugger_drawCircle},
    { "drawPath", _wrap_Debugger_drawPath},
    { "clear", _wrap_Debugger_clear},
    {0,0}
};
static swig_lua_method swig_Debugger_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Debugger_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Debugger_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Debugger_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Debugger_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Debugger_Sf_SwigStatic = {
    "Debugger",
    swig_Debugger_Sf_SwigStatic_methods,
    swig_Debugger_Sf_SwigStatic_attributes,
    swig_Debugger_Sf_SwigStatic_constants,
    swig_Debugger_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Debugger_bases[] = {0};
static const char *swig_Debugger_base_names[] = {0};
static swig_lua_class _wrap_class_Debugger = { "Debugger", "Debugger", &SWIGTYPE_p_gsDebugger,_proxy__wrap_new_Debugger, swig_delete_Debugger, swig_Debugger_methods, swig_Debugger_attributes, &swig_Debugger_Sf_SwigStatic, swig_Debugger_meta, swig_Debugger_bases, swig_Debugger_base_names };

static int _wrap_new_gsRecastDebugger__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkRecastDebugger *arg1 = (gkRecastDebugger *) 0 ;
  gsRecastDebugger *result = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::gsRecastDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",1,"gkRecastDebugger *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkRecastDebugger,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",1,SWIGTYPE_p_gkRecastDebugger);
  }
  
  result = (gsRecastDebugger *)new gsRecastDebugger(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRecastDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsRecastDebugger__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsRecastDebugger *result = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::gsRecastDebugger",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",3,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",3,SWIGTYPE_p_gsVector3);
  }
  
  result = (gsRecastDebugger *)new gsRecastDebugger(arg1,(gsVector3 const &)*arg2,(gsVector3 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRecastDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsRecastDebugger__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsRecastDebugger *result = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::gsRecastDebugger",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",1,"gsScene *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",1,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (gsRecastDebugger *)new gsRecastDebugger(arg1,(gsVector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRecastDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsRecastDebugger__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsRecastDebugger *result = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::gsRecastDebugger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::gsRecastDebugger",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_gsRecastDebugger",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsRecastDebugger *)new gsRecastDebugger(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRecastDebugger,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsRecastDebugger(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsRecastDebugger__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsRecastDebugger__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_gsRecastDebugger__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_new_gsRecastDebugger__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsRecastDebugger'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::gsRecastDebugger(gkRecastDebugger *)\n"
    "    gsRecastDebugger::gsRecastDebugger(gsScene *,gsVector3 const &,gsVector3 const &)\n"
    "    gsRecastDebugger::gsRecastDebugger(gsScene *,gsVector3 const &)\n"
    "    gsRecastDebugger::gsRecastDebugger(gsScene *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_drawCircle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  float arg4 ;
  gsVector4 *arg5 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCircle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCircle",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCircle",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCircle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsRecastDebugger::drawCircle",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsRecastDebugger::drawCircle",5,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",5,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawCircle((gsVector3 const &)*arg2,arg3,arg4,(gsVector4 const &)*arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCircle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCircle",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCircle",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCircle",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCircle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsRecastDebugger::drawCircle",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->drawCircle((gsVector3 const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCircle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCircle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCircle",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCircle",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCircle",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCircle",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->drawCircle((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCircle(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsRecastDebugger_drawCircle__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsRecastDebugger_drawCircle__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_gsRecastDebugger_drawCircle__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawCircle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawCircle(gsVector3 const &,float,float,gsVector4 const &)\n"
    "    gsRecastDebugger::drawCircle(gsVector3 const &,float,float)\n"
    "    gsRecastDebugger::drawCircle(gsVector3 const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_drawCylinder__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector4 *arg4 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCylinder",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",2,"gsVector3 &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",3,"gsVector3 &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",4,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",4,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawCylinder(*arg2,*arg3,(gsVector4 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCylinder__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCylinder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",2,"gsVector3 &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCylinder",3,"gsVector3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCylinder",3,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawCylinder(*arg2,*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCylinder(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsRecastDebugger_drawCylinder__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsRecastDebugger_drawCylinder__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawCylinder'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawCylinder(gsVector3 &,gsVector3 &,gsVector4 const &)\n"
    "    gsRecastDebugger::drawCylinder(gsVector3 &,gsVector3 &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_drawBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector4 *arg4 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawBox",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawBox",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawBox",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawBox",4,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",4,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawBox((gsVector3 const &)*arg2,(gsVector3 const &)*arg3,(gsVector4 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawBox",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawBox",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawBox",3,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawBox",3,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawBox((gsVector3 const &)*arg2,(gsVector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawBox(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsRecastDebugger_drawBox__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsRecastDebugger_drawBox__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawBox(gsVector3 const &,gsVector3 const &,gsVector4 const &)\n"
    "    gsRecastDebugger::drawBox(gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_drawCross__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  gsVector4 *arg4 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCross",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCross",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCross",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCross",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawCross",4,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCross",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCross",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCross",4,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawCross((gsVector3 const &)*arg2,arg3,(gsVector4 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCross__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawCross",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawCross",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawCross",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRecastDebugger::drawCross",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCross",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawCross",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->drawCross((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawCross(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsRecastDebugger_drawCross__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsRecastDebugger_drawCross__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawCross'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawCross(gsVector3 const &,float,gsVector4 const &)\n"
    "    gsRecastDebugger::drawCross(gsVector3 const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_drawNavMesh(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawNavMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawNavMesh",1,"gsRecastDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsRecastDebugger::drawNavMesh",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawNavMesh",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawNavMesh",2,SWIGTYPE_p_gsScene);
  }
  
  (arg1)->drawNavMesh(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawLine(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector4 *arg4 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawLine",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawLine",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawLine",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawLine",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawLine",4,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawLine",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawLine",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawLine",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawLine",4,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawLine((gsVector3 const &)*arg2,(gsVector3 const &)*arg3,(gsVector4 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawTri__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  gsVector4 *arg5 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawTri",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawTri",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawTri",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawTri",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawTri",4,"gsVector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsRecastDebugger::drawTri",5,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",4,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",5,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawTri((gsVector3 const &)*arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4,(gsVector4 const &)*arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawTri__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawTri",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawTri",1,"gsRecastDebugger *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRecastDebugger::drawTri",2,"gsVector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawTri",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsRecastDebugger::drawTri",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",2,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawTri",4,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->drawTri((gsVector3 const &)*arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawTri(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsRecastDebugger_drawTri__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_gsRecastDebugger_drawTri__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawTri'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawTri(gsVector3 const &,gsVector3 const &,gsVector3 const &,gsVector4 const &)\n"
    "    gsRecastDebugger::drawTri(gsVector3 const &,gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRecastDebugger_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::clear",1,"gsRecastDebugger *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_clear",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawPath__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsNavPath *arg2 = (gsNavPath *) 0 ;
  gsVector4 *arg3 = 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawPath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawPath",1,"gsRecastDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsRecastDebugger::drawPath",2,"gsNavPath *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRecastDebugger::drawPath",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawPath",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawPath",2,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawPath",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->drawPath(arg2,(gsVector4 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawPath__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRecastDebugger *arg1 = (gsRecastDebugger *) 0 ;
  gsNavPath *arg2 = (gsNavPath *) 0 ;
  
  SWIG_check_num_args("gsRecastDebugger::drawPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRecastDebugger::drawPath",1,"gsRecastDebugger *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsRecastDebugger::drawPath",2,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRecastDebugger,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawPath",1,SWIGTYPE_p_gsRecastDebugger);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("gsRecastDebugger_drawPath",2,SWIGTYPE_p_gsNavPath);
  }
  
  (arg1)->drawPath(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRecastDebugger_drawPath(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsRecastDebugger_drawPath__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRecastDebugger, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsRecastDebugger_drawPath__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRecastDebugger_drawPath'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRecastDebugger::drawPath(gsNavPath *,gsVector4 const &)\n"
    "    gsRecastDebugger::drawPath(gsNavPath *)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsRecastDebugger(void *obj) {
gsRecastDebugger *arg1 = (gsRecastDebugger *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsRecastDebugger(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsRecastDebugger);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsRecastDebugger_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsRecastDebugger_methods[]= {
    { "drawCircle", _wrap_gsRecastDebugger_drawCircle},
    { "drawCylinder", _wrap_gsRecastDebugger_drawCylinder},
    { "drawBox", _wrap_gsRecastDebugger_drawBox},
    { "drawCross", _wrap_gsRecastDebugger_drawCross},
    { "drawNavMesh", _wrap_gsRecastDebugger_drawNavMesh},
    { "drawLine", _wrap_gsRecastDebugger_drawLine},
    { "drawTri", _wrap_gsRecastDebugger_drawTri},
    { "clear", _wrap_gsRecastDebugger_clear},
    { "drawPath", _wrap_gsRecastDebugger_drawPath},
    {0,0}
};
static swig_lua_method swig_gsRecastDebugger_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsRecastDebugger_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsRecastDebugger_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsRecastDebugger_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsRecastDebugger_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsRecastDebugger_Sf_SwigStatic = {
    "gsRecastDebugger",
    swig_gsRecastDebugger_Sf_SwigStatic_methods,
    swig_gsRecastDebugger_Sf_SwigStatic_attributes,
    swig_gsRecastDebugger_Sf_SwigStatic_constants,
    swig_gsRecastDebugger_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsRecastDebugger_bases[] = {0};
static const char *swig_gsRecastDebugger_base_names[] = {0};
static swig_lua_class _wrap_class_gsRecastDebugger = { "gsRecastDebugger", "gsRecastDebugger", &SWIGTYPE_p_gsRecastDebugger,_proxy__wrap_new_gsRecastDebugger, swig_delete_gsRecastDebugger, swig_gsRecastDebugger_methods, swig_gsRecastDebugger_attributes, &swig_gsRecastDebugger_Sf_SwigStatic, swig_gsRecastDebugger_meta, swig_gsRecastDebugger_bases, swig_gsRecastDebugger_base_names };

static int _wrap_new_gsSubMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *result = 0 ;
  
  SWIG_check_num_args("gsSubMesh::gsSubMesh",0,0)
  result = (gsSubMesh *)new gsSubMesh();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSubMesh,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsSubMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkSubMesh *arg1 = (gkSubMesh *) 0 ;
  gsSubMesh *result = 0 ;
  
  SWIG_check_num_args("gsSubMesh::gsSubMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::gsSubMesh",1,"gkSubMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSubMesh,0))){
    SWIG_fail_ptr("new_gsSubMesh",1,SWIGTYPE_p_gkSubMesh);
  }
  
  result = (gsSubMesh *)new gsSubMesh(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSubMesh,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsSubMesh(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_gsSubMesh__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gkSubMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsSubMesh__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsSubMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSubMesh::gsSubMesh()\n"
    "    gsSubMesh::gsSubMesh(gkSubMesh *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsSubMesh_getVertex(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  int arg2 ;
  gkVertex *result = 0 ;
  
  SWIG_check_num_args("gsSubMesh::getVertex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::getVertex",1,"gsSubMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSubMesh::getVertex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_getVertex",1,SWIGTYPE_p_gsSubMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkVertex *)(arg1)->getVertex(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkVertex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_getVertexAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSubMesh::getVertexAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::getVertexAmount",1,"gsSubMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_getVertexAmount",1,SWIGTYPE_p_gsSubMesh);
  }
  
  result = (int)(arg1)->getVertexAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_addTriangle(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  gkVertex *arg2 = 0 ;
  unsigned int arg3 ;
  gkVertex *arg4 = 0 ;
  unsigned int arg5 ;
  gkVertex *arg6 = 0 ;
  unsigned int arg7 ;
  gkTriangle result;
  
  SWIG_check_num_args("gsSubMesh::addTriangle",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::addTriangle",1,"gsSubMesh *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSubMesh::addTriangle",2,"gkVertex const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSubMesh::addTriangle",3,"unsigned int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsSubMesh::addTriangle",4,"gkVertex const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsSubMesh::addTriangle",5,"unsigned int");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("gsSubMesh::addTriangle",6,"gkVertex const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsSubMesh::addTriangle",7,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_addTriangle",1,SWIGTYPE_p_gsSubMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gsSubMesh_addTriangle",2,SWIGTYPE_p_gkVertex);
  }
  
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gsSubMesh_addTriangle",4,SWIGTYPE_p_gkVertex);
  }
  
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_gkVertex,0))){
    SWIG_fail_ptr("gsSubMesh_addTriangle",6,SWIGTYPE_p_gkVertex);
  }
  
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  result = (arg1)->addTriangle((gkVertex const &)*arg2,arg3,(gkVertex const &)*arg4,arg5,(gkVertex const &)*arg6,arg7);
  {
    gkTriangle * resultptr = new gkTriangle((const gkTriangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkTriangle,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_getMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  gkMaterialProperties *result = 0 ;
  
  SWIG_check_num_args("gsSubMesh::getMaterial",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::getMaterial",1,"gsSubMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_getMaterial",1,SWIGTYPE_p_gsSubMesh);
  }
  
  result = (gkMaterialProperties *) &(arg1)->getMaterial();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkMaterialProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_setUVCount(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsSubMesh::setUVCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::setUVCount",1,"gsSubMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSubMesh::setUVCount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_setUVCount",1,SWIGTYPE_p_gsSubMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setUVCount(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_getUVCount(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSubMesh::getUVCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::getUVCount",1,"gsSubMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_getUVCount",1,SWIGTYPE_p_gsSubMesh);
  }
  
  result = (int)(arg1)->getUVCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSubMesh_setMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsSubMesh *arg1 = (gsSubMesh *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSubMesh::setMaterialName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSubMesh::setMaterialName",1,"gsSubMesh *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSubMesh::setMaterialName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsSubMesh_setMaterialName",1,SWIGTYPE_p_gsSubMesh);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterialName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSubMesh(void *obj) {
gsSubMesh *arg1 = (gsSubMesh *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSubMesh(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSubMesh);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSubMesh_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSubMesh_methods[]= {
    { "getVertex", _wrap_gsSubMesh_getVertex},
    { "getVertexAmount", _wrap_gsSubMesh_getVertexAmount},
    { "addTriangle", _wrap_gsSubMesh_addTriangle},
    { "getMaterial", _wrap_gsSubMesh_getMaterial},
    { "setUVCount", _wrap_gsSubMesh_setUVCount},
    { "getUVCount", _wrap_gsSubMesh_getUVCount},
    { "setMaterialName", _wrap_gsSubMesh_setMaterialName},
    {0,0}
};
static swig_lua_method swig_gsSubMesh_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSubMesh_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSubMesh_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSubMesh_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSubMesh_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSubMesh_Sf_SwigStatic = {
    "gsSubMesh",
    swig_gsSubMesh_Sf_SwigStatic_methods,
    swig_gsSubMesh_Sf_SwigStatic_attributes,
    swig_gsSubMesh_Sf_SwigStatic_constants,
    swig_gsSubMesh_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSubMesh_bases[] = {0};
static const char *swig_gsSubMesh_base_names[] = {0};
static swig_lua_class _wrap_class_gsSubMesh = { "gsSubMesh", "gsSubMesh", &SWIGTYPE_p_gsSubMesh,_proxy__wrap_new_gsSubMesh, swig_delete_gsSubMesh, swig_gsSubMesh_methods, swig_gsSubMesh_attributes, &swig_gsSubMesh_Sf_SwigStatic, swig_gsSubMesh_meta, swig_gsSubMesh_bases, swig_gsSubMesh_base_names };

static int _wrap_new_gsMesh(lua_State* L) {
  int SWIG_arg = 0;
  gkMesh *arg1 = (gkMesh *) 0 ;
  gsMesh *result = 0 ;
  
  SWIG_check_num_args("gsMesh::gsMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMesh::gsMesh",1,"gkMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMesh,0))){
    SWIG_fail_ptr("new_gsMesh",1,SWIGTYPE_p_gkMesh);
  }
  
  result = (gsMesh *)new gsMesh(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMesh,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMesh_getSubMeshAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsMesh *arg1 = (gsMesh *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMesh::getSubMeshAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMesh::getSubMeshAmount",1,"gsMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMesh,0))){
    SWIG_fail_ptr("gsMesh_getSubMeshAmount",1,SWIGTYPE_p_gsMesh);
  }
  
  result = (int)(arg1)->getSubMeshAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMesh_getSubMesh(lua_State* L) {
  int SWIG_arg = 0;
  gsMesh *arg1 = (gsMesh *) 0 ;
  int arg2 ;
  gkSubMesh *result = 0 ;
  
  SWIG_check_num_args("gsMesh::getSubMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMesh::getSubMesh",1,"gsMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMesh::getSubMesh",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMesh,0))){
    SWIG_fail_ptr("gsMesh_getSubMesh",1,SWIGTYPE_p_gsMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkSubMesh *)(arg1)->getSubMesh(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, SubMesh); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMesh_addSubMesh(lua_State* L) {
  int SWIG_arg = 0;
  gsMesh *arg1 = (gsMesh *) 0 ;
  gsSubMesh *arg2 = (gsSubMesh *) 0 ;
  
  SWIG_check_num_args("gsMesh::addSubMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMesh::addSubMesh",1,"gsMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsMesh::addSubMesh",2,"gsSubMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMesh,0))){
    SWIG_fail_ptr("gsMesh_addSubMesh",1,SWIGTYPE_p_gsMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSubMesh,0))){
    SWIG_fail_ptr("gsMesh_addSubMesh",2,SWIGTYPE_p_gsSubMesh);
  }
  
  (arg1)->addSubMesh(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMesh_reload(lua_State* L) {
  int SWIG_arg = 0;
  gsMesh *arg1 = (gsMesh *) 0 ;
  
  SWIG_check_num_args("gsMesh::reload",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMesh::reload",1,"gsMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMesh,0))){
    SWIG_fail_ptr("gsMesh_reload",1,SWIGTYPE_p_gsMesh);
  }
  
  (arg1)->reload();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMesh(void *obj) {
gsMesh *arg1 = (gsMesh *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMesh(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMesh);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMesh_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMesh_methods[]= {
    { "getSubMeshAmount", _wrap_gsMesh_getSubMeshAmount},
    { "getSubMesh", _wrap_gsMesh_getSubMesh},
    { "addSubMesh", _wrap_gsMesh_addSubMesh},
    { "reload", _wrap_gsMesh_reload},
    {0,0}
};
static swig_lua_method swig_gsMesh_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMesh_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMesh_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMesh_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMesh_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMesh_Sf_SwigStatic = {
    "gsMesh",
    swig_gsMesh_Sf_SwigStatic_methods,
    swig_gsMesh_Sf_SwigStatic_attributes,
    swig_gsMesh_Sf_SwigStatic_constants,
    swig_gsMesh_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMesh_bases[] = {0};
static const char *swig_gsMesh_base_names[] = {0};
static swig_lua_class _wrap_class_gsMesh = { "gsMesh", "gsMesh", &SWIGTYPE_p_gsMesh,_proxy__wrap_new_gsMesh, swig_delete_gsMesh, swig_gsMesh_methods, swig_gsMesh_attributes, &swig_gsMesh_Sf_SwigStatic, swig_gsMesh_meta, swig_gsMesh_bases, swig_gsMesh_base_names };

static int _wrap_new_gsTween__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  gsTween *result = 0 ;
  
  SWIG_check_num_args("gsTween::gsTween",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsTween::gsTween",1,"float");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsTween::gsTween",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsTween::gsTween",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsTween::gsTween",4,"gkString const &");
  arg1 = (float)lua_tonumber(L, 1);
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  result = (gsTween *)new gsTween(arg1,arg2,arg3,(gkString const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTween,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTween__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsTween *result = 0 ;
  
  SWIG_check_num_args("gsTween::gsTween",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsTween::gsTween",1,"float");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsTween::gsTween",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsTween::gsTween",3,"gsFunction");
  arg1 = (float)lua_tonumber(L, 1);
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsTween *)new gsTween(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTween,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTween__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  gsTween *result = 0 ;
  
  SWIG_check_num_args("gsTween::gsTween",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsTween::gsTween",1,"float");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsTween::gsTween",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsTween::gsTween",3,"gkString const &");
  arg1 = (float)lua_tonumber(L, 1);
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (gsTween *)new gsTween(arg1,arg2,(gkString const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTween,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTween__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsFunction arg2 ;
  gsTween *result = 0 ;
  
  SWIG_check_num_args("gsTween::gsTween",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsTween::gsTween",1,"float");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsTween::gsTween",2,"gsFunction");
  arg1 = (float)lua_tonumber(L, 1);
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  result = (gsTween *)new gsTween(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTween,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTween(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_new_gsTween__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_gsTween__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_new_gsTween__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_gsTween__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsTween'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsTween::gsTween(float,gsSelf,gsFunction,gkString const &)\n"
    "    gsTween::gsTween(float,gsSelf,gsFunction)\n"
    "    gsTween::gsTween(float,gsFunction,gkString const &)\n"
    "    gsTween::gsTween(float,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsTween_start(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsTween::start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::start",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_start",1,SWIGTYPE_p_gsTween);
  }
  
  result = (bool)(arg1)->start();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_addValue(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsTween::addValue",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::addValue",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::addValue",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsTween::addValue",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_addValue",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->addValue(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_onTweenStep(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsTween::onTweenStep",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::onTweenStep",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_onTweenStep",1,SWIGTYPE_p_gsTween);
  }
  
  result = (bool)(arg1)->onTweenStep();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_onTweenComplete(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  
  SWIG_check_num_args("gsTween::onTweenComplete",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::onTweenComplete",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_onTweenComplete",1,SWIGTYPE_p_gsTween);
  }
  
  (arg1)->onTweenComplete();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_stop(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  
  SWIG_check_num_args("gsTween::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::stop",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_stop",1,SWIGTYPE_p_gsTween);
  }
  
  (arg1)->stop();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_clearValues(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  
  SWIG_check_num_args("gsTween::clearValues",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::clearValues",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_clearValues",1,SWIGTYPE_p_gsTween);
  }
  
  (arg1)->clearValues();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setTransition(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("gsTween::setTransition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setTransition",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setTransition",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setTransition",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  (arg1)->setTransition(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setEquation(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("gsTween::setEquation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setEquation",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setEquation",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setEquation",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  (arg1)->setEquation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsTween::setDelay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setDelay",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setDelay",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setDelay",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setDelay(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setDelayFinished(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsTween::setDelayFinished",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setDelayFinished",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setDelayFinished",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setDelayFinished",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setDelayFinished(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_isStarted(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsTween::isStarted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::isStarted",1,"gsTween *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_isStarted",1,SWIGTYPE_p_gsTween);
  }
  
  result = (bool)(arg1)->isStarted();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setReverse(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsTween::setReverse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setReverse",1,"gsTween *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsTween::setReverse",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setReverse",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setReverse(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setInfinite(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsTween::setInfinite",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setInfinite",1,"gsTween *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsTween::setInfinite",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setInfinite",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setInfinite(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setRepeat(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsTween::setRepeat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setRepeat",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setRepeat",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setRepeat",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setRepeat(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTween_setRepeatWithReverse(lua_State* L) {
  int SWIG_arg = 0;
  gsTween *arg1 = (gsTween *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsTween::setRepeatWithReverse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTween::setRepeatWithReverse",1,"gsTween *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTween::setRepeatWithReverse",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTween,0))){
    SWIG_fail_ptr("gsTween_setRepeatWithReverse",1,SWIGTYPE_p_gsTween);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setRepeatWithReverse(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTween(void *obj) {
gsTween *arg1 = (gsTween *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTween(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTween);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTween_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTween_methods[]= {
    { "start", _wrap_gsTween_start},
    { "addValue", _wrap_gsTween_addValue},
    { "onTweenStep", _wrap_gsTween_onTweenStep},
    { "onTweenComplete", _wrap_gsTween_onTweenComplete},
    { "stop", _wrap_gsTween_stop},
    { "clearValues", _wrap_gsTween_clearValues},
    { "setTransition", _wrap_gsTween_setTransition},
    { "setEquation", _wrap_gsTween_setEquation},
    { "setDelay", _wrap_gsTween_setDelay},
    { "setDelayFinished", _wrap_gsTween_setDelayFinished},
    { "isStarted", _wrap_gsTween_isStarted},
    { "setReverse", _wrap_gsTween_setReverse},
    { "setInfinite", _wrap_gsTween_setInfinite},
    { "setRepeat", _wrap_gsTween_setRepeat},
    { "setRepeatWithReverse", _wrap_gsTween_setRepeatWithReverse},
    {0,0}
};
static swig_lua_method swig_gsTween_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTween_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTween_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTween_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTween_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTween_Sf_SwigStatic = {
    "gsTween",
    swig_gsTween_Sf_SwigStatic_methods,
    swig_gsTween_Sf_SwigStatic_attributes,
    swig_gsTween_Sf_SwigStatic_constants,
    swig_gsTween_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTween_bases[] = {0};
static const char *swig_gsTween_base_names[] = {0};
static swig_lua_class _wrap_class_gsTween = { "gsTween", "gsTween", &SWIGTYPE_p_gsTween,_proxy__wrap_new_gsTween, swig_delete_gsTween, swig_gsTween_methods, swig_gsTween_attributes, &swig_gsTween_Sf_SwigStatic, swig_gsTween_meta, swig_gsTween_bases, swig_gsTween_base_names };

static int _wrap_gsProcedural_createBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createBox",6,"unsigned int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsProcedural::createBox",7,"unsigned int");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("gsProcedural::createBox",8,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  SWIG_contract_assert((lua_tonumber(L,8)>=0),"number must not be negative")
  arg8 = (unsigned int)lua_tonumber(L, 8);
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createBox",6,"unsigned int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsProcedural::createBox",7,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3,arg4,arg5,arg6,arg7);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createBox",6,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3,arg4,arg5,arg6);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createBox",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createBox",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3,arg4);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createBox",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createBox",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->createBox((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createBox(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsProcedural_createBox__SWIG_6(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsProcedural_createBox__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsProcedural_createBox__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_gsProcedural_createBox__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsProcedural_createBox__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_gsProcedural_createBox__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_gsProcedural_createBox__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsProcedural_createBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int,unsigned int)\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int)\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real,Ogre::Real)\n"
    "    gsProcedural::createBox(gkString const &,Ogre::Real)\n"
    "    gsProcedural::createBox(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  float arg9 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createRoundedBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createRoundedBox",6,"unsigned int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsProcedural::createRoundedBox",7,"unsigned int");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("gsProcedural::createRoundedBox",8,"unsigned int");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("gsProcedural::createRoundedBox",9,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  SWIG_contract_assert((lua_tonumber(L,8)>=0),"number must not be negative")
  arg8 = (unsigned int)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createRoundedBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createRoundedBox",6,"unsigned int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsProcedural::createRoundedBox",7,"unsigned int");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("gsProcedural::createRoundedBox",8,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  SWIG_contract_assert((lua_tonumber(L,8)>=0),"number must not be negative")
  arg8 = (unsigned int)lua_tonumber(L, 8);
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createRoundedBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createRoundedBox",6,"unsigned int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsProcedural::createRoundedBox",7,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4,arg5,arg6,arg7);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  unsigned int arg6 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createRoundedBox",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsProcedural::createRoundedBox",6,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4,arg5,arg6);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  Ogre::Real *argp5 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcedural::createRoundedBox",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",5,SWIGTYPE_p_Ogre__Real);
  }
  arg5 = *argp5;
  
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  Ogre::Real *argp4 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcedural::createRoundedBox",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",4,SWIGTYPE_p_Ogre__Real);
  }
  arg4 = *argp4;
  
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3,arg4);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  Ogre::Real arg3 ;
  gkString temp2 ;
  Ogre::Real *argp3 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsProcedural::createRoundedBox",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Real,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",3,SWIGTYPE_p_Ogre__Real);
  }
  arg3 = *argp3;
  
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox__SWIG_7(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *arg1 = (gsProcedural *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::createRoundedBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcedural::createRoundedBox",1,"gsProcedural *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcedural::createRoundedBox",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcedural,0))){
    SWIG_fail_ptr("gsProcedural_createRoundedBox",1,SWIGTYPE_p_gsProcedural);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGameObject *)(arg1)->createRoundedBox((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsProcedural_createRoundedBox(lua_State* L) {
  int argc;
  int argv[10]={
    1,2,3,4,5,6,7,8,9,10
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsProcedural_createRoundedBox__SWIG_7(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsProcedural_createRoundedBox__SWIG_6(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_gsProcedural_createRoundedBox__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_gsProcedural_createRoundedBox__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsProcedural_createRoundedBox__SWIG_3(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_gsProcedural_createRoundedBox__SWIG_2(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_gsProcedural_createRoundedBox__SWIG_1(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcedural, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Real, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      return _wrap_gsProcedural_createRoundedBox__SWIG_0(L);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsProcedural_createRoundedBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int,unsigned int,float)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int,unsigned int)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real,unsigned int)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real,Ogre::Real)\n"
    "    gsProcedural::createRoundedBox(gkString const &,Ogre::Real)\n"
    "    gsProcedural::createRoundedBox(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_new_gsProcedural(lua_State* L) {
  int SWIG_arg = 0;
  gsProcedural *result = 0 ;
  
  SWIG_check_num_args("gsProcedural::gsProcedural",0,0)
  result = (gsProcedural *)new gsProcedural();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcedural,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsProcedural(void *obj) {
gsProcedural *arg1 = (gsProcedural *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsProcedural(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsProcedural);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsProcedural_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsProcedural_methods[]= {
    { "createBox", _wrap_gsProcedural_createBox},
    { "createRoundedBox", _wrap_gsProcedural_createRoundedBox},
    {0,0}
};
static swig_lua_method swig_gsProcedural_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsProcedural_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsProcedural_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsProcedural_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsProcedural_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsProcedural_Sf_SwigStatic = {
    "gsProcedural",
    swig_gsProcedural_Sf_SwigStatic_methods,
    swig_gsProcedural_Sf_SwigStatic_attributes,
    swig_gsProcedural_Sf_SwigStatic_constants,
    swig_gsProcedural_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsProcedural_bases[] = {0};
static const char *swig_gsProcedural_base_names[] = {0};
static swig_lua_class _wrap_class_gsProcedural = { "gsProcedural", "gsProcedural", &SWIGTYPE_p_gsProcedural,_proxy__wrap_new_gsProcedural, swig_delete_gsProcedural, swig_gsProcedural_methods, swig_gsProcedural_attributes, &swig_gsProcedural_Sf_SwigStatic, swig_gsProcedural_meta, swig_gsProcedural_bases, swig_gsProcedural_base_names };

static int _wrap_addResourceLocation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("addResourceLocation",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("addResourceLocation",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("addResourceLocation",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("addResourceLocation",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("addResourceLocation",4,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  addResourceLocation((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_addResourceLocation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("addResourceLocation",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("addResourceLocation",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("addResourceLocation",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("addResourceLocation",3,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  addResourceLocation((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_addResourceLocation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_addResourceLocation__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_addResourceLocation__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'addResourceLocation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    addResourceLocation(gkString const &,gkString const &,gkString const &,bool)\n"
    "    addResourceLocation(gkString const &,gkString const &,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_loadResource(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  
  SWIG_check_num_args("loadResource",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("loadResource",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("loadResource",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  loadResource((gkString const &)*arg1,(gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loadBlend__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("loadBlend",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("loadBlend",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("loadBlend",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("loadBlend",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("loadBlend",4,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  loadBlend((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loadBlend__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("loadBlend",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("loadBlend",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("loadBlend",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("loadBlend",3,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  loadBlend((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loadBlend__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  
  SWIG_check_num_args("loadBlend",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("loadBlend",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("loadBlend",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  loadBlend((gkString const &)*arg1,(gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loadBlend__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("loadBlend",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("loadBlend",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  loadBlend((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loadBlend(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_loadBlend__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_loadBlend__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_loadBlend__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_loadBlend__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'loadBlend'\n"
    "  Possible C/C++ prototypes are:\n"
    "    loadBlend(gkString const &,gkString const &,gkString const &,bool)\n"
    "    loadBlend(gkString const &,gkString const &,gkString const &)\n"
    "    loadBlend(gkString const &,gkString const &)\n"
    "    loadBlend(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_unloadBlendFile(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("unloadBlendFile",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("unloadBlendFile",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  unloadBlendFile((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unloadAllBlendFiles(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("unloadAllBlendFiles",0,0)
  unloadAllBlendFiles();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsLuaStream(lua_State* L) {
  int SWIG_arg = 0;
  utMemoryStream arg1 ;
  utMemoryStream *argp1 ;
  gsLuaStream *result = 0 ;
  
  SWIG_check_num_args("gsLuaStream::gsLuaStream",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsLuaStream::gsLuaStream",1,"utMemoryStream");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_utMemoryStream,0))){
    SWIG_fail_ptr("new_gsLuaStream",1,SWIGTYPE_p_utMemoryStream);
  }
  arg1 = *argp1;
  
  result = (gsLuaStream *)new gsLuaStream(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLuaStream,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLuaStream_read(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaStream *arg1 = (gsLuaStream *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsLuaStream::read",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaStream::read",1,"gsLuaStream *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLuaStream::read",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaStream,0))){
    SWIG_fail_ptr("gsLuaStream_read",1,SWIGTYPE_p_gsLuaStream);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->read(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLuaStream_pos(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaStream *arg1 = (gsLuaStream *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLuaStream::pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaStream::pos",1,"gsLuaStream *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaStream,0))){
    SWIG_fail_ptr("gsLuaStream_pos",1,SWIGTYPE_p_gsLuaStream);
  }
  
  result = (int)(arg1)->pos();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLuaStream_size(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaStream *arg1 = (gsLuaStream *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLuaStream::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaStream::size",1,"gsLuaStream *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaStream,0))){
    SWIG_fail_ptr("gsLuaStream_size",1,SWIGTYPE_p_gsLuaStream);
  }
  
  result = (int)(arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsLuaStream(void *obj) {
gsLuaStream *arg1 = (gsLuaStream *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsLuaStream(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsLuaStream);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsLuaStream_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsLuaStream_methods[]= {
    { "read", _wrap_gsLuaStream_read},
    { "pos", _wrap_gsLuaStream_pos},
    { "size", _wrap_gsLuaStream_size},
    {0,0}
};
static swig_lua_method swig_gsLuaStream_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsLuaStream_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsLuaStream_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsLuaStream_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsLuaStream_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsLuaStream_Sf_SwigStatic = {
    "gsLuaStream",
    swig_gsLuaStream_Sf_SwigStatic_methods,
    swig_gsLuaStream_Sf_SwigStatic_attributes,
    swig_gsLuaStream_Sf_SwigStatic_constants,
    swig_gsLuaStream_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsLuaStream_bases[] = {0};
static const char *swig_gsLuaStream_base_names[] = {0};
static swig_lua_class _wrap_class_gsLuaStream = { "gsLuaStream", "gsLuaStream", &SWIGTYPE_p_gsLuaStream,_proxy__wrap_new_gsLuaStream, swig_delete_gsLuaStream, swig_gsLuaStream_methods, swig_gsLuaStream_attributes, &swig_gsLuaStream_Sf_SwigStatic, swig_gsLuaStream_meta, swig_gsLuaStream_bases, swig_gsLuaStream_base_names };

static int _wrap_downloadFile__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("downloadFile",6,6)
  if(!lua_isstring(L,1)) SWIG_fail_arg("downloadFile",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadFile",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("downloadFile",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("downloadFile",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("downloadFile",6,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0);
  arg6 = (lua_toboolean(L, 6)!=0);
  downloadFile((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadFile__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  bool arg5 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("downloadFile",5,5)
  if(!lua_isstring(L,1)) SWIG_fail_arg("downloadFile",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadFile",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("downloadFile",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("downloadFile",5,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0);
  downloadFile((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadFile__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("downloadFile",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("downloadFile",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadFile",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("downloadFile",4,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  downloadFile((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadFile__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("downloadFile",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("downloadFile",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadFile",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadFile",3,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  downloadFile((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadFile__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  
  SWIG_check_num_args("downloadFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("downloadFile",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadFile",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  downloadFile((gkString const &)*arg1,(gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadFile(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_downloadFile__SWIG_4(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_downloadFile__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_downloadFile__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_downloadFile__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                return _wrap_downloadFile__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'downloadFile'\n"
    "  Possible C/C++ prototypes are:\n"
    "    downloadFile(gkString const &,gkString const &,gkString const &,bool,bool,bool)\n"
    "    downloadFile(gkString const &,gkString const &,gkString const &,bool,bool)\n"
    "    downloadFile(gkString const &,gkString const &,gkString const &,bool)\n"
    "    downloadFile(gkString const &,gkString const &,gkString const &)\n"
    "    downloadFile(gkString const &,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_downloadToString__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  bool arg5 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString result;
  
  SWIG_check_num_args("downloadToString",5,5)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("downloadToString",1,"bool");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadToString",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadToString",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("downloadToString",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("downloadToString",5,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = downloadToString(arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4,arg5);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadToString__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString result;
  
  SWIG_check_num_args("downloadToString",4,4)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("downloadToString",1,"bool");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadToString",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadToString",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("downloadToString",4,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = downloadToString(arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadToString__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString result;
  
  SWIG_check_num_args("downloadToString",3,3)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("downloadToString",1,"bool");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadToString",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("downloadToString",3,"gkString const &");
  arg1 = (lua_toboolean(L, 1)!=0);
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = downloadToString(arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadToString__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("downloadToString",2,2)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("downloadToString",1,"bool");
  if(!lua_isstring(L,2)) SWIG_fail_arg("downloadToString",2,"gkString const &");
  arg1 = (lua_toboolean(L, 1)!=0);
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = downloadToString(arg1,(gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_downloadToString(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_downloadToString__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_downloadToString__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_downloadToString__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_downloadToString__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'downloadToString'\n"
    "  Possible C/C++ prototypes are:\n"
    "    downloadToString(bool,gkString const &,gkString const &,bool,bool)\n"
    "    downloadToString(bool,gkString const &,gkString const &,bool)\n"
    "    downloadToString(bool,gkString const &,gkString const &)\n"
    "    downloadToString(bool,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_nbDownload(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("nbDownload",0,0)
  nbDownload();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_nbPoll(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("nbPoll",0,0)
  nbPoll();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_nbSetCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSelf arg1 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("nbSetCallback",2,2)
  if(!lua_istable(L,1)) SWIG_fail_arg("nbSetCallback",1,"gsSelf");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("nbSetCallback",2,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  nbSetCallback(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_nbSetCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsFunction arg1 ;
  
  SWIG_check_num_args("nbSetCallback",1,1)
  if(!lua_isfunction(L,1)) SWIG_fail_arg("nbSetCallback",1,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  nbSetCallback(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_nbSetCallback(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    _v = lua_isfunction(L, argv[0]); 
    if (_v) {
      return _wrap_nbSetCallback__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    _v = lua_istable(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_nbSetCallback__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'nbSetCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    nbSetCallback(gsSelf,gsFunction)\n"
    "    nbSetCallback(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_nbIsRunning(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("nbIsRunning",0,0)
  result = (bool)nbIsRunning();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendMessage(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  char *arg4 = (char *) 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("sendMessage",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("sendMessage",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("sendMessage",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("sendMessage",3,"gkString const &");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("sendMessage",4,"char const *");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (char *)lua_tostring(L, 4);
  sendMessage((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,(char const *)arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendEventMessage__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  bool arg4 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("sendEventMessage",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("sendEventMessage",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("sendEventMessage",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("sendEventMessage",3,"gkString const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("sendEventMessage",4,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  sendEventMessage((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendEventMessage__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("sendEventMessage",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("sendEventMessage",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("sendEventMessage",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("sendEventMessage",3,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  sendEventMessage((gkString const &)*arg1,(gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendEventMessage__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  
  SWIG_check_num_args("sendEventMessage",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("sendEventMessage",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("sendEventMessage",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  sendEventMessage((gkString const &)*arg1,(gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendEventMessage__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("sendEventMessage",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("sendEventMessage",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  sendEventMessage((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sendEventMessage(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_sendEventMessage__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_sendEventMessage__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_sendEventMessage__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_sendEventMessage__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'sendEventMessage'\n"
    "  Possible C/C++ prototypes are:\n"
    "    sendEventMessage(gkString const &,gkString const &,gkString const &,bool)\n"
    "    sendEventMessage(gkString const &,gkString const &,gkString const &)\n"
    "    sendEventMessage(gkString const &,gkString const &)\n"
    "    sendEventMessage(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_DebugPrint(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("gsDebugPrint",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("gsDebugPrint",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  gsDebugPrint((char const *)arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_infoClear(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("infoClear",0,0)
  infoClear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_infoLock(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  
  SWIG_check_num_args("infoLock",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("infoLock",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  infoLock(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_infoShow(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  
  SWIG_check_num_args("infoShow",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("infoShow",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  infoShow(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getScriptFolder(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getScriptFolder",0,0)
  result = getScriptFolder();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SetCompositorChain(lua_State* L) {
  int SWIG_arg = 0;
  gsCompositorOp arg1 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsSetCompositorChain",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSetCompositorChain",1,"gsCompositorOp");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSetCompositorChain",2,"gkString const &");
  arg1 = (gsCompositorOp)(int)lua_tonumber(L, 1);
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)gsSetCompositorChain(arg1,(gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_import__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  bool arg2 ;
  gkString temp1 ;
  bool result;
  
  SWIG_check_num_args("import",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("import",1,"gkString const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("import",2,"bool");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)import((gkString const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_import__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  bool result;
  
  SWIG_check_num_args("import",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("import",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (bool)import((gkString const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_import(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_import__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_import__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'import'\n"
    "  Possible C/C++ prototypes are:\n"
    "    import(gkString const &,bool)\n"
    "    import(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_fileExists(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  bool result;
  
  SWIG_check_num_args("fileExists",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("fileExists",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (bool)fileExists((gkString const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_fileLoad(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("fileLoad",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("fileLoad",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = fileLoad((gkString const &)*arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getPlatform(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getPlatform",0,0)
  result = getPlatform();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isMobile(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isMobile",0,0)
  result = (bool)isMobile();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isSoundAvailable(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isSoundAvailable",0,0)
  result = (bool)isSoundAvailable();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isMaterialInitialized(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  bool result;
  
  SWIG_check_num_args("isMaterialInitialized",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("isMaterialInitialized",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (bool)isMaterialInitialized((gkString const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_initMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("initMaterial",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("initMaterial",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  initMaterial((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getWindowTitle(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getWindowTitle",0,0)
  result = getWindowTitle();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setMaterialParam__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  int arg2 ;
  gkString *arg3 = 0 ;
  float arg4 ;
  gkString temp1 ;
  gkString temp3 ;
  
  SWIG_check_num_args("setMaterialParam",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("setMaterialParam",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setMaterialParam",2,"int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("setMaterialParam",3,"gkString const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setMaterialParam",4,"float");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (int)lua_tonumber(L, 2);
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (float)lua_tonumber(L, 4);
  setMaterialParam((gkString const &)*arg1,arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setMaterialParam__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  int arg2 ;
  gkString *arg3 = 0 ;
  int arg4 ;
  gkString temp1 ;
  gkString temp3 ;
  
  SWIG_check_num_args("setMaterialParam",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("setMaterialParam",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setMaterialParam",2,"int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("setMaterialParam",3,"gkString const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setMaterialParam",4,"int");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (int)lua_tonumber(L, 2);
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  arg4 = (int)lua_tonumber(L, 4);
  setMaterialParam((gkString const &)*arg1,arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setMaterialParam__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  int arg2 ;
  gkString *arg3 = 0 ;
  gsVector3 *arg4 = (gsVector3 *) 0 ;
  gkString temp1 ;
  gkString temp3 ;
  
  SWIG_check_num_args("setMaterialParam",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("setMaterialParam",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setMaterialParam",2,"int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("setMaterialParam",3,"gkString const &");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("setMaterialParam",4,"gsVector3 *");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (int)lua_tonumber(L, 2);
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("setMaterialParam",4,SWIGTYPE_p_gsVector3);
  }
  
  setMaterialParam((gkString const &)*arg1,arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setMaterialParam__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  int arg2 ;
  gkString *arg3 = 0 ;
  gsVector4 *arg4 = (gsVector4 *) 0 ;
  gkString temp1 ;
  gkString temp3 ;
  
  SWIG_check_num_args("setMaterialParam",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("setMaterialParam",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setMaterialParam",2,"int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("setMaterialParam",3,"gkString const &");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("setMaterialParam",4,"gsVector4 *");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (int)lua_tonumber(L, 2);
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("setMaterialParam",4,SWIGTYPE_p_gsVector4);
  }
  
  setMaterialParam((gkString const &)*arg1,arg2,(gkString const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setMaterialParam(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_setMaterialParam__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_setMaterialParam__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_setMaterialParam__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_setMaterialParam__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setMaterialParam'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setMaterialParam(gkString const &,int,gkString const &,float)\n"
    "    setMaterialParam(gkString const &,int,gkString const &,int)\n"
    "    setMaterialParam(gkString const &,int,gkString const &,gsVector3 *)\n"
    "    setMaterialParam(gkString const &,int,gkString const &,gsVector4 *)\n");
  lua_error(L);return 0;
}


static int _wrap_log(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("log",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("log",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  log((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_logDisable(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("logDisable",0,0)
  logDisable();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_logEnable__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  
  SWIG_check_num_args("logEnable",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("logEnable",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  logEnable(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_logEnable__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("logEnable",0,0)
  logEnable();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_logEnable(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_logEnable__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      return _wrap_logEnable__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'logEnable'\n"
    "  Possible C/C++ prototypes are:\n"
    "    logEnable(bool)\n"
    "    logEnable()\n");
  lua_error(L);return 0;
}


static int _wrap_md5(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("md5",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("md5",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = md5((gkString const &)*arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_blowfishEncrypt(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("blowfishEncrypt",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("blowfishEncrypt",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("blowfishEncrypt",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = blowfishEncrypt((gkString const &)*arg1,(gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_blowfishDecrypt(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString *arg2 = 0 ;
  gkString temp1 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("blowfishDecrypt",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("blowfishDecrypt",1,"gkString const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("blowfishDecrypt",2,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = blowfishDecrypt((gkString const &)*arg1,(gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isNetworkAvailable__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  bool result;
  
  SWIG_check_num_args("isNetworkAvailable",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("isNetworkAvailable",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (bool)isNetworkAvailable((gkString const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isNetworkAvailable__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isNetworkAvailable",0,0)
  result = (bool)isNetworkAvailable();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isNetworkAvailable(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_isNetworkAvailable__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_isNetworkAvailable__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'isNetworkAvailable'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isNetworkAvailable(gkString const &)\n"
    "    isNetworkAvailable()\n");
  lua_error(L);return 0;
}


static int _wrap_asyncIsNetworkAvailable__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSelf arg1 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("asyncIsNetworkAvailable",3,3)
  if(!lua_istable(L,1)) SWIG_fail_arg("asyncIsNetworkAvailable",1,"gsSelf");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("asyncIsNetworkAvailable",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("asyncIsNetworkAvailable",3,"gkString const &");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  asyncIsNetworkAvailable(arg1,arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_asyncIsNetworkAvailable__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSelf arg1 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("asyncIsNetworkAvailable",2,2)
  if(!lua_istable(L,1)) SWIG_fail_arg("asyncIsNetworkAvailable",1,"gsSelf");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("asyncIsNetworkAvailable",2,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  asyncIsNetworkAvailable(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_asyncIsNetworkAvailable(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    _v = lua_istable(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_asyncIsNetworkAvailable__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = lua_istable(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_asyncIsNetworkAvailable__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'asyncIsNetworkAvailable'\n"
    "  Possible C/C++ prototypes are:\n"
    "    asyncIsNetworkAvailable(gsSelf,gsFunction,gkString const &)\n"
    "    asyncIsNetworkAvailable(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_ribbon__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gsVector3 arg7 ;
  gsVector4 arg8 ;
  gkString temp6 ;
  gsVector3 *argp7 ;
  gsVector4 *argp8 ;
  
  SWIG_check_num_args("ribbon",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ribbon",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ribbon",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("ribbon",6,"gkString const &");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ribbon",7,"gsVector3");
  if(!lua_isuserdata(L,8)) SWIG_fail_arg("ribbon",8,"gsVector4");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&argp7,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ribbon",7,SWIGTYPE_p_gsVector3);
  }
  arg7 = *argp7;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,8,(void**)&argp8,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("ribbon",8,SWIGTYPE_p_gsVector4);
  }
  arg8 = *argp8;
  
  ribbon(arg1,arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7,arg8);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gsVector3 arg7 ;
  gkString temp6 ;
  gsVector3 *argp7 ;
  
  SWIG_check_num_args("ribbon",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ribbon",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ribbon",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("ribbon",6,"gkString const &");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ribbon",7,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&argp7,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ribbon",7,SWIGTYPE_p_gsVector3);
  }
  arg7 = *argp7;
  
  ribbon(arg1,arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  
  SWIG_check_num_args("ribbon",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ribbon",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ribbon",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("ribbon",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  ribbon(arg1,arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("ribbon",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ribbon",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ribbon",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  ribbon(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("ribbon",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ribbon",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  ribbon(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("ribbon",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ribbon",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  ribbon(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("ribbon",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ribbon",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  ribbon(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon__SWIG_7(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("ribbon",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ribbon",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ribbon",1,SWIGTYPE_p_gsGameObject);
  }
  
  ribbon(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ribbon(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_ribbon__SWIG_7(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_ribbon__SWIG_6(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_ribbon__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_ribbon__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_ribbon__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_ribbon__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  void *ptr;
                  if (lua_isuserdata(L,argv[6])==0 || SWIG_ConvertPtr(L,argv[6], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                    _v = 0;
                  } else {
                    _v = 1;
                  }
                }
                if (_v) {
                  return _wrap_ribbon__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  void *ptr;
                  if (lua_isuserdata(L,argv[6])==0 || SWIG_ConvertPtr(L,argv[6], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                    _v = 0;
                  } else {
                    _v = 1;
                  }
                }
                if (_v) {
                  {
                    void *ptr;
                    if (lua_isuserdata(L,argv[7])==0 || SWIG_ConvertPtr(L,argv[7], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
                      _v = 0;
                    } else {
                      _v = 1;
                    }
                  }
                  if (_v) {
                    return _wrap_ribbon__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ribbon'\n"
    "  Possible C/C++ prototypes are:\n"
    "    ribbon(gsGameObject *,float,float,int,int,gkString const &,gsVector3,gsVector4)\n"
    "    ribbon(gsGameObject *,float,float,int,int,gkString const &,gsVector3)\n"
    "    ribbon(gsGameObject *,float,float,int,int,gkString const &)\n"
    "    ribbon(gsGameObject *,float,float,int,int)\n"
    "    ribbon(gsGameObject *,float,float,int)\n"
    "    ribbon(gsGameObject *,float,float)\n"
    "    ribbon(gsGameObject *,float)\n"
    "    ribbon(gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_scancodeToInt(lua_State* L) {
  int SWIG_arg = 0;
  gkScanCode arg1 ;
  gkScanCode *argp1 ;
  int result;
  
  SWIG_check_num_args("scancodeToInt",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("scancodeToInt",1,"gkScanCode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_gkScanCode,0))){
    SWIG_fail_ptr("scancodeToInt",1,SWIGTYPE_p_gkScanCode);
  }
  arg1 = *argp1;
  
  result = (int)scancodeToInt(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getTime(lua_State* L) {
  int SWIG_arg = 0;
  unsigned long result;
  
  SWIG_check_num_args("getTime",0,0)
  result = (unsigned long)getTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getSystemTime(lua_State* L) {
  int SWIG_arg = 0;
  unsigned long result;
  
  SWIG_check_num_args("getSystemTime",0,0)
  result = (unsigned long)getSystemTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getScreenSize(lua_State* L) {
  int SWIG_arg = 0;
  gsVector2 result;
  
  SWIG_check_num_args("getScreenSize",0,0)
  result = getScreenSize();
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setScreenSize(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int arg2 ;
  
  SWIG_check_num_args("setScreenSize",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("setScreenSize",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setScreenSize",2,"int");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  setScreenSize(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getFPS(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("getFPS",0,0)
  result = (float)getFPS();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getDataDirectory__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("getDataDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getDataDirectory",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = getDataDirectory((gkString const &)*arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getDataDirectory__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getDataDirectory",0,0)
  result = getDataDirectory();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getDataDirectory(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_getDataDirectory__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_getDataDirectory__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getDataDirectory'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDataDirectory(gkString const &)\n"
    "    getDataDirectory()\n");
  lua_error(L);return 0;
}


static int _wrap_getWorkingFolder(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getWorkingFolder",0,0)
  result = getWorkingFolder();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressString(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsCompressionLevel arg2 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("compressString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("compressString",1,"gkString const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("compressString",2,"gsCompressionLevel");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  arg2 = (gsCompressionLevel)(int)lua_tonumber(L, 2);
  result = compressString((gkString const &)*arg1,arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressCString(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int *arg2 = 0 ;
  gsCompressionLevel arg3 ;
  char *result = 0 ;
  
  SWIG_check_num_args("compressCString",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("compressCString",1,"char *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("compressCString",2,"int &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("compressCString",3,"gsCompressionLevel");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("compressCString",2,SWIGTYPE_p_int);
  }
  
  arg3 = (gsCompressionLevel)(int)lua_tonumber(L, 3);
  result = (char *)compressCString(arg1,*arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_uncompressString(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("uncompressString",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("uncompressString",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = uncompressString((gkString const &)*arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_executeScript(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  
  SWIG_check_num_args("executeScript",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("executeScript",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  executeScript((gkString const &)*arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setSinglestepMode(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  
  SWIG_check_num_args("setSinglestepMode",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("setSinglestepMode",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  setSinglestepMode(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_inSinglestepMode(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("inSinglestepMode",0,0)
  result = (bool)inSinglestepMode();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_requestSinglestep(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("requestSinglestep",0,0)
  requestSinglestep();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_createInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::createInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::createInstance",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_createInstance",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  (arg1)->createInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_destroyInstance(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::destroyInstance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::destroyInstance",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_destroyInstance",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  (arg1)->destroyInstance();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_isInstanced(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::isInstanced",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::isInstanced",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_isInstanced",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (bool)(arg1)->isInstanced();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getName",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getName",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getElementById(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getElementById",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getElementById",1,"gsGuiDocumentRocket *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiDocumentRocket::getElementById",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getElementById",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGuiElement *)(arg1)->getElementById((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getChildAmount__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  bool arg2 ;
  int result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getChildAmount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getChildAmount",1,"gsGuiDocumentRocket *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGuiDocumentRocket::getChildAmount",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getChildAmount",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (int)(arg1)->getChildAmount(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getChildAmount__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getChildAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getChildAmount",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getChildAmount",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (int)(arg1)->getChildAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getChildAmount(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiDocumentRocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGuiDocumentRocket_getChildAmount__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiDocumentRocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGuiDocumentRocket_getChildAmount__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiDocumentRocket_getChildAmount'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiDocumentRocket::getChildAmount(bool)\n"
    "    gsGuiDocumentRocket::getChildAmount()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiDocumentRocket_getChild__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  int arg2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getChild",1,"gsGuiDocumentRocket *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiDocumentRocket::getChild",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getChild",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGuiElement *)(arg1)->getChild(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getChild__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getChild",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getChild",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getChild",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (gkGuiElement *)(arg1)->getChild();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getChild(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiDocumentRocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGuiDocumentRocket_getChild__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiDocumentRocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGuiDocumentRocket_getChild__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiDocumentRocket_getChild'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiDocumentRocket::getChild(int)\n"
    "    gsGuiDocumentRocket::getChild()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiDocumentRocket_getElementsByClass(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGuiElementQuery *result = 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getElementsByClass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getElementsByClass",1,"gsGuiDocumentRocket *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiDocumentRocket::getElementsByClass",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getElementsByClass",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGuiElementQuery *)(arg1)->getElementsByClass((gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementQuery,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getElementsByTagname(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGuiElementQuery *result = 0 ;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getElementsByTagname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getElementsByTagname",1,"gsGuiDocumentRocket *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiDocumentRocket::getElementsByTagname",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getElementsByTagname",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGuiElementQuery *)(arg1)->getElementsByTagname((gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementQuery,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getRML(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getRML",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getRML",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getRML",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (arg1)->getRML();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDocumentRocket_getInnerRML(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiDocumentRocket::getInnerRML",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDocumentRocket::getInnerRML",1,"gsGuiDocumentRocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDocumentRocket,0))){
    SWIG_fail_ptr("gsGuiDocumentRocket_getInnerRML",1,SWIGTYPE_p_gsGuiDocumentRocket);
  }
  
  result = (arg1)->getInnerRML();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiDocumentRocket(void *obj) {
gsGuiDocumentRocket *arg1 = (gsGuiDocumentRocket *) obj;
delete arg1;
}
static swig_lua_attribute swig_gsGuiDocumentRocket_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiDocumentRocket_methods[]= {
    { "createInstance", _wrap_gsGuiDocumentRocket_createInstance},
    { "destroyInstance", _wrap_gsGuiDocumentRocket_destroyInstance},
    { "isInstanced", _wrap_gsGuiDocumentRocket_isInstanced},
    { "getName", _wrap_gsGuiDocumentRocket_getName},
    { "getElementById", _wrap_gsGuiDocumentRocket_getElementById},
    { "getChildAmount", _wrap_gsGuiDocumentRocket_getChildAmount},
    { "getChild", _wrap_gsGuiDocumentRocket_getChild},
    { "getElementsByClass", _wrap_gsGuiDocumentRocket_getElementsByClass},
    { "getElementsByTagname", _wrap_gsGuiDocumentRocket_getElementsByTagname},
    { "getRML", _wrap_gsGuiDocumentRocket_getRML},
    { "getInnerRML", _wrap_gsGuiDocumentRocket_getInnerRML},
    {0,0}
};
static swig_lua_method swig_gsGuiDocumentRocket_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiDocumentRocket_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiDocumentRocket_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiDocumentRocket_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiDocumentRocket_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiDocumentRocket_Sf_SwigStatic = {
    "gsGuiDocumentRocket",
    swig_gsGuiDocumentRocket_Sf_SwigStatic_methods,
    swig_gsGuiDocumentRocket_Sf_SwigStatic_attributes,
    swig_gsGuiDocumentRocket_Sf_SwigStatic_constants,
    swig_gsGuiDocumentRocket_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiDocumentRocket_bases[] = {0};
static const char *swig_gsGuiDocumentRocket_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiDocumentRocket = { "gsGuiDocumentRocket", "gsGuiDocumentRocket", &SWIGTYPE_p_gsGuiDocumentRocket,0, swig_delete_gsGuiDocumentRocket, swig_gsGuiDocumentRocket_methods, swig_gsGuiDocumentRocket_attributes, &swig_gsGuiDocumentRocket_Sf_SwigStatic, swig_gsGuiDocumentRocket_meta, swig_gsGuiDocumentRocket_bases, swig_gsGuiDocumentRocket_base_names };

static int _wrap_gsGuiElementQuery_size(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElementQuery *arg1 = (gsGuiElementQuery *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGuiElementQuery::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElementQuery::size",1,"gsGuiElementQuery *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElementQuery,0))){
    SWIG_fail_ptr("gsGuiElementQuery_size",1,SWIGTYPE_p_gsGuiElementQuery);
  }
  
  result = (int)(arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElementQuery_at(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElementQuery *arg1 = (gsGuiElementQuery *) 0 ;
  int arg2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElementQuery::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElementQuery::at",1,"gsGuiElementQuery *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElementQuery::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElementQuery,0))){
    SWIG_fail_ptr("gsGuiElementQuery_at",1,SWIGTYPE_p_gsGuiElementQuery);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGuiElement *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiElementQuery(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElementQuery *result = 0 ;
  
  SWIG_check_num_args("gsGuiElementQuery::gsGuiElementQuery",0,0)
  result = (gsGuiElementQuery *)new gsGuiElementQuery();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementQuery,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiElementQuery(void *obj) {
gsGuiElementQuery *arg1 = (gsGuiElementQuery *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGuiElementQuery(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGuiElementQuery);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGuiElementQuery_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiElementQuery_methods[]= {
    { "size", _wrap_gsGuiElementQuery_size},
    { "at", _wrap_gsGuiElementQuery_at},
    {0,0}
};
static swig_lua_method swig_gsGuiElementQuery_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiElementQuery_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiElementQuery_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiElementQuery_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiElementQuery_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiElementQuery_Sf_SwigStatic = {
    "gsGuiElementQuery",
    swig_gsGuiElementQuery_Sf_SwigStatic_methods,
    swig_gsGuiElementQuery_Sf_SwigStatic_attributes,
    swig_gsGuiElementQuery_Sf_SwigStatic_constants,
    swig_gsGuiElementQuery_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiElementQuery_bases[] = {0};
static const char *swig_gsGuiElementQuery_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiElementQuery = { "gsGuiElementQuery", "gsGuiElementQuery", &SWIGTYPE_p_gsGuiElementQuery,_proxy__wrap_new_gsGuiElementQuery, swig_delete_gsGuiElementQuery, swig_gsGuiElementQuery_methods, swig_gsGuiElementQuery_attributes, &swig_gsGuiElementQuery_Sf_SwigStatic, swig_gsGuiElementQuery_meta, swig_gsGuiElementQuery_bases, swig_gsGuiElementQuery_base_names };

static int _wrap_new_gsGuiElementEventListener__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString temp1 ;
  gsGuiElementEventListener *result = 0 ;
  
  SWIG_check_num_args("gsGuiElementEventListener::gsGuiElementEventListener",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiElementEventListener::gsGuiElementEventListener",1,"gkString const &");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGuiElementEventListener::gsGuiElementEventListener",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiElementEventListener::gsGuiElementEventListener",3,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsGuiElementEventListener *)new gsGuiElementEventListener((gkString const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementEventListener,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiElementEventListener__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsFunction arg2 ;
  gkString temp1 ;
  gsGuiElementEventListener *result = 0 ;
  
  SWIG_check_num_args("gsGuiElementEventListener::gsGuiElementEventListener",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiElementEventListener::gsGuiElementEventListener",1,"gkString const &");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGuiElementEventListener::gsGuiElementEventListener",2,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  result = (gsGuiElementEventListener *)new gsGuiElementEventListener((gkString const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementEventListener,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiElementEventListener(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_new_gsGuiElementEventListener__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_new_gsGuiElementEventListener__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsGuiElementEventListener'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiElementEventListener::gsGuiElementEventListener(gkString const &,gsSelf,gsFunction)\n"
    "    gsGuiElementEventListener::gsGuiElementEventListener(gkString const &,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiElementEventListener_ProcessEvent(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElementEventListener *arg1 = (gsGuiElementEventListener *) 0 ;
  Rocket::Core::Event *arg2 = 0 ;
  
  SWIG_check_num_args("gsGuiElementEventListener::ProcessEvent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElementEventListener::ProcessEvent",1,"gsGuiElementEventListener *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGuiElementEventListener::ProcessEvent",2,"Rocket::Core::Event &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElementEventListener,0))){
    SWIG_fail_ptr("gsGuiElementEventListener_ProcessEvent",1,SWIGTYPE_p_gsGuiElementEventListener);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Rocket__Core__Event,0))){
    SWIG_fail_ptr("gsGuiElementEventListener_ProcessEvent",2,SWIGTYPE_p_Rocket__Core__Event);
  }
  
  (arg1)->ProcessEvent(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiElementEventListener(void *obj) {
gsGuiElementEventListener *arg1 = (gsGuiElementEventListener *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGuiElementEventListener(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGuiElementEventListener);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGuiElementEventListener_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiElementEventListener_methods[]= {
    { "ProcessEvent", _wrap_gsGuiElementEventListener_ProcessEvent},
    {0,0}
};
static swig_lua_method swig_gsGuiElementEventListener_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiElementEventListener_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiElementEventListener_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiElementEventListener_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiElementEventListener_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiElementEventListener_Sf_SwigStatic = {
    "gsGuiElementEventListener",
    swig_gsGuiElementEventListener_Sf_SwigStatic_methods,
    swig_gsGuiElementEventListener_Sf_SwigStatic_attributes,
    swig_gsGuiElementEventListener_Sf_SwigStatic_constants,
    swig_gsGuiElementEventListener_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiElementEventListener_bases[] = {0};
static const char *swig_gsGuiElementEventListener_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiElementEventListener = { "gsGuiElementEventListener", "gsGuiElementEventListener", &SWIGTYPE_p_gsGuiElementEventListener,_proxy__wrap_new_gsGuiElementEventListener, swig_delete_gsGuiElementEventListener, swig_gsGuiElementEventListener_methods, swig_gsGuiElementEventListener_attributes, &swig_gsGuiElementEventListener_Sf_SwigStatic, swig_gsGuiElementEventListener_meta, swig_gsGuiElementEventListener_bases, swig_gsGuiElementEventListener_base_names };

static int _wrap_new_gsGuiElement(lua_State* L) {
  int SWIG_arg = 0;
  gkGuiElement *arg1 = (gkGuiElement *) 0 ;
  gsGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::gsGuiElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::gsGuiElement",1,"gkGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rocket__Core__Element,0))){
    SWIG_fail_ptr("new_gsGuiElement",1,SWIGTYPE_p_Rocket__Core__Element);
  }
  
  result = (gsGuiElement *)new gsGuiElement(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElement,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_addEventListener__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::addEventListener",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::addEventListener",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::addEventListener",2,"gkString const &");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsGuiElement::addEventListener",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsGuiElement::addEventListener",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_addEventListener",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->addEventListener((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_addEventListener__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gsFunction arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::addEventListener",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::addEventListener",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::addEventListener",2,"gkString const &");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiElement::addEventListener",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_addEventListener",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->addEventListener((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_addEventListener(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGuiElement_addEventListener__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_istable(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_gsGuiElement_addEventListener__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiElement_addEventListener'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiElement::addEventListener(gkString const &,gsSelf,gsFunction)\n"
    "    gsGuiElement::addEventListener(gkString const &,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiElement_removeEventListener(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::removeEventListener",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::removeEventListener",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::removeEventListener",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_removeEventListener",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->removeEventListener((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getValue",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getValue",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setValue",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setValue",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setValueIdx(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGuiElement::setValueIdx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setValueIdx",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::setValueIdx",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setValueIdx",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setValueIdx(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setClass(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::setClass",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setClass",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setClass",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsGuiElement::setClass",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setClass",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setClass((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_isClassSet(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsGuiElement::isClassSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::isClassSet",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::isClassSet",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_isClassSet",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->isClassSet((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setPseudoClass(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  bool arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::setPseudoClass",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setPseudoClass",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setPseudoClass",2,"gkString const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsGuiElement::setPseudoClass",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setPseudoClass",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setPseudoClass((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_isPseudoClassSet(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsGuiElement::isPseudoClassSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::isPseudoClassSet",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::isPseudoClassSet",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_isPseudoClassSet",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->isPseudoClassSet((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getAttribute(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getAttribute",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getAttribute",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getAttribute",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->getAttribute((gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setAttribute(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGuiElement::setAttribute",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setAttribute",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setAttribute",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGuiElement::setAttribute",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setAttribute",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->setAttribute((gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_hasAttribute(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsGuiElement::hasAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::hasAttribute",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::hasAttribute",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_hasAttribute",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->hasAttribute((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_removeAttribute(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::removeAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::removeAttribute",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::removeAttribute",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_removeAttribute",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->removeAttribute((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getProperty",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getProperty",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (arg1)->getProperty((gkString const &)*arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getPropertyInt(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  int result;
  
  SWIG_check_num_args("gsGuiElement::getPropertyInt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getPropertyInt",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getPropertyInt",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getPropertyInt",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (int)(arg1)->getPropertyInt((gkString const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGuiElement::setProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setProperty",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setProperty",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGuiElement::setProperty",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setProperty",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->setProperty((gkString const &)*arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_resolveProperty__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  gkString temp2 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::resolveProperty",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::resolveProperty",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::resolveProperty",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGuiElement::resolveProperty",3,"float const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_resolveProperty",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float const)lua_tonumber(L, 3);
  result = (float)(arg1)->resolveProperty((gkString const &)*arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_resolveProperty__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::resolveProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::resolveProperty",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::resolveProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_resolveProperty",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (float)(arg1)->resolveProperty((gkString const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_resolveProperty(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGuiElement_resolveProperty__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGuiElement_resolveProperty__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiElement_resolveProperty'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiElement::resolveProperty(gkString const &,float const)\n"
    "    gsGuiElement::resolveProperty(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiElement_test(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::test",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::test",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_test",1,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->test();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getId(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getId",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getId",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (arg1)->getId();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setId(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::setId",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setId",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setId",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setId",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setId((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getRML(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getRML",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getRML",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getRML",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (arg1)->getRML();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getInnerRML(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getInnerRML",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getInnerRML",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getInnerRML",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (arg1)->getInnerRML();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getChildAmount__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  bool arg2 ;
  int result;
  
  SWIG_check_num_args("gsGuiElement::getChildAmount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getChildAmount",1,"gsGuiElement *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGuiElement::getChildAmount",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getChildAmount",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (int)(arg1)->getChildAmount(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getChildAmount__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGuiElement::getChildAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getChildAmount",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getChildAmount",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (int)(arg1)->getChildAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getChildAmount(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGuiElement_getChildAmount__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGuiElement_getChildAmount__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiElement_getChildAmount'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiElement::getChildAmount(bool)\n"
    "    gsGuiElement::getChildAmount()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiElement_getChild__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int arg2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getChild",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::getChild",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getChild",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGuiElement *)(arg1)->getChild(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getChild__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getChild",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getChild",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getChild",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->getChild();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getChild(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGuiElement_getChild__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGuiElement, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGuiElement_getChild__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGuiElement_getChild'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiElement::getChild(int)\n"
    "    gsGuiElement::getChild()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiElement_appendChild(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gsGuiElement *arg2 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::appendChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::appendChild",1,"gsGuiElement *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGuiElement::appendChild",2,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_appendChild",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_appendChild",2,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->appendChild(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_removeChild(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gsGuiElement *arg2 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::removeChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::removeChild",1,"gsGuiElement *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGuiElement::removeChild",2,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_removeChild",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_removeChild",2,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->removeChild(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_remove(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::remove",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::remove",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_remove",1,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->remove();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_insertBefore(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gsGuiElement *arg2 = (gsGuiElement *) 0 ;
  gsGuiElement *arg3 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::insertBefore",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::insertBefore",1,"gsGuiElement *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGuiElement::insertBefore",2,"gsGuiElement *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsGuiElement::insertBefore",3,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_insertBefore",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_insertBefore",2,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_insertBefore",3,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->insertBefore(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_replaceChild(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gsGuiElement *arg2 = (gsGuiElement *) 0 ;
  gsGuiElement *arg3 = (gsGuiElement *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::replaceChild",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::replaceChild",1,"gsGuiElement *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGuiElement::replaceChild",2,"gsGuiElement *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsGuiElement::replaceChild",3,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_replaceChild",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_replaceChild",2,SWIGTYPE_p_gsGuiElement);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_replaceChild",3,SWIGTYPE_p_gsGuiElement);
  }
  
  (arg1)->replaceChild(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getPreviousSibling(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getPreviousSibling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getPreviousSibling",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getPreviousSibling",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->getPreviousSibling();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getNextSibling(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getNextSibling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getNextSibling",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getNextSibling",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->getNextSibling();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getWidth(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getWidth",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getWidth",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (float)(arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setWidth(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGuiElement::setWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setWidth",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::setWidth",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setWidth",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setWidth(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getHeight(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getHeight",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getHeight",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (float)(arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGuiElement::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setHeight",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::setHeight",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setHeight",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHeight(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getAbsX(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::getAbsX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getAbsX",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getAbsX",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (float)(arg1)->getAbsX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getAbsY(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGuiElement::getAbsY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getAbsY",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getAbsY",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (float)(arg1)->getAbsY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setInnerRML(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("gsGuiElement::setInnerRML",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setInnerRML",1,"gsGuiElement *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("gsGuiElement::setInnerRML",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setInnerRML",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->setInnerRML((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getTagName(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getTagName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getTagName",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getTagName",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (arg1)->getTagName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getSelection(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGuiElement::getSelection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getSelection",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getSelection",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (int)(arg1)->getSelection();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setSelection(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGuiElement::setSelection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setSelection",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::setSelection",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setSelection",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setSelection(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getNumOptions(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGuiElement::getNumOptions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getNumOptions",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getNumOptions",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (int)(arg1)->getNumOptions();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getOption(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsGuiElement::getOption",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getOption",1,"gsGuiElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGuiElement::getOption",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getOption",1,SWIGTYPE_p_gsGuiElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getOption(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_setDatasource(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiElement::setDatasource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::setDatasource",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::setDatasource",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_setDatasource",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setDatasource((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_get(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::get",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_get",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->get();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getParent(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getParent",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getParent",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->getParent();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getElementById(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getElementById",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getElementById",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getElementById",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getElementById",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGuiElement *)(arg1)->getElementById((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_clone(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::clone",1,"gsGuiElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_clone",1,SWIGTYPE_p_gsGuiElement);
  }
  
  result = (gkGuiElement *)(arg1)->clone();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getElementsByClass(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGuiElementQuery *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getElementsByClass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getElementsByClass",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getElementsByClass",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getElementsByClass",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGuiElementQuery *)(arg1)->getElementsByClass((gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementQuery,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiElement_getElementsByTagname(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiElement *arg1 = (gsGuiElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGuiElementQuery *result = 0 ;
  
  SWIG_check_num_args("gsGuiElement::getElementsByTagname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiElement::getElementsByTagname",1,"gsGuiElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiElement::getElementsByTagname",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiElement,0))){
    SWIG_fail_ptr("gsGuiElement_getElementsByTagname",1,SWIGTYPE_p_gsGuiElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGuiElementQuery *)(arg1)->getElementsByTagname((gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiElementQuery,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiElement(void *obj) {
gsGuiElement *arg1 = (gsGuiElement *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGuiElement(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGuiElement);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGuiElement_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiElement_methods[]= {
    { "addEventListener", _wrap_gsGuiElement_addEventListener},
    { "removeEventListener", _wrap_gsGuiElement_removeEventListener},
    { "getValue", _wrap_gsGuiElement_getValue},
    { "setValue", _wrap_gsGuiElement_setValue},
    { "setValueIdx", _wrap_gsGuiElement_setValueIdx},
    { "setClass", _wrap_gsGuiElement_setClass},
    { "isClassSet", _wrap_gsGuiElement_isClassSet},
    { "setPseudoClass", _wrap_gsGuiElement_setPseudoClass},
    { "isPseudoClassSet", _wrap_gsGuiElement_isPseudoClassSet},
    { "getAttribute", _wrap_gsGuiElement_getAttribute},
    { "setAttribute", _wrap_gsGuiElement_setAttribute},
    { "hasAttribute", _wrap_gsGuiElement_hasAttribute},
    { "removeAttribute", _wrap_gsGuiElement_removeAttribute},
    { "getProperty", _wrap_gsGuiElement_getProperty},
    { "getPropertyInt", _wrap_gsGuiElement_getPropertyInt},
    { "setProperty", _wrap_gsGuiElement_setProperty},
    { "resolveProperty", _wrap_gsGuiElement_resolveProperty},
    { "test", _wrap_gsGuiElement_test},
    { "getId", _wrap_gsGuiElement_getId},
    { "setId", _wrap_gsGuiElement_setId},
    { "getRML", _wrap_gsGuiElement_getRML},
    { "getInnerRML", _wrap_gsGuiElement_getInnerRML},
    { "getChildAmount", _wrap_gsGuiElement_getChildAmount},
    { "getChild", _wrap_gsGuiElement_getChild},
    { "appendChild", _wrap_gsGuiElement_appendChild},
    { "removeChild", _wrap_gsGuiElement_removeChild},
    { "remove", _wrap_gsGuiElement_remove},
    { "insertBefore", _wrap_gsGuiElement_insertBefore},
    { "replaceChild", _wrap_gsGuiElement_replaceChild},
    { "getPreviousSibling", _wrap_gsGuiElement_getPreviousSibling},
    { "getNextSibling", _wrap_gsGuiElement_getNextSibling},
    { "getWidth", _wrap_gsGuiElement_getWidth},
    { "setWidth", _wrap_gsGuiElement_setWidth},
    { "getHeight", _wrap_gsGuiElement_getHeight},
    { "setHeight", _wrap_gsGuiElement_setHeight},
    { "getAbsX", _wrap_gsGuiElement_getAbsX},
    { "getAbsY", _wrap_gsGuiElement_getAbsY},
    { "setInnerRML", _wrap_gsGuiElement_setInnerRML},
    { "getTagName", _wrap_gsGuiElement_getTagName},
    { "getSelection", _wrap_gsGuiElement_getSelection},
    { "setSelection", _wrap_gsGuiElement_setSelection},
    { "getNumOptions", _wrap_gsGuiElement_getNumOptions},
    { "getOption", _wrap_gsGuiElement_getOption},
    { "setDatasource", _wrap_gsGuiElement_setDatasource},
    { "get", _wrap_gsGuiElement_get},
    { "getParent", _wrap_gsGuiElement_getParent},
    { "getElementById", _wrap_gsGuiElement_getElementById},
    { "clone", _wrap_gsGuiElement_clone},
    { "getElementsByClass", _wrap_gsGuiElement_getElementsByClass},
    { "getElementsByTagname", _wrap_gsGuiElement_getElementsByTagname},
    {0,0}
};
static swig_lua_method swig_gsGuiElement_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiElement_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiElement_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiElement_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiElement_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiElement_Sf_SwigStatic = {
    "gsGuiElement",
    swig_gsGuiElement_Sf_SwigStatic_methods,
    swig_gsGuiElement_Sf_SwigStatic_attributes,
    swig_gsGuiElement_Sf_SwigStatic_constants,
    swig_gsGuiElement_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiElement_bases[] = {0};
static const char *swig_gsGuiElement_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiElement = { "gsGuiElement", "gsGuiElement", &SWIGTYPE_p_gsGuiElement,_proxy__wrap_new_gsGuiElement, swig_delete_gsGuiElement, swig_gsGuiElement_methods, swig_gsGuiElement_attributes, &swig_gsGuiElement_Sf_SwigStatic, swig_gsGuiElement_meta, swig_gsGuiElement_bases, swig_gsGuiElement_base_names };

static int _wrap_new_gsGUI(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *result = 0 ;
  
  SWIG_check_num_args("gsGUI::gsGUI",0,0)
  result = (gsGUI *)new gsGUI();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_getDocument(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGuiDocumentRocket *result = 0 ;
  
  SWIG_check_num_args("gsGUI::getDocument",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::getDocument",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::getDocument",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_getDocument",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGuiDocumentRocket *)(arg1)->getDocument((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiDocumentRocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_loadFont(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI::loadFont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::loadFont",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::loadFont",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_loadFont",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->loadFont((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_loadCursor(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI::loadCursor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::loadCursor",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::loadCursor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_loadCursor",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->loadCursor((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI__touchMouse(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  
  SWIG_check_num_args("gsGUI::_touchMouse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::_touchMouse",1,"gsGUI *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI__touchMouse",1,SWIGTYPE_p_gsGUI);
  }
  
  (arg1)->_touchMouse();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_showCursor(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI::showCursor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::showCursor",1,"gsGUI *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI::showCursor",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_showCursor",1,SWIGTYPE_p_gsGUI);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->showCursor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_isCursorVisible(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGUI::isCursorVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::isCursorVisible",1,"gsGUI *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_isCursorVisible",1,SWIGTYPE_p_gsGUI);
  }
  
  result = (bool)(arg1)->isCursorVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_setLuaTranslation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI::setLuaTranslation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::setLuaTranslation",1,"gsGUI *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI::setLuaTranslation",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI::setLuaTranslation",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_setLuaTranslation",1,SWIGTYPE_p_gsGUI);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setLuaTranslation(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_setLuaTranslation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI::setLuaTranslation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::setLuaTranslation",1,"gsGUI *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI::setLuaTranslation",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_setLuaTranslation",1,SWIGTYPE_p_gsGUI);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setLuaTranslation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_setLuaTranslation(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI_setLuaTranslation__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI_setLuaTranslation__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI_setLuaTranslation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI::setLuaTranslation(gsSelf,gsFunction)\n"
    "    gsGUI::setLuaTranslation(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI_setCursor(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI::setCursor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::setCursor",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::setCursor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_setCursor",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setCursor((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_showDebugger(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI::showDebugger",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::showDebugger",1,"gsGUI *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI::showDebugger",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_showDebugger",1,SWIGTYPE_p_gsGUI);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->showDebugger(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_getPathPrefix(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGUI::getPathPrefix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::getPathPrefix",1,"gsGUI *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_getPathPrefix",1,SWIGTYPE_p_gsGUI);
  }
  
  result = (arg1)->getPathPrefix();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_setPathPrefix(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI::setPathPrefix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::setPathPrefix",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::setPathPrefix",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_setPathPrefix",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPathPrefix((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI_createElement(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI *arg1 = (gsGUI *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("gsGUI::createElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI::createElement",1,"gsGUI *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI::createElement",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI,0))){
    SWIG_fail_ptr("gsGUI_createElement",1,SWIGTYPE_p_gsGUI);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGuiElement *)(arg1)->createElement((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGUI(void *obj) {
gsGUI *arg1 = (gsGUI *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI_methods[]= {
    { "getDocument", _wrap_gsGUI_getDocument},
    { "loadFont", _wrap_gsGUI_loadFont},
    { "loadCursor", _wrap_gsGUI_loadCursor},
    { "_touchMouse", _wrap_gsGUI__touchMouse},
    { "showCursor", _wrap_gsGUI_showCursor},
    { "isCursorVisible", _wrap_gsGUI_isCursorVisible},
    { "setLuaTranslation", _wrap_gsGUI_setLuaTranslation},
    { "setCursor", _wrap_gsGUI_setCursor},
    { "showDebugger", _wrap_gsGUI_showDebugger},
    { "getPathPrefix", _wrap_gsGUI_getPathPrefix},
    { "setPathPrefix", _wrap_gsGUI_setPathPrefix},
    { "createElement", _wrap_gsGUI_createElement},
    {0,0}
};
static swig_lua_method swig_gsGUI_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI_Sf_SwigStatic = {
    "gsGUI",
    swig_gsGUI_Sf_SwigStatic_methods,
    swig_gsGUI_Sf_SwigStatic_attributes,
    swig_gsGUI_Sf_SwigStatic_constants,
    swig_gsGUI_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI_bases[] = {0};
static const char *swig_gsGUI_base_names[] = {0};
static swig_lua_class _wrap_class_gsGUI = { "gsGUI", "gsGUI", &SWIGTYPE_p_gsGUI,_proxy__wrap_new_gsGUI, swig_delete_gsGUI, swig_gsGUI_methods, swig_gsGUI_attributes, &swig_gsGUI_Sf_SwigStatic, swig_gsGUI_meta, swig_gsGUI_bases, swig_gsGUI_base_names };

static int _wrap_getCurrentGUIElement(lua_State* L) {
  int SWIG_arg = 0;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("getCurrentGUIElement",0,0)
  result = (gkGuiElement *)getCurrentGUIElement();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getDraggedElement(lua_State* L) {
  int SWIG_arg = 0;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("getDraggedElement",0,0)
  result = (gkGuiElement *)getDraggedElement();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentTargetElement(lua_State* L) {
  int SWIG_arg = 0;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("getCurrentTargetElement",0,0)
  result = (gkGuiElement *)getCurrentTargetElement();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentRCSSEvent(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getCurrentRCSSEvent",0,0)
  result = getCurrentRCSSEvent();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentRCSSElement(lua_State* L) {
  int SWIG_arg = 0;
  gkGuiElement *result = 0 ;
  
  SWIG_check_num_args("getCurrentRCSSElement",0,0)
  result = (gkGuiElement *)getCurrentRCSSElement();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GuiElement); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentRCSSProperty(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getCurrentRCSSProperty",0,0)
  result = getCurrentRCSSProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getStringEventParameter(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkString result;
  
  SWIG_check_num_args("getStringEventParameter",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getStringEventParameter",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = getStringEventParameter((gkString const &)*arg1);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getIntEventParameter(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  int result;
  
  SWIG_check_num_args("getIntEventParameter",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getIntEventParameter",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (int)getIntEventParameter((gkString const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiDataSource__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsFunction arg4 ;
  gkString temp1 ;
  gsGuiDataSource *result = 0 ;
  
  SWIG_check_num_args("gsGuiDataSource::gsGuiDataSource",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",1,"gkString const &");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",3,"gsFunction");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",4,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  result = (gsGuiDataSource *)new gsGuiDataSource((gkString const &)*arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiDataSource,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiDataSource__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsSelf arg4 ;
  gsFunction arg5 ;
  gkString temp1 ;
  gsGuiDataSource *result = 0 ;
  
  SWIG_check_num_args("gsGuiDataSource::gsGuiDataSource",5,5)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",1,"gkString const &");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",3,"gsFunction");
  if(!lua_istable(L,4)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",4,"gsSelf");
  if(!lua_isfunction(L,5)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",5,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  result = (gsGuiDataSource *)new gsGuiDataSource((gkString const &)*arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiDataSource,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiDataSource__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsFunction arg2 ;
  gsFunction arg3 ;
  gkString temp1 ;
  gsGuiDataSource *result = 0 ;
  
  SWIG_check_num_args("gsGuiDataSource::gsGuiDataSource",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",1,"gkString const &");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",2,"gsFunction");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiDataSource::gsGuiDataSource",3,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsGuiDataSource *)new gsGuiDataSource((gkString const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiDataSource,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGuiDataSource(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_new_gsGuiDataSource__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_new_gsGuiDataSource__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          _v = lua_istable(L, argv[3]); 
          if (_v) {
            _v = lua_isfunction(L, argv[4]); 
            if (_v) {
              return _wrap_new_gsGuiDataSource__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsGuiDataSource'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGuiDataSource::gsGuiDataSource(gkString const &,gsSelf,gsFunction,gsFunction)\n"
    "    gsGuiDataSource::gsGuiDataSource(gkString const &,gsSelf,gsFunction,gsSelf,gsFunction)\n"
    "    gsGuiDataSource::gsGuiDataSource(gkString const &,gsFunction,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGuiDataSource_update(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDataSource *arg1 = (gsGuiDataSource *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGuiDataSource::update",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDataSource::update",1,"gsGuiDataSource *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGuiDataSource::update",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDataSource,0))){
    SWIG_fail_ptr("gsGuiDataSource_update",1,SWIGTYPE_p_gsGuiDataSource);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->update((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiDataSource(void *obj) {
gsGuiDataSource *arg1 = (gsGuiDataSource *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGuiDataSource(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGuiDataSource);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGuiDataSource_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiDataSource_methods[]= {
    { "update", _wrap_gsGuiDataSource_update},
    {0,0}
};
static swig_lua_method swig_gsGuiDataSource_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiDataSource_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiDataSource_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiDataSource_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiDataSource_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiDataSource_Sf_SwigStatic = {
    "gsGuiDataSource",
    swig_gsGuiDataSource_Sf_SwigStatic_methods,
    swig_gsGuiDataSource_Sf_SwigStatic_attributes,
    swig_gsGuiDataSource_Sf_SwigStatic_constants,
    swig_gsGuiDataSource_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiDataSource_bases[] = {0};
static const char *swig_gsGuiDataSource_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiDataSource = { "gsGuiDataSource", "gsGuiDataSource", &SWIGTYPE_p_gsGuiDataSource,_proxy__wrap_new_gsGuiDataSource, swig_delete_gsGuiDataSource, swig_gsGuiDataSource_methods, swig_gsGuiDataSource_attributes, &swig_gsGuiDataSource_Sf_SwigStatic, swig_gsGuiDataSource_meta, swig_gsGuiDataSource_bases, swig_gsGuiDataSource_base_names };

static int _wrap_new_gsGuiDataFormatter(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString temp1 ;
  gsGuiDataFormatter *result = 0 ;
  
  SWIG_check_num_args("gsGuiDataFormatter::gsGuiDataFormatter",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGuiDataFormatter::gsGuiDataFormatter",1,"gkString const &");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGuiDataFormatter::gsGuiDataFormatter",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGuiDataFormatter::gsGuiDataFormatter",3,"gsFunction");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsGuiDataFormatter *)new gsGuiDataFormatter((gkString const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGuiDataFormatter,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGuiDataFormatter_FormatData(lua_State* L) {
  int SWIG_arg = 0;
  gsGuiDataFormatter *arg1 = (gsGuiDataFormatter *) 0 ;
  Rocket::Core::String *arg2 = 0 ;
  Rocket::Core::StringList *arg3 = 0 ;
  
  SWIG_check_num_args("gsGuiDataFormatter::FormatData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGuiDataFormatter::FormatData",1,"gsGuiDataFormatter *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGuiDataFormatter::FormatData",2,"Rocket::Core::String &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGuiDataFormatter::FormatData",3,"Rocket::Core::StringList const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGuiDataFormatter,0))){
    SWIG_fail_ptr("gsGuiDataFormatter_FormatData",1,SWIGTYPE_p_gsGuiDataFormatter);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Rocket__Core__String,0))){
    SWIG_fail_ptr("gsGuiDataFormatter_FormatData",2,SWIGTYPE_p_Rocket__Core__String);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Rocket__Core__StringList,0))){
    SWIG_fail_ptr("gsGuiDataFormatter_FormatData",3,SWIGTYPE_p_Rocket__Core__StringList);
  }
  
  (arg1)->FormatData(*arg2,(Rocket::Core::StringList const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGuiDataFormatter(void *obj) {
gsGuiDataFormatter *arg1 = (gsGuiDataFormatter *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGuiDataFormatter(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGuiDataFormatter);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGuiDataFormatter_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGuiDataFormatter_methods[]= {
    { "FormatData", _wrap_gsGuiDataFormatter_FormatData},
    {0,0}
};
static swig_lua_method swig_gsGuiDataFormatter_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGuiDataFormatter_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGuiDataFormatter_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGuiDataFormatter_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGuiDataFormatter_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGuiDataFormatter_Sf_SwigStatic = {
    "gsGuiDataFormatter",
    swig_gsGuiDataFormatter_Sf_SwigStatic_methods,
    swig_gsGuiDataFormatter_Sf_SwigStatic_attributes,
    swig_gsGuiDataFormatter_Sf_SwigStatic_constants,
    swig_gsGuiDataFormatter_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGuiDataFormatter_bases[] = {0};
static const char *swig_gsGuiDataFormatter_base_names[] = {0};
static swig_lua_class _wrap_class_gsGuiDataFormatter = { "gsGuiDataFormatter", "gsGuiDataFormatter", &SWIGTYPE_p_gsGuiDataFormatter,_proxy__wrap_new_gsGuiDataFormatter, swig_delete_gsGuiDataFormatter, swig_gsGuiDataFormatter_methods, swig_gsGuiDataFormatter_attributes, &swig_gsGuiDataFormatter_Sf_SwigStatic, swig_gsGuiDataFormatter_meta, swig_gsGuiDataFormatter_bases, swig_gsGuiDataFormatter_base_names };

static int _wrap_WhenEvent_when__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsWhenEvent::when",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->when(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsWhenEvent::when",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsWhenEvent::when",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->when(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsWhenEvent::when",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsWhenEvent::when",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsWhenEvent::when",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->when(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("gsWhenEvent::when",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsWhenEvent::when",3,"gsFunction");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsWhenEvent::when",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->when(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsWhenEvent::when",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsWhenEvent::when",3,"gsFunction");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsWhenEvent::when",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->when(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  gsWhenEvent *arg1 = (gsWhenEvent *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  bool arg4 ;
  
  SWIG_check_num_args("gsWhenEvent::when",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsWhenEvent::when",1,"gsWhenEvent *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsWhenEvent::when",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsWhenEvent::when",3,"gsFunction");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("gsWhenEvent::when",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsWhenEvent,0))){
    SWIG_fail_ptr("WhenEvent_when",1,SWIGTYPE_p_gsWhenEvent);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  arg4 = (lua_toboolean(L, 4)!=0);
  (arg1)->when(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhenEvent_when(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_WhenEvent_when__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_WhenEvent_when__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_WhenEvent_when__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_WhenEvent_when__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_WhenEvent_when__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsWhenEvent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_WhenEvent_when__SWIG_5(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'WhenEvent_when'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsWhenEvent::when(gsFunction)\n"
    "    gsWhenEvent::when(gsSelf,gsFunction)\n"
    "    gsWhenEvent::when(gsSelf,gsFunction,gkString const &)\n"
    "    gsWhenEvent::when(gsSelf,gsFunction,int)\n"
    "    gsWhenEvent::when(gsSelf,gsFunction,float)\n"
    "    gsWhenEvent::when(gsSelf,gsFunction,bool)\n");
  lua_error(L);return 0;
}


static void swig_delete_WhenEvent(void *obj) {
gsWhenEvent *arg1 = (gsWhenEvent *) obj;
delete arg1;
}
static swig_lua_attribute swig_WhenEvent_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_WhenEvent_methods[]= {
    { "when", _wrap_WhenEvent_when},
    {0,0}
};
static swig_lua_method swig_WhenEvent_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_WhenEvent_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_WhenEvent_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_WhenEvent_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_WhenEvent_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_WhenEvent_Sf_SwigStatic = {
    "WhenEvent",
    swig_WhenEvent_Sf_SwigStatic_methods,
    swig_WhenEvent_Sf_SwigStatic_attributes,
    swig_WhenEvent_Sf_SwigStatic_constants,
    swig_WhenEvent_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_WhenEvent_bases[] = {0};
static const char *swig_WhenEvent_base_names[] = {0};
static swig_lua_class _wrap_class_WhenEvent = { "WhenEvent", "WhenEvent", &SWIGTYPE_p_gsWhenEvent,0, swig_delete_WhenEvent, swig_WhenEvent_methods, swig_WhenEvent_attributes, &swig_WhenEvent_Sf_SwigStatic, swig_WhenEvent_meta, swig_WhenEvent_bases, swig_WhenEvent_base_names };

static int _wrap_new_FSM(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *result = 0 ;
  
  SWIG_check_num_args("gsFSM::gsFSM",0,0)
  result = (gsFSM *)new gsFSM();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsFSM,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_update(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  
  SWIG_check_num_args("gsFSM::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::update",1,"gsFSM *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_update",1,SWIGTYPE_p_gsFSM);
  }
  
  (arg1)->update();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_setState(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsFSM::setState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::setState",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::setState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_setState",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setState(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_getState(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int result;
  
  SWIG_check_num_args("gsFSM::getState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::getState",1,"gsFSM *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_getState",1,SWIGTYPE_p_gsFSM);
  }
  
  result = (int)(arg1)->getState();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addStartTrigger(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  
  SWIG_check_num_args("gsFSM::addStartTrigger",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addStartTrigger",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addStartTrigger",2,"int");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsFSM::addStartTrigger",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsFSM::addStartTrigger",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addStartTrigger",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->addStartTrigger(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addEndTrigger(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  
  SWIG_check_num_args("gsFSM::addEndTrigger",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addEndTrigger",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addEndTrigger",2,"int");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsFSM::addEndTrigger",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsFSM::addEndTrigger",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addEndTrigger",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->addEndTrigger(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addEvent(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  
  SWIG_check_num_args("gsFSM::addEvent",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addEvent",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addEvent",2,"int");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsFSM::addEvent",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsFSM::addEvent",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addEvent",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->addEvent(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addTransition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  int arg3 ;
  gsWhenEvent *result = 0 ;
  
  SWIG_check_num_args("gsFSM::addTransition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addTransition",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addTransition",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsFSM::addTransition",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addTransition",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (gsWhenEvent *)(arg1)->addTransition(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsWhenEvent,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addTransition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  gsWhenEvent *result = 0 ;
  
  SWIG_check_num_args("gsFSM::addTransition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addTransition",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addTransition",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsFSM::addTransition",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsFSM::addTransition",4,"unsigned long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addTransition",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned long)lua_tonumber(L, 4);
  result = (gsWhenEvent *)(arg1)->addTransition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsWhenEvent,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addTransition__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsFSM *arg1 = (gsFSM *) 0 ;
  int arg2 ;
  int arg3 ;
  unsigned long arg4 ;
  gsSelf arg5 ;
  gsFunction arg6 ;
  gsWhenEvent *result = 0 ;
  
  SWIG_check_num_args("gsFSM::addTransition",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFSM::addTransition",1,"gsFSM *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsFSM::addTransition",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsFSM::addTransition",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsFSM::addTransition",4,"unsigned long");
  if(!lua_istable(L,5)) SWIG_fail_arg("gsFSM::addTransition",5,"gsSelf");
  if(!lua_isfunction(L,6)) SWIG_fail_arg("gsFSM::addTransition",6,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFSM,0))){
    SWIG_fail_ptr("FSM_addTransition",1,SWIGTYPE_p_gsFSM);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned long)lua_tonumber(L, 4);
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  (&arg6)->m_id = 6; (&arg6)->L = L; 
  result = (gsWhenEvent *)(arg1)->addTransition(arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsWhenEvent,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FSM_addTransition(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsFSM, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_FSM_addTransition__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsFSM, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_FSM_addTransition__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsFSM, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            _v = lua_istable(L, argv[4]); 
            if (_v) {
              _v = lua_isfunction(L, argv[5]); 
              if (_v) {
                return _wrap_FSM_addTransition__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FSM_addTransition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsFSM::addTransition(int,int)\n"
    "    gsFSM::addTransition(int,int,unsigned long)\n"
    "    gsFSM::addTransition(int,int,unsigned long,gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_FSM(void *obj) {
gsFSM *arg1 = (gsFSM *) obj;
delete arg1;
}
static int _proxy__wrap_new_FSM(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FSM);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FSM_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FSM_methods[]= {
    { "update", _wrap_FSM_update},
    { "setState", _wrap_FSM_setState},
    { "getState", _wrap_FSM_getState},
    { "addStartTrigger", _wrap_FSM_addStartTrigger},
    { "addEndTrigger", _wrap_FSM_addEndTrigger},
    { "addEvent", _wrap_FSM_addEvent},
    { "addTransition", _wrap_FSM_addTransition},
    {0,0}
};
static swig_lua_method swig_FSM_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FSM_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FSM_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FSM_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FSM_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FSM_Sf_SwigStatic = {
    "FSM",
    swig_FSM_Sf_SwigStatic_methods,
    swig_FSM_Sf_SwigStatic_attributes,
    swig_FSM_Sf_SwigStatic_constants,
    swig_FSM_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FSM_bases[] = {0};
static const char *swig_FSM_base_names[] = {0};
static swig_lua_class _wrap_class_FSM = { "FSM", "FSM", &SWIGTYPE_p_gsFSM,_proxy__wrap_new_FSM, swig_delete_FSM, swig_FSM_methods, swig_FSM_attributes, &swig_FSM_Sf_SwigStatic, swig_FSM_meta, swig_FSM_bases, swig_FSM_base_names };

static int _wrap_new_NavPath(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *result = 0 ;
  
  SWIG_check_num_args("gsNavPath::gsNavPath",0,0)
  result = (gsNavPath *)new gsNavPath();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNavPath,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_addPoint(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsNavPath::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::addPoint",1,"gsNavPath *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsNavPath::addPoint",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_addPoint",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_addPoint",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->addPoint((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_getPoint(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  int arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsNavPath::getPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::getPoint",1,"gsNavPath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsNavPath::getPoint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_getPoint",1,SWIGTYPE_p_gsNavPath);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getPoint(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_getPointAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  int result;
  
  SWIG_check_num_args("gsNavPath::getPointAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::getPointAmount",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_getPointAmount",1,SWIGTYPE_p_gsNavPath);
  }
  
  result = (int)(arg1)->getPointAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_setCyclic(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsNavPath::setCyclic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::setCyclic",1,"gsNavPath *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsNavPath::setCyclic",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_setCyclic",1,SWIGTYPE_p_gsNavPath);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setCyclic(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_isCyclic(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsNavPath::isCyclic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::isCyclic",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_isCyclic",1,SWIGTYPE_p_gsNavPath);
  }
  
  result = (bool)(arg1)->isCyclic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromCurve__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsCurve *arg2 = (gsCurve *) 0 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsNavPath::createFromCurve",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromCurve",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromCurve",2,"gsCurve *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsNavPath::createFromCurve",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsNavPath::createFromCurve",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",2,SWIGTYPE_p_gsCurve);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->createFromCurve(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromCurve__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsCurve *arg2 = (gsCurve *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsNavPath::createFromCurve",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromCurve",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromCurve",2,"gsCurve *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsNavPath::createFromCurve",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",2,SWIGTYPE_p_gsCurve);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->createFromCurve(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromCurve__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsCurve *arg2 = (gsCurve *) 0 ;
  
  SWIG_check_num_args("gsNavPath::createFromCurve",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromCurve",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromCurve",2,"gsCurve *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsCurve,0))){
    SWIG_fail_ptr("NavPath_createFromCurve",2,SWIGTYPE_p_gsCurve);
  }
  
  (arg1)->createFromCurve(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromCurve(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_NavPath_createFromCurve__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_NavPath_createFromCurve__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsCurve, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_NavPath_createFromCurve__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'NavPath_createFromCurve'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsNavPath::createFromCurve(gsCurve *,float,float)\n"
    "    gsNavPath::createFromCurve(gsCurve *,float)\n"
    "    gsNavPath::createFromCurve(gsCurve *)\n");
  lua_error(L);return 0;
}


static int _wrap_NavPath_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  
  SWIG_check_num_args("gsNavPath::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::clear",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_clear",1,SWIGTYPE_p_gsNavPath);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_show(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  
  SWIG_check_num_args("gsNavPath::show",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::show",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_show",1,SWIGTYPE_p_gsNavPath);
  }
  
  (arg1)->show();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_getLast(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsNavPath::getLast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::getLast",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_getLast",1,SWIGTYPE_p_gsNavPath);
  }
  
  result = (arg1)->getLast();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromRecast__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  float arg5 ;
  gsVector3 *arg6 = 0 ;
  int arg7 ;
  
  SWIG_check_num_args("gsNavPath::createFromRecast",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromRecast",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromRecast",2,"gsScene *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsNavPath::createFromRecast",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsNavPath::createFromRecast",4,"gsVector3 const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsNavPath::createFromRecast",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("gsNavPath::createFromRecast",6,"gsVector3 const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("gsNavPath::createFromRecast",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",2,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",4,SWIGTYPE_p_gsVector3);
  }
  
  arg5 = (float)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",6,SWIGTYPE_p_gsVector3);
  }
  
  arg7 = (int)lua_tonumber(L, 7);
  (arg1)->createFromRecast(arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4,arg5,(gsVector3 const &)*arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromRecast__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  float arg5 ;
  gsVector3 *arg6 = 0 ;
  
  SWIG_check_num_args("gsNavPath::createFromRecast",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromRecast",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromRecast",2,"gsScene *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsNavPath::createFromRecast",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsNavPath::createFromRecast",4,"gsVector3 const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsNavPath::createFromRecast",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("gsNavPath::createFromRecast",6,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",2,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",4,SWIGTYPE_p_gsVector3);
  }
  
  arg5 = (float)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",6,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->createFromRecast(arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4,arg5,(gsVector3 const &)*arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromRecast__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  float arg5 ;
  
  SWIG_check_num_args("gsNavPath::createFromRecast",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromRecast",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromRecast",2,"gsScene *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsNavPath::createFromRecast",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsNavPath::createFromRecast",4,"gsVector3 const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsNavPath::createFromRecast",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",2,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",4,SWIGTYPE_p_gsVector3);
  }
  
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->createFromRecast(arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromRecast__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gsVector3 *arg3 = 0 ;
  gsVector3 *arg4 = 0 ;
  
  SWIG_check_num_args("gsNavPath::createFromRecast",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::createFromRecast",1,"gsNavPath *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsNavPath::createFromRecast",2,"gsScene *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsNavPath::createFromRecast",3,"gsVector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsNavPath::createFromRecast",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",1,SWIGTYPE_p_gsNavPath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",2,SWIGTYPE_p_gsScene);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",3,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("NavPath_createFromRecast",4,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->createFromRecast(arg2,(gsVector3 const &)*arg3,(gsVector3 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NavPath_createFromRecast(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_NavPath_createFromRecast__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_NavPath_createFromRecast__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                return _wrap_NavPath_createFromRecast__SWIG_1(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsNavPath, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_NavPath_createFromRecast__SWIG_0(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'NavPath_createFromRecast'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsNavPath::createFromRecast(gsScene *,gsVector3 const &,gsVector3 const &,float,gsVector3 const &,int)\n"
    "    gsNavPath::createFromRecast(gsScene *,gsVector3 const &,gsVector3 const &,float,gsVector3 const &)\n"
    "    gsNavPath::createFromRecast(gsScene *,gsVector3 const &,gsVector3 const &,float)\n"
    "    gsNavPath::createFromRecast(gsScene *,gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_NavPath_get(lua_State* L) {
  int SWIG_arg = 0;
  gsNavPath *arg1 = (gsNavPath *) 0 ;
  gkNavPath *result = 0 ;
  
  SWIG_check_num_args("gsNavPath::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNavPath::get",1,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("NavPath_get",1,SWIGTYPE_p_gsNavPath);
  }
  
  result = (gkNavPath *)(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkNavPath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NavPath(void *obj) {
gsNavPath *arg1 = (gsNavPath *) obj;
delete arg1;
}
static int _proxy__wrap_new_NavPath(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_NavPath);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_NavPath_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_NavPath_methods[]= {
    { "addPoint", _wrap_NavPath_addPoint},
    { "getPoint", _wrap_NavPath_getPoint},
    { "getPointAmount", _wrap_NavPath_getPointAmount},
    { "setCyclic", _wrap_NavPath_setCyclic},
    { "isCyclic", _wrap_NavPath_isCyclic},
    { "createFromCurve", _wrap_NavPath_createFromCurve},
    { "clear", _wrap_NavPath_clear},
    { "show", _wrap_NavPath_show},
    { "getLast", _wrap_NavPath_getLast},
    { "createFromRecast", _wrap_NavPath_createFromRecast},
    { "get", _wrap_NavPath_get},
    {0,0}
};
static swig_lua_method swig_NavPath_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_NavPath_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_NavPath_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_NavPath_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_NavPath_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_NavPath_Sf_SwigStatic = {
    "NavPath",
    swig_NavPath_Sf_SwigStatic_methods,
    swig_NavPath_Sf_SwigStatic_attributes,
    swig_NavPath_Sf_SwigStatic_constants,
    swig_NavPath_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_NavPath_bases[] = {0};
static const char *swig_NavPath_base_names[] = {0};
static swig_lua_class _wrap_class_NavPath = { "NavPath", "NavPath", &SWIGTYPE_p_gsNavPath,_proxy__wrap_new_NavPath, swig_delete_NavPath, swig_NavPath_methods, swig_NavPath_attributes, &swig_NavPath_Sf_SwigStatic, swig_NavPath_meta, swig_NavPath_bases, swig_NavPath_base_names };

static int _wrap_new_SteerGroup(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerGroup *result = 0 ;
  
  SWIG_check_num_args("gsSteerGroup::gsSteerGroup",0,0)
  result = (gsSteerGroup *)new gsSteerGroup();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerGroup,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerGroup_add(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerGroup *arg1 = (gsSteerGroup *) 0 ;
  gsSteerObject *arg2 = (gsSteerObject *) 0 ;
  
  SWIG_check_num_args("gsSteerGroup::add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerGroup::add",1,"gsSteerGroup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerGroup::add",2,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerGroup_add",1,SWIGTYPE_p_gsSteerGroup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerGroup_add",2,SWIGTYPE_p_gsSteerObject);
  }
  
  (arg1)->add(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerGroup_get(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerGroup *arg1 = (gsSteerGroup *) 0 ;
  OpenSteer::AVGroup *result = 0 ;
  
  SWIG_check_num_args("gsSteerGroup::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerGroup::get",1,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerGroup_get",1,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (OpenSteer::AVGroup *) &(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_OpenSteer__AVGroup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerGroup_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerGroup *arg1 = (gsSteerGroup *) 0 ;
  
  SWIG_check_num_args("gsSteerGroup::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerGroup::clear",1,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerGroup_clear",1,SWIGTYPE_p_gsSteerGroup);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerGroup_getAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerGroup *arg1 = (gsSteerGroup *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSteerGroup::getAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerGroup::getAmount",1,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerGroup_getAmount",1,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (int)(arg1)->getAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SteerGroup(void *obj) {
gsSteerGroup *arg1 = (gsSteerGroup *) obj;
delete arg1;
}
static int _proxy__wrap_new_SteerGroup(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SteerGroup);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SteerGroup_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SteerGroup_methods[]= {
    { "add", _wrap_SteerGroup_add},
    { "get", _wrap_SteerGroup_get},
    { "clear", _wrap_SteerGroup_clear},
    { "getAmount", _wrap_SteerGroup_getAmount},
    {0,0}
};
static swig_lua_method swig_SteerGroup_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SteerGroup_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SteerGroup_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SteerGroup_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SteerGroup_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SteerGroup_SwigStatic = {
    "SteerGroup",
    swig_SteerGroup_SwigStatic_methods,
    swig_SteerGroup_SwigStatic_attributes,
    swig_SteerGroup_SwigStatic_constants,
    swig_SteerGroup_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SteerGroup_bases[] = {0};
static const char *swig_SteerGroup_base_names[] = {0};
static swig_lua_class _wrap_class_SteerGroup = { "SteerGroup", "SteerGroup", &SWIGTYPE_p_gsSteerGroup,_proxy__wrap_new_SteerGroup, swig_delete_SteerGroup, swig_SteerGroup_methods, swig_SteerGroup_attributes, &swig_SteerGroup_SwigStatic, swig_SteerGroup_meta, swig_SteerGroup_bases, swig_SteerGroup_base_names };

static int _wrap_new_SteerRayObstacle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsSteerRayObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerRayObstacle::gsSteerRayObstacle",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSteerRayObstacle::gsSteerRayObstacle",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (gsSteerRayObstacle *)new gsSteerRayObstacle(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerRayObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerRayObstacle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerRayObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerRayObstacle::gsSteerRayObstacle",0,0)
  result = (gsSteerRayObstacle *)new gsSteerRayObstacle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerRayObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerRayObstacle(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SteerRayObstacle__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_SteerRayObstacle__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SteerRayObstacle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerRayObstacle::gsSteerRayObstacle(float)\n"
    "    gsSteerRayObstacle::gsSteerRayObstacle()\n");
  lua_error(L);return 0;
}


static int _wrap_SteerRayObstacle_get(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerRayObstacle *arg1 = (gsSteerRayObstacle *) 0 ;
  gkSceneRayObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerRayObstacle::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerRayObstacle::get",1,"gsSteerRayObstacle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerRayObstacle,0))){
    SWIG_fail_ptr("SteerRayObstacle_get",1,SWIGTYPE_p_gsSteerRayObstacle);
  }
  
  result = (gkSceneRayObstacle *)(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSceneRayObstacle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SteerRayObstacle(void *obj) {
gsSteerRayObstacle *arg1 = (gsSteerRayObstacle *) obj;
delete arg1;
}
static int _proxy__wrap_new_SteerRayObstacle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SteerRayObstacle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SteerRayObstacle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SteerRayObstacle_methods[]= {
    { "get", _wrap_SteerRayObstacle_get},
    {0,0}
};
static swig_lua_method swig_SteerRayObstacle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SteerRayObstacle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SteerRayObstacle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SteerRayObstacle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SteerRayObstacle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SteerRayObstacle_Sf_SwigStatic = {
    "SteerRayObstacle",
    swig_SteerRayObstacle_Sf_SwigStatic_methods,
    swig_SteerRayObstacle_Sf_SwigStatic_attributes,
    swig_SteerRayObstacle_Sf_SwigStatic_constants,
    swig_SteerRayObstacle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SteerRayObstacle_bases[] = {0};
static const char *swig_SteerRayObstacle_base_names[] = {0};
static swig_lua_class _wrap_class_SteerRayObstacle = { "SteerRayObstacle", "SteerRayObstacle", &SWIGTYPE_p_gsSteerRayObstacle,_proxy__wrap_new_SteerRayObstacle, swig_delete_SteerRayObstacle, swig_SteerRayObstacle_methods, swig_SteerRayObstacle_attributes, &swig_SteerRayObstacle_Sf_SwigStatic, swig_SteerRayObstacle_meta, swig_SteerRayObstacle_bases, swig_SteerRayObstacle_base_names };

static int _wrap_new_SteerSweptObstacle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  int arg3 ;
  int arg4 ;
  gsSteerSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::gsSteerSweptObstacle",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",4,"int");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (gsSteerSweptObstacle *)new gsSteerSweptObstacle(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerSweptObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerSweptObstacle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  int arg3 ;
  gsSteerSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::gsSteerSweptObstacle",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",3,"int");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (gsSteerSweptObstacle *)new gsSteerSweptObstacle(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerSweptObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerSweptObstacle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  gsSteerSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::gsSteerSweptObstacle",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (gsSteerSweptObstacle *)new gsSteerSweptObstacle(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerSweptObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerSweptObstacle__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  gsSteerSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::gsSteerSweptObstacle",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::gsSteerSweptObstacle",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (gsSteerSweptObstacle *)new gsSteerSweptObstacle(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerSweptObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerSweptObstacle__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::gsSteerSweptObstacle",0,0)
  result = (gsSteerSweptObstacle *)new gsSteerSweptObstacle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerSweptObstacle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerSweptObstacle(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SteerSweptObstacle__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_SteerSweptObstacle__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SteerSweptObstacle__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_SteerSweptObstacle__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_SteerSweptObstacle__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SteerSweptObstacle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerSweptObstacle::gsSteerSweptObstacle(float,float,int,int)\n"
    "    gsSteerSweptObstacle::gsSteerSweptObstacle(float,float,int)\n"
    "    gsSteerSweptObstacle::gsSteerSweptObstacle(float,float)\n"
    "    gsSteerSweptObstacle::gsSteerSweptObstacle(float)\n"
    "    gsSteerSweptObstacle::gsSteerSweptObstacle()\n");
  lua_error(L);return 0;
}


static int _wrap_SteerSweptObstacle_ignoreObject(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerSweptObstacle *arg1 = (gsSteerSweptObstacle *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::ignoreObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::ignoreObject",1,"gsSteerSweptObstacle *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::ignoreObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerSweptObstacle_ignoreObject",1,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("SteerSweptObstacle_ignoreObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->ignoreObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerSweptObstacle_reincludeObject(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerSweptObstacle *arg1 = (gsSteerSweptObstacle *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::reincludeObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::reincludeObject",1,"gsSteerSweptObstacle *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::reincludeObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerSweptObstacle_reincludeObject",1,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("SteerSweptObstacle_reincludeObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->reincludeObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerSweptObstacle_setPositiveList(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerSweptObstacle *arg1 = (gsSteerSweptObstacle *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::setPositiveList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::setPositiveList",1,"gsSteerSweptObstacle *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsSteerSweptObstacle::setPositiveList",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerSweptObstacle_setPositiveList",1,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setPositiveList(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerSweptObstacle_get(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerSweptObstacle *arg1 = (gsSteerSweptObstacle *) 0 ;
  gkSceneSweptObstacle *result = 0 ;
  
  SWIG_check_num_args("gsSteerSweptObstacle::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerSweptObstacle::get",1,"gsSteerSweptObstacle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerSweptObstacle_get",1,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  result = (gkSceneSweptObstacle *)(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSceneSweptObstacle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SteerSweptObstacle(void *obj) {
gsSteerSweptObstacle *arg1 = (gsSteerSweptObstacle *) obj;
delete arg1;
}
static int _proxy__wrap_new_SteerSweptObstacle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SteerSweptObstacle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SteerSweptObstacle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SteerSweptObstacle_methods[]= {
    { "ignoreObject", _wrap_SteerSweptObstacle_ignoreObject},
    { "reincludeObject", _wrap_SteerSweptObstacle_reincludeObject},
    { "setPositiveList", _wrap_SteerSweptObstacle_setPositiveList},
    { "get", _wrap_SteerSweptObstacle_get},
    {0,0}
};
static swig_lua_method swig_SteerSweptObstacle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SteerSweptObstacle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SteerSweptObstacle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SteerSweptObstacle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SteerSweptObstacle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SteerSweptObstacle_Sf_SwigStatic = {
    "SteerSweptObstacle",
    swig_SteerSweptObstacle_Sf_SwigStatic_methods,
    swig_SteerSweptObstacle_Sf_SwigStatic_attributes,
    swig_SteerSweptObstacle_Sf_SwigStatic_constants,
    swig_SteerSweptObstacle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SteerSweptObstacle_bases[] = {0};
static const char *swig_SteerSweptObstacle_base_names[] = {0};
static swig_lua_class _wrap_class_SteerSweptObstacle = { "SteerSweptObstacle", "SteerSweptObstacle", &SWIGTYPE_p_gsSteerSweptObstacle,_proxy__wrap_new_SteerSweptObstacle, swig_delete_SteerSweptObstacle, swig_SteerSweptObstacle_methods, swig_SteerSweptObstacle_attributes, &swig_SteerSweptObstacle_Sf_SwigStatic, swig_SteerSweptObstacle_meta, swig_SteerSweptObstacle_bases, swig_SteerSweptObstacle_base_names };

static int _wrap_new_SteerObstacleGroup(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObstacleGroup *result = 0 ;
  
  SWIG_check_num_args("gsSteerObstacleGroup::gsSteerObstacleGroup",0,0)
  result = (gsSteerObstacleGroup *)new gsSteerObstacleGroup();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerObstacleGroup,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObstacleGroup_add(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObstacleGroup *arg1 = (gsSteerObstacleGroup *) 0 ;
  gsSteerSweptObstacle *arg2 = (gsSteerSweptObstacle *) 0 ;
  
  SWIG_check_num_args("gsSteerObstacleGroup::add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObstacleGroup::add",1,"gsSteerObstacleGroup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObstacleGroup::add",2,"gsSteerSweptObstacle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObstacleGroup,0))){
    SWIG_fail_ptr("SteerObstacleGroup_add",1,SWIGTYPE_p_gsSteerObstacleGroup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerObstacleGroup_add",2,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  (arg1)->add(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObstacleGroup_get(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObstacleGroup *arg1 = (gsSteerObstacleGroup *) 0 ;
  OpenSteer::ObstacleGroup *result = 0 ;
  
  SWIG_check_num_args("gsSteerObstacleGroup::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObstacleGroup::get",1,"gsSteerObstacleGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObstacleGroup,0))){
    SWIG_fail_ptr("SteerObstacleGroup_get",1,SWIGTYPE_p_gsSteerObstacleGroup);
  }
  
  result = (OpenSteer::ObstacleGroup *) &(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_OpenSteer__ObstacleGroup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SteerObstacleGroup(void *obj) {
gsSteerObstacleGroup *arg1 = (gsSteerObstacleGroup *) obj;
delete arg1;
}
static int _proxy__wrap_new_SteerObstacleGroup(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SteerObstacleGroup);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SteerObstacleGroup_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SteerObstacleGroup_methods[]= {
    { "add", _wrap_SteerObstacleGroup_add},
    { "get", _wrap_SteerObstacleGroup_get},
    {0,0}
};
static swig_lua_method swig_SteerObstacleGroup_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SteerObstacleGroup_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SteerObstacleGroup_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SteerObstacleGroup_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SteerObstacleGroup_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SteerObstacleGroup_SwigStatic = {
    "SteerObstacleGroup",
    swig_SteerObstacleGroup_SwigStatic_methods,
    swig_SteerObstacleGroup_SwigStatic_attributes,
    swig_SteerObstacleGroup_SwigStatic_constants,
    swig_SteerObstacleGroup_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SteerObstacleGroup_bases[] = {0};
static const char *swig_SteerObstacleGroup_base_names[] = {0};
static swig_lua_class _wrap_class_SteerObstacleGroup = { "SteerObstacleGroup", "SteerObstacleGroup", &SWIGTYPE_p_gsSteerObstacleGroup,_proxy__wrap_new_SteerObstacleGroup, swig_delete_SteerObstacleGroup, swig_SteerObstacleGroup_methods, swig_SteerObstacleGroup_attributes, &swig_SteerObstacleGroup_SwigStatic, swig_SteerObstacleGroup_meta, swig_SteerObstacleGroup_bases, swig_SteerObstacleGroup_base_names };

static int _wrap_new_gsSteerPathFollowing__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  gsSteerPathFollowing *result = 0 ;
  
  SWIG_check_num_args("gsSteerPathFollowing::gsSteerPathFollowing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerPathFollowing::gsSteerPathFollowing",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerPathFollowing::gsSteerPathFollowing",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("new_gsSteerPathFollowing",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (gsSteerPathFollowing *)new gsSteerPathFollowing(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerPathFollowing,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsSteerPathFollowing__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  gsSteerPathFollowing *result = 0 ;
  
  SWIG_check_num_args("gsSteerPathFollowing::gsSteerPathFollowing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerPathFollowing::gsSteerPathFollowing",1,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("new_gsSteerPathFollowing",1,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gsSteerPathFollowing *)new gsSteerPathFollowing(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerPathFollowing,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsSteerPathFollowing(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsSteerPathFollowing__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_gsSteerPathFollowing__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsSteerPathFollowing'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerPathFollowing::gsSteerPathFollowing(gsGameObject *,float)\n"
    "    gsSteerPathFollowing::gsSteerPathFollowing(gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsSteerPathFollowing_setSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerPathFollowing *arg1 = (gsSteerPathFollowing *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSteerPathFollowing::setSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerPathFollowing::setSpeed",1,"gsSteerPathFollowing *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerPathFollowing::setSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerPathFollowing,0))){
    SWIG_fail_ptr("gsSteerPathFollowing_setSpeed",1,SWIGTYPE_p_gsSteerPathFollowing);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSteerPathFollowing_setPath(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerPathFollowing *arg1 = (gsSteerPathFollowing *) 0 ;
  gsNavPath *arg2 = (gsNavPath *) 0 ;
  
  SWIG_check_num_args("gsSteerPathFollowing::setPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerPathFollowing::setPath",1,"gsSteerPathFollowing *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerPathFollowing::setPath",2,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerPathFollowing,0))){
    SWIG_fail_ptr("gsSteerPathFollowing_setPath",1,SWIGTYPE_p_gsSteerPathFollowing);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("gsSteerPathFollowing_setPath",2,SWIGTYPE_p_gsNavPath);
  }
  
  (arg1)->setPath(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSteerPathFollowing_update(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerPathFollowing *arg1 = (gsSteerPathFollowing *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSteerPathFollowing::update",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerPathFollowing::update",1,"gsSteerPathFollowing *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerPathFollowing::update",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerPathFollowing,0))){
    SWIG_fail_ptr("gsSteerPathFollowing_update",1,SWIGTYPE_p_gsSteerPathFollowing);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->update(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSteerPathFollowing(void *obj) {
gsSteerPathFollowing *arg1 = (gsSteerPathFollowing *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSteerPathFollowing(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSteerPathFollowing);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSteerPathFollowing_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSteerPathFollowing_methods[]= {
    { "setSpeed", _wrap_gsSteerPathFollowing_setSpeed},
    { "setPath", _wrap_gsSteerPathFollowing_setPath},
    { "update", _wrap_gsSteerPathFollowing_update},
    {0,0}
};
static swig_lua_method swig_gsSteerPathFollowing_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSteerPathFollowing_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSteerPathFollowing_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSteerPathFollowing_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSteerPathFollowing_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSteerPathFollowing_Sf_SwigStatic = {
    "gsSteerPathFollowing",
    swig_gsSteerPathFollowing_Sf_SwigStatic_methods,
    swig_gsSteerPathFollowing_Sf_SwigStatic_attributes,
    swig_gsSteerPathFollowing_Sf_SwigStatic_constants,
    swig_gsSteerPathFollowing_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSteerPathFollowing_bases[] = {0};
static const char *swig_gsSteerPathFollowing_base_names[] = {0};
static swig_lua_class _wrap_class_gsSteerPathFollowing = { "gsSteerPathFollowing", "gsSteerPathFollowing", &SWIGTYPE_p_gsSteerPathFollowing,_proxy__wrap_new_gsSteerPathFollowing, swig_delete_gsSteerPathFollowing, swig_gsSteerPathFollowing_methods, swig_gsSteerPathFollowing_attributes, &swig_gsSteerPathFollowing_Sf_SwigStatic, swig_gsSteerPathFollowing_meta, swig_gsSteerPathFollowing_bases, swig_gsSteerPathFollowing_base_names };

static int _wrap_new_MyVehicle(lua_State* L) {
  int SWIG_arg = 0;
  MyVehicle *result = 0 ;
  
  SWIG_check_num_args("MyVehicle::MyVehicle",0,0)
  result = (MyVehicle *)new MyVehicle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MyVehicle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MyVehicle(void *obj) {
MyVehicle *arg1 = (MyVehicle *) obj;
delete arg1;
}
static int _proxy__wrap_new_MyVehicle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MyVehicle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MyVehicle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MyVehicle_methods[]= {
    {0,0}
};
static swig_lua_method swig_MyVehicle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MyVehicle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MyVehicle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MyVehicle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MyVehicle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MyVehicle_Sf_SwigStatic = {
    "MyVehicle",
    swig_MyVehicle_Sf_SwigStatic_methods,
    swig_MyVehicle_Sf_SwigStatic_attributes,
    swig_MyVehicle_Sf_SwigStatic_constants,
    swig_MyVehicle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MyVehicle_bases[] = {0};
static const char *swig_MyVehicle_base_names[] = {0};
static swig_lua_class _wrap_class_MyVehicle = { "MyVehicle", "MyVehicle", &SWIGTYPE_p_MyVehicle,_proxy__wrap_new_MyVehicle, swig_delete_MyVehicle, swig_MyVehicle_methods, swig_MyVehicle_attributes, &swig_MyVehicle_Sf_SwigStatic, swig_MyVehicle_meta, swig_MyVehicle_bases, swig_MyVehicle_base_names };

static int _wrap_new_SteerObject__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  float arg3 ;
  gsSteerObject *result = 0 ;
  
  SWIG_check_num_args("gsSteerObject::gsSteerObject",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::gsSteerObject",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::gsSteerObject",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::gsSteerObject",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("new_SteerObject",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (gsSteerObject *)new gsSteerObject(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerObject,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerObject__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGameObject *arg1 = (gsGameObject *) 0 ;
  float arg2 ;
  gsSteerObject *result = 0 ;
  
  SWIG_check_num_args("gsSteerObject::gsSteerObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::gsSteerObject",1,"gsGameObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::gsSteerObject",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("new_SteerObject",1,SWIGTYPE_p_gsGameObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (gsSteerObject *)new gsSteerObject(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSteerObject,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SteerObject(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SteerObject__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_SteerObject__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SteerObject'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::gsSteerObject(gsGameObject *,float,float)\n"
    "    gsSteerObject::gsSteerObject(gsGameObject *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_get(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  OpenSteer::AbstractVehicle *result = 0 ;
  
  SWIG_check_num_args("gsSteerObject::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::get",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_get",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (OpenSteer::AbstractVehicle *)(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_OpenSteer__AbstractVehicle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_applySteeringForce(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsSteerObject::applySteeringForce",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::applySteeringForce",1,"gsSteerObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSteerObject::applySteeringForce",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::applySteeringForce",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_applySteeringForce",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("SteerObject_applySteeringForce",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->applySteeringForce((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_applyBreakingForce(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsSteerObject::applyBreakingForce",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::applyBreakingForce",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::applyBreakingForce",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::applyBreakingForce",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_applyBreakingForce",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->applyBreakingForce(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_radius(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSteerObject::radius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::radius",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_radius",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (float)(arg1)->radius();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSteerObject::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::setRadius",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::setRadius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_setRadius",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRadius(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_speed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSteerObject::speed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::speed",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_speed",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (float)(arg1)->speed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_setSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSteerObject::setSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::setSpeed",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::setSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_setSpeed",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_maxSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSteerObject::maxSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::maxSpeed",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_maxSpeed",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (float)(arg1)->maxSpeed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_setMaxSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSteerObject::setMaxSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::setMaxSpeed",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::setMaxSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_setMaxSpeed",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMaxSpeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_forward(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::forward",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::forward",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_forward",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->forward();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_side(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::side",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::side",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_side",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->side();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_up(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::up",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::up",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_up",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->up();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_predictedPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::predictedPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::predictedPosition",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::predictedPosition",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_predictedPosition",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->predictedPosition(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_velocity(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::velocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::velocity",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_velocity",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->velocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_position(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::position",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::position",1,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_position",1,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->position();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForWander(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForWander",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForWander",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::steerForWander",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForWander",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->steerForWander(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForPursuit__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerObject *arg2 = (gsSteerObject *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForPursuit",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForPursuit",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForPursuit",2,"gsSteerObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerForPursuit",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForPursuit",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForPursuit",2,SWIGTYPE_p_gsSteerObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerForPursuit(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForPursuit__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerObject *arg2 = (gsSteerObject *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForPursuit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForPursuit",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForPursuit",2,"gsSteerObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForPursuit",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForPursuit",2,SWIGTYPE_p_gsSteerObject);
  }
  
  result = (arg1)->steerForPursuit(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForPursuit(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerForPursuit__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerForPursuit__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerForPursuit'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerForPursuit(gsSteerObject *,float)\n"
    "    gsSteerObject::steerForPursuit(gsSteerObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerForSeparation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  float arg3 ;
  float arg4 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForSeparation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForSeparation",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForSeparation",2,"gsSteerGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerForSeparation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsSteerObject::steerForSeparation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (arg1)->steerForSeparation(arg2,arg3,arg4);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForSeparation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForSeparation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForSeparation",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForSeparation",2,"gsSteerGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerForSeparation",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerForSeparation(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForSeparation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForSeparation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForSeparation",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForSeparation",2,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForSeparation",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (arg1)->steerForSeparation(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForSeparation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerForSeparation__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerForSeparation__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_SteerObject_steerForSeparation__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerForSeparation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerForSeparation(gsSteerGroup *,float,float)\n"
    "    gsSteerObject::steerForSeparation(gsSteerGroup *,float)\n"
    "    gsSteerObject::steerForSeparation(gsSteerGroup *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerForSeek(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 *arg2 = 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForSeek",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForSeek",1,"gsSteerObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSteerObject::steerForSeek",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForSeek",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("SteerObject_steerForSeek",2,SWIGTYPE_p_gsVector3);
  }
  
  result = (arg1)->steerForSeek((gsVector3 const &)*arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForFlee(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsVector3 arg2 ;
  gsVector3 *argp2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForFlee",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForFlee",1,"gsSteerObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSteerObject::steerForFlee",2,"gsVector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForFlee",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("SteerObject_steerForFlee",2,SWIGTYPE_p_gsVector3);
  }
  arg2 = *argp2;
  
  result = (arg1)->steerForFlee(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidNeighbours__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidNeighbours",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidNeighbours",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidNeighbours",2,"gsSteerGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerToAvoidNeighbours",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidNeighbours",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidNeighbours",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerToAvoidNeighbours(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidNeighbours__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidNeighbours",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidNeighbours",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidNeighbours",2,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidNeighbours",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidNeighbours",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (arg1)->steerToAvoidNeighbours(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidNeighbours(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerToAvoidNeighbours__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerToAvoidNeighbours__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerToAvoidNeighbours'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerToAvoidNeighbours(gsSteerGroup *,float)\n"
    "    gsSteerObject::steerToAvoidNeighbours(gsSteerGroup *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerToAvoidObstacles__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerObstacleGroup *arg2 = (gsSteerObstacleGroup *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidObstacles",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacles",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacles",2,"gsSteerObstacleGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacles",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacles",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerObstacleGroup,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacles",2,SWIGTYPE_p_gsSteerObstacleGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerToAvoidObstacles(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidObstacles__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerObstacleGroup *arg2 = (gsSteerObstacleGroup *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidObstacles",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacles",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacles",2,"gsSteerObstacleGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacles",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerObstacleGroup,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacles",2,SWIGTYPE_p_gsSteerObstacleGroup);
  }
  
  result = (arg1)->steerToAvoidObstacles(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidObstacles(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerObstacleGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerToAvoidObstacles__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerObstacleGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerToAvoidObstacles__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerToAvoidObstacles'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerToAvoidObstacles(gsSteerObstacleGroup *,float)\n"
    "    gsSteerObject::steerToAvoidObstacles(gsSteerObstacleGroup *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerToAvoidObstacle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerSweptObstacle *arg2 = (gsSteerSweptObstacle *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidObstacle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacle",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacle",2,"gsSteerSweptObstacle *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacle",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacle",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacle",2,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerToAvoidObstacle(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidObstacle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerSweptObstacle *arg2 = (gsSteerSweptObstacle *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToAvoidObstacle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacle",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToAvoidObstacle",2,"gsSteerSweptObstacle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacle",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerSweptObstacle,0))){
    SWIG_fail_ptr("SteerObject_steerToAvoidObstacle",2,SWIGTYPE_p_gsSteerSweptObstacle);
  }
  
  result = (arg1)->steerToAvoidObstacle(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToAvoidObstacle(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerSweptObstacle, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerToAvoidObstacle__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerSweptObstacle, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerToAvoidObstacle__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerToAvoidObstacle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerToAvoidObstacle(gsSteerSweptObstacle *,float)\n"
    "    gsSteerObject::steerToAvoidObstacle(gsSteerSweptObstacle *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerForAlignment__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  float arg3 ;
  float arg4 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForAlignment",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForAlignment",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForAlignment",2,"gsSteerGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerForAlignment",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsSteerObject::steerForAlignment",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (arg1)->steerForAlignment(arg2,arg3,arg4);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForAlignment__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  float arg3 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForAlignment",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForAlignment",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForAlignment",2,"gsSteerGroup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerForAlignment",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (arg1)->steerForAlignment(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForAlignment__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForAlignment",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForAlignment",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerForAlignment",2,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerForAlignment",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (arg1)->steerForAlignment(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForAlignment(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_SteerObject_steerForAlignment__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SteerObject_steerForAlignment__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSteerObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSteerGroup, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_SteerObject_steerForAlignment__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SteerObject_steerForAlignment'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSteerObject::steerForAlignment(gsSteerGroup *,float,float)\n"
    "    gsSteerObject::steerForAlignment(gsSteerGroup *,float)\n"
    "    gsSteerObject::steerForAlignment(gsSteerGroup *)\n");
  lua_error(L);return 0;
}


static int _wrap_SteerObject_steerToFlock(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  gsSteerGroup *arg2 = (gsSteerGroup *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToFlock",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToFlock",1,"gsSteerObject *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSteerObject::steerToFlock",2,"gsSteerGroup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToFlock",1,SWIGTYPE_p_gsSteerObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSteerGroup,0))){
    SWIG_fail_ptr("SteerObject_steerToFlock",2,SWIGTYPE_p_gsSteerGroup);
  }
  
  result = (arg1)->steerToFlock(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToFollowPath(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  int arg2 ;
  float arg3 ;
  gsNavPath *arg4 = (gsNavPath *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToFollowPath",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToFollowPath",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::steerToFollowPath",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSteerObject::steerToFollowPath",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("gsSteerObject::steerToFollowPath",4,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToFollowPath",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("SteerObject_steerToFollowPath",4,SWIGTYPE_p_gsNavPath);
  }
  
  result = (arg1)->steerToFollowPath(arg2,arg3,arg4);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerToStayOnPath(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  gsNavPath *arg3 = (gsNavPath *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerToStayOnPath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerToStayOnPath",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::steerToStayOnPath",2,"float");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsSteerObject::steerToStayOnPath",3,"gsNavPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerToStayOnPath",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsNavPath,0))){
    SWIG_fail_ptr("SteerObject_steerToStayOnPath",3,SWIGTYPE_p_gsNavPath);
  }
  
  result = (arg1)->steerToStayOnPath(arg2,arg3);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SteerObject_steerForTargetSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsSteerObject *arg1 = (gsSteerObject *) 0 ;
  float arg2 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSteerObject::steerForTargetSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSteerObject::steerForTargetSpeed",1,"gsSteerObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSteerObject::steerForTargetSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSteerObject,0))){
    SWIG_fail_ptr("SteerObject_steerForTargetSpeed",1,SWIGTYPE_p_gsSteerObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->steerForTargetSpeed(arg2);
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SteerObject(void *obj) {
gsSteerObject *arg1 = (gsSteerObject *) obj;
delete arg1;
}
static int _proxy__wrap_new_SteerObject(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SteerObject);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SteerObject_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SteerObject_methods[]= {
    { "get", _wrap_SteerObject_get},
    { "applySteeringForce", _wrap_SteerObject_applySteeringForce},
    { "applyBreakingForce", _wrap_SteerObject_applyBreakingForce},
    { "radius", _wrap_SteerObject_radius},
    { "setRadius", _wrap_SteerObject_setRadius},
    { "speed", _wrap_SteerObject_speed},
    { "setSpeed", _wrap_SteerObject_setSpeed},
    { "maxSpeed", _wrap_SteerObject_maxSpeed},
    { "setMaxSpeed", _wrap_SteerObject_setMaxSpeed},
    { "forward", _wrap_SteerObject_forward},
    { "side", _wrap_SteerObject_side},
    { "up", _wrap_SteerObject_up},
    { "predictedPosition", _wrap_SteerObject_predictedPosition},
    { "velocity", _wrap_SteerObject_velocity},
    { "position", _wrap_SteerObject_position},
    { "steerForWander", _wrap_SteerObject_steerForWander},
    { "steerForPursuit", _wrap_SteerObject_steerForPursuit},
    { "steerForSeparation", _wrap_SteerObject_steerForSeparation},
    { "steerForSeek", _wrap_SteerObject_steerForSeek},
    { "steerForFlee", _wrap_SteerObject_steerForFlee},
    { "steerToAvoidNeighbours", _wrap_SteerObject_steerToAvoidNeighbours},
    { "steerToAvoidObstacles", _wrap_SteerObject_steerToAvoidObstacles},
    { "steerToAvoidObstacle", _wrap_SteerObject_steerToAvoidObstacle},
    { "steerForAlignment", _wrap_SteerObject_steerForAlignment},
    { "steerToFlock", _wrap_SteerObject_steerToFlock},
    { "steerToFollowPath", _wrap_SteerObject_steerToFollowPath},
    { "steerToStayOnPath", _wrap_SteerObject_steerToStayOnPath},
    { "steerForTargetSpeed", _wrap_SteerObject_steerForTargetSpeed},
    {0,0}
};
static swig_lua_method swig_SteerObject_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SteerObject_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SteerObject_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SteerObject_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SteerObject_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SteerObject_Sf_SwigStatic = {
    "SteerObject",
    swig_SteerObject_Sf_SwigStatic_methods,
    swig_SteerObject_Sf_SwigStatic_attributes,
    swig_SteerObject_Sf_SwigStatic_constants,
    swig_SteerObject_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SteerObject_bases[] = {0};
static const char *swig_SteerObject_base_names[] = {0};
static swig_lua_class _wrap_class_SteerObject = { "SteerObject", "SteerObject", &SWIGTYPE_p_gsSteerObject,_proxy__wrap_new_SteerObject, swig_delete_SteerObject, swig_SteerObject_methods, swig_SteerObject_attributes, &swig_SteerObject_Sf_SwigStatic, swig_SteerObject_meta, swig_SteerObject_bases, swig_SteerObject_base_names };

static int _wrap_new_gsAnimationPlayer(lua_State* L) {
  int SWIG_arg = 0;
  gkAnimationPlayer *arg1 = (gkAnimationPlayer *) 0 ;
  gsAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsAnimationPlayer::gsAnimationPlayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::gsAnimationPlayer",1,"gkAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAnimationPlayer,0))){
    SWIG_fail_ptr("new_gsAnimationPlayer",1,SWIGTYPE_p_gkAnimationPlayer);
  }
  
  result = (gsAnimationPlayer *)new gsAnimationPlayer(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAnimationPlayer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_getFrame(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationPlayer::getFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::getFrame",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_getFrame",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (int)(arg1)->getFrame();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setFrame(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setFrame",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setFrame",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::setFrame",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setFrame",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setFrame(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_getTimePosition(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float result;
  
  SWIG_check_num_args("gsAnimationPlayer::getTimePosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::getTimePosition",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_getTimePosition",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (float)(arg1)->getTimePosition();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setTimePosition(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setTimePosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setTimePosition",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::setTimePosition",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setTimePosition",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setTimePosition(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_getMode(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationPlayer::getMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::getMode",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_getMode",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (int)(arg1)->getMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setMode(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setMode",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::setMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setMode",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_getSpeedFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float result;
  
  SWIG_check_num_args("gsAnimationPlayer::getSpeedFactor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::getSpeedFactor",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_getSpeedFactor",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (float)(arg1)->getSpeedFactor();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setSpeedFactor(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setSpeedFactor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setSpeedFactor",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::setSpeedFactor",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setSpeedFactor",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpeedFactor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_isDone(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsAnimationPlayer::isDone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::isDone",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_isDone",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (bool)(arg1)->isDone();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_isEnabled(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsAnimationPlayer::isEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::isEnabled",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_isEnabled",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (bool)(arg1)->isEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setEnabled(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setEnabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setEnabled",1,"gsAnimationPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsAnimationPlayer::setEnabled",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setEnabled",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setEnabled(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_evaluate(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::evaluate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::evaluate",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::evaluate",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_evaluate",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->evaluate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_setWeight(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsAnimationPlayer::setWeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::setWeight",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::setWeight",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_setWeight",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setWeight(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_getWeight(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float result;
  
  SWIG_check_num_args("gsAnimationPlayer::getWeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::getWeight",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_getWeight",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (float)(arg1)->getWeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_reset(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  
  SWIG_check_num_args("gsAnimationPlayer::reset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::reset",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_reset",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  (arg1)->reset();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_get(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  gkAnimationPlayer *result = 0 ;
  
  SWIG_check_num_args("gsAnimationPlayer::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::get",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_get",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  result = (gkAnimationPlayer *)(arg1)->get();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, AnimationPlayer); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_addEventListener(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsAnimationPlayer::addEventListener",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::addEventListener",1,"gsAnimationPlayer *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsAnimationPlayer::addEventListener",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsAnimationPlayer::addEventListener",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_addEventListener",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->addEventListener(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_clearEvents(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  
  SWIG_check_num_args("gsAnimationPlayer::clearEvents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::clearEvents",1,"gsAnimationPlayer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_clearEvents",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  (arg1)->clearEvents();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayer_addTrigger(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayer *arg1 = (gsAnimationPlayer *) 0 ;
  float arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("gsAnimationPlayer::addTrigger",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayer::addTrigger",1,"gsAnimationPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationPlayer::addTrigger",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsAnimationPlayer::addTrigger",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayer,0))){
    SWIG_fail_ptr("gsAnimationPlayer_addTrigger",1,SWIGTYPE_p_gsAnimationPlayer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->addTrigger(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAnimationPlayer(void *obj) {
gsAnimationPlayer *arg1 = (gsAnimationPlayer *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAnimationPlayer(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAnimationPlayer);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAnimationPlayer_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAnimationPlayer_methods[]= {
    { "getFrame", _wrap_gsAnimationPlayer_getFrame},
    { "setFrame", _wrap_gsAnimationPlayer_setFrame},
    { "getTimePosition", _wrap_gsAnimationPlayer_getTimePosition},
    { "setTimePosition", _wrap_gsAnimationPlayer_setTimePosition},
    { "getMode", _wrap_gsAnimationPlayer_getMode},
    { "setMode", _wrap_gsAnimationPlayer_setMode},
    { "getSpeedFactor", _wrap_gsAnimationPlayer_getSpeedFactor},
    { "setSpeedFactor", _wrap_gsAnimationPlayer_setSpeedFactor},
    { "isDone", _wrap_gsAnimationPlayer_isDone},
    { "isEnabled", _wrap_gsAnimationPlayer_isEnabled},
    { "setEnabled", _wrap_gsAnimationPlayer_setEnabled},
    { "evaluate", _wrap_gsAnimationPlayer_evaluate},
    { "setWeight", _wrap_gsAnimationPlayer_setWeight},
    { "getWeight", _wrap_gsAnimationPlayer_getWeight},
    { "reset", _wrap_gsAnimationPlayer_reset},
    { "get", _wrap_gsAnimationPlayer_get},
    { "addEventListener", _wrap_gsAnimationPlayer_addEventListener},
    { "clearEvents", _wrap_gsAnimationPlayer_clearEvents},
    { "addTrigger", _wrap_gsAnimationPlayer_addTrigger},
    {0,0}
};
static swig_lua_method swig_gsAnimationPlayer_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAnimationPlayer_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAnimationPlayer_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("onStart", gsAnimationPlayer::onStart)},
    {SWIG_LUA_CONSTTAB_INT("onEnd", gsAnimationPlayer::onEnd)},
    {SWIG_LUA_CONSTTAB_INT("onLoopEnd", gsAnimationPlayer::onLoopEnd)},
    {SWIG_LUA_CONSTTAB_INT("onTrigger", gsAnimationPlayer::onTrigger)},
    {SWIG_LUA_CONSTTAB_INT("onDestruction", gsAnimationPlayer::onDestruction)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAnimationPlayer_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAnimationPlayer_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAnimationPlayer_Sf_SwigStatic = {
    "gsAnimationPlayer",
    swig_gsAnimationPlayer_Sf_SwigStatic_methods,
    swig_gsAnimationPlayer_Sf_SwigStatic_attributes,
    swig_gsAnimationPlayer_Sf_SwigStatic_constants,
    swig_gsAnimationPlayer_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAnimationPlayer_bases[] = {0};
static const char *swig_gsAnimationPlayer_base_names[] = {0};
static swig_lua_class _wrap_class_gsAnimationPlayer = { "gsAnimationPlayer", "gsAnimationPlayer", &SWIGTYPE_p_gsAnimationPlayer,_proxy__wrap_new_gsAnimationPlayer, swig_delete_gsAnimationPlayer, swig_gsAnimationPlayer_methods, swig_gsAnimationPlayer_attributes, &swig_gsAnimationPlayer_Sf_SwigStatic, swig_gsAnimationPlayer_meta, swig_gsAnimationPlayer_bases, swig_gsAnimationPlayer_base_names };

static int _wrap_new_LogicList__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::gsArray",0,0)
  result = (gsArray< gsLogicObject,gkLogicLink > *)new gsArray< gsLogicObject,gkLogicLink >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicList__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink >::Array *arg1 = 0 ;
  gsArray< gsLogicObject,gkLogicLink > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::gsArray",1,"gsArray< gsLogicObject,gkLogicLink >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkLogicLink_p_t,0))){
    SWIG_fail_ptr("new_LogicList",1,SWIGTYPE_p_utArrayT_gkLogicLink_p_t);
  }
  
  result = (gsArray< gsLogicObject,gkLogicLink > *)new gsArray< gsLogicObject,gkLogicLink >((gsArray< gsLogicObject,gkLogicLink >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicList(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_LogicList__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkLogicLink_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_LogicList__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_LogicList'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsLogicObject,gkLogicLink >::gsArray()\n"
    "    gsArray< gsLogicObject,gkLogicLink >::gsArray(gsArray< gsLogicObject,gkLogicLink >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_LogicList_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::clear",1,"gsArray< gsLogicObject,gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_clear",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::size",1,"gsArray< gsLogicObject,gkLogicLink > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_size",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  result = (int)((gsArray< gsLogicObject,gkLogicLink > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::empty",1,"gsArray< gsLogicObject,gkLogicLink > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_empty",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  result = (bool)((gsArray< gsLogicObject,gkLogicLink > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  int arg2 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::__getitem__",1,"gsArray< gsLogicObject,gkLogicLink > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList___getitem",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicLink *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  int arg2 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::at",1,"gsArray< gsLogicObject,gkLogicLink > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_at",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicLink *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  gsLogicObject *arg2 = (gsLogicObject *) 0 ;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::push",1,"gsArray< gsLogicObject,gkLogicLink > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::push",2,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_push",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicList_push",2,SWIGTYPE_p_gsLogicObject);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  gsLogicObject *arg2 = (gsLogicObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::erase",1,"gsArray< gsLogicObject,gkLogicLink > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::erase",2,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_erase",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicList_erase",2,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicList_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) 0 ;
  gsArrayIterator< gkLogicLink > result;
  
  SWIG_check_num_args("gsArray< gsLogicObject,gkLogicLink >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsLogicObject,gkLogicLink >::iterator",1,"gsArray< gsLogicObject,gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicList_iterator",1,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkLogicLink > * resultptr = new gsArrayIterator< gkLogicLink >((const gsArrayIterator< gkLogicLink > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LogicList(void *obj) {
gsArray< gsLogicObject,gkLogicLink > *arg1 = (gsArray< gsLogicObject,gkLogicLink > *) obj;
delete arg1;
}
static int _proxy__wrap_new_LogicList(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LogicList);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LogicList_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LogicList_methods[]= {
    { "clear", _wrap_LogicList_clear},
    { "size", _wrap_LogicList_size},
    { "empty", _wrap_LogicList_empty},
    { "__getitem", _wrap_LogicList___getitem},
    { "at", _wrap_LogicList_at},
    { "push", _wrap_LogicList_push},
    { "erase", _wrap_LogicList_erase},
    { "iterator", _wrap_LogicList_iterator},
    {0,0}
};
static swig_lua_method swig_LogicList_meta[] = {
    { "__getitem", _wrap_LogicList___getitem},
    {0,0}
};

static swig_lua_attribute swig_LogicList_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LogicList_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LogicList_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LogicList_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LogicList_Sf_SwigStatic = {
    "LogicList",
    swig_LogicList_Sf_SwigStatic_methods,
    swig_LogicList_Sf_SwigStatic_attributes,
    swig_LogicList_Sf_SwigStatic_constants,
    swig_LogicList_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LogicList_bases[] = {0};
static const char *swig_LogicList_base_names[] = {0};
static swig_lua_class _wrap_class_LogicList = { "LogicList", "LogicList", &SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,_proxy__wrap_new_LogicList, swig_delete_LogicList, swig_LogicList_methods, swig_LogicList_attributes, &swig_LogicList_Sf_SwigStatic, swig_LogicList_meta, swig_LogicList_bases, swig_LogicList_base_names };

static int _wrap_new_LogicIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicLink > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicLink >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkLogicLink > *)new gsArrayIterator< gkLogicLink >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicLink > *arg1 = (gsArrayIterator< gkLogicLink > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicLink >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicLink >::hasMoreElements",1,"gsArrayIterator< gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicLink > *arg1 = (gsArrayIterator< gkLogicLink > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicLink >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicLink >::moveNext",1,"gsArrayIterator< gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicLink > *arg1 = (gsArrayIterator< gkLogicLink > *) 0 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicLink >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicLink >::peekNext",1,"gsArrayIterator< gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t);
  }
  
  result = (gkLogicLink *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicLink > *arg1 = (gsArrayIterator< gkLogicLink > *) 0 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicLink >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicLink >::getNext",1,"gsArrayIterator< gkLogicLink > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,0))){
    SWIG_fail_ptr("LogicIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t);
  }
  
  result = (gkLogicLink *)(arg1)->getNext();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LogicIterator(void *obj) {
gsArrayIterator< gkLogicLink > *arg1 = (gsArrayIterator< gkLogicLink > *) obj;
delete arg1;
}
static int _proxy__wrap_new_LogicIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LogicIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LogicIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LogicIterator_methods[]= {
    { "hasMoreElements", _wrap_LogicIterator_hasMoreElements},
    { "moveNext", _wrap_LogicIterator_moveNext},
    { "peekNext", _wrap_LogicIterator_peekNext},
    { "getNext", _wrap_LogicIterator_getNext},
    {0,0}
};
static swig_lua_method swig_LogicIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LogicIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LogicIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LogicIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LogicIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LogicIterator_Sf_SwigStatic = {
    "LogicIterator",
    swig_LogicIterator_Sf_SwigStatic_methods,
    swig_LogicIterator_Sf_SwigStatic_attributes,
    swig_LogicIterator_Sf_SwigStatic_constants,
    swig_LogicIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LogicIterator_bases[] = {0};
static const char *swig_LogicIterator_base_names[] = {0};
static swig_lua_class _wrap_class_LogicIterator = { "LogicIterator", "LogicIterator", &SWIGTYPE_p_gsArrayIteratorT_gkLogicLink_t,_proxy__wrap_new_LogicIterator, swig_delete_LogicIterator, swig_LogicIterator_methods, swig_LogicIterator_attributes, &swig_LogicIterator_Sf_SwigStatic, swig_LogicIterator_meta, swig_LogicIterator_bases, swig_LogicIterator_base_names };

static int _wrap_new_Sensors__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::gsArray",0,0)
  result = (gsArray< gsSensor,gkLogicSensor > *)new gsArray< gsSensor,gkLogicSensor >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Sensors__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor >::Array *arg1 = 0 ;
  gsArray< gsSensor,gkLogicSensor > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::gsArray",1,"gsArray< gsSensor,gkLogicSensor >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkLogicSensor_p_t,0))){
    SWIG_fail_ptr("new_Sensors",1,SWIGTYPE_p_utArrayT_gkLogicSensor_p_t);
  }
  
  result = (gsArray< gsSensor,gkLogicSensor > *)new gsArray< gsSensor,gkLogicSensor >((gsArray< gsSensor,gkLogicSensor >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Sensors(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Sensors__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkLogicSensor_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Sensors__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Sensors'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsSensor,gkLogicSensor >::gsArray()\n"
    "    gsArray< gsSensor,gkLogicSensor >::gsArray(gsArray< gsSensor,gkLogicSensor >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Sensors_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::clear",1,"gsArray< gsSensor,gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_clear",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::size",1,"gsArray< gsSensor,gkLogicSensor > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_size",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  result = (int)((gsArray< gsSensor,gkLogicSensor > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::empty",1,"gsArray< gsSensor,gkLogicSensor > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_empty",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  result = (bool)((gsArray< gsSensor,gkLogicSensor > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  int arg2 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::__getitem__",1,"gsArray< gsSensor,gkLogicSensor > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors___getitem",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicSensor *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  int arg2 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::at",1,"gsArray< gsSensor,gkLogicSensor > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_at",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicSensor *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  gsSensor *arg2 = (gsSensor *) 0 ;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::push",1,"gsArray< gsSensor,gkLogicSensor > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::push",2,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_push",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensors_push",2,SWIGTYPE_p_gsSensor);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  gsSensor *arg2 = (gsSensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::erase",1,"gsArray< gsSensor,gkLogicSensor > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::erase",2,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_erase",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensors_erase",2,SWIGTYPE_p_gsSensor);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensors_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) 0 ;
  gsArrayIterator< gkLogicSensor > result;
  
  SWIG_check_num_args("gsArray< gsSensor,gkLogicSensor >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsSensor,gkLogicSensor >::iterator",1,"gsArray< gsSensor,gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,0))){
    SWIG_fail_ptr("Sensors_iterator",1,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkLogicSensor > * resultptr = new gsArrayIterator< gkLogicSensor >((const gsArrayIterator< gkLogicSensor > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Sensors(void *obj) {
gsArray< gsSensor,gkLogicSensor > *arg1 = (gsArray< gsSensor,gkLogicSensor > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Sensors(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Sensors);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Sensors_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Sensors_methods[]= {
    { "clear", _wrap_Sensors_clear},
    { "size", _wrap_Sensors_size},
    { "empty", _wrap_Sensors_empty},
    { "__getitem", _wrap_Sensors___getitem},
    { "at", _wrap_Sensors_at},
    { "push", _wrap_Sensors_push},
    { "erase", _wrap_Sensors_erase},
    { "iterator", _wrap_Sensors_iterator},
    {0,0}
};
static swig_lua_method swig_Sensors_meta[] = {
    { "__getitem", _wrap_Sensors___getitem},
    {0,0}
};

static swig_lua_attribute swig_Sensors_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Sensors_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Sensors_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Sensors_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Sensors_Sf_SwigStatic = {
    "Sensors",
    swig_Sensors_Sf_SwigStatic_methods,
    swig_Sensors_Sf_SwigStatic_attributes,
    swig_Sensors_Sf_SwigStatic_constants,
    swig_Sensors_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Sensors_bases[] = {0};
static const char *swig_Sensors_base_names[] = {0};
static swig_lua_class _wrap_class_Sensors = { "Sensors", "Sensors", &SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,_proxy__wrap_new_Sensors, swig_delete_Sensors, swig_Sensors_methods, swig_Sensors_attributes, &swig_Sensors_Sf_SwigStatic, swig_Sensors_meta, swig_Sensors_bases, swig_Sensors_base_names };

static int _wrap_new_SensorIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicSensor > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicSensor >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkLogicSensor > *)new gsArrayIterator< gkLogicSensor >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SensorIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicSensor > *arg1 = (gsArrayIterator< gkLogicSensor > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicSensor >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicSensor >::hasMoreElements",1,"gsArrayIterator< gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,0))){
    SWIG_fail_ptr("SensorIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SensorIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicSensor > *arg1 = (gsArrayIterator< gkLogicSensor > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicSensor >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicSensor >::moveNext",1,"gsArrayIterator< gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,0))){
    SWIG_fail_ptr("SensorIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SensorIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicSensor > *arg1 = (gsArrayIterator< gkLogicSensor > *) 0 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicSensor >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicSensor >::peekNext",1,"gsArrayIterator< gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,0))){
    SWIG_fail_ptr("SensorIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t);
  }
  
  result = (gkLogicSensor *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SensorIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicSensor > *arg1 = (gsArrayIterator< gkLogicSensor > *) 0 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicSensor >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicSensor >::getNext",1,"gsArrayIterator< gkLogicSensor > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,0))){
    SWIG_fail_ptr("SensorIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t);
  }
  
  result = (gkLogicSensor *)(arg1)->getNext();
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SensorIterator(void *obj) {
gsArrayIterator< gkLogicSensor > *arg1 = (gsArrayIterator< gkLogicSensor > *) obj;
delete arg1;
}
static int _proxy__wrap_new_SensorIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SensorIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SensorIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SensorIterator_methods[]= {
    { "hasMoreElements", _wrap_SensorIterator_hasMoreElements},
    { "moveNext", _wrap_SensorIterator_moveNext},
    { "peekNext", _wrap_SensorIterator_peekNext},
    { "getNext", _wrap_SensorIterator_getNext},
    {0,0}
};
static swig_lua_method swig_SensorIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SensorIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SensorIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SensorIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SensorIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SensorIterator_Sf_SwigStatic = {
    "SensorIterator",
    swig_SensorIterator_Sf_SwigStatic_methods,
    swig_SensorIterator_Sf_SwigStatic_attributes,
    swig_SensorIterator_Sf_SwigStatic_constants,
    swig_SensorIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SensorIterator_bases[] = {0};
static const char *swig_SensorIterator_base_names[] = {0};
static swig_lua_class _wrap_class_SensorIterator = { "SensorIterator", "SensorIterator", &SWIGTYPE_p_gsArrayIteratorT_gkLogicSensor_t,_proxy__wrap_new_SensorIterator, swig_delete_SensorIterator, swig_SensorIterator_methods, swig_SensorIterator_attributes, &swig_SensorIterator_Sf_SwigStatic, swig_SensorIterator_meta, swig_SensorIterator_bases, swig_SensorIterator_base_names };

static int _wrap_new_Controllers__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::gsArray",0,0)
  result = (gsArray< gsController,gkLogicController > *)new gsArray< gsController,gkLogicController >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Controllers__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController >::Array *arg1 = 0 ;
  gsArray< gsController,gkLogicController > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::gsArray",1,"gsArray< gsController,gkLogicController >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkLogicController_p_t,0))){
    SWIG_fail_ptr("new_Controllers",1,SWIGTYPE_p_utArrayT_gkLogicController_p_t);
  }
  
  result = (gsArray< gsController,gkLogicController > *)new gsArray< gsController,gkLogicController >((gsArray< gsController,gkLogicController >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Controllers(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Controllers__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkLogicController_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Controllers__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Controllers'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsController,gkLogicController >::gsArray()\n"
    "    gsArray< gsController,gkLogicController >::gsArray(gsArray< gsController,gkLogicController >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Controllers_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::clear",1,"gsArray< gsController,gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_clear",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::size",1,"gsArray< gsController,gkLogicController > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_size",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  result = (int)((gsArray< gsController,gkLogicController > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::empty",1,"gsArray< gsController,gkLogicController > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_empty",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  result = (bool)((gsArray< gsController,gkLogicController > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  int arg2 ;
  gkLogicController *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::__getitem__",1,"gsArray< gsController,gkLogicController > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers___getitem",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicController *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += gsWrapController(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  int arg2 ;
  gkLogicController *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::at",1,"gsArray< gsController,gkLogicController > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_at",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicController *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += gsWrapController(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  gsController *arg2 = (gsController *) 0 ;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::push",1,"gsArray< gsController,gkLogicController > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::push",2,"gsController *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_push",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controllers_push",2,SWIGTYPE_p_gsController);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  gsController *arg2 = (gsController *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::erase",1,"gsArray< gsController,gkLogicController > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::erase",2,"gsController *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_erase",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controllers_erase",2,SWIGTYPE_p_gsController);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controllers_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) 0 ;
  gsArrayIterator< gkLogicController > result;
  
  SWIG_check_num_args("gsArray< gsController,gkLogicController >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsController,gkLogicController >::iterator",1,"gsArray< gsController,gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,0))){
    SWIG_fail_ptr("Controllers_iterator",1,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkLogicController > * resultptr = new gsArrayIterator< gkLogicController >((const gsArrayIterator< gkLogicController > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Controllers(void *obj) {
gsArray< gsController,gkLogicController > *arg1 = (gsArray< gsController,gkLogicController > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Controllers(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Controllers);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Controllers_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Controllers_methods[]= {
    { "clear", _wrap_Controllers_clear},
    { "size", _wrap_Controllers_size},
    { "empty", _wrap_Controllers_empty},
    { "__getitem", _wrap_Controllers___getitem},
    { "at", _wrap_Controllers_at},
    { "push", _wrap_Controllers_push},
    { "erase", _wrap_Controllers_erase},
    { "iterator", _wrap_Controllers_iterator},
    {0,0}
};
static swig_lua_method swig_Controllers_meta[] = {
    { "__getitem", _wrap_Controllers___getitem},
    {0,0}
};

static swig_lua_attribute swig_Controllers_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Controllers_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Controllers_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Controllers_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Controllers_Sf_SwigStatic = {
    "Controllers",
    swig_Controllers_Sf_SwigStatic_methods,
    swig_Controllers_Sf_SwigStatic_attributes,
    swig_Controllers_Sf_SwigStatic_constants,
    swig_Controllers_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Controllers_bases[] = {0};
static const char *swig_Controllers_base_names[] = {0};
static swig_lua_class _wrap_class_Controllers = { "Controllers", "Controllers", &SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,_proxy__wrap_new_Controllers, swig_delete_Controllers, swig_Controllers_methods, swig_Controllers_attributes, &swig_Controllers_Sf_SwigStatic, swig_Controllers_meta, swig_Controllers_bases, swig_Controllers_base_names };

static int _wrap_new_ControllerIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicController > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicController >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkLogicController > *)new gsArrayIterator< gkLogicController >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ControllerIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicController > *arg1 = (gsArrayIterator< gkLogicController > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicController >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicController >::hasMoreElements",1,"gsArrayIterator< gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,0))){
    SWIG_fail_ptr("ControllerIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ControllerIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicController > *arg1 = (gsArrayIterator< gkLogicController > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicController >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicController >::moveNext",1,"gsArrayIterator< gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,0))){
    SWIG_fail_ptr("ControllerIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ControllerIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicController > *arg1 = (gsArrayIterator< gkLogicController > *) 0 ;
  gkLogicController *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicController >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicController >::peekNext",1,"gsArrayIterator< gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,0))){
    SWIG_fail_ptr("ControllerIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t);
  }
  
  result = (gkLogicController *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += gsWrapController(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ControllerIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicController > *arg1 = (gsArrayIterator< gkLogicController > *) 0 ;
  gkLogicController *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicController >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicController >::getNext",1,"gsArrayIterator< gkLogicController > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,0))){
    SWIG_fail_ptr("ControllerIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t);
  }
  
  result = (gkLogicController *)(arg1)->getNext();
  if (result) {
    SWIG_arg += gsWrapController(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ControllerIterator(void *obj) {
gsArrayIterator< gkLogicController > *arg1 = (gsArrayIterator< gkLogicController > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ControllerIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ControllerIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ControllerIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ControllerIterator_methods[]= {
    { "hasMoreElements", _wrap_ControllerIterator_hasMoreElements},
    { "moveNext", _wrap_ControllerIterator_moveNext},
    { "peekNext", _wrap_ControllerIterator_peekNext},
    { "getNext", _wrap_ControllerIterator_getNext},
    {0,0}
};
static swig_lua_method swig_ControllerIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ControllerIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ControllerIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ControllerIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ControllerIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ControllerIterator_Sf_SwigStatic = {
    "ControllerIterator",
    swig_ControllerIterator_Sf_SwigStatic_methods,
    swig_ControllerIterator_Sf_SwigStatic_attributes,
    swig_ControllerIterator_Sf_SwigStatic_constants,
    swig_ControllerIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ControllerIterator_bases[] = {0};
static const char *swig_ControllerIterator_base_names[] = {0};
static swig_lua_class _wrap_class_ControllerIterator = { "ControllerIterator", "ControllerIterator", &SWIGTYPE_p_gsArrayIteratorT_gkLogicController_t,_proxy__wrap_new_ControllerIterator, swig_delete_ControllerIterator, swig_ControllerIterator_methods, swig_ControllerIterator_attributes, &swig_ControllerIterator_Sf_SwigStatic, swig_ControllerIterator_meta, swig_ControllerIterator_bases, swig_ControllerIterator_base_names };

static int _wrap_new_Actuators__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::gsArray",0,0)
  result = (gsArray< gsActuator,gkLogicActuator > *)new gsArray< gsActuator,gkLogicActuator >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Actuators__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator >::Array *arg1 = 0 ;
  gsArray< gsActuator,gkLogicActuator > *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::gsArray",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::gsArray",1,"gsArray< gsActuator,gkLogicActuator >::Array const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_utArrayT_gkLogicActuator_p_t,0))){
    SWIG_fail_ptr("new_Actuators",1,SWIGTYPE_p_utArrayT_gkLogicActuator_p_t);
  }
  
  result = (gsArray< gsActuator,gkLogicActuator > *)new gsArray< gsActuator,gkLogicActuator >((gsArray< gsActuator,gkLogicActuator >::Array const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Actuators(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Actuators__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_utArrayT_gkLogicActuator_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Actuators__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Actuators'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsArray< gsActuator,gkLogicActuator >::gsArray()\n"
    "    gsArray< gsActuator,gkLogicActuator >::gsArray(gsArray< gsActuator,gkLogicActuator >::Array const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Actuators_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::clear",1,"gsArray< gsActuator,gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_clear",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_size(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  int result;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::size",1,"gsArray< gsActuator,gkLogicActuator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_size",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  result = (int)((gsArray< gsActuator,gkLogicActuator > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_empty(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::empty",1,"gsArray< gsActuator,gkLogicActuator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_empty",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  result = (bool)((gsArray< gsActuator,gkLogicActuator > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators___getitem(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  int arg2 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::__getitem__",1,"gsArray< gsActuator,gkLogicActuator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators___getitem",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicActuator *)(arg1)->__getitem__(arg2);
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_at(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  int arg2 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::at",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::at",1,"gsArray< gsActuator,gkLogicActuator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::at",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_at",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicActuator *)(arg1)->at(arg2);
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_push(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  gsActuator *arg2 = (gsActuator *) 0 ;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::push",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::push",1,"gsArray< gsActuator,gkLogicActuator > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::push",2,"gsActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_push",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsActuator,0))){
    SWIG_fail_ptr("Actuators_push",2,SWIGTYPE_p_gsActuator);
  }
  
  (arg1)->push(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_erase(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  gsActuator *arg2 = (gsActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::erase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::erase",1,"gsArray< gsActuator,gkLogicActuator > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::erase",2,"gsActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_erase",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsActuator,0))){
    SWIG_fail_ptr("Actuators_erase",2,SWIGTYPE_p_gsActuator);
  }
  
  result = (bool)(arg1)->erase(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Actuators_iterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) 0 ;
  gsArrayIterator< gkLogicActuator > result;
  
  SWIG_check_num_args("gsArray< gsActuator,gkLogicActuator >::iterator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArray< gsActuator,gkLogicActuator >::iterator",1,"gsArray< gsActuator,gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,0))){
    SWIG_fail_ptr("Actuators_iterator",1,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t);
  }
  
  result = (arg1)->iterator();
  {
    gsArrayIterator< gkLogicActuator > * resultptr = new gsArrayIterator< gkLogicActuator >((const gsArrayIterator< gkLogicActuator > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Actuators(void *obj) {
gsArray< gsActuator,gkLogicActuator > *arg1 = (gsArray< gsActuator,gkLogicActuator > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Actuators(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Actuators);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Actuators_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Actuators_methods[]= {
    { "clear", _wrap_Actuators_clear},
    { "size", _wrap_Actuators_size},
    { "empty", _wrap_Actuators_empty},
    { "__getitem", _wrap_Actuators___getitem},
    { "at", _wrap_Actuators_at},
    { "push", _wrap_Actuators_push},
    { "erase", _wrap_Actuators_erase},
    { "iterator", _wrap_Actuators_iterator},
    {0,0}
};
static swig_lua_method swig_Actuators_meta[] = {
    { "__getitem", _wrap_Actuators___getitem},
    {0,0}
};

static swig_lua_attribute swig_Actuators_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Actuators_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Actuators_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Actuators_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Actuators_Sf_SwigStatic = {
    "Actuators",
    swig_Actuators_Sf_SwigStatic_methods,
    swig_Actuators_Sf_SwigStatic_attributes,
    swig_Actuators_Sf_SwigStatic_constants,
    swig_Actuators_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Actuators_bases[] = {0};
static const char *swig_Actuators_base_names[] = {0};
static swig_lua_class _wrap_class_Actuators = { "Actuators", "Actuators", &SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,_proxy__wrap_new_Actuators, swig_delete_Actuators, swig_Actuators_methods, swig_Actuators_attributes, &swig_Actuators_Sf_SwigStatic, swig_Actuators_meta, swig_Actuators_bases, swig_Actuators_base_names };

static int _wrap_new_ActuatorIterator(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicActuator > *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicActuator >::gsArrayIterator",0,0)
  result = (gsArrayIterator< gkLogicActuator > *)new gsArrayIterator< gkLogicActuator >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActuatorIterator_hasMoreElements(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicActuator > *arg1 = (gsArrayIterator< gkLogicActuator > *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicActuator >::hasMoreElements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicActuator >::hasMoreElements",1,"gsArrayIterator< gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,0))){
    SWIG_fail_ptr("ActuatorIterator_hasMoreElements",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t);
  }
  
  result = (bool)(arg1)->hasMoreElements();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActuatorIterator_moveNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicActuator > *arg1 = (gsArrayIterator< gkLogicActuator > *) 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicActuator >::moveNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicActuator >::moveNext",1,"gsArrayIterator< gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,0))){
    SWIG_fail_ptr("ActuatorIterator_moveNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t);
  }
  
  (arg1)->moveNext();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActuatorIterator_peekNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicActuator > *arg1 = (gsArrayIterator< gkLogicActuator > *) 0 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicActuator >::peekNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicActuator >::peekNext",1,"gsArrayIterator< gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,0))){
    SWIG_fail_ptr("ActuatorIterator_peekNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t);
  }
  
  result = (gkLogicActuator *)(arg1)->peekNext();
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActuatorIterator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  gsArrayIterator< gkLogicActuator > *arg1 = (gsArrayIterator< gkLogicActuator > *) 0 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsArrayIterator< gkLogicActuator >::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsArrayIterator< gkLogicActuator >::getNext",1,"gsArrayIterator< gkLogicActuator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,0))){
    SWIG_fail_ptr("ActuatorIterator_getNext",1,SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t);
  }
  
  result = (gkLogicActuator *)(arg1)->getNext();
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ActuatorIterator(void *obj) {
gsArrayIterator< gkLogicActuator > *arg1 = (gsArrayIterator< gkLogicActuator > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ActuatorIterator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ActuatorIterator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ActuatorIterator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ActuatorIterator_methods[]= {
    { "hasMoreElements", _wrap_ActuatorIterator_hasMoreElements},
    { "moveNext", _wrap_ActuatorIterator_moveNext},
    { "peekNext", _wrap_ActuatorIterator_peekNext},
    { "getNext", _wrap_ActuatorIterator_getNext},
    {0,0}
};
static swig_lua_method swig_ActuatorIterator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ActuatorIterator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ActuatorIterator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ActuatorIterator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ActuatorIterator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ActuatorIterator_Sf_SwigStatic = {
    "ActuatorIterator",
    swig_ActuatorIterator_Sf_SwigStatic_methods,
    swig_ActuatorIterator_Sf_SwigStatic_attributes,
    swig_ActuatorIterator_Sf_SwigStatic_constants,
    swig_ActuatorIterator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ActuatorIterator_bases[] = {0};
static const char *swig_ActuatorIterator_base_names[] = {0};
static swig_lua_class _wrap_class_ActuatorIterator = { "ActuatorIterator", "ActuatorIterator", &SWIGTYPE_p_gsArrayIteratorT_gkLogicActuator_t,_proxy__wrap_new_ActuatorIterator, swig_delete_ActuatorIterator, swig_ActuatorIterator_methods, swig_ActuatorIterator_attributes, &swig_ActuatorIterator_Sf_SwigStatic, swig_ActuatorIterator_meta, swig_ActuatorIterator_bases, swig_ActuatorIterator_base_names };

static int _wrap_new_LogicManager__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsLogicManager *result = 0 ;
  
  SWIG_check_num_args("gsLogicManager::gsLogicManager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicManager::gsLogicManager",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_LogicManager",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsLogicManager *)new gsLogicManager(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicManager__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicManager *result = 0 ;
  
  SWIG_check_num_args("gsLogicManager::gsLogicManager",0,0)
  result = (gsLogicManager *)new gsLogicManager();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicManager(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_LogicManager__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_LogicManager__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_LogicManager'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicManager::gsLogicManager(gsScene *)\n"
    "    gsLogicManager::gsLogicManager()\n");
  lua_error(L);return 0;
}


static int _wrap_LogicManager_newObject(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicManager *arg1 = (gsLogicManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsLogicManager::newObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicManager::newObject",1,"gsLogicManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsLogicManager::newObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicManager,0))){
    SWIG_fail_ptr("LogicManager_newObject",1,SWIGTYPE_p_gsLogicManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("LogicManager_newObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkLogicLink *)(arg1)->newObject(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicManager_getObject__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicManager *arg1 = (gsLogicManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsLogicManager::getObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicManager::getObject",1,"gsLogicManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicManager::getObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicManager,0))){
    SWIG_fail_ptr("LogicManager_getObject",1,SWIGTYPE_p_gsLogicManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLogicLink *)(arg1)->getObject((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicManager_getObject__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicManager *arg1 = (gsLogicManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsLogicManager::getObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicManager::getObject",1,"gsLogicManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsLogicManager::getObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicManager,0))){
    SWIG_fail_ptr("LogicManager_getObject",1,SWIGTYPE_p_gsLogicManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("LogicManager_getObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkLogicLink *)(arg1)->getObject(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicManager_getObject(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_LogicManager_getObject__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_LogicManager_getObject__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'LogicManager_getObject'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicManager::getObject(gkString const &)\n"
    "    gsLogicManager::getObject(gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_LogicManager_getObjectList(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicManager *arg1 = (gsLogicManager *) 0 ;
  gsArray< gsLogicObject,gkLogicLink > result;
  
  SWIG_check_num_args("gsLogicManager::getObjectList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicManager::getObjectList",1,"gsLogicManager *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicManager,0))){
    SWIG_fail_ptr("LogicManager_getObjectList",1,SWIGTYPE_p_gsLogicManager);
  }
  
  result = (arg1)->getObjectList();
  {
    gsArray< gsLogicObject,gkLogicLink > * resultptr = new gsArray< gsLogicObject,gkLogicLink >((const gsArray< gsLogicObject,gkLogicLink > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayT_gsLogicObject_gkLogicLink_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LogicManager(void *obj) {
gsLogicManager *arg1 = (gsLogicManager *) obj;
delete arg1;
}
static int _proxy__wrap_new_LogicManager(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LogicManager);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LogicManager_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LogicManager_methods[]= {
    { "newObject", _wrap_LogicManager_newObject},
    { "getObject", _wrap_LogicManager_getObject},
    { "getObjectList", _wrap_LogicManager_getObjectList},
    {0,0}
};
static swig_lua_method swig_LogicManager_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LogicManager_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LogicManager_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LogicManager_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LogicManager_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LogicManager_Sf_SwigStatic = {
    "LogicManager",
    swig_LogicManager_Sf_SwigStatic_methods,
    swig_LogicManager_Sf_SwigStatic_attributes,
    swig_LogicManager_Sf_SwigStatic_constants,
    swig_LogicManager_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LogicManager_bases[] = {0};
static const char *swig_LogicManager_base_names[] = {0};
static swig_lua_class _wrap_class_LogicManager = { "LogicManager", "LogicManager", &SWIGTYPE_p_gsLogicManager,_proxy__wrap_new_LogicManager, swig_delete_LogicManager, swig_LogicManager_methods, swig_LogicManager_attributes, &swig_LogicManager_Sf_SwigStatic, swig_LogicManager_meta, swig_LogicManager_bases, swig_LogicManager_base_names };

static int _wrap_new_LogicObject(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *result = 0 ;
  
  SWIG_check_num_args("gsLogicObject::gsLogicObject",0,0)
  result = (gsLogicObject *)new gsLogicObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicObject,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLogicObject::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getName",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getName",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_setDebug(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsLogicObject::setDebug",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::setDebug",1,"gsLogicObject *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsLogicObject::setDebug",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_setDebug",1,SWIGTYPE_p_gsLogicObject);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setDebug(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_isDebug(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsLogicObject::isDebug",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::isDebug",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_isDebug",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (bool)(arg1)->isDebug();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getSensor(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsLogicObject::getSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicObject::getSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLogicSensor *)(arg1)->getSensor((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getController(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLogicController *result = 0 ;
  
  SWIG_check_num_args("gsLogicObject::getController",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getController",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicObject::getController",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLogicController *)(arg1)->getController((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapController(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getActuator(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsLogicObject::getActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicObject::getActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLogicActuator *)(arg1)->getActuator((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getSensors(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsArray< gsSensor,gkLogicSensor > result;
  
  SWIG_check_num_args("gsLogicObject::getSensors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getSensors",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getSensors",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (arg1)->getSensors();
  {
    gsArray< gsSensor,gkLogicSensor > * resultptr = new gsArray< gsSensor,gkLogicSensor >((const gsArray< gsSensor,gkLogicSensor > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayT_gsSensor_gkLogicSensor_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getControllers(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsArray< gsController,gkLogicController > result;
  
  SWIG_check_num_args("gsLogicObject::getControllers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getControllers",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getControllers",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (arg1)->getControllers();
  {
    gsArray< gsController,gkLogicController > * resultptr = new gsArray< gsController,gkLogicController >((const gsArray< gsController,gkLogicController > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayT_gsController_gkLogicController_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicObject_getActuators(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsArray< gsActuator,gkLogicActuator > result;
  
  SWIG_check_num_args("gsLogicObject::getActuators",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicObject::getActuators",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("LogicObject_getActuators",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (arg1)->getActuators();
  {
    gsArray< gsActuator,gkLogicActuator > * resultptr = new gsArray< gsActuator,gkLogicActuator >((const gsArray< gsActuator,gkLogicActuator > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsArrayT_gsActuator_gkLogicActuator_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LogicObject(void *obj) {
gsLogicObject *arg1 = (gsLogicObject *) obj;
delete arg1;
}
static int _proxy__wrap_new_LogicObject(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LogicObject);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LogicObject_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LogicObject_methods[]= {
    { "getName", _wrap_LogicObject_getName},
    { "setDebug", _wrap_LogicObject_setDebug},
    { "isDebug", _wrap_LogicObject_isDebug},
    { "getSensor", _wrap_LogicObject_getSensor},
    { "getController", _wrap_LogicObject_getController},
    { "getActuator", _wrap_LogicObject_getActuator},
    { "getSensors", _wrap_LogicObject_getSensors},
    { "getControllers", _wrap_LogicObject_getControllers},
    { "getActuators", _wrap_LogicObject_getActuators},
    {0,0}
};
static swig_lua_method swig_LogicObject_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LogicObject_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LogicObject_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LogicObject_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LogicObject_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LogicObject_Sf_SwigStatic = {
    "LogicObject",
    swig_LogicObject_Sf_SwigStatic_methods,
    swig_LogicObject_Sf_SwigStatic_attributes,
    swig_LogicObject_Sf_SwigStatic_constants,
    swig_LogicObject_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LogicObject_bases[] = {0};
static const char *swig_LogicObject_base_names[] = {0};
static swig_lua_class _wrap_class_LogicObject = { "LogicObject", "LogicObject", &SWIGTYPE_p_gsLogicObject,_proxy__wrap_new_LogicObject, swig_delete_LogicObject, swig_LogicObject_methods, swig_LogicObject_attributes, &swig_LogicObject_Sf_SwigStatic, swig_LogicObject_meta, swig_LogicObject_bases, swig_LogicObject_base_names };

static int _wrap_new_Brick(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *result = 0 ;
  
  SWIG_check_num_args("gsBrick::gsBrick",0,0)
  result = (gsBrick *)new gsBrick();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsBrick,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsBrick::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::getName",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_getName",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_isOn(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsBrick::isOn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::isOn",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_isOn",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (bool)(arg1)->isOn();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_isOff(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsBrick::isOff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::isOff",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_isOff",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (bool)(arg1)->isOff();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_isActive(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsBrick::isActive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::isActive",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_isActive",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (bool)(arg1)->isActive();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_getOwner(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsBrick::getOwner",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::getOwner",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_getOwner",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (gkGameObject *)(arg1)->getOwner();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_getLogicObject(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  gkLogicLink *result = 0 ;
  
  SWIG_check_num_args("gsBrick::getLogicObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::getLogicObject",1,"gsBrick *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_getLogicObject",1,SWIGTYPE_p_gsBrick);
  }
  
  result = (gkLogicLink *)(arg1)->getLogicObject();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_WRAP_STORE(result, LogicLink, LogicObject); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Brick_connect(lua_State* L) {
  int SWIG_arg = 0;
  gsBrick *arg1 = (gsBrick *) 0 ;
  gsListenerMode arg2 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  
  SWIG_check_num_args("gsBrick::connect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBrick::connect",1,"gsBrick *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsBrick::connect",2,"gsListenerMode");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsBrick::connect",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsBrick::connect",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBrick,0))){
    SWIG_fail_ptr("Brick_connect",1,SWIGTYPE_p_gsBrick);
  }
  
  arg2 = (gsListenerMode)(int)lua_tonumber(L, 2);
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->connect(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Brick(void *obj) {
gsBrick *arg1 = (gsBrick *) obj;
delete arg1;
}
static int _proxy__wrap_new_Brick(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Brick);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Brick_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Brick_methods[]= {
    { "getName", _wrap_Brick_getName},
    { "isOn", _wrap_Brick_isOn},
    { "isOff", _wrap_Brick_isOff},
    { "isActive", _wrap_Brick_isActive},
    { "getOwner", _wrap_Brick_getOwner},
    { "getLogicObject", _wrap_Brick_getLogicObject},
    { "connect", _wrap_Brick_connect},
    {0,0}
};
static swig_lua_method swig_Brick_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Brick_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Brick_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Brick_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Brick_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Brick_Sf_SwigStatic = {
    "Brick",
    swig_Brick_Sf_SwigStatic_methods,
    swig_Brick_Sf_SwigStatic_attributes,
    swig_Brick_Sf_SwigStatic_constants,
    swig_Brick_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Brick_bases[] = {0};
static const char *swig_Brick_base_names[] = {0};
static swig_lua_class _wrap_class_Brick = { "Brick", "Brick", &SWIGTYPE_p_gsBrick,_proxy__wrap_new_Brick, swig_delete_Brick, swig_Brick_methods, swig_Brick_attributes, &swig_Brick_Sf_SwigStatic, swig_Brick_meta, swig_Brick_bases, swig_Brick_base_names };

static int _wrap_new_Sensor(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *result = 0 ;
  
  SWIG_check_num_args("gsSensor::gsSensor",0,0)
  result = (gsSensor *)new gsSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_setPulse(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsSensor::setPulse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::setPulse",1,"gsSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSensor::setPulse",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_setPulse",1,SWIGTYPE_p_gsSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPulse(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_getPulse(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSensor::getPulse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::getPulse",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_getPulse",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (int)(arg1)->getPulse();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_setFrequency(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSensor::setFrequency",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::setFrequency",1,"gsSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSensor::setFrequency",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_setFrequency",1,SWIGTYPE_p_gsSensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setFrequency(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_getFrequency(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSensor::getFrequency",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::getFrequency",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_getFrequency",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (float)(arg1)->getFrequency();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_setLevel(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsSensor::setLevel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::setLevel",1,"gsSensor *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsSensor::setLevel",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_setLevel",1,SWIGTYPE_p_gsSensor);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setLevel(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_isLevel(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSensor::isLevel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::isLevel",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_isLevel",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (bool)(arg1)->isLevel();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_setTap(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsSensor::setTap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::setTap",1,"gsSensor *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsSensor::setTap",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_setTap",1,SWIGTYPE_p_gsSensor);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setTap(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_isTap(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSensor::isTap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::isTap",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_isTap",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (bool)(arg1)->isTap();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_setInvert(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsSensor::setInvert",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::setInvert",1,"gsSensor *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsSensor::setInvert",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_setInvert",1,SWIGTYPE_p_gsSensor);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setInvert(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_isInverse(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSensor::isInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::isInverse",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_isInverse",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (bool)(arg1)->isInverse();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sensor_isPositive(lua_State* L) {
  int SWIG_arg = 0;
  gsSensor *arg1 = (gsSensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSensor::isPositive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSensor::isPositive",1,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Sensor_isPositive",1,SWIGTYPE_p_gsSensor);
  }
  
  result = (bool)(arg1)->isPositive();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Sensor(void *obj) {
gsSensor *arg1 = (gsSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_Sensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Sensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Sensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Sensor_methods[]= {
    { "setPulse", _wrap_Sensor_setPulse},
    { "getPulse", _wrap_Sensor_getPulse},
    { "setFrequency", _wrap_Sensor_setFrequency},
    { "getFrequency", _wrap_Sensor_getFrequency},
    { "setLevel", _wrap_Sensor_setLevel},
    { "isLevel", _wrap_Sensor_isLevel},
    { "setTap", _wrap_Sensor_setTap},
    { "isTap", _wrap_Sensor_isTap},
    { "setInvert", _wrap_Sensor_setInvert},
    { "isInverse", _wrap_Sensor_isInverse},
    { "isPositive", _wrap_Sensor_isPositive},
    {0,0}
};
static swig_lua_method swig_Sensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Sensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Sensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Sensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Sensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Sensor_Sf_SwigStatic = {
    "Sensor",
    swig_Sensor_Sf_SwigStatic_methods,
    swig_Sensor_Sf_SwigStatic_attributes,
    swig_Sensor_Sf_SwigStatic_constants,
    swig_Sensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Sensor_bases[] = {0,0};
static const char *swig_Sensor_base_names[] = {"gsBrick *",0};
static swig_lua_class _wrap_class_Sensor = { "Sensor", "Sensor", &SWIGTYPE_p_gsSensor,_proxy__wrap_new_Sensor, swig_delete_Sensor, swig_Sensor_methods, swig_Sensor_attributes, &swig_Sensor_Sf_SwigStatic, swig_Sensor_meta, swig_Sensor_bases, swig_Sensor_base_names };

static int _wrap_new_ActuatorSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsActuatorSensor *result = 0 ;
  
  SWIG_check_num_args("gsActuatorSensor::gsActuatorSensor",0,0)
  result = (gsActuatorSensor *)new gsActuatorSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActuatorSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActuatorSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsActuatorSensor *result = 0 ;
  
  SWIG_check_num_args("gsActuatorSensor::gsActuatorSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActuatorSensor::gsActuatorSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsActuatorSensor::gsActuatorSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ActuatorSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsActuatorSensor *)new gsActuatorSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActuatorSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActuatorSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsActuatorSensor *result = 0 ;
  
  SWIG_check_num_args("gsActuatorSensor::gsActuatorSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActuatorSensor::gsActuatorSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ActuatorSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsActuatorSensor *)new gsActuatorSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActuatorSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActuatorSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ActuatorSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ActuatorSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ActuatorSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ActuatorSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsActuatorSensor::gsActuatorSensor()\n"
    "    gsActuatorSensor::gsActuatorSensor(gsLogicObject *,gkString const &)\n"
    "    gsActuatorSensor::gsActuatorSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_ActuatorSensor_setActuatorName(lua_State* L) {
  int SWIG_arg = 0;
  gsActuatorSensor *arg1 = (gsActuatorSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsActuatorSensor::setActuatorName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActuatorSensor::setActuatorName",1,"gsActuatorSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsActuatorSensor::setActuatorName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActuatorSensor,0))){
    SWIG_fail_ptr("ActuatorSensor_setActuatorName",1,SWIGTYPE_p_gsActuatorSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setActuatorName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActuatorSensor_getActuatorName(lua_State* L) {
  int SWIG_arg = 0;
  gsActuatorSensor *arg1 = (gsActuatorSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsActuatorSensor::getActuatorName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActuatorSensor::getActuatorName",1,"gsActuatorSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActuatorSensor,0))){
    SWIG_fail_ptr("ActuatorSensor_getActuatorName",1,SWIGTYPE_p_gsActuatorSensor);
  }
  
  result = (arg1)->getActuatorName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ActuatorSensor(void *obj) {
gsActuatorSensor *arg1 = (gsActuatorSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_ActuatorSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ActuatorSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ActuatorSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ActuatorSensor_methods[]= {
    { "setActuatorName", _wrap_ActuatorSensor_setActuatorName},
    { "getActuatorName", _wrap_ActuatorSensor_getActuatorName},
    {0,0}
};
static swig_lua_method swig_ActuatorSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ActuatorSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ActuatorSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ActuatorSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ActuatorSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ActuatorSensor_Sf_SwigStatic = {
    "ActuatorSensor",
    swig_ActuatorSensor_Sf_SwigStatic_methods,
    swig_ActuatorSensor_Sf_SwigStatic_attributes,
    swig_ActuatorSensor_Sf_SwigStatic_constants,
    swig_ActuatorSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ActuatorSensor_bases[] = {0,0};
static const char *swig_ActuatorSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_ActuatorSensor = { "ActuatorSensor", "ActuatorSensor", &SWIGTYPE_p_gsActuatorSensor,_proxy__wrap_new_ActuatorSensor, swig_delete_ActuatorSensor, swig_ActuatorSensor_methods, swig_ActuatorSensor_attributes, &swig_ActuatorSensor_Sf_SwigStatic, swig_ActuatorSensor_meta, swig_ActuatorSensor_bases, swig_ActuatorSensor_base_names };

static int _wrap_new_AlwaysSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsAlwaysSensor *result = 0 ;
  
  SWIG_check_num_args("gsAlwaysSensor::gsAlwaysSensor",0,0)
  result = (gsAlwaysSensor *)new gsAlwaysSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAlwaysSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AlwaysSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsAlwaysSensor *result = 0 ;
  
  SWIG_check_num_args("gsAlwaysSensor::gsAlwaysSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAlwaysSensor::gsAlwaysSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAlwaysSensor::gsAlwaysSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_AlwaysSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsAlwaysSensor *)new gsAlwaysSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAlwaysSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AlwaysSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsAlwaysSensor *result = 0 ;
  
  SWIG_check_num_args("gsAlwaysSensor::gsAlwaysSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAlwaysSensor::gsAlwaysSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_AlwaysSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsAlwaysSensor *)new gsAlwaysSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAlwaysSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AlwaysSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AlwaysSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_AlwaysSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_AlwaysSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_AlwaysSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsAlwaysSensor::gsAlwaysSensor()\n"
    "    gsAlwaysSensor::gsAlwaysSensor(gsLogicObject *,gkString const &)\n"
    "    gsAlwaysSensor::gsAlwaysSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static void swig_delete_AlwaysSensor(void *obj) {
gsAlwaysSensor *arg1 = (gsAlwaysSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_AlwaysSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_AlwaysSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_AlwaysSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_AlwaysSensor_methods[]= {
    {0,0}
};
static swig_lua_method swig_AlwaysSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_AlwaysSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_AlwaysSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_AlwaysSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_AlwaysSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_AlwaysSensor_Sf_SwigStatic = {
    "AlwaysSensor",
    swig_AlwaysSensor_Sf_SwigStatic_methods,
    swig_AlwaysSensor_Sf_SwigStatic_attributes,
    swig_AlwaysSensor_Sf_SwigStatic_constants,
    swig_AlwaysSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_AlwaysSensor_bases[] = {0,0};
static const char *swig_AlwaysSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_AlwaysSensor = { "AlwaysSensor", "AlwaysSensor", &SWIGTYPE_p_gsAlwaysSensor,_proxy__wrap_new_AlwaysSensor, swig_delete_AlwaysSensor, swig_AlwaysSensor_methods, swig_AlwaysSensor_attributes, &swig_AlwaysSensor_Sf_SwigStatic, swig_AlwaysSensor_meta, swig_AlwaysSensor_bases, swig_AlwaysSensor_base_names };

static int _wrap_new_CollisionSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *result = 0 ;
  
  SWIG_check_num_args("gsCollisionSensor::gsCollisionSensor",0,0)
  result = (gsCollisionSensor *)new gsCollisionSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCollisionSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CollisionSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsCollisionSensor *result = 0 ;
  
  SWIG_check_num_args("gsCollisionSensor::gsCollisionSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::gsCollisionSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsCollisionSensor::gsCollisionSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_CollisionSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsCollisionSensor *)new gsCollisionSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCollisionSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CollisionSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsCollisionSensor *result = 0 ;
  
  SWIG_check_num_args("gsCollisionSensor::gsCollisionSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::gsCollisionSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_CollisionSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsCollisionSensor *)new gsCollisionSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCollisionSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CollisionSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_CollisionSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_CollisionSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_CollisionSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_CollisionSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsCollisionSensor::gsCollisionSensor()\n"
    "    gsCollisionSensor::gsCollisionSensor(gsLogicObject *,gkString const &)\n"
    "    gsCollisionSensor::gsCollisionSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_CollisionSensor_setMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsCollisionSensor::setMaterialName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::setMaterialName",1,"gsCollisionSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsCollisionSensor::setMaterialName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_setMaterialName",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterialName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CollisionSensor_getMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsCollisionSensor::getMaterialName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::getMaterialName",1,"gsCollisionSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_getMaterialName",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  result = (arg1)->getMaterialName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CollisionSensor_setPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsCollisionSensor::setPropertyName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::setPropertyName",1,"gsCollisionSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsCollisionSensor::setPropertyName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_setPropertyName",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropertyName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CollisionSensor_getPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsCollisionSensor::getPropertyName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::getPropertyName",1,"gsCollisionSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_getPropertyName",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  result = (arg1)->getPropertyName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CollisionSensor_getHitObjectsCount(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsCollisionSensor::getHitObjectsCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::getHitObjectsCount",1,"gsCollisionSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_getHitObjectsCount",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  result = (int)(arg1)->getHitObjectsCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CollisionSensor_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionSensor *arg1 = (gsCollisionSensor *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsCollisionSensor::getHitObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionSensor::getHitObject",1,"gsCollisionSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCollisionSensor::getHitObject",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionSensor,0))){
    SWIG_fail_ptr("CollisionSensor_getHitObject",1,SWIGTYPE_p_gsCollisionSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getHitObject(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CollisionSensor(void *obj) {
gsCollisionSensor *arg1 = (gsCollisionSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_CollisionSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_CollisionSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_CollisionSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_CollisionSensor_methods[]= {
    { "setMaterialName", _wrap_CollisionSensor_setMaterialName},
    { "getMaterialName", _wrap_CollisionSensor_getMaterialName},
    { "setPropertyName", _wrap_CollisionSensor_setPropertyName},
    { "getPropertyName", _wrap_CollisionSensor_getPropertyName},
    { "getHitObjectsCount", _wrap_CollisionSensor_getHitObjectsCount},
    { "getHitObject", _wrap_CollisionSensor_getHitObject},
    {0,0}
};
static swig_lua_method swig_CollisionSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_CollisionSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_CollisionSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_CollisionSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_CollisionSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_CollisionSensor_Sf_SwigStatic = {
    "CollisionSensor",
    swig_CollisionSensor_Sf_SwigStatic_methods,
    swig_CollisionSensor_Sf_SwigStatic_attributes,
    swig_CollisionSensor_Sf_SwigStatic_constants,
    swig_CollisionSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_CollisionSensor_bases[] = {0,0};
static const char *swig_CollisionSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_CollisionSensor = { "CollisionSensor", "CollisionSensor", &SWIGTYPE_p_gsCollisionSensor,_proxy__wrap_new_CollisionSensor, swig_delete_CollisionSensor, swig_CollisionSensor_methods, swig_CollisionSensor_attributes, &swig_CollisionSensor_Sf_SwigStatic, swig_CollisionSensor_meta, swig_CollisionSensor_bases, swig_CollisionSensor_base_names };

static int _wrap_new_gsTouchSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *result = 0 ;
  
  SWIG_check_num_args("gsTouchSensor::gsTouchSensor",0,0)
  result = (gsTouchSensor *)new gsTouchSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTouchSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTouchSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsTouchSensor *result = 0 ;
  
  SWIG_check_num_args("gsTouchSensor::gsTouchSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::gsTouchSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTouchSensor::gsTouchSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_gsTouchSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsTouchSensor *)new gsTouchSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTouchSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTouchSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsTouchSensor *result = 0 ;
  
  SWIG_check_num_args("gsTouchSensor::gsTouchSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::gsTouchSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_gsTouchSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsTouchSensor *)new gsTouchSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTouchSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsTouchSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_gsTouchSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gsTouchSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_gsTouchSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsTouchSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsTouchSensor::gsTouchSensor()\n"
    "    gsTouchSensor::gsTouchSensor(gsLogicObject *,gkString const &)\n"
    "    gsTouchSensor::gsTouchSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsTouchSensor_setMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTouchSensor::setMaterialName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::setMaterialName",1,"gsTouchSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTouchSensor::setMaterialName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_setMaterialName",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterialName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTouchSensor_getMaterialName(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsTouchSensor::getMaterialName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::getMaterialName",1,"gsTouchSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_getMaterialName",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  result = (arg1)->getMaterialName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTouchSensor_setPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTouchSensor::setPropertyName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::setPropertyName",1,"gsTouchSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTouchSensor::setPropertyName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_setPropertyName",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropertyName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTouchSensor_getPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsTouchSensor::getPropertyName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::getPropertyName",1,"gsTouchSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_getPropertyName",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  result = (arg1)->getPropertyName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTouchSensor_getHitObjectsCount(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsTouchSensor::getHitObjectsCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::getHitObjectsCount",1,"gsTouchSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_getHitObjectsCount",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  result = (int)(arg1)->getHitObjectsCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTouchSensor_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsTouchSensor *arg1 = (gsTouchSensor *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsTouchSensor::getHitObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTouchSensor::getHitObject",1,"gsTouchSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTouchSensor::getHitObject",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTouchSensor,0))){
    SWIG_fail_ptr("gsTouchSensor_getHitObject",1,SWIGTYPE_p_gsTouchSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getHitObject(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTouchSensor(void *obj) {
gsTouchSensor *arg1 = (gsTouchSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTouchSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTouchSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTouchSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTouchSensor_methods[]= {
    { "setMaterialName", _wrap_gsTouchSensor_setMaterialName},
    { "getMaterialName", _wrap_gsTouchSensor_getMaterialName},
    { "setPropertyName", _wrap_gsTouchSensor_setPropertyName},
    { "getPropertyName", _wrap_gsTouchSensor_getPropertyName},
    { "getHitObjectsCount", _wrap_gsTouchSensor_getHitObjectsCount},
    { "getHitObject", _wrap_gsTouchSensor_getHitObject},
    {0,0}
};
static swig_lua_method swig_gsTouchSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTouchSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTouchSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTouchSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTouchSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTouchSensor_Sf_SwigStatic = {
    "gsTouchSensor",
    swig_gsTouchSensor_Sf_SwigStatic_methods,
    swig_gsTouchSensor_Sf_SwigStatic_attributes,
    swig_gsTouchSensor_Sf_SwigStatic_constants,
    swig_gsTouchSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTouchSensor_bases[] = {0,0};
static const char *swig_gsTouchSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_gsTouchSensor = { "gsTouchSensor", "gsTouchSensor", &SWIGTYPE_p_gsTouchSensor,_proxy__wrap_new_gsTouchSensor, swig_delete_gsTouchSensor, swig_gsTouchSensor_methods, swig_gsTouchSensor_attributes, &swig_gsTouchSensor_Sf_SwigStatic, swig_gsTouchSensor_meta, swig_gsTouchSensor_bases, swig_gsTouchSensor_base_names };

static int _wrap_new_DelaySensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *result = 0 ;
  
  SWIG_check_num_args("gsDelaySensor::gsDelaySensor",0,0)
  result = (gsDelaySensor *)new gsDelaySensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDelaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DelaySensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsDelaySensor *result = 0 ;
  
  SWIG_check_num_args("gsDelaySensor::gsDelaySensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::gsDelaySensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsDelaySensor::gsDelaySensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_DelaySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsDelaySensor *)new gsDelaySensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDelaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DelaySensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsDelaySensor *result = 0 ;
  
  SWIG_check_num_args("gsDelaySensor::gsDelaySensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::gsDelaySensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_DelaySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsDelaySensor *)new gsDelaySensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDelaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DelaySensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_DelaySensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_DelaySensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_DelaySensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_DelaySensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsDelaySensor::gsDelaySensor()\n"
    "    gsDelaySensor::gsDelaySensor(gsLogicObject *,gkString const &)\n"
    "    gsDelaySensor::gsDelaySensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_DelaySensor_setDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsDelaySensor::setDelay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::setDelay",1,"gsDelaySensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsDelaySensor::setDelay",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_setDelay",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDelay(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DelaySensor_setDuration(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsDelaySensor::setDuration",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::setDuration",1,"gsDelaySensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsDelaySensor::setDuration",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_setDuration",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDuration(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DelaySensor_setRepeat(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsDelaySensor::setRepeat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::setRepeat",1,"gsDelaySensor *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsDelaySensor::setRepeat",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_setRepeat",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setRepeat(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DelaySensor_getDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsDelaySensor::getDelay",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::getDelay",1,"gsDelaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_getDelay",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  result = (int)(arg1)->getDelay();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DelaySensor_getDuration(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsDelaySensor::getDuration",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::getDuration",1,"gsDelaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_getDuration",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  result = (int)(arg1)->getDuration();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DelaySensor_getRepeat(lua_State* L) {
  int SWIG_arg = 0;
  gsDelaySensor *arg1 = (gsDelaySensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsDelaySensor::getRepeat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDelaySensor::getRepeat",1,"gsDelaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDelaySensor,0))){
    SWIG_fail_ptr("DelaySensor_getRepeat",1,SWIGTYPE_p_gsDelaySensor);
  }
  
  result = (bool)(arg1)->getRepeat();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_DelaySensor(void *obj) {
gsDelaySensor *arg1 = (gsDelaySensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_DelaySensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_DelaySensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_DelaySensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_DelaySensor_methods[]= {
    { "setDelay", _wrap_DelaySensor_setDelay},
    { "setDuration", _wrap_DelaySensor_setDuration},
    { "setRepeat", _wrap_DelaySensor_setRepeat},
    { "getDelay", _wrap_DelaySensor_getDelay},
    { "getDuration", _wrap_DelaySensor_getDuration},
    { "getRepeat", _wrap_DelaySensor_getRepeat},
    {0,0}
};
static swig_lua_method swig_DelaySensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_DelaySensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_DelaySensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_DelaySensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_DelaySensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_DelaySensor_Sf_SwigStatic = {
    "DelaySensor",
    swig_DelaySensor_Sf_SwigStatic_methods,
    swig_DelaySensor_Sf_SwigStatic_attributes,
    swig_DelaySensor_Sf_SwigStatic_constants,
    swig_DelaySensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_DelaySensor_bases[] = {0,0};
static const char *swig_DelaySensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_DelaySensor = { "DelaySensor", "DelaySensor", &SWIGTYPE_p_gsDelaySensor,_proxy__wrap_new_DelaySensor, swig_delete_DelaySensor, swig_DelaySensor_methods, swig_DelaySensor_attributes, &swig_DelaySensor_Sf_SwigStatic, swig_DelaySensor_meta, swig_DelaySensor_bases, swig_DelaySensor_base_names };

static int _wrap_new_KeyboardSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *result = 0 ;
  
  SWIG_check_num_args("gsKeyboardSensor::gsKeyboardSensor",0,0)
  result = (gsKeyboardSensor *)new gsKeyboardSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsKeyboardSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KeyboardSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsKeyboardSensor *result = 0 ;
  
  SWIG_check_num_args("gsKeyboardSensor::gsKeyboardSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::gsKeyboardSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsKeyboardSensor::gsKeyboardSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_KeyboardSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsKeyboardSensor *)new gsKeyboardSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsKeyboardSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KeyboardSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsKeyboardSensor *result = 0 ;
  
  SWIG_check_num_args("gsKeyboardSensor::gsKeyboardSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::gsKeyboardSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_KeyboardSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsKeyboardSensor *)new gsKeyboardSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsKeyboardSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KeyboardSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_KeyboardSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_KeyboardSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_KeyboardSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_KeyboardSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsKeyboardSensor::gsKeyboardSensor()\n"
    "    gsKeyboardSensor::gsKeyboardSensor(gsLogicObject *,gkString const &)\n"
    "    gsKeyboardSensor::gsKeyboardSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_KeyboardSensor_setKey(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsKeyboardSensor::setKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::setKey",1,"gsKeyboardSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboardSensor::setKey",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_setKey",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setKey(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_setModifier0(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsKeyboardSensor::setModifier0",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::setModifier0",1,"gsKeyboardSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboardSensor::setModifier0",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_setModifier0",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setModifier0(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_setModifier1(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsKeyboardSensor::setModifier1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::setModifier1",1,"gsKeyboardSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyboardSensor::setModifier1",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_setModifier1",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setModifier1(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_setAllKeys(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsKeyboardSensor::setAllKeys",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::setAllKeys",1,"gsKeyboardSensor *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsKeyboardSensor::setAllKeys",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_setAllKeys",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setAllKeys(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_getKey(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsKeyboardSensor::getKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::getKey",1,"gsKeyboardSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_getKey",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  result = (int)(arg1)->getKey();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_getModifier0(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsKeyboardSensor::getModifier0",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::getModifier0",1,"gsKeyboardSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_getModifier0",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  result = (int)(arg1)->getModifier0();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_getModifier1(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsKeyboardSensor::getModifier1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::getModifier1",1,"gsKeyboardSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_getModifier1",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  result = (int)(arg1)->getModifier1();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KeyboardSensor_getAllKeys(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyboardSensor *arg1 = (gsKeyboardSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsKeyboardSensor::getAllKeys",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyboardSensor::getAllKeys",1,"gsKeyboardSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyboardSensor,0))){
    SWIG_fail_ptr("KeyboardSensor_getAllKeys",1,SWIGTYPE_p_gsKeyboardSensor);
  }
  
  result = (int)(arg1)->getAllKeys();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_KeyboardSensor(void *obj) {
gsKeyboardSensor *arg1 = (gsKeyboardSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_KeyboardSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_KeyboardSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_KeyboardSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_KeyboardSensor_methods[]= {
    { "setKey", _wrap_KeyboardSensor_setKey},
    { "setModifier0", _wrap_KeyboardSensor_setModifier0},
    { "setModifier1", _wrap_KeyboardSensor_setModifier1},
    { "setAllKeys", _wrap_KeyboardSensor_setAllKeys},
    { "getKey", _wrap_KeyboardSensor_getKey},
    { "getModifier0", _wrap_KeyboardSensor_getModifier0},
    { "getModifier1", _wrap_KeyboardSensor_getModifier1},
    { "getAllKeys", _wrap_KeyboardSensor_getAllKeys},
    {0,0}
};
static swig_lua_method swig_KeyboardSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_KeyboardSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_KeyboardSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_KeyboardSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_KeyboardSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_KeyboardSensor_Sf_SwigStatic = {
    "KeyboardSensor",
    swig_KeyboardSensor_Sf_SwigStatic_methods,
    swig_KeyboardSensor_Sf_SwigStatic_attributes,
    swig_KeyboardSensor_Sf_SwigStatic_constants,
    swig_KeyboardSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_KeyboardSensor_bases[] = {0,0};
static const char *swig_KeyboardSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_KeyboardSensor = { "KeyboardSensor", "KeyboardSensor", &SWIGTYPE_p_gsKeyboardSensor,_proxy__wrap_new_KeyboardSensor, swig_delete_KeyboardSensor, swig_KeyboardSensor_methods, swig_KeyboardSensor_attributes, &swig_KeyboardSensor_Sf_SwigStatic, swig_KeyboardSensor_meta, swig_KeyboardSensor_bases, swig_KeyboardSensor_base_names };

static int _wrap_new_MessageSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *result = 0 ;
  
  SWIG_check_num_args("gsMessageSensor::gsMessageSensor",0,0)
  result = (gsMessageSensor *)new gsMessageSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsMessageSensor *result = 0 ;
  
  SWIG_check_num_args("gsMessageSensor::gsMessageSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::gsMessageSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageSensor::gsMessageSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MessageSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsMessageSensor *)new gsMessageSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsMessageSensor *result = 0 ;
  
  SWIG_check_num_args("gsMessageSensor::gsMessageSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::gsMessageSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MessageSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsMessageSensor *)new gsMessageSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_MessageSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_MessageSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_MessageSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_MessageSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMessageSensor::gsMessageSensor()\n"
    "    gsMessageSensor::gsMessageSensor(gsLogicObject *,gkString const &)\n"
    "    gsMessageSensor::gsMessageSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_MessageSensor_setSubject(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageSensor::setSubject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::setSubject",1,"gsMessageSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageSensor::setSubject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_setSubject",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setSubject((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getSubject(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSensor::getSubject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getSubject",1,"gsMessageSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getSubject",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  result = (arg1)->getSubject();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getMessageCount(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMessageSensor::getMessageCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getMessageCount",1,"gsMessageSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getMessageCount",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  result = (int)(arg1)->getMessageCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getMessageSubject(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSensor::getMessageSubject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getMessageSubject",1,"gsMessageSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMessageSensor::getMessageSubject",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getMessageSubject",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getMessageSubject(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getMessageBody(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSensor::getMessageBody",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getMessageBody",1,"gsMessageSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMessageSensor::getMessageBody",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getMessageBody",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getMessageBody(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getMessageFrom(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSensor::getMessageFrom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getMessageFrom",1,"gsMessageSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMessageSensor::getMessageFrom",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getMessageFrom",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getMessageFrom(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageSensor_getMessageTo(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSensor *arg1 = (gsMessageSensor *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSensor::getMessageTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSensor::getMessageTo",1,"gsMessageSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMessageSensor::getMessageTo",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSensor,0))){
    SWIG_fail_ptr("MessageSensor_getMessageTo",1,SWIGTYPE_p_gsMessageSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getMessageTo(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MessageSensor(void *obj) {
gsMessageSensor *arg1 = (gsMessageSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_MessageSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MessageSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MessageSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MessageSensor_methods[]= {
    { "setSubject", _wrap_MessageSensor_setSubject},
    { "getSubject", _wrap_MessageSensor_getSubject},
    { "getMessageCount", _wrap_MessageSensor_getMessageCount},
    { "getMessageSubject", _wrap_MessageSensor_getMessageSubject},
    { "getMessageBody", _wrap_MessageSensor_getMessageBody},
    { "getMessageFrom", _wrap_MessageSensor_getMessageFrom},
    { "getMessageTo", _wrap_MessageSensor_getMessageTo},
    {0,0}
};
static swig_lua_method swig_MessageSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MessageSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MessageSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MessageSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MessageSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MessageSensor_Sf_SwigStatic = {
    "MessageSensor",
    swig_MessageSensor_Sf_SwigStatic_methods,
    swig_MessageSensor_Sf_SwigStatic_attributes,
    swig_MessageSensor_Sf_SwigStatic_constants,
    swig_MessageSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MessageSensor_bases[] = {0,0};
static const char *swig_MessageSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_MessageSensor = { "MessageSensor", "MessageSensor", &SWIGTYPE_p_gsMessageSensor,_proxy__wrap_new_MessageSensor, swig_delete_MessageSensor, swig_MessageSensor_methods, swig_MessageSensor_attributes, &swig_MessageSensor_Sf_SwigStatic, swig_MessageSensor_meta, swig_MessageSensor_bases, swig_MessageSensor_base_names };

static int _wrap_new_MouseSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseSensor *result = 0 ;
  
  SWIG_check_num_args("gsMouseSensor::gsMouseSensor",0,0)
  result = (gsMouseSensor *)new gsMouseSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouseSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MouseSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsMouseSensor *result = 0 ;
  
  SWIG_check_num_args("gsMouseSensor::gsMouseSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseSensor::gsMouseSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMouseSensor::gsMouseSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MouseSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsMouseSensor *)new gsMouseSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouseSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MouseSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsMouseSensor *result = 0 ;
  
  SWIG_check_num_args("gsMouseSensor::gsMouseSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseSensor::gsMouseSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MouseSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsMouseSensor *)new gsMouseSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouseSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MouseSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_MouseSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_MouseSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_MouseSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_MouseSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMouseSensor::gsMouseSensor()\n"
    "    gsMouseSensor::gsMouseSensor(gsLogicObject *,gkString const &)\n"
    "    gsMouseSensor::gsMouseSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_MouseSensor_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseSensor *arg1 = (gsMouseSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMouseSensor::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseSensor::setType",1,"gsMouseSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouseSensor::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseSensor,0))){
    SWIG_fail_ptr("MouseSensor_setType",1,SWIGTYPE_p_gsMouseSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MouseSensor_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseSensor *arg1 = (gsMouseSensor *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("gsMouseSensor::getType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseSensor::getType",1,"gsMouseSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouseSensor::getType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseSensor,0))){
    SWIG_fail_ptr("MouseSensor_getType",1,SWIGTYPE_p_gsMouseSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->getType(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MouseSensor(void *obj) {
gsMouseSensor *arg1 = (gsMouseSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_MouseSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MouseSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MouseSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MouseSensor_methods[]= {
    { "setType", _wrap_MouseSensor_setType},
    { "getType", _wrap_MouseSensor_getType},
    {0,0}
};
static swig_lua_method swig_MouseSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MouseSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MouseSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MouseSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MouseSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MouseSensor_Sf_SwigStatic = {
    "MouseSensor",
    swig_MouseSensor_Sf_SwigStatic_methods,
    swig_MouseSensor_Sf_SwigStatic_attributes,
    swig_MouseSensor_Sf_SwigStatic_constants,
    swig_MouseSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MouseSensor_bases[] = {0,0};
static const char *swig_MouseSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_MouseSensor = { "MouseSensor", "MouseSensor", &SWIGTYPE_p_gsMouseSensor,_proxy__wrap_new_MouseSensor, swig_delete_MouseSensor, swig_MouseSensor_methods, swig_MouseSensor_attributes, &swig_MouseSensor_Sf_SwigStatic, swig_MouseSensor_meta, swig_MouseSensor_bases, swig_MouseSensor_base_names };

static int _wrap_new_NearSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *result = 0 ;
  
  SWIG_check_num_args("gsNearSensor::gsNearSensor",0,0)
  result = (gsNearSensor *)new gsNearSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNearSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NearSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsNearSensor *result = 0 ;
  
  SWIG_check_num_args("gsNearSensor::gsNearSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::gsNearSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsNearSensor::gsNearSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_NearSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsNearSensor *)new gsNearSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNearSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NearSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsNearSensor *result = 0 ;
  
  SWIG_check_num_args("gsNearSensor::gsNearSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::gsNearSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_NearSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsNearSensor *)new gsNearSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNearSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NearSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_NearSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_NearSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_NearSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_NearSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsNearSensor::gsNearSensor()\n"
    "    gsNearSensor::gsNearSensor(gsLogicObject *,gkString const &)\n"
    "    gsNearSensor::gsNearSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_NearSensor_setRange(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsNearSensor::setRange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::setRange",1,"gsNearSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsNearSensor::setRange",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_setRange",1,SWIGTYPE_p_gsNearSensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRange(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_setResetRange(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsNearSensor::setResetRange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::setResetRange",1,"gsNearSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsNearSensor::setResetRange",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_setResetRange",1,SWIGTYPE_p_gsNearSensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setResetRange(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_setMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsNearSensor::setMaterial",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::setMaterial",1,"gsNearSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsNearSensor::setMaterial",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_setMaterial",1,SWIGTYPE_p_gsNearSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterial((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsNearSensor::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::setProperty",1,"gsNearSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsNearSensor::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_setProperty",1,SWIGTYPE_p_gsNearSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getRange(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsNearSensor::getRange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getRange",1,"gsNearSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getRange",1,SWIGTYPE_p_gsNearSensor);
  }
  
  result = (float)(arg1)->getRange();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getResetRange(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsNearSensor::getResetRange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getResetRange",1,"gsNearSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getResetRange",1,SWIGTYPE_p_gsNearSensor);
  }
  
  result = (float)(arg1)->getResetRange();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsNearSensor::getMaterial",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getMaterial",1,"gsNearSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getMaterial",1,SWIGTYPE_p_gsNearSensor);
  }
  
  result = (arg1)->getMaterial();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsNearSensor::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getProperty",1,"gsNearSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getProperty",1,SWIGTYPE_p_gsNearSensor);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getNearObjectCount(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsNearSensor::getNearObjectCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getNearObjectCount",1,"gsNearSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getNearObjectCount",1,SWIGTYPE_p_gsNearSensor);
  }
  
  result = (int)(arg1)->getNearObjectCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSensor_getNearObject(lua_State* L) {
  int SWIG_arg = 0;
  gsNearSensor *arg1 = (gsNearSensor *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsNearSensor::getNearObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNearSensor::getNearObject",1,"gsNearSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsNearSensor::getNearObject",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNearSensor,0))){
    SWIG_fail_ptr("NearSensor_getNearObject",1,SWIGTYPE_p_gsNearSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getNearObject(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NearSensor(void *obj) {
gsNearSensor *arg1 = (gsNearSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_NearSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_NearSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_NearSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_NearSensor_methods[]= {
    { "setRange", _wrap_NearSensor_setRange},
    { "setResetRange", _wrap_NearSensor_setResetRange},
    { "setMaterial", _wrap_NearSensor_setMaterial},
    { "setProperty", _wrap_NearSensor_setProperty},
    { "getRange", _wrap_NearSensor_getRange},
    { "getResetRange", _wrap_NearSensor_getResetRange},
    { "getMaterial", _wrap_NearSensor_getMaterial},
    { "getProperty", _wrap_NearSensor_getProperty},
    { "getNearObjectCount", _wrap_NearSensor_getNearObjectCount},
    { "getNearObject", _wrap_NearSensor_getNearObject},
    {0,0}
};
static swig_lua_method swig_NearSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_NearSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_NearSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_NearSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_NearSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_NearSensor_Sf_SwigStatic = {
    "NearSensor",
    swig_NearSensor_Sf_SwigStatic_methods,
    swig_NearSensor_Sf_SwigStatic_attributes,
    swig_NearSensor_Sf_SwigStatic_constants,
    swig_NearSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_NearSensor_bases[] = {0,0};
static const char *swig_NearSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_NearSensor = { "NearSensor", "NearSensor", &SWIGTYPE_p_gsNearSensor,_proxy__wrap_new_NearSensor, swig_delete_NearSensor, swig_NearSensor_methods, swig_NearSensor_attributes, &swig_NearSensor_Sf_SwigStatic, swig_NearSensor_meta, swig_NearSensor_bases, swig_NearSensor_base_names };

static int _wrap_new_PropertySensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *result = 0 ;
  
  SWIG_check_num_args("gsPropertySensor::gsPropertySensor",0,0)
  result = (gsPropertySensor *)new gsPropertySensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertySensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsPropertySensor *result = 0 ;
  
  SWIG_check_num_args("gsPropertySensor::gsPropertySensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::gsPropertySensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertySensor::gsPropertySensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_PropertySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsPropertySensor *)new gsPropertySensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertySensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsPropertySensor *result = 0 ;
  
  SWIG_check_num_args("gsPropertySensor::gsPropertySensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::gsPropertySensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_PropertySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsPropertySensor *)new gsPropertySensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertySensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_PropertySensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_PropertySensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_PropertySensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_PropertySensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsPropertySensor::gsPropertySensor()\n"
    "    gsPropertySensor::gsPropertySensor(gsLogicObject *,gkString const &)\n"
    "    gsPropertySensor::gsPropertySensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_PropertySensor_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPropertySensor::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::setType",1,"gsPropertySensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPropertySensor::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_setType",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertySensor_setPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertySensor::setPropertyName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::setPropertyName",1,"gsPropertySensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertySensor::setPropertyName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_setPropertyName",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropertyName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertySensor_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertySensor::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::setValue",1,"gsPropertySensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertySensor::setValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_setValue",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertySensor_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPropertySensor::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::getType",1,"gsPropertySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_getType",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertySensor_getPropertyName(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertySensor::getPropertyName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::getPropertyName",1,"gsPropertySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_getPropertyName",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  result = (arg1)->getPropertyName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertySensor_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertySensor *arg1 = (gsPropertySensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertySensor::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertySensor::getValue",1,"gsPropertySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertySensor,0))){
    SWIG_fail_ptr("PropertySensor_getValue",1,SWIGTYPE_p_gsPropertySensor);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PropertySensor(void *obj) {
gsPropertySensor *arg1 = (gsPropertySensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_PropertySensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_PropertySensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_PropertySensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_PropertySensor_methods[]= {
    { "setType", _wrap_PropertySensor_setType},
    { "setPropertyName", _wrap_PropertySensor_setPropertyName},
    { "setValue", _wrap_PropertySensor_setValue},
    { "getType", _wrap_PropertySensor_getType},
    { "getPropertyName", _wrap_PropertySensor_getPropertyName},
    { "getValue", _wrap_PropertySensor_getValue},
    {0,0}
};
static swig_lua_method swig_PropertySensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_PropertySensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_PropertySensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_PropertySensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_PropertySensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_PropertySensor_Sf_SwigStatic = {
    "PropertySensor",
    swig_PropertySensor_Sf_SwigStatic_methods,
    swig_PropertySensor_Sf_SwigStatic_attributes,
    swig_PropertySensor_Sf_SwigStatic_constants,
    swig_PropertySensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_PropertySensor_bases[] = {0,0};
static const char *swig_PropertySensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_PropertySensor = { "PropertySensor", "PropertySensor", &SWIGTYPE_p_gsPropertySensor,_proxy__wrap_new_PropertySensor, swig_delete_PropertySensor, swig_PropertySensor_methods, swig_PropertySensor_attributes, &swig_PropertySensor_Sf_SwigStatic, swig_PropertySensor_meta, swig_PropertySensor_bases, swig_PropertySensor_base_names };

static int _wrap_new_RaySensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *result = 0 ;
  
  SWIG_check_num_args("gsRaySensor::gsRaySensor",0,0)
  result = (gsRaySensor *)new gsRaySensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RaySensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsRaySensor *result = 0 ;
  
  SWIG_check_num_args("gsRaySensor::gsRaySensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::gsRaySensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRaySensor::gsRaySensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RaySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsRaySensor *)new gsRaySensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RaySensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsRaySensor *result = 0 ;
  
  SWIG_check_num_args("gsRaySensor::gsRaySensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::gsRaySensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RaySensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsRaySensor *)new gsRaySensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRaySensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RaySensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RaySensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RaySensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_RaySensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_RaySensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRaySensor::gsRaySensor()\n"
    "    gsRaySensor::gsRaySensor(gsLogicObject *,gkString const &)\n"
    "    gsRaySensor::gsRaySensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_RaySensor_setRange(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRaySensor::setRange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::setRange",1,"gsRaySensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRaySensor::setRange",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_setRange",1,SWIGTYPE_p_gsRaySensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRange(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getRange(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRaySensor::getRange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getRange",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getRange",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (float)(arg1)->getRange();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_setAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsRaySensor::setAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::setAxis",1,"gsRaySensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRaySensor::setAxis",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_setAxis",1,SWIGTYPE_p_gsRaySensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setAxis(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRaySensor::getAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getAxis",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getAxis",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (int)(arg1)->getAxis();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_setMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRaySensor::setMaterial",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::setMaterial",1,"gsRaySensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRaySensor::setMaterial",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_setMaterial",1,SWIGTYPE_p_gsRaySensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterial((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsRaySensor::getMaterial",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getMaterial",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getMaterial",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (arg1)->getMaterial();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRaySensor::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::setProperty",1,"gsRaySensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRaySensor::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_setProperty",1,SWIGTYPE_p_gsRaySensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsRaySensor::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getProperty",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getProperty",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getHitPoint(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRaySensor::getHitPoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getHitPoint",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getHitPoint",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (arg1)->getHitPoint();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getHitNormal(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRaySensor::getHitNormal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getHitNormal",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getHitNormal",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (arg1)->getHitNormal();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsRaySensor::getHitObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getHitObject",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getHitObject",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (gkGameObject *)(arg1)->getHitObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_getHitFraction(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRaySensor::getHitFraction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::getHitFraction",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_getHitFraction",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (float)(arg1)->getHitFraction();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RaySensor_hasHit(lua_State* L) {
  int SWIG_arg = 0;
  gsRaySensor *arg1 = (gsRaySensor *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsRaySensor::hasHit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRaySensor::hasHit",1,"gsRaySensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRaySensor,0))){
    SWIG_fail_ptr("RaySensor_hasHit",1,SWIGTYPE_p_gsRaySensor);
  }
  
  result = (bool)(arg1)->hasHit();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RaySensor(void *obj) {
gsRaySensor *arg1 = (gsRaySensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_RaySensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_RaySensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_RaySensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_RaySensor_methods[]= {
    { "setRange", _wrap_RaySensor_setRange},
    { "getRange", _wrap_RaySensor_getRange},
    { "setAxis", _wrap_RaySensor_setAxis},
    { "getAxis", _wrap_RaySensor_getAxis},
    { "setMaterial", _wrap_RaySensor_setMaterial},
    { "getMaterial", _wrap_RaySensor_getMaterial},
    { "setProperty", _wrap_RaySensor_setProperty},
    { "getProperty", _wrap_RaySensor_getProperty},
    { "getHitPoint", _wrap_RaySensor_getHitPoint},
    { "getHitNormal", _wrap_RaySensor_getHitNormal},
    { "getHitObject", _wrap_RaySensor_getHitObject},
    { "getHitFraction", _wrap_RaySensor_getHitFraction},
    { "hasHit", _wrap_RaySensor_hasHit},
    {0,0}
};
static swig_lua_method swig_RaySensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_RaySensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_RaySensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_RaySensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_RaySensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_RaySensor_Sf_SwigStatic = {
    "RaySensor",
    swig_RaySensor_Sf_SwigStatic_methods,
    swig_RaySensor_Sf_SwigStatic_attributes,
    swig_RaySensor_Sf_SwigStatic_constants,
    swig_RaySensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_RaySensor_bases[] = {0,0};
static const char *swig_RaySensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_RaySensor = { "RaySensor", "RaySensor", &SWIGTYPE_p_gsRaySensor,_proxy__wrap_new_RaySensor, swig_delete_RaySensor, swig_RaySensor_methods, swig_RaySensor_attributes, &swig_RaySensor_Sf_SwigStatic, swig_RaySensor_meta, swig_RaySensor_bases, swig_RaySensor_base_names };

static int _wrap_new_RadarSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *result = 0 ;
  
  SWIG_check_num_args("gsRadarSensor::gsRadarSensor",0,0)
  result = (gsRadarSensor *)new gsRadarSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRadarSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RadarSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsRadarSensor *result = 0 ;
  
  SWIG_check_num_args("gsRadarSensor::gsRadarSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::gsRadarSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRadarSensor::gsRadarSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RadarSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsRadarSensor *)new gsRadarSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRadarSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RadarSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsRadarSensor *result = 0 ;
  
  SWIG_check_num_args("gsRadarSensor::gsRadarSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::gsRadarSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RadarSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsRadarSensor *)new gsRadarSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRadarSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RadarSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RadarSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RadarSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_RadarSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_RadarSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRadarSensor::gsRadarSensor()\n"
    "    gsRadarSensor::gsRadarSensor(gsLogicObject *,gkString const &)\n"
    "    gsRadarSensor::gsRadarSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_RadarSensor_setRange(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRadarSensor::setRange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::setRange",1,"gsRadarSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRadarSensor::setRange",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_setRange",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRange(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getRange(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRadarSensor::getRange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getRange",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getRange",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (float)(arg1)->getRange();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_setAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsRadarSensor::setAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::setAxis",1,"gsRadarSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRadarSensor::setAxis",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_setAxis",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setAxis(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getAxis(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRadarSensor::getAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getAxis",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getAxis",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (int)(arg1)->getAxis();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_setMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRadarSensor::setMaterial",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::setMaterial",1,"gsRadarSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRadarSensor::setMaterial",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_setMaterial",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMaterial((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getMaterial(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsRadarSensor::getMaterial",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getMaterial",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getMaterial",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (arg1)->getMaterial();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRadarSensor::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::setProperty",1,"gsRadarSensor *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRadarSensor::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_setProperty",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsRadarSensor::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getProperty",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getProperty",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_setAngle(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRadarSensor::setAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::setAngle",1,"gsRadarSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRadarSensor::setAngle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_setAngle",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setAngle(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getAngle(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRadarSensor::getAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getAngle",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getAngle",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (float)(arg1)->getAngle();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getHitObjectCount(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRadarSensor::getHitObjectCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getHitObjectCount",1,"gsRadarSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getHitObjectCount",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  result = (int)(arg1)->getHitObjectCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RadarSensor_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsRadarSensor *arg1 = (gsRadarSensor *) 0 ;
  int arg2 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsRadarSensor::getHitObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRadarSensor::getHitObject",1,"gsRadarSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRadarSensor::getHitObject",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRadarSensor,0))){
    SWIG_fail_ptr("RadarSensor_getHitObject",1,SWIGTYPE_p_gsRadarSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGameObject *)(arg1)->getHitObject(arg2);
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RadarSensor(void *obj) {
gsRadarSensor *arg1 = (gsRadarSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_RadarSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_RadarSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_RadarSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_RadarSensor_methods[]= {
    { "setRange", _wrap_RadarSensor_setRange},
    { "getRange", _wrap_RadarSensor_getRange},
    { "setAxis", _wrap_RadarSensor_setAxis},
    { "getAxis", _wrap_RadarSensor_getAxis},
    { "setMaterial", _wrap_RadarSensor_setMaterial},
    { "getMaterial", _wrap_RadarSensor_getMaterial},
    { "setProperty", _wrap_RadarSensor_setProperty},
    { "getProperty", _wrap_RadarSensor_getProperty},
    { "setAngle", _wrap_RadarSensor_setAngle},
    { "getAngle", _wrap_RadarSensor_getAngle},
    { "getHitObjectCount", _wrap_RadarSensor_getHitObjectCount},
    { "getHitObject", _wrap_RadarSensor_getHitObject},
    {0,0}
};
static swig_lua_method swig_RadarSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_RadarSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_RadarSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_RadarSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_RadarSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_RadarSensor_Sf_SwigStatic = {
    "RadarSensor",
    swig_RadarSensor_Sf_SwigStatic_methods,
    swig_RadarSensor_Sf_SwigStatic_attributes,
    swig_RadarSensor_Sf_SwigStatic_constants,
    swig_RadarSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_RadarSensor_bases[] = {0,0};
static const char *swig_RadarSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_RadarSensor = { "RadarSensor", "RadarSensor", &SWIGTYPE_p_gsRadarSensor,_proxy__wrap_new_RadarSensor, swig_delete_RadarSensor, swig_RadarSensor_methods, swig_RadarSensor_attributes, &swig_RadarSensor_Sf_SwigStatic, swig_RadarSensor_meta, swig_RadarSensor_bases, swig_RadarSensor_base_names };

static int _wrap_new_RandomSensor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomSensor *result = 0 ;
  
  SWIG_check_num_args("gsRandomSensor::gsRandomSensor",0,0)
  result = (gsRandomSensor *)new gsRandomSensor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomSensor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsRandomSensor *result = 0 ;
  
  SWIG_check_num_args("gsRandomSensor::gsRandomSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomSensor::gsRandomSensor",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRandomSensor::gsRandomSensor",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RandomSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsRandomSensor *)new gsRandomSensor(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomSensor__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsRandomSensor *result = 0 ;
  
  SWIG_check_num_args("gsRandomSensor::gsRandomSensor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomSensor::gsRandomSensor",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RandomSensor",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsRandomSensor *)new gsRandomSensor(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomSensor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomSensor(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RandomSensor__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RandomSensor__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_RandomSensor__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_RandomSensor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRandomSensor::gsRandomSensor()\n"
    "    gsRandomSensor::gsRandomSensor(gsLogicObject *,gkString const &)\n"
    "    gsRandomSensor::gsRandomSensor(gsLogicObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_RandomSensor_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomSensor *arg1 = (gsRandomSensor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsRandomSensor::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomSensor::setSeed",1,"gsRandomSensor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomSensor::setSeed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomSensor,0))){
    SWIG_fail_ptr("RandomSensor_setSeed",1,SWIGTYPE_p_gsRandomSensor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setSeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomSensor_getSeed(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomSensor *arg1 = (gsRandomSensor *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRandomSensor::getSeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomSensor::getSeed",1,"gsRandomSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomSensor,0))){
    SWIG_fail_ptr("RandomSensor_getSeed",1,SWIGTYPE_p_gsRandomSensor);
  }
  
  result = (int)(arg1)->getSeed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RandomSensor(void *obj) {
gsRandomSensor *arg1 = (gsRandomSensor *) obj;
delete arg1;
}
static int _proxy__wrap_new_RandomSensor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_RandomSensor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_RandomSensor_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_RandomSensor_methods[]= {
    { "setSeed", _wrap_RandomSensor_setSeed},
    { "getSeed", _wrap_RandomSensor_getSeed},
    {0,0}
};
static swig_lua_method swig_RandomSensor_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_RandomSensor_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_RandomSensor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_RandomSensor_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_RandomSensor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_RandomSensor_Sf_SwigStatic = {
    "RandomSensor",
    swig_RandomSensor_Sf_SwigStatic_methods,
    swig_RandomSensor_Sf_SwigStatic_attributes,
    swig_RandomSensor_Sf_SwigStatic_constants,
    swig_RandomSensor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_RandomSensor_bases[] = {0,0};
static const char *swig_RandomSensor_base_names[] = {"gsSensor *",0};
static swig_lua_class _wrap_class_RandomSensor = { "RandomSensor", "RandomSensor", &SWIGTYPE_p_gsRandomSensor,_proxy__wrap_new_RandomSensor, swig_delete_RandomSensor, swig_RandomSensor_methods, swig_RandomSensor_attributes, &swig_RandomSensor_Sf_SwigStatic, swig_RandomSensor_meta, swig_RandomSensor_bases, swig_RandomSensor_base_names };

static int _wrap_new_Controller(lua_State* L) {
  int SWIG_arg = 0;
  gsController *result = 0 ;
  
  SWIG_check_num_args("gsController::gsController",0,0)
  result = (gsController *)new gsController();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controller_link__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsController *arg1 = (gsController *) 0 ;
  gsSensor *arg2 = (gsSensor *) 0 ;
  
  SWIG_check_num_args("gsController::link",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsController::link",1,"gsController *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsController::link",2,"gsSensor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controller_link",1,SWIGTYPE_p_gsController);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSensor,0))){
    SWIG_fail_ptr("Controller_link",2,SWIGTYPE_p_gsSensor);
  }
  
  (arg1)->link(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controller_link__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsController *arg1 = (gsController *) 0 ;
  gsActuator *arg2 = (gsActuator *) 0 ;
  
  SWIG_check_num_args("gsController::link",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsController::link",1,"gsController *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsController::link",2,"gsActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controller_link",1,SWIGTYPE_p_gsController);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsActuator,0))){
    SWIG_fail_ptr("Controller_link",2,SWIGTYPE_p_gsActuator);
  }
  
  (arg1)->link(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controller_link(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsController, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsSensor, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Controller_link__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsController, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsActuator, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Controller_link__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Controller_link'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsController::link(gsSensor *)\n"
    "    gsController::link(gsActuator *)\n");
  lua_error(L);return 0;
}


static int _wrap_Controller_getSensor(lua_State* L) {
  int SWIG_arg = 0;
  gsController *arg1 = (gsController *) 0 ;
  gkString arg2 ;
  gkLogicSensor *result = 0 ;
  
  SWIG_check_num_args("gsController::getSensor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsController::getSensor",1,"gsController *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsController::getSensor",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controller_getSensor",1,SWIGTYPE_p_gsController);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  result = (gkLogicSensor *)(arg1)->getSensor(arg2);
  if (result) {
    SWIG_arg += gsWrapSensor(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Controller_getActuator(lua_State* L) {
  int SWIG_arg = 0;
  gsController *arg1 = (gsController *) 0 ;
  gkString arg2 ;
  gkLogicActuator *result = 0 ;
  
  SWIG_check_num_args("gsController::getActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsController::getActuator",1,"gsController *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsController::getActuator",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsController,0))){
    SWIG_fail_ptr("Controller_getActuator",1,SWIGTYPE_p_gsController);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  result = (gkLogicActuator *)(arg1)->getActuator(arg2);
  if (result) {
    SWIG_arg += gsWrapActuator(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Controller(void *obj) {
gsController *arg1 = (gsController *) obj;
delete arg1;
}
static int _proxy__wrap_new_Controller(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Controller);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Controller_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Controller_methods[]= {
    { "link", _wrap_Controller_link},
    { "getSensor", _wrap_Controller_getSensor},
    { "getActuator", _wrap_Controller_getActuator},
    {0,0}
};
static swig_lua_method swig_Controller_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Controller_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Controller_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Controller_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Controller_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Controller_Sf_SwigStatic = {
    "Controller",
    swig_Controller_Sf_SwigStatic_methods,
    swig_Controller_Sf_SwigStatic_attributes,
    swig_Controller_Sf_SwigStatic_constants,
    swig_Controller_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Controller_bases[] = {0,0};
static const char *swig_Controller_base_names[] = {"gsBrick *",0};
static swig_lua_class _wrap_class_Controller = { "Controller", "Controller", &SWIGTYPE_p_gsController,_proxy__wrap_new_Controller, swig_delete_Controller, swig_Controller_methods, swig_Controller_attributes, &swig_Controller_Sf_SwigStatic, swig_Controller_meta, swig_Controller_bases, swig_Controller_base_names };

static int _wrap_new_LogicOpController__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsLogicOpController *result = 0 ;
  
  SWIG_check_num_args("gsLogicOpController::gsLogicOpController",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicOpController::gsLogicOpController",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicOpController::gsLogicOpController",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_LogicOpController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsLogicOpController *)new gsLogicOpController(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicOpController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicOpController__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsLogicOpController *result = 0 ;
  
  SWIG_check_num_args("gsLogicOpController::gsLogicOpController",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicOpController::gsLogicOpController",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_LogicOpController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsLogicOpController *)new gsLogicOpController(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicOpController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicOpController__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicOpController *result = 0 ;
  
  SWIG_check_num_args("gsLogicOpController::gsLogicOpController",0,0)
  result = (gsLogicOpController *)new gsLogicOpController();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicOpController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LogicOpController(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_LogicOpController__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_LogicOpController__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_LogicOpController__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_LogicOpController'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicOpController::gsLogicOpController(gsLogicObject *,gkString const &)\n"
    "    gsLogicOpController::gsLogicOpController(gsLogicObject *)\n"
    "    gsLogicOpController::gsLogicOpController()\n");
  lua_error(L);return 0;
}


static int _wrap_LogicOpController_getOp(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicOpController *arg1 = (gsLogicOpController *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLogicOpController::getOp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicOpController::getOp",1,"gsLogicOpController *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicOpController,0))){
    SWIG_fail_ptr("LogicOpController_getOp",1,SWIGTYPE_p_gsLogicOpController);
  }
  
  result = (int)(arg1)->getOp();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LogicOpController_setOp(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicOpController *arg1 = (gsLogicOpController *) 0 ;
  gsLogicOp arg2 ;
  
  SWIG_check_num_args("gsLogicOpController::setOp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicOpController::setOp",1,"gsLogicOpController *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicOpController::setOp",2,"gsLogicOp");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicOpController,0))){
    SWIG_fail_ptr("LogicOpController_setOp",1,SWIGTYPE_p_gsLogicOpController);
  }
  
  arg2 = (gsLogicOp)(int)lua_tonumber(L, 2);
  (arg1)->setOp(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LogicOpController(void *obj) {
gsLogicOpController *arg1 = (gsLogicOpController *) obj;
delete arg1;
}
static int _proxy__wrap_new_LogicOpController(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LogicOpController);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LogicOpController_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LogicOpController_methods[]= {
    { "getOp", _wrap_LogicOpController_getOp},
    { "setOp", _wrap_LogicOpController_setOp},
    {0,0}
};
static swig_lua_method swig_LogicOpController_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LogicOpController_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LogicOpController_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LogicOpController_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LogicOpController_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LogicOpController_Sf_SwigStatic = {
    "LogicOpController",
    swig_LogicOpController_Sf_SwigStatic_methods,
    swig_LogicOpController_Sf_SwigStatic_attributes,
    swig_LogicOpController_Sf_SwigStatic_constants,
    swig_LogicOpController_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LogicOpController_bases[] = {0,0};
static const char *swig_LogicOpController_base_names[] = {"gsController *",0};
static swig_lua_class _wrap_class_LogicOpController = { "LogicOpController", "LogicOpController", &SWIGTYPE_p_gsLogicOpController,_proxy__wrap_new_LogicOpController, swig_delete_LogicOpController, swig_LogicOpController_methods, swig_LogicOpController_attributes, &swig_LogicOpController_Sf_SwigStatic, swig_LogicOpController_meta, swig_LogicOpController_bases, swig_LogicOpController_base_names };

static int _wrap_new_ExpressionController__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsExpressionController *result = 0 ;
  
  SWIG_check_num_args("gsExpressionController::gsExpressionController",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsExpressionController::gsExpressionController",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsExpressionController::gsExpressionController",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ExpressionController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsExpressionController *)new gsExpressionController(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsExpressionController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ExpressionController__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsExpressionController *result = 0 ;
  
  SWIG_check_num_args("gsExpressionController::gsExpressionController",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsExpressionController::gsExpressionController",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ExpressionController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsExpressionController *)new gsExpressionController(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsExpressionController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ExpressionController__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsExpressionController *result = 0 ;
  
  SWIG_check_num_args("gsExpressionController::gsExpressionController",0,0)
  result = (gsExpressionController *)new gsExpressionController();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsExpressionController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ExpressionController(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ExpressionController__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ExpressionController__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ExpressionController__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ExpressionController'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsExpressionController::gsExpressionController(gsLogicObject *,gkString const &)\n"
    "    gsExpressionController::gsExpressionController(gsLogicObject *)\n"
    "    gsExpressionController::gsExpressionController()\n");
  lua_error(L);return 0;
}


static int _wrap_ExpressionController_setExpression(lua_State* L) {
  int SWIG_arg = 0;
  gsExpressionController *arg1 = (gsExpressionController *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsExpressionController::setExpression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsExpressionController::setExpression",1,"gsExpressionController *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsExpressionController::setExpression",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsExpressionController,0))){
    SWIG_fail_ptr("ExpressionController_setExpression",1,SWIGTYPE_p_gsExpressionController);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setExpression((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ExpressionController(void *obj) {
gsExpressionController *arg1 = (gsExpressionController *) obj;
delete arg1;
}
static int _proxy__wrap_new_ExpressionController(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ExpressionController);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ExpressionController_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ExpressionController_methods[]= {
    { "setExpression", _wrap_ExpressionController_setExpression},
    {0,0}
};
static swig_lua_method swig_ExpressionController_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ExpressionController_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ExpressionController_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ExpressionController_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ExpressionController_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ExpressionController_Sf_SwigStatic = {
    "ExpressionController",
    swig_ExpressionController_Sf_SwigStatic_methods,
    swig_ExpressionController_Sf_SwigStatic_attributes,
    swig_ExpressionController_Sf_SwigStatic_constants,
    swig_ExpressionController_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ExpressionController_bases[] = {0,0};
static const char *swig_ExpressionController_base_names[] = {"gsController *",0};
static swig_lua_class _wrap_class_ExpressionController = { "ExpressionController", "ExpressionController", &SWIGTYPE_p_gsExpressionController,_proxy__wrap_new_ExpressionController, swig_delete_ExpressionController, swig_ExpressionController_methods, swig_ExpressionController_attributes, &swig_ExpressionController_Sf_SwigStatic, swig_ExpressionController_meta, swig_ExpressionController_bases, swig_ExpressionController_base_names };

static int _wrap_new_ScriptController__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsScriptController *result = 0 ;
  
  SWIG_check_num_args("gsScriptController::gsScriptController",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::gsScriptController",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScriptController::gsScriptController",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ScriptController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsScriptController *)new gsScriptController(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsScriptController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ScriptController__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsScriptController *result = 0 ;
  
  SWIG_check_num_args("gsScriptController::gsScriptController",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::gsScriptController",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ScriptController",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsScriptController *)new gsScriptController(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsScriptController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ScriptController__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsScriptController *result = 0 ;
  
  SWIG_check_num_args("gsScriptController::gsScriptController",0,0)
  result = (gsScriptController *)new gsScriptController();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsScriptController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ScriptController(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ScriptController__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ScriptController__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ScriptController__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ScriptController'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScriptController::gsScriptController(gsLogicObject *,gkString const &)\n"
    "    gsScriptController::gsScriptController(gsLogicObject *)\n"
    "    gsScriptController::gsScriptController()\n");
  lua_error(L);return 0;
}


static int _wrap_ScriptController_setScript(lua_State* L) {
  int SWIG_arg = 0;
  gsScriptController *arg1 = (gsScriptController *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsScriptController::setScript",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::setScript",1,"gsScriptController *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScriptController::setScript",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScriptController,0))){
    SWIG_fail_ptr("ScriptController_setScript",1,SWIGTYPE_p_gsScriptController);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setScript((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptController_setScriptByString(lua_State* L) {
  int SWIG_arg = 0;
  gsScriptController *arg1 = (gsScriptController *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsScriptController::setScriptByString",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::setScriptByString",1,"gsScriptController *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScriptController::setScriptByString",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScriptController,0))){
    SWIG_fail_ptr("ScriptController_setScriptByString",1,SWIGTYPE_p_gsScriptController);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setScriptByString((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptController_setLuaScript__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScriptController *arg1 = (gsScriptController *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsScriptController::setLuaScript",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::setLuaScript",1,"gsScriptController *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsScriptController::setLuaScript",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScriptController,0))){
    SWIG_fail_ptr("ScriptController_setLuaScript",1,SWIGTYPE_p_gsScriptController);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setLuaScript(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptController_setLuaScript__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsScriptController *arg1 = (gsScriptController *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsScriptController::setLuaScript",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScriptController::setLuaScript",1,"gsScriptController *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsScriptController::setLuaScript",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsScriptController::setLuaScript",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScriptController,0))){
    SWIG_fail_ptr("ScriptController_setLuaScript",1,SWIGTYPE_p_gsScriptController);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setLuaScript(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptController_setLuaScript(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScriptController, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_ScriptController_setLuaScript__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScriptController, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_ScriptController_setLuaScript__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ScriptController_setLuaScript'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsScriptController::setLuaScript(gsFunction)\n"
    "    gsScriptController::setLuaScript(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_ScriptController(void *obj) {
gsScriptController *arg1 = (gsScriptController *) obj;
delete arg1;
}
static int _proxy__wrap_new_ScriptController(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ScriptController);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ScriptController_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ScriptController_methods[]= {
    { "setScript", _wrap_ScriptController_setScript},
    { "setScriptByString", _wrap_ScriptController_setScriptByString},
    { "setLuaScript", _wrap_ScriptController_setLuaScript},
    {0,0}
};
static swig_lua_method swig_ScriptController_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ScriptController_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ScriptController_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ScriptController_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ScriptController_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ScriptController_Sf_SwigStatic = {
    "ScriptController",
    swig_ScriptController_Sf_SwigStatic_methods,
    swig_ScriptController_Sf_SwigStatic_attributes,
    swig_ScriptController_Sf_SwigStatic_constants,
    swig_ScriptController_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ScriptController_bases[] = {0,0};
static const char *swig_ScriptController_base_names[] = {"gsController *",0};
static swig_lua_class _wrap_class_ScriptController = { "ScriptController", "ScriptController", &SWIGTYPE_p_gsScriptController,_proxy__wrap_new_ScriptController, swig_delete_ScriptController, swig_ScriptController_methods, swig_ScriptController_attributes, &swig_ScriptController_Sf_SwigStatic, swig_ScriptController_meta, swig_ScriptController_bases, swig_ScriptController_base_names };

static int _wrap_getCurrentController(lua_State* L) {
  int SWIG_arg = 0;
  gsController *result = 0 ;
  
  SWIG_check_num_args("getCurrentController",0,0)
  result = (gsController *)getCurrentController();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsController,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Actuator(lua_State* L) {
  int SWIG_arg = 0;
  gsActuator *result = 0 ;
  
  SWIG_check_num_args("gsActuator::gsActuator",0,0)
  result = (gsActuator *)new gsActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Actuator(void *obj) {
gsActuator *arg1 = (gsActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_Actuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Actuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Actuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Actuator_methods[]= {
    {0,0}
};
static swig_lua_method swig_Actuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Actuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Actuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Actuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Actuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Actuator_Sf_SwigStatic = {
    "Actuator",
    swig_Actuator_Sf_SwigStatic_methods,
    swig_Actuator_Sf_SwigStatic_attributes,
    swig_Actuator_Sf_SwigStatic_constants,
    swig_Actuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Actuator_bases[] = {0,0};
static const char *swig_Actuator_base_names[] = {"gsBrick *",0};
static swig_lua_class _wrap_class_Actuator = { "Actuator", "Actuator", &SWIGTYPE_p_gsActuator,_proxy__wrap_new_Actuator, swig_delete_Actuator, swig_Actuator_methods, swig_Actuator_attributes, &swig_Actuator_Sf_SwigStatic, swig_Actuator_meta, swig_Actuator_bases, swig_Actuator_base_names };

static int _wrap_new_ActionActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsActionActuator *result = 0 ;
  
  SWIG_check_num_args("gsActionActuator::gsActionActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::gsActionActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsActionActuator::gsActionActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ActionActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsActionActuator *)new gsActionActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActionActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsActionActuator *result = 0 ;
  
  SWIG_check_num_args("gsActionActuator::gsActionActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::gsActionActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ActionActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsActionActuator *)new gsActionActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActionActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *result = 0 ;
  
  SWIG_check_num_args("gsActionActuator::gsActionActuator",0,0)
  result = (gsActionActuator *)new gsActionActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsActionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ActionActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ActionActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ActionActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ActionActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ActionActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsActionActuator::gsActionActuator(gsLogicObject *,gkString const &)\n"
    "    gsActionActuator::gsActionActuator(gsLogicObject *)\n"
    "    gsActionActuator::gsActionActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_ActionActuator_setStart(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setStart",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setStart",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setStart",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setStart(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setEnd(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setEnd",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setEnd",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setEnd",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setEnd(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setBlend(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setBlend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setBlend",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setBlend",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setBlend",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setBlend(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setMode(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setMode",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setMode",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setPriority(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setPriority",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setPriority",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setPriority",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setPriority",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPriority(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setAnimation(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsActionActuator::setAnimation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setAnimation",1,"gsActionActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsActionActuator::setAnimation",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setAnimation",1,SWIGTYPE_p_gsActionActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setAnimation((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsActionActuator::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setProperty",1,"gsActionActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsActionActuator::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setProperty",1,SWIGTYPE_p_gsActionActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setReset(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setReset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setReset",1,"gsActionActuator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsActionActuator::setReset",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setReset",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setReset(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_reInit(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  
  SWIG_check_num_args("gsActionActuator::reInit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::reInit",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_reInit",1,SWIGTYPE_p_gsActionActuator);
  }
  
  (arg1)->reInit();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_play(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  
  SWIG_check_num_args("gsActionActuator::play",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::play",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_play",1,SWIGTYPE_p_gsActionActuator);
  }
  
  (arg1)->play();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_stop(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  
  SWIG_check_num_args("gsActionActuator::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::stop",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_stop",1,SWIGTYPE_p_gsActionActuator);
  }
  
  (arg1)->stop();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getStart(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsActionActuator::getStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getStart",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getStart",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (int)(arg1)->getStart();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getEnd(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsActionActuator::getEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getEnd",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getEnd",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (int)(arg1)->getEnd();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getBlend(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsActionActuator::getBlend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getBlend",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getBlend",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (int)(arg1)->getBlend();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getMode(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsActionActuator::getMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getMode",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getMode",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (int)(arg1)->getMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getPriority(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsActionActuator::getPriority",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getPriority",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getPriority",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (int)(arg1)->getPriority();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getAnimation(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsActionActuator::getAnimation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getAnimation",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getAnimation",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (arg1)->getAnimation();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsActionActuator::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getProperty",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getProperty",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getReset(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsActionActuator::getReset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getReset",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getReset",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (bool)(arg1)->getReset();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_setAnimPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsActionActuator::setAnimPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::setAnimPosition",1,"gsActionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsActionActuator::setAnimPosition",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_setAnimPosition",1,SWIGTYPE_p_gsActionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setAnimPosition(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getAnimPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsActionActuator::getAnimPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getAnimPosition",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getAnimPosition",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (float)(arg1)->getAnimPosition();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_getAnimLength(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsActionActuator::getAnimLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::getAnimLength",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_getAnimLength",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (float)(arg1)->getAnimLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_isActionEnded(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsActionActuator::isActionEnded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::isActionEnded",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_isActionEnded",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (bool)(arg1)->isActionEnded();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ActionActuator_isPlaying(lua_State* L) {
  int SWIG_arg = 0;
  gsActionActuator *arg1 = (gsActionActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsActionActuator::isPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsActionActuator::isPlaying",1,"gsActionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsActionActuator,0))){
    SWIG_fail_ptr("ActionActuator_isPlaying",1,SWIGTYPE_p_gsActionActuator);
  }
  
  result = (bool)(arg1)->isPlaying();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ActionActuator(void *obj) {
gsActionActuator *arg1 = (gsActionActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_ActionActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ActionActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ActionActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ActionActuator_methods[]= {
    { "setStart", _wrap_ActionActuator_setStart},
    { "setEnd", _wrap_ActionActuator_setEnd},
    { "setBlend", _wrap_ActionActuator_setBlend},
    { "setMode", _wrap_ActionActuator_setMode},
    { "setPriority", _wrap_ActionActuator_setPriority},
    { "setAnimation", _wrap_ActionActuator_setAnimation},
    { "setProperty", _wrap_ActionActuator_setProperty},
    { "setReset", _wrap_ActionActuator_setReset},
    { "reInit", _wrap_ActionActuator_reInit},
    { "play", _wrap_ActionActuator_play},
    { "stop", _wrap_ActionActuator_stop},
    { "getStart", _wrap_ActionActuator_getStart},
    { "getEnd", _wrap_ActionActuator_getEnd},
    { "getBlend", _wrap_ActionActuator_getBlend},
    { "getMode", _wrap_ActionActuator_getMode},
    { "getPriority", _wrap_ActionActuator_getPriority},
    { "getAnimation", _wrap_ActionActuator_getAnimation},
    { "getProperty", _wrap_ActionActuator_getProperty},
    { "getReset", _wrap_ActionActuator_getReset},
    { "setAnimPosition", _wrap_ActionActuator_setAnimPosition},
    { "getAnimPosition", _wrap_ActionActuator_getAnimPosition},
    { "getAnimLength", _wrap_ActionActuator_getAnimLength},
    { "isActionEnded", _wrap_ActionActuator_isActionEnded},
    { "isPlaying", _wrap_ActionActuator_isPlaying},
    {0,0}
};
static swig_lua_method swig_ActionActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ActionActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ActionActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ActionActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ActionActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ActionActuator_Sf_SwigStatic = {
    "ActionActuator",
    swig_ActionActuator_Sf_SwigStatic_methods,
    swig_ActionActuator_Sf_SwigStatic_attributes,
    swig_ActionActuator_Sf_SwigStatic_constants,
    swig_ActionActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ActionActuator_bases[] = {0,0};
static const char *swig_ActionActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_ActionActuator = { "ActionActuator", "ActionActuator", &SWIGTYPE_p_gsActionActuator,_proxy__wrap_new_ActionActuator, swig_delete_ActionActuator, swig_ActionActuator_methods, swig_ActionActuator_attributes, &swig_ActionActuator_Sf_SwigStatic, swig_ActionActuator_meta, swig_ActionActuator_bases, swig_ActionActuator_base_names };

static int _wrap_new_EditObjectActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsEditObjectActuator *result = 0 ;
  
  SWIG_check_num_args("gsEditObjectActuator::gsEditObjectActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::gsEditObjectActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEditObjectActuator::gsEditObjectActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_EditObjectActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsEditObjectActuator *)new gsEditObjectActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEditObjectActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_EditObjectActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsEditObjectActuator *result = 0 ;
  
  SWIG_check_num_args("gsEditObjectActuator::gsEditObjectActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::gsEditObjectActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_EditObjectActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsEditObjectActuator *)new gsEditObjectActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEditObjectActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_EditObjectActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *result = 0 ;
  
  SWIG_check_num_args("gsEditObjectActuator::gsEditObjectActuator",0,0)
  result = (gsEditObjectActuator *)new gsEditObjectActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEditObjectActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_EditObjectActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_EditObjectActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_EditObjectActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_EditObjectActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_EditObjectActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsEditObjectActuator::gsEditObjectActuator(gsLogicObject *,gkString const &)\n"
    "    gsEditObjectActuator::gsEditObjectActuator(gsLogicObject *)\n"
    "    gsEditObjectActuator::gsEditObjectActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_EditObjectActuator_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setType",1,"gsEditObjectActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEditObjectActuator::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setType",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_setDynMode(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setDynMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setDynMode",1,"gsEditObjectActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEditObjectActuator::setDynMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setDynMode",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDynMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_setObject(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setObject",1,"gsEditObjectActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsEditObjectActuator::setObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setObject",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setObject((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_setLinearVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setLinearVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setLinearVelocity",1,"gsEditObjectActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsEditObjectActuator::setLinearVelocity",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsEditObjectActuator::setLinearVelocity",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setLinearVelocity",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("EditObjectActuator_setLinearVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setLinearVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_setAngularVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setAngularVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setAngularVelocity",1,"gsEditObjectActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsEditObjectActuator::setAngularVelocity",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsEditObjectActuator::setAngularVelocity",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setAngularVelocity",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("EditObjectActuator_setAngularVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setAngularVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_setLifeSpan(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsEditObjectActuator::setLifeSpan",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::setLifeSpan",1,"gsEditObjectActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsEditObjectActuator::setLifeSpan",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_setLifeSpan",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setLifeSpan(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsEditObjectActuator::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getType",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getType",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getDynMode(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsEditObjectActuator::getDynMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getDynMode",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getDynMode",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (int)(arg1)->getDynMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getObject(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsEditObjectActuator::getObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getObject",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getObject",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (arg1)->getObject();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getLinearVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsEditObjectActuator::getLinearVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getLinearVelocity",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getLinearVelocity",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (arg1)->getLinearVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getAngularVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsEditObjectActuator::getAngularVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getAngularVelocity",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getAngularVelocity",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (arg1)->getAngularVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getLifeSpan(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsEditObjectActuator::getLifeSpan",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getLifeSpan",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getLifeSpan",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (int)(arg1)->getLifeSpan();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_getLastCreatedObject(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsEditObjectActuator::getLastCreatedObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::getLastCreatedObject",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_getLastCreatedObject",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  result = (gkGameObject *)(arg1)->getLastCreatedObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EditObjectActuator_refreshTrackTo(lua_State* L) {
  int SWIG_arg = 0;
  gsEditObjectActuator *arg1 = (gsEditObjectActuator *) 0 ;
  
  SWIG_check_num_args("gsEditObjectActuator::refreshTrackTo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEditObjectActuator::refreshTrackTo",1,"gsEditObjectActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsEditObjectActuator,0))){
    SWIG_fail_ptr("EditObjectActuator_refreshTrackTo",1,SWIGTYPE_p_gsEditObjectActuator);
  }
  
  (arg1)->refreshTrackTo();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_EditObjectActuator(void *obj) {
gsEditObjectActuator *arg1 = (gsEditObjectActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_EditObjectActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_EditObjectActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_EditObjectActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_EditObjectActuator_methods[]= {
    { "setType", _wrap_EditObjectActuator_setType},
    { "setDynMode", _wrap_EditObjectActuator_setDynMode},
    { "setObject", _wrap_EditObjectActuator_setObject},
    { "setLinearVelocity", _wrap_EditObjectActuator_setLinearVelocity},
    { "setAngularVelocity", _wrap_EditObjectActuator_setAngularVelocity},
    { "setLifeSpan", _wrap_EditObjectActuator_setLifeSpan},
    { "getType", _wrap_EditObjectActuator_getType},
    { "getDynMode", _wrap_EditObjectActuator_getDynMode},
    { "getObject", _wrap_EditObjectActuator_getObject},
    { "getLinearVelocity", _wrap_EditObjectActuator_getLinearVelocity},
    { "getAngularVelocity", _wrap_EditObjectActuator_getAngularVelocity},
    { "getLifeSpan", _wrap_EditObjectActuator_getLifeSpan},
    { "getLastCreatedObject", _wrap_EditObjectActuator_getLastCreatedObject},
    { "refreshTrackTo", _wrap_EditObjectActuator_refreshTrackTo},
    {0,0}
};
static swig_lua_method swig_EditObjectActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_EditObjectActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_EditObjectActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_EditObjectActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_EditObjectActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_EditObjectActuator_Sf_SwigStatic = {
    "EditObjectActuator",
    swig_EditObjectActuator_Sf_SwigStatic_methods,
    swig_EditObjectActuator_Sf_SwigStatic_attributes,
    swig_EditObjectActuator_Sf_SwigStatic_constants,
    swig_EditObjectActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_EditObjectActuator_bases[] = {0,0};
static const char *swig_EditObjectActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_EditObjectActuator = { "EditObjectActuator", "EditObjectActuator", &SWIGTYPE_p_gsEditObjectActuator,_proxy__wrap_new_EditObjectActuator, swig_delete_EditObjectActuator, swig_EditObjectActuator_methods, swig_EditObjectActuator_attributes, &swig_EditObjectActuator_Sf_SwigStatic, swig_EditObjectActuator_meta, swig_EditObjectActuator_bases, swig_EditObjectActuator_base_names };

static int _wrap_new_GameActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGameActuator *result = 0 ;
  
  SWIG_check_num_args("gsGameActuator::gsGameActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameActuator::gsGameActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGameActuator::gsGameActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_GameActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGameActuator *)new gsGameActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGameActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_GameActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsGameActuator *result = 0 ;
  
  SWIG_check_num_args("gsGameActuator::gsGameActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameActuator::gsGameActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_GameActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsGameActuator *)new gsGameActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGameActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_GameActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGameActuator *result = 0 ;
  
  SWIG_check_num_args("gsGameActuator::gsGameActuator",0,0)
  result = (gsGameActuator *)new gsGameActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGameActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_GameActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_GameActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_GameActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_GameActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_GameActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGameActuator::gsGameActuator(gsLogicObject *,gkString const &)\n"
    "    gsGameActuator::gsGameActuator(gsLogicObject *)\n"
    "    gsGameActuator::gsGameActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_GameActuator_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsGameActuator *arg1 = (gsGameActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGameActuator::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameActuator::setType",1,"gsGameActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGameActuator::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameActuator,0))){
    SWIG_fail_ptr("GameActuator_setType",1,SWIGTYPE_p_gsGameActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GameActuator_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsGameActuator *arg1 = (gsGameActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGameActuator::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGameActuator::getType",1,"gsGameActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGameActuator,0))){
    SWIG_fail_ptr("GameActuator_getType",1,SWIGTYPE_p_gsGameActuator);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_GameActuator(void *obj) {
gsGameActuator *arg1 = (gsGameActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_GameActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_GameActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_GameActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_GameActuator_methods[]= {
    { "setType", _wrap_GameActuator_setType},
    { "getType", _wrap_GameActuator_getType},
    {0,0}
};
static swig_lua_method swig_GameActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_GameActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_GameActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_GameActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_GameActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_GameActuator_Sf_SwigStatic = {
    "GameActuator",
    swig_GameActuator_Sf_SwigStatic_methods,
    swig_GameActuator_Sf_SwigStatic_attributes,
    swig_GameActuator_Sf_SwigStatic_constants,
    swig_GameActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_GameActuator_bases[] = {0,0};
static const char *swig_GameActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_GameActuator = { "GameActuator", "GameActuator", &SWIGTYPE_p_gsGameActuator,_proxy__wrap_new_GameActuator, swig_delete_GameActuator, swig_GameActuator_methods, swig_GameActuator_attributes, &swig_GameActuator_Sf_SwigStatic, swig_GameActuator_meta, swig_GameActuator_bases, swig_GameActuator_base_names };

static int _wrap_new_MessageActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsMessageActuator *result = 0 ;
  
  SWIG_check_num_args("gsMessageActuator::gsMessageActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::gsMessageActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageActuator::gsMessageActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MessageActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsMessageActuator *)new gsMessageActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsMessageActuator *result = 0 ;
  
  SWIG_check_num_args("gsMessageActuator::gsMessageActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::gsMessageActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MessageActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsMessageActuator *)new gsMessageActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *result = 0 ;
  
  SWIG_check_num_args("gsMessageActuator::gsMessageActuator",0,0)
  result = (gsMessageActuator *)new gsMessageActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MessageActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_MessageActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_MessageActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_MessageActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_MessageActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMessageActuator::gsMessageActuator(gsLogicObject *,gkString const &)\n"
    "    gsMessageActuator::gsMessageActuator(gsLogicObject *)\n"
    "    gsMessageActuator::gsMessageActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_MessageActuator_setTo(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageActuator::setTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::setTo",1,"gsMessageActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageActuator::setTo",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_setTo",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setTo((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_getTo(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageActuator::getTo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::getTo",1,"gsMessageActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_getTo",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  result = (arg1)->getTo();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_setSubject(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageActuator::setSubject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::setSubject",1,"gsMessageActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageActuator::setSubject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_setSubject",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setSubject((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_getSubject(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageActuator::getSubject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::getSubject",1,"gsMessageActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_getSubject",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  result = (arg1)->getSubject();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_setBodyText(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageActuator::setBodyText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::setBodyText",1,"gsMessageActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageActuator::setBodyText",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_setBodyText",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setBodyText((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_getBodyText(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageActuator::getBodyText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::getBodyText",1,"gsMessageActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_getBodyText",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  result = (arg1)->getBodyText();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_setBodyProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageActuator::setBodyProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::setBodyProperty",1,"gsMessageActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageActuator::setBodyProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_setBodyProperty",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setBodyProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_getBodyProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageActuator::getBodyProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::getBodyProperty",1,"gsMessageActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_getBodyProperty",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  result = (arg1)->getBodyProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_setBodyType(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMessageActuator::setBodyType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::setBodyType",1,"gsMessageActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMessageActuator::setBodyType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_setBodyType",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setBodyType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MessageActuator_getBodyType(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageActuator *arg1 = (gsMessageActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMessageActuator::getBodyType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageActuator::getBodyType",1,"gsMessageActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageActuator,0))){
    SWIG_fail_ptr("MessageActuator_getBodyType",1,SWIGTYPE_p_gsMessageActuator);
  }
  
  result = (int)(arg1)->getBodyType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MessageActuator(void *obj) {
gsMessageActuator *arg1 = (gsMessageActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_MessageActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MessageActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MessageActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MessageActuator_methods[]= {
    { "setTo", _wrap_MessageActuator_setTo},
    { "getTo", _wrap_MessageActuator_getTo},
    { "setSubject", _wrap_MessageActuator_setSubject},
    { "getSubject", _wrap_MessageActuator_getSubject},
    { "setBodyText", _wrap_MessageActuator_setBodyText},
    { "getBodyText", _wrap_MessageActuator_getBodyText},
    { "setBodyProperty", _wrap_MessageActuator_setBodyProperty},
    { "getBodyProperty", _wrap_MessageActuator_getBodyProperty},
    { "setBodyType", _wrap_MessageActuator_setBodyType},
    { "getBodyType", _wrap_MessageActuator_getBodyType},
    {0,0}
};
static swig_lua_method swig_MessageActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MessageActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MessageActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MessageActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MessageActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MessageActuator_Sf_SwigStatic = {
    "MessageActuator",
    swig_MessageActuator_Sf_SwigStatic_methods,
    swig_MessageActuator_Sf_SwigStatic_attributes,
    swig_MessageActuator_Sf_SwigStatic_constants,
    swig_MessageActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MessageActuator_bases[] = {0,0};
static const char *swig_MessageActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_MessageActuator = { "MessageActuator", "MessageActuator", &SWIGTYPE_p_gsMessageActuator,_proxy__wrap_new_MessageActuator, swig_delete_MessageActuator, swig_MessageActuator_methods, swig_MessageActuator_attributes, &swig_MessageActuator_Sf_SwigStatic, swig_MessageActuator_meta, swig_MessageActuator_bases, swig_MessageActuator_base_names };

static int _wrap_new_MotionActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsMotionActuator *result = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::gsMotionActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::gsMotionActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMotionActuator::gsMotionActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MotionActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsMotionActuator *)new gsMotionActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMotionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MotionActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsMotionActuator *result = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::gsMotionActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::gsMotionActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_MotionActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsMotionActuator *)new gsMotionActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMotionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MotionActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *result = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::gsMotionActuator",0,0)
  result = (gsMotionActuator *)new gsMotionActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMotionActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MotionActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_MotionActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_MotionActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_MotionActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_MotionActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::gsMotionActuator(gsLogicObject *,gkString const &)\n"
    "    gsMotionActuator::gsMotionActuator(gsLogicObject *)\n"
    "    gsMotionActuator::gsMotionActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setTranslation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setTranslation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTranslation",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setTranslation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setTranslation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setTranslation",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setTranslation",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setTranslation(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTranslation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setTranslation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTranslation",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setTranslation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setTranslation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setTranslation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setTranslation(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTranslation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setTranslation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTranslation",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setTranslation",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setTranslation",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setTranslation((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTranslation__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setTranslation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTranslation",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setTranslation",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setTranslation",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setTranslation((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTranslation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setTranslation__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setTranslation__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setTranslation__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setTranslation__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setTranslation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setTranslation(float,float,float,bool)\n"
    "    gsMotionActuator::setTranslation(float,float,float)\n"
    "    gsMotionActuator::setTranslation(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setTranslation(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setRotation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setRotation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setRotation",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setRotation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setRotation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setRotation",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setRotation",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setRotation(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setRotation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setRotation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setRotation",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setRotation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setRotation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setRotation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setRotation(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setRotation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setRotation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setRotation",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setRotation",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setRotation",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setRotation((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setRotation__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setRotation",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setRotation",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setRotation",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setRotation((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setRotation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setRotation__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setRotation__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setRotation__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setRotation__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setRotation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setRotation(float,float,float,bool)\n"
    "    gsMotionActuator::setRotation(float,float,float)\n"
    "    gsMotionActuator::setRotation(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setRotation(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setForce__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setForce",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setForce",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setForce",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setForce",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setForce",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setForce",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setForce",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setForce(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setForce__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setForce",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setForce",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setForce",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setForce",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setForce",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setForce",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setForce(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setForce__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setForce",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setForce",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setForce",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setForce",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setForce",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setForce",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setForce((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setForce__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setForce",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setForce",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setForce",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setForce",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setForce",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setForce((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setForce(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setForce__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setForce__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setForce__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setForce__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setForce'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setForce(float,float,float,bool)\n"
    "    gsMotionActuator::setForce(float,float,float)\n"
    "    gsMotionActuator::setForce(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setForce(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setTorque__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setTorque",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTorque",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setTorque",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setTorque",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setTorque",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setTorque",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setTorque(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTorque__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setTorque",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTorque",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setTorque",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setTorque",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setTorque",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setTorque(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTorque__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setTorque",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTorque",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setTorque",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setTorque",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setTorque((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTorque__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setTorque",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setTorque",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setTorque",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setTorque",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setTorque((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setTorque(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setTorque__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setTorque__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setTorque__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setTorque__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setTorque'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setTorque(float,float,float,bool)\n"
    "    gsMotionActuator::setTorque(float,float,float)\n"
    "    gsMotionActuator::setTorque(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setTorque(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setLinearVelocity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setLinearVelocity",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setLinearVelocity(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setLinearVelocity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setLinearVelocity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setLinearVelocity(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setLinearVelocity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setLinearVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setLinearVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setLinearVelocity__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setLinearVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setLinearVelocity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setLinearVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setLinearVelocity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setLinearVelocity(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setLinearVelocity__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setLinearVelocity__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setLinearVelocity__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setLinearVelocity__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setLinearVelocity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setLinearVelocity(float,float,float,bool)\n"
    "    gsMotionActuator::setLinearVelocity(float,float,float)\n"
    "    gsMotionActuator::setLinearVelocity(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setLinearVelocity(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setAngularVelocity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("gsMotionActuator::setAngularVelocity",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  (arg1)->setAngularVelocity(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setAngularVelocity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsMotionActuator::setAngularVelocity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setAngularVelocity(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setAngularVelocity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("gsMotionActuator::setAngularVelocity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",2,"gsVector3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setAngularVelocity((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setAngularVelocity__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionActuator::setAngularVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",1,"gsMotionActuator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionActuator::setAngularVelocity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("MotionActuator_setAngularVelocity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setAngularVelocity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setAngularVelocity(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_MotionActuator_setAngularVelocity__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_MotionActuator_setAngularVelocity__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_MotionActuator_setAngularVelocity__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsMotionActuator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_MotionActuator_setAngularVelocity__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MotionActuator_setAngularVelocity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsMotionActuator::setAngularVelocity(float,float,float,bool)\n"
    "    gsMotionActuator::setAngularVelocity(float,float,float)\n"
    "    gsMotionActuator::setAngularVelocity(gsVector3 const &,bool)\n"
    "    gsMotionActuator::setAngularVelocity(gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_MotionActuator_setIncrementalTargetVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMotionActuator::setIncrementalTargetVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setIncrementalTargetVelocity",1,"gsMotionActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionActuator::setIncrementalTargetVelocity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setIncrementalTargetVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setIncrementalTargetVelocity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_setIncrementalVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsMotionActuator::setIncrementalVelocity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::setIncrementalVelocity",1,"gsMotionActuator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsMotionActuator::setIncrementalVelocity",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_setIncrementalVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setIncrementalVelocity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getIncrementalTargetVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMotionActuator::getIncrementalTargetVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getIncrementalTargetVelocity",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getIncrementalTargetVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (float)(arg1)->getIncrementalTargetVelocity();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getIncrementalVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsMotionActuator::getIncrementalVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getIncrementalVelocity",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getIncrementalVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (bool)(arg1)->getIncrementalVelocity();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getTranslation(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getTranslation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getTranslation",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getTranslation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getTranslation();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getRotation(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getRotation",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getRotation",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getRotation();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getForce(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getForce",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getForce",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getForce",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getForce();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getTorque(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getTorque",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getTorque",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getTorque",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getTorque();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getLinearVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getLinearVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getLinearVelocity",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getLinearVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getLinearVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MotionActuator_getAngularVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionActuator *arg1 = (gsMotionActuator *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsMotionActuator::getAngularVelocity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionActuator::getAngularVelocity",1,"gsMotionActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionActuator,0))){
    SWIG_fail_ptr("MotionActuator_getAngularVelocity",1,SWIGTYPE_p_gsMotionActuator);
  }
  
  result = (arg1)->getAngularVelocity();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MotionActuator(void *obj) {
gsMotionActuator *arg1 = (gsMotionActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_MotionActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MotionActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MotionActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MotionActuator_methods[]= {
    { "setTranslation", _wrap_MotionActuator_setTranslation},
    { "setRotation", _wrap_MotionActuator_setRotation},
    { "setForce", _wrap_MotionActuator_setForce},
    { "setTorque", _wrap_MotionActuator_setTorque},
    { "setLinearVelocity", _wrap_MotionActuator_setLinearVelocity},
    { "setAngularVelocity", _wrap_MotionActuator_setAngularVelocity},
    { "setIncrementalTargetVelocity", _wrap_MotionActuator_setIncrementalTargetVelocity},
    { "setIncrementalVelocity", _wrap_MotionActuator_setIncrementalVelocity},
    { "getIncrementalTargetVelocity", _wrap_MotionActuator_getIncrementalTargetVelocity},
    { "getIncrementalVelocity", _wrap_MotionActuator_getIncrementalVelocity},
    { "getTranslation", _wrap_MotionActuator_getTranslation},
    { "getRotation", _wrap_MotionActuator_getRotation},
    { "getForce", _wrap_MotionActuator_getForce},
    { "getTorque", _wrap_MotionActuator_getTorque},
    { "getLinearVelocity", _wrap_MotionActuator_getLinearVelocity},
    { "getAngularVelocity", _wrap_MotionActuator_getAngularVelocity},
    {0,0}
};
static swig_lua_method swig_MotionActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MotionActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MotionActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MotionActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MotionActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MotionActuator_Sf_SwigStatic = {
    "MotionActuator",
    swig_MotionActuator_Sf_SwigStatic_methods,
    swig_MotionActuator_Sf_SwigStatic_attributes,
    swig_MotionActuator_Sf_SwigStatic_constants,
    swig_MotionActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MotionActuator_bases[] = {0,0};
static const char *swig_MotionActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_MotionActuator = { "MotionActuator", "MotionActuator", &SWIGTYPE_p_gsMotionActuator,_proxy__wrap_new_MotionActuator, swig_delete_MotionActuator, swig_MotionActuator_methods, swig_MotionActuator_attributes, &swig_MotionActuator_Sf_SwigStatic, swig_MotionActuator_meta, swig_MotionActuator_bases, swig_MotionActuator_base_names };

static int _wrap_new_ParentActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsParentActuator *result = 0 ;
  
  SWIG_check_num_args("gsParentActuator::gsParentActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::gsParentActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsParentActuator::gsParentActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ParentActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsParentActuator *)new gsParentActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsParentActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ParentActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsParentActuator *result = 0 ;
  
  SWIG_check_num_args("gsParentActuator::gsParentActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::gsParentActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_ParentActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsParentActuator *)new gsParentActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsParentActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ParentActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *result = 0 ;
  
  SWIG_check_num_args("gsParentActuator::gsParentActuator",0,0)
  result = (gsParentActuator *)new gsParentActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsParentActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ParentActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ParentActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ParentActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ParentActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ParentActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsParentActuator::gsParentActuator(gsLogicObject *,gkString const &)\n"
    "    gsParentActuator::gsParentActuator(gsLogicObject *)\n"
    "    gsParentActuator::gsParentActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_ParentActuator_setMode(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsParentActuator::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::setMode",1,"gsParentActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsParentActuator::setMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_setMode",1,SWIGTYPE_p_gsParentActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_getMode(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsParentActuator::getMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::getMode",1,"gsParentActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_getMode",1,SWIGTYPE_p_gsParentActuator);
  }
  
  result = (int)(arg1)->getMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_setParent(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsParentActuator::setParent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::setParent",1,"gsParentActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsParentActuator::setParent",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_setParent",1,SWIGTYPE_p_gsParentActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setParent((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_getParent(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsParentActuator::getParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::getParent",1,"gsParentActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_getParent",1,SWIGTYPE_p_gsParentActuator);
  }
  
  result = (arg1)->getParent();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_setCompound(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsParentActuator::setCompound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::setCompound",1,"gsParentActuator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsParentActuator::setCompound",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_setCompound",1,SWIGTYPE_p_gsParentActuator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setCompound(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_getCompound(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsParentActuator::getCompound",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::getCompound",1,"gsParentActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_getCompound",1,SWIGTYPE_p_gsParentActuator);
  }
  
  result = (bool)(arg1)->getCompound();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_setGhost(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsParentActuator::setGhost",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::setGhost",1,"gsParentActuator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsParentActuator::setGhost",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_setGhost",1,SWIGTYPE_p_gsParentActuator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setGhost(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParentActuator_getGhost(lua_State* L) {
  int SWIG_arg = 0;
  gsParentActuator *arg1 = (gsParentActuator *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsParentActuator::getGhost",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsParentActuator::getGhost",1,"gsParentActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsParentActuator,0))){
    SWIG_fail_ptr("ParentActuator_getGhost",1,SWIGTYPE_p_gsParentActuator);
  }
  
  result = (bool)(arg1)->getGhost();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ParentActuator(void *obj) {
gsParentActuator *arg1 = (gsParentActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_ParentActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ParentActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ParentActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ParentActuator_methods[]= {
    { "setMode", _wrap_ParentActuator_setMode},
    { "getMode", _wrap_ParentActuator_getMode},
    { "setParent", _wrap_ParentActuator_setParent},
    { "getParent", _wrap_ParentActuator_getParent},
    { "setCompound", _wrap_ParentActuator_setCompound},
    { "getCompound", _wrap_ParentActuator_getCompound},
    { "setGhost", _wrap_ParentActuator_setGhost},
    { "getGhost", _wrap_ParentActuator_getGhost},
    {0,0}
};
static swig_lua_method swig_ParentActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ParentActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ParentActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ParentActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ParentActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ParentActuator_Sf_SwigStatic = {
    "ParentActuator",
    swig_ParentActuator_Sf_SwigStatic_methods,
    swig_ParentActuator_Sf_SwigStatic_attributes,
    swig_ParentActuator_Sf_SwigStatic_constants,
    swig_ParentActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ParentActuator_bases[] = {0,0};
static const char *swig_ParentActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_ParentActuator = { "ParentActuator", "ParentActuator", &SWIGTYPE_p_gsParentActuator,_proxy__wrap_new_ParentActuator, swig_delete_ParentActuator, swig_ParentActuator_methods, swig_ParentActuator_attributes, &swig_ParentActuator_Sf_SwigStatic, swig_ParentActuator_meta, swig_ParentActuator_bases, swig_ParentActuator_base_names };

static int _wrap_new_PropertyActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsPropertyActuator *result = 0 ;
  
  SWIG_check_num_args("gsPropertyActuator::gsPropertyActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::gsPropertyActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyActuator::gsPropertyActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_PropertyActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsPropertyActuator *)new gsPropertyActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertyActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertyActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsPropertyActuator *result = 0 ;
  
  SWIG_check_num_args("gsPropertyActuator::gsPropertyActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::gsPropertyActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_PropertyActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsPropertyActuator *)new gsPropertyActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertyActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertyActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *result = 0 ;
  
  SWIG_check_num_args("gsPropertyActuator::gsPropertyActuator",0,0)
  result = (gsPropertyActuator *)new gsPropertyActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertyActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PropertyActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_PropertyActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_PropertyActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_PropertyActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_PropertyActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsPropertyActuator::gsPropertyActuator(gsLogicObject *,gkString const &)\n"
    "    gsPropertyActuator::gsPropertyActuator(gsLogicObject *)\n"
    "    gsPropertyActuator::gsPropertyActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_PropertyActuator_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPropertyActuator::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::setType",1,"gsPropertyActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPropertyActuator::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_setType",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPropertyActuator::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::getType",1,"gsPropertyActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_getType",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertyActuator::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::setProperty",1,"gsPropertyActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyActuator::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_setProperty",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertyActuator::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::getProperty",1,"gsPropertyActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_getProperty",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertyActuator::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::setValue",1,"gsPropertyActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyActuator::setValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_setValue",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertyActuator::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::getValue",1,"gsPropertyActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_getValue",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_setObject(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertyActuator::setObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::setObject",1,"gsPropertyActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyActuator::setObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_setObject",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setObject((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PropertyActuator_getObject(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyActuator *arg1 = (gsPropertyActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertyActuator::getObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyActuator::getObject",1,"gsPropertyActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyActuator,0))){
    SWIG_fail_ptr("PropertyActuator_getObject",1,SWIGTYPE_p_gsPropertyActuator);
  }
  
  result = (arg1)->getObject();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PropertyActuator(void *obj) {
gsPropertyActuator *arg1 = (gsPropertyActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_PropertyActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_PropertyActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_PropertyActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_PropertyActuator_methods[]= {
    { "setType", _wrap_PropertyActuator_setType},
    { "getType", _wrap_PropertyActuator_getType},
    { "setProperty", _wrap_PropertyActuator_setProperty},
    { "getProperty", _wrap_PropertyActuator_getProperty},
    { "setValue", _wrap_PropertyActuator_setValue},
    { "getValue", _wrap_PropertyActuator_getValue},
    { "setObject", _wrap_PropertyActuator_setObject},
    { "getObject", _wrap_PropertyActuator_getObject},
    {0,0}
};
static swig_lua_method swig_PropertyActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_PropertyActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_PropertyActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_PropertyActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_PropertyActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_PropertyActuator_Sf_SwigStatic = {
    "PropertyActuator",
    swig_PropertyActuator_Sf_SwigStatic_methods,
    swig_PropertyActuator_Sf_SwigStatic_attributes,
    swig_PropertyActuator_Sf_SwigStatic_constants,
    swig_PropertyActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_PropertyActuator_bases[] = {0,0};
static const char *swig_PropertyActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_PropertyActuator = { "PropertyActuator", "PropertyActuator", &SWIGTYPE_p_gsPropertyActuator,_proxy__wrap_new_PropertyActuator, swig_delete_PropertyActuator, swig_PropertyActuator_methods, swig_PropertyActuator_attributes, &swig_PropertyActuator_Sf_SwigStatic, swig_PropertyActuator_meta, swig_PropertyActuator_bases, swig_PropertyActuator_base_names };

static int _wrap_new_RandomActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsRandomActuator *result = 0 ;
  
  SWIG_check_num_args("gsRandomActuator::gsRandomActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::gsRandomActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRandomActuator::gsRandomActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RandomActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsRandomActuator *)new gsRandomActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsRandomActuator *result = 0 ;
  
  SWIG_check_num_args("gsRandomActuator::gsRandomActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::gsRandomActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_RandomActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsRandomActuator *)new gsRandomActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *result = 0 ;
  
  SWIG_check_num_args("gsRandomActuator::gsRandomActuator",0,0)
  result = (gsRandomActuator *)new gsRandomActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRandomActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RandomActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RandomActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RandomActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_RandomActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_RandomActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRandomActuator::gsRandomActuator(gsLogicObject *,gkString const &)\n"
    "    gsRandomActuator::gsRandomActuator(gsLogicObject *)\n"
    "    gsRandomActuator::gsRandomActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_RandomActuator_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setSeed",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setSeed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setSeed",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setSeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getSeed(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRandomActuator::getSeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getSeed",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getSeed",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (int)(arg1)->getSeed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setDistribution(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setDistribution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setDistribution",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setDistribution",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setDistribution",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDistribution(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getDistribution(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsRandomActuator::getDistribution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getDistribution",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getDistribution",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (int)(arg1)->getDistribution();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRandomActuator::setProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setProperty",1,"gsRandomActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRandomActuator::setProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setProperty",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsRandomActuator::getProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getProperty",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getProperty",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (arg1)->getProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setMin(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setMin",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setMin",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setMin",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMin(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getMin(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getMin",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getMin",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getMin();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setMax(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setMax",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setMax",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setMax",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMax(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getMax(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getMax",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getMax",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getMax();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setConstant(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setConstant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setConstant",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setConstant",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setConstant",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setConstant(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getConstant(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getConstant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getConstant",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getConstant",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getConstant();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setMean(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setMean",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setMean",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setMean",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setMean",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setMean(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getMean(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getMean",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getMean",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getMean",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getMean();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setDeviation(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setDeviation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setDeviation",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setDeviation",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setDeviation",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setDeviation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getDeviation(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getDeviation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getDeviation",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getDeviation",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getDeviation();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_setHalfLife(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsRandomActuator::setHalfLife",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::setHalfLife",1,"gsRandomActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRandomActuator::setHalfLife",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_setHalfLife",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHalfLife(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomActuator_getHalfLife(lua_State* L) {
  int SWIG_arg = 0;
  gsRandomActuator *arg1 = (gsRandomActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRandomActuator::getHalfLife",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRandomActuator::getHalfLife",1,"gsRandomActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRandomActuator,0))){
    SWIG_fail_ptr("RandomActuator_getHalfLife",1,SWIGTYPE_p_gsRandomActuator);
  }
  
  result = (float)(arg1)->getHalfLife();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RandomActuator(void *obj) {
gsRandomActuator *arg1 = (gsRandomActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_RandomActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_RandomActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_RandomActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_RandomActuator_methods[]= {
    { "setSeed", _wrap_RandomActuator_setSeed},
    { "getSeed", _wrap_RandomActuator_getSeed},
    { "setDistribution", _wrap_RandomActuator_setDistribution},
    { "getDistribution", _wrap_RandomActuator_getDistribution},
    { "setProperty", _wrap_RandomActuator_setProperty},
    { "getProperty", _wrap_RandomActuator_getProperty},
    { "setMin", _wrap_RandomActuator_setMin},
    { "getMin", _wrap_RandomActuator_getMin},
    { "setMax", _wrap_RandomActuator_setMax},
    { "getMax", _wrap_RandomActuator_getMax},
    { "setConstant", _wrap_RandomActuator_setConstant},
    { "getConstant", _wrap_RandomActuator_getConstant},
    { "setMean", _wrap_RandomActuator_setMean},
    { "getMean", _wrap_RandomActuator_getMean},
    { "setDeviation", _wrap_RandomActuator_setDeviation},
    { "getDeviation", _wrap_RandomActuator_getDeviation},
    { "setHalfLife", _wrap_RandomActuator_setHalfLife},
    { "getHalfLife", _wrap_RandomActuator_getHalfLife},
    {0,0}
};
static swig_lua_method swig_RandomActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_RandomActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_RandomActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_RandomActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_RandomActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_RandomActuator_Sf_SwigStatic = {
    "RandomActuator",
    swig_RandomActuator_Sf_SwigStatic_methods,
    swig_RandomActuator_Sf_SwigStatic_attributes,
    swig_RandomActuator_Sf_SwigStatic_constants,
    swig_RandomActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_RandomActuator_bases[] = {0,0};
static const char *swig_RandomActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_RandomActuator = { "RandomActuator", "RandomActuator", &SWIGTYPE_p_gsRandomActuator,_proxy__wrap_new_RandomActuator, swig_delete_RandomActuator, swig_RandomActuator_methods, swig_RandomActuator_attributes, &swig_RandomActuator_Sf_SwigStatic, swig_RandomActuator_meta, swig_RandomActuator_bases, swig_RandomActuator_base_names };

static int _wrap_new_SceneActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsSceneActuator *result = 0 ;
  
  SWIG_check_num_args("gsSceneActuator::gsSceneActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::gsSceneActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSceneActuator::gsSceneActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_SceneActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsSceneActuator *)new gsSceneActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSceneActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SceneActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsSceneActuator *result = 0 ;
  
  SWIG_check_num_args("gsSceneActuator::gsSceneActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::gsSceneActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_SceneActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsSceneActuator *)new gsSceneActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSceneActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SceneActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *result = 0 ;
  
  SWIG_check_num_args("gsSceneActuator::gsSceneActuator",0,0)
  result = (gsSceneActuator *)new gsSceneActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSceneActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SceneActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SceneActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_SceneActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SceneActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SceneActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSceneActuator::gsSceneActuator(gsLogicObject *,gkString const &)\n"
    "    gsSceneActuator::gsSceneActuator(gsLogicObject *)\n"
    "    gsSceneActuator::gsSceneActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_SceneActuator_setMode(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsSceneActuator::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::setMode",1,"gsSceneActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSceneActuator::setMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_setMode",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SceneActuator_getMode(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSceneActuator::getMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::getMode",1,"gsSceneActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_getMode",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  result = (int)(arg1)->getMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SceneActuator_setScene(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSceneActuator::setScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::setScene",1,"gsSceneActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSceneActuator::setScene",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_setScene",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setScene((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SceneActuator_getScene(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsSceneActuator::getScene",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::getScene",1,"gsSceneActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_getScene",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  result = (arg1)->getScene();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SceneActuator_setCamera(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSceneActuator::setCamera",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::setCamera",1,"gsSceneActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSceneActuator::setCamera",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_setCamera",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setCamera((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SceneActuator_getCamera(lua_State* L) {
  int SWIG_arg = 0;
  gsSceneActuator *arg1 = (gsSceneActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsSceneActuator::getCamera",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSceneActuator::getCamera",1,"gsSceneActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSceneActuator,0))){
    SWIG_fail_ptr("SceneActuator_getCamera",1,SWIGTYPE_p_gsSceneActuator);
  }
  
  result = (arg1)->getCamera();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SceneActuator(void *obj) {
gsSceneActuator *arg1 = (gsSceneActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_SceneActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SceneActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SceneActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SceneActuator_methods[]= {
    { "setMode", _wrap_SceneActuator_setMode},
    { "getMode", _wrap_SceneActuator_getMode},
    { "setScene", _wrap_SceneActuator_setScene},
    { "getScene", _wrap_SceneActuator_getScene},
    { "setCamera", _wrap_SceneActuator_setCamera},
    { "getCamera", _wrap_SceneActuator_getCamera},
    {0,0}
};
static swig_lua_method swig_SceneActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SceneActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SceneActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SceneActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SceneActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SceneActuator_Sf_SwigStatic = {
    "SceneActuator",
    swig_SceneActuator_Sf_SwigStatic_methods,
    swig_SceneActuator_Sf_SwigStatic_attributes,
    swig_SceneActuator_Sf_SwigStatic_constants,
    swig_SceneActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SceneActuator_bases[] = {0,0};
static const char *swig_SceneActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_SceneActuator = { "SceneActuator", "SceneActuator", &SWIGTYPE_p_gsSceneActuator,_proxy__wrap_new_SceneActuator, swig_delete_SceneActuator, swig_SceneActuator_methods, swig_SceneActuator_attributes, &swig_SceneActuator_Sf_SwigStatic, swig_SceneActuator_meta, swig_SceneActuator_bases, swig_SceneActuator_base_names };

static int _wrap_new_SoundActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsSoundActuator *result = 0 ;
  
  SWIG_check_num_args("gsSoundActuator::gsSoundActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::gsSoundActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundActuator::gsSoundActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_SoundActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsSoundActuator *)new gsSoundActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSoundActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SoundActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsSoundActuator *result = 0 ;
  
  SWIG_check_num_args("gsSoundActuator::gsSoundActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::gsSoundActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_SoundActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsSoundActuator *)new gsSoundActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSoundActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SoundActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *result = 0 ;
  
  SWIG_check_num_args("gsSoundActuator::gsSoundActuator",0,0)
  result = (gsSoundActuator *)new gsSoundActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSoundActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SoundActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SoundActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_SoundActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SoundActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SoundActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSoundActuator::gsSoundActuator(gsLogicObject *,gkString const &)\n"
    "    gsSoundActuator::gsSoundActuator(gsLogicObject *)\n"
    "    gsSoundActuator::gsSoundActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_SoundActuator_setType(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsSoundActuator::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::setType",1,"gsSoundActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSoundActuator::setType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_setType",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSoundActuator::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::getType",1,"gsSoundActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_getType",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  result = (int)(arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_setSoundFile(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSoundActuator::setSoundFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::setSoundFile",1,"gsSoundActuator *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundActuator::setSoundFile",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_setSoundFile",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setSoundFile((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_getSoundFile(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsSoundActuator::getSoundFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::getSoundFile",1,"gsSoundActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_getSoundFile",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  result = (arg1)->getSoundFile();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_setVolume(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSoundActuator::setVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::setVolume",1,"gsSoundActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSoundActuator::setVolume",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_setVolume",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setVolume(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_getVolume(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSoundActuator::getVolume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::getVolume",1,"gsSoundActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_getVolume",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  result = (float)(arg1)->getVolume();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_setPitch(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSoundActuator::setPitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::setPitch",1,"gsSoundActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSoundActuator::setPitch",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_setPitch",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPitch(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundActuator_getPitch(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundActuator *arg1 = (gsSoundActuator *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSoundActuator::getPitch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundActuator::getPitch",1,"gsSoundActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundActuator,0))){
    SWIG_fail_ptr("SoundActuator_getPitch",1,SWIGTYPE_p_gsSoundActuator);
  }
  
  result = (float)(arg1)->getPitch();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SoundActuator(void *obj) {
gsSoundActuator *arg1 = (gsSoundActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SoundActuator_methods[]= {
    { "setType", _wrap_SoundActuator_setType},
    { "getType", _wrap_SoundActuator_getType},
    { "setSoundFile", _wrap_SoundActuator_setSoundFile},
    { "getSoundFile", _wrap_SoundActuator_getSoundFile},
    { "setVolume", _wrap_SoundActuator_setVolume},
    { "getVolume", _wrap_SoundActuator_getVolume},
    { "setPitch", _wrap_SoundActuator_setPitch},
    { "getPitch", _wrap_SoundActuator_getPitch},
    {0,0}
};
static swig_lua_method swig_SoundActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundActuator_Sf_SwigStatic = {
    "SoundActuator",
    swig_SoundActuator_Sf_SwigStatic_methods,
    swig_SoundActuator_Sf_SwigStatic_attributes,
    swig_SoundActuator_Sf_SwigStatic_constants,
    swig_SoundActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundActuator_bases[] = {0,0};
static const char *swig_SoundActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_SoundActuator = { "SoundActuator", "SoundActuator", &SWIGTYPE_p_gsSoundActuator,_proxy__wrap_new_SoundActuator, swig_delete_SoundActuator, swig_SoundActuator_methods, swig_SoundActuator_attributes, &swig_SoundActuator_Sf_SwigStatic, swig_SoundActuator_meta, swig_SoundActuator_bases, swig_SoundActuator_base_names };

static int _wrap_new_StateActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsStateActuator *result = 0 ;
  
  SWIG_check_num_args("gsStateActuator::gsStateActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::gsStateActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateActuator::gsStateActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_StateActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsStateActuator *)new gsStateActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StateActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsStateActuator *result = 0 ;
  
  SWIG_check_num_args("gsStateActuator::gsStateActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::gsStateActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_StateActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsStateActuator *)new gsStateActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StateActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsStateActuator *result = 0 ;
  
  SWIG_check_num_args("gsStateActuator::gsStateActuator",0,0)
  result = (gsStateActuator *)new gsStateActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StateActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_StateActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_StateActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_StateActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_StateActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsStateActuator::gsStateActuator(gsLogicObject *,gkString const &)\n"
    "    gsStateActuator::gsStateActuator(gsLogicObject *)\n"
    "    gsStateActuator::gsStateActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_StateActuator_setMask(lua_State* L) {
  int SWIG_arg = 0;
  gsStateActuator *arg1 = (gsStateActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateActuator::setMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::setMask",1,"gsStateActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateActuator::setMask",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateActuator,0))){
    SWIG_fail_ptr("StateActuator_setMask",1,SWIGTYPE_p_gsStateActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMask(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StateActuator_getMask(lua_State* L) {
  int SWIG_arg = 0;
  gsStateActuator *arg1 = (gsStateActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateActuator::getMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::getMask",1,"gsStateActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateActuator,0))){
    SWIG_fail_ptr("StateActuator_getMask",1,SWIGTYPE_p_gsStateActuator);
  }
  
  result = (int)(arg1)->getMask();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StateActuator_setOp(lua_State* L) {
  int SWIG_arg = 0;
  gsStateActuator *arg1 = (gsStateActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateActuator::setOp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::setOp",1,"gsStateActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateActuator::setOp",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateActuator,0))){
    SWIG_fail_ptr("StateActuator_setOp",1,SWIGTYPE_p_gsStateActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setOp(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StateActuator_getOp(lua_State* L) {
  int SWIG_arg = 0;
  gsStateActuator *arg1 = (gsStateActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateActuator::getOp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateActuator::getOp",1,"gsStateActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateActuator,0))){
    SWIG_fail_ptr("StateActuator_getOp",1,SWIGTYPE_p_gsStateActuator);
  }
  
  result = (int)(arg1)->getOp();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_StateActuator(void *obj) {
gsStateActuator *arg1 = (gsStateActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_StateActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_StateActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_StateActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_StateActuator_methods[]= {
    { "setMask", _wrap_StateActuator_setMask},
    { "getMask", _wrap_StateActuator_getMask},
    { "setOp", _wrap_StateActuator_setOp},
    { "getOp", _wrap_StateActuator_getOp},
    {0,0}
};
static swig_lua_method swig_StateActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_StateActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_StateActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_StateActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_StateActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_StateActuator_Sf_SwigStatic = {
    "StateActuator",
    swig_StateActuator_Sf_SwigStatic_methods,
    swig_StateActuator_Sf_SwigStatic_attributes,
    swig_StateActuator_Sf_SwigStatic_constants,
    swig_StateActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_StateActuator_bases[] = {0,0};
static const char *swig_StateActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_StateActuator = { "StateActuator", "StateActuator", &SWIGTYPE_p_gsStateActuator,_proxy__wrap_new_StateActuator, swig_delete_StateActuator, swig_StateActuator_methods, swig_StateActuator_attributes, &swig_StateActuator_Sf_SwigStatic, swig_StateActuator_meta, swig_StateActuator_bases, swig_StateActuator_base_names };

static int _wrap_new_VisibilityActuator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsVisibilityActuator *result = 0 ;
  
  SWIG_check_num_args("gsVisibilityActuator::gsVisibilityActuator",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVisibilityActuator::gsVisibilityActuator",1,"gsLogicObject *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsVisibilityActuator::gsVisibilityActuator",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_VisibilityActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsVisibilityActuator *)new gsVisibilityActuator(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVisibilityActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VisibilityActuator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicObject *arg1 = (gsLogicObject *) 0 ;
  gsVisibilityActuator *result = 0 ;
  
  SWIG_check_num_args("gsVisibilityActuator::gsVisibilityActuator",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVisibilityActuator::gsVisibilityActuator",1,"gsLogicObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicObject,0))){
    SWIG_fail_ptr("new_VisibilityActuator",1,SWIGTYPE_p_gsLogicObject);
  }
  
  result = (gsVisibilityActuator *)new gsVisibilityActuator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVisibilityActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VisibilityActuator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsVisibilityActuator *result = 0 ;
  
  SWIG_check_num_args("gsVisibilityActuator::gsVisibilityActuator",0,0)
  result = (gsVisibilityActuator *)new gsVisibilityActuator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVisibilityActuator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VisibilityActuator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_VisibilityActuator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_VisibilityActuator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_VisibilityActuator__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_VisibilityActuator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsVisibilityActuator::gsVisibilityActuator(gsLogicObject *,gkString const &)\n"
    "    gsVisibilityActuator::gsVisibilityActuator(gsLogicObject *)\n"
    "    gsVisibilityActuator::gsVisibilityActuator()\n");
  lua_error(L);return 0;
}


static int _wrap_VisibilityActuator_setFlag(lua_State* L) {
  int SWIG_arg = 0;
  gsVisibilityActuator *arg1 = (gsVisibilityActuator *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVisibilityActuator::setFlag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVisibilityActuator::setFlag",1,"gsVisibilityActuator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVisibilityActuator::setFlag",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVisibilityActuator,0))){
    SWIG_fail_ptr("VisibilityActuator_setFlag",1,SWIGTYPE_p_gsVisibilityActuator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setFlag(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisibilityActuator_getFlag(lua_State* L) {
  int SWIG_arg = 0;
  gsVisibilityActuator *arg1 = (gsVisibilityActuator *) 0 ;
  int result;
  
  SWIG_check_num_args("gsVisibilityActuator::getFlag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVisibilityActuator::getFlag",1,"gsVisibilityActuator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVisibilityActuator,0))){
    SWIG_fail_ptr("VisibilityActuator_getFlag",1,SWIGTYPE_p_gsVisibilityActuator);
  }
  
  result = (int)(arg1)->getFlag();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VisibilityActuator(void *obj) {
gsVisibilityActuator *arg1 = (gsVisibilityActuator *) obj;
delete arg1;
}
static int _proxy__wrap_new_VisibilityActuator(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_VisibilityActuator);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_VisibilityActuator_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_VisibilityActuator_methods[]= {
    { "setFlag", _wrap_VisibilityActuator_setFlag},
    { "getFlag", _wrap_VisibilityActuator_getFlag},
    {0,0}
};
static swig_lua_method swig_VisibilityActuator_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VisibilityActuator_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VisibilityActuator_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VisibilityActuator_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VisibilityActuator_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VisibilityActuator_Sf_SwigStatic = {
    "VisibilityActuator",
    swig_VisibilityActuator_Sf_SwigStatic_methods,
    swig_VisibilityActuator_Sf_SwigStatic_attributes,
    swig_VisibilityActuator_Sf_SwigStatic_constants,
    swig_VisibilityActuator_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VisibilityActuator_bases[] = {0,0};
static const char *swig_VisibilityActuator_base_names[] = {"gsActuator *",0};
static swig_lua_class _wrap_class_VisibilityActuator = { "VisibilityActuator", "VisibilityActuator", &SWIGTYPE_p_gsVisibilityActuator,_proxy__wrap_new_VisibilityActuator, swig_delete_VisibilityActuator, swig_VisibilityActuator_methods, swig_VisibilityActuator_attributes, &swig_VisibilityActuator_Sf_SwigStatic, swig_VisibilityActuator_meta, swig_VisibilityActuator_bases, swig_VisibilityActuator_base_names };

static swig_lua_attribute swig_gsNetwork_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsNetwork_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsNetwork_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsNetwork_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsNetwork_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsNetwork_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsNetwork_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsNetwork_Sf_SwigStatic = {
    "gsNetwork",
    swig_gsNetwork_Sf_SwigStatic_methods,
    swig_gsNetwork_Sf_SwigStatic_attributes,
    swig_gsNetwork_Sf_SwigStatic_constants,
    swig_gsNetwork_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsNetwork_bases[] = {0};
static const char *swig_gsNetwork_base_names[] = {0};
static swig_lua_class _wrap_class_gsNetwork = { "gsNetwork", "gsNetwork", &SWIGTYPE_p_gsNetwork,0,0, swig_gsNetwork_methods, swig_gsNetwork_attributes, &swig_gsNetwork_Sf_SwigStatic, swig_gsNetwork_meta, swig_gsNetwork_bases, swig_gsNetwork_base_names };

static int _wrap_initCallbacks(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("initCallbacks",0,0)
  initCallbacks();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_socketCallback_set(lua_State* L) {
  int SWIG_arg = 0;
  gkLuaEvent *arg1 = (gkLuaEvent *) 0 ;
  
  SWIG_check_num_args("socketCallback",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("socketCallback",1,"gkLuaEvent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLuaEvent,0))){
    SWIG_fail_ptr("socketCallback_set",1,SWIGTYPE_p_gkLuaEvent);
  }
  
  socketCallback = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_socketCallback_get(lua_State* L) {
  int SWIG_arg = 0;
  gkLuaEvent *result = 0 ;
  
  SWIG_check_num_args("socketCallback",0,0)
  result = (gkLuaEvent *)socketCallback;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkLuaEvent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_onSocketOpen(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("onSocketOpen",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("onSocketOpen",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("onSocketOpen",2,"void *");
  arg1 = (int)lua_tonumber(L, 1);
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"onSocketOpen");
  onSocketOpen(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_onSocketMessage(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("onSocketMessage",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("onSocketMessage",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("onSocketMessage",2,"void *");
  arg1 = (int)lua_tonumber(L, 1);
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"onSocketMessage");
  onSocketMessage(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_onSocketError(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  void *arg4 = (void *) 0 ;
  
  SWIG_check_num_args("onSocketError",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("onSocketError",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("onSocketError",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("onSocketError",3,"char const *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("onSocketError",4,"void *");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4=(void *)SWIG_MustGetPtr(L,4,0,0,4,"onSocketError");
  onSocketError(arg1,arg2,(char const *)arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_setSocketCallback(lua_State* L) {
  int SWIG_arg = 0;
  gsFunction arg1 ;
  
  SWIG_check_num_args("setSocketCallback",1,1)
  if(!lua_isfunction(L,1)) SWIG_fail_arg("setSocketCallback",1,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  setSocketCallback(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_startNetServer(lua_State* L) {
  int SWIG_arg = 0;
  unsigned short arg1 ;
  
  SWIG_check_num_args("startNetServer",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("startNetServer",1,"unsigned short");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (unsigned short)lua_tonumber(L, 1);
  startNetServer(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_stopNetServer(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("stopNetServer",0,0)
  stopNetServer();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isServerRunning(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isServerRunning",0,0)
  result = (bool)isServerRunning();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_startNetClient(lua_State* L) {
  int SWIG_arg = 0;
  gkString arg1 ;
  unsigned short arg2 ;
  
  SWIG_check_num_args("startNetClient",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("startNetClient",1,"gkString");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("startNetClient",2,"unsigned short");
  
  arg1 = gkString((const char*)lua_tostring(L, 1));
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned short)lua_tonumber(L, 2);
  startNetClient(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_stopNetClient(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("stopNetClient",0,0)
  stopNetClient();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isClientRunning(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isClientRunning",0,0)
  result = (bool)isClientRunning();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getLogicTree(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gkLogicTree *result = 0 ;
  
  SWIG_check_num_args("getLogicTree",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("getLogicTree",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (gkLogicTree *)getLogicTree((gkString const &)*arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LogicTree); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getLogicTreeAmount(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("getLogicTreeAmount",0,0)
  result = (int)getLogicTreeAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getLogicTreeAt(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  gkLogicTree *result = 0 ;
  
  SWIG_check_num_args("getLogicTreeAt",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("getLogicTreeAt",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (gkLogicTree *)getLogicTreeAt(arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LogicTree); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentLogicTree(lua_State* L) {
  int SWIG_arg = 0;
  gkLogicTree *result = 0 ;
  
  SWIG_check_num_args("getCurrentLogicTree",0,0)
  result = (gkLogicTree *)getCurrentLogicTree();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LogicTree); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getCurrentLogicNode(lua_State* L) {
  int SWIG_arg = 0;
  gkLogicNode *result = 0 ;
  
  SWIG_check_num_args("getCurrentLogicNode",0,0)
  result = (gkLogicNode *)getCurrentLogicNode();
  if (result) {
    SWIG_arg += gsWrapLogicNode(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_enableLogicTreeDebug(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  
  SWIG_check_num_args("enableLogicTreeDebug",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("enableLogicTreeDebug",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  enableLogicTreeDebug(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getLogicTreeDebugOutput(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getLogicTreeDebugOutput",0,0)
  result = getLogicTreeDebugOutput();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getLogicTreeDebugOutputCompressed(lua_State* L) {
  int SWIG_arg = 0;
  gkString result;
  
  SWIG_check_num_args("getLogicTreeDebugOutputCompressed",0,0)
  result = getLogicTreeDebugOutputCompressed();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isLogicTreeDebugging(lua_State* L) {
  int SWIG_arg = 0;
  bool result;
  
  SWIG_check_num_args("isLogicTreeDebugging",0,0)
  result = (bool)isLogicTreeDebugging();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsLogicTree(lua_State* L) {
  int SWIG_arg = 0;
  gkLogicTree *arg1 = (gkLogicTree *) 0 ;
  gsLogicTree *result = 0 ;
  
  SWIG_check_num_args("gsLogicTree::gsLogicTree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::gsLogicTree",1,"gkLogicTree *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLogicTree,0))){
    SWIG_fail_ptr("new_gsLogicTree",1,SWIGTYPE_p_gkLogicTree);
  }
  
  result = (gsLogicTree *)new gsLogicTree(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicTree,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicTree_getNodeByName(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicTree *arg1 = (gsLogicTree *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLogicNode *result = 0 ;
  
  SWIG_check_num_args("gsLogicTree::getNodeByName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::getNodeByName",1,"gsLogicTree *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicTree::getNodeByName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicTree,0))){
    SWIG_fail_ptr("gsLogicTree_getNodeByName",1,SWIGTYPE_p_gsLogicTree);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLogicNode *)(arg1)->getNodeByName((gkString const &)*arg2);
  if (result) {
    SWIG_arg += gsWrapLogicNode(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicTree_getNodeAt(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicTree *arg1 = (gsLogicTree *) 0 ;
  int arg2 ;
  gkLogicNode *result = 0 ;
  
  SWIG_check_num_args("gsLogicTree::getNodeAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::getNodeAt",1,"gsLogicTree *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicTree::getNodeAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicTree,0))){
    SWIG_fail_ptr("gsLogicTree_getNodeAt",1,SWIGTYPE_p_gsLogicTree);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkLogicNode *)(arg1)->getNodeAt(arg2);
  if (result) {
    SWIG_arg += gsWrapLogicNode(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicTree_getNodeAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicTree *arg1 = (gsLogicTree *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLogicTree::getNodeAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::getNodeAmount",1,"gsLogicTree *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicTree,0))){
    SWIG_fail_ptr("gsLogicTree_getNodeAmount",1,SWIGTYPE_p_gsLogicTree);
  }
  
  result = (int)(arg1)->getNodeAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicTree_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicTree *arg1 = (gsLogicTree *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLogicTree::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::getName",1,"gsLogicTree *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicTree,0))){
    SWIG_fail_ptr("gsLogicTree_getName",1,SWIGTYPE_p_gsLogicTree);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicTree_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicTree *arg1 = (gsLogicTree *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLogicTree::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicTree::getType",1,"gsLogicTree *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicTree,0))){
    SWIG_fail_ptr("gsLogicTree_getType",1,SWIGTYPE_p_gsLogicTree);
  }
  
  result = (arg1)->getType();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsLogicTree(void *obj) {
gsLogicTree *arg1 = (gsLogicTree *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsLogicTree(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsLogicTree);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsLogicTree_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsLogicTree_methods[]= {
    { "getNodeByName", _wrap_gsLogicTree_getNodeByName},
    { "getNodeAt", _wrap_gsLogicTree_getNodeAt},
    { "getNodeAmount", _wrap_gsLogicTree_getNodeAmount},
    { "getName", _wrap_gsLogicTree_getName},
    { "getType", _wrap_gsLogicTree_getType},
    {0,0}
};
static swig_lua_method swig_gsLogicTree_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsLogicTree_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsLogicTree_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsLogicTree_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsLogicTree_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsLogicTree_Sf_SwigStatic = {
    "gsLogicTree",
    swig_gsLogicTree_Sf_SwigStatic_methods,
    swig_gsLogicTree_Sf_SwigStatic_attributes,
    swig_gsLogicTree_Sf_SwigStatic_constants,
    swig_gsLogicTree_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsLogicTree_bases[] = {0};
static const char *swig_gsLogicTree_base_names[] = {0};
static swig_lua_class _wrap_class_gsLogicTree = { "gsLogicTree", "gsLogicTree", &SWIGTYPE_p_gsLogicTree,_proxy__wrap_new_gsLogicTree, swig_delete_gsLogicTree, swig_gsLogicTree_methods, swig_gsLogicTree_attributes, &swig_gsLogicTree_Sf_SwigStatic, swig_gsLogicTree_meta, swig_gsLogicTree_bases, swig_gsLogicTree_base_names };

static int _wrap_new_gsILogicSocket(lua_State* L) {
  int SWIG_arg = 0;
  gkILogicSocket *arg1 = (gkILogicSocket *) 0 ;
  gsILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::gsILogicSocket",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::gsILogicSocket",1,"gkILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkILogicSocket,0))){
    SWIG_fail_ptr("new_gsILogicSocket",1,SWIGTYPE_p_gkILogicSocket);
  }
  
  result = (gsILogicSocket *)new gsILogicSocket(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsILogicSocket,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_isConnected(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsILogicSocket::isConnected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::isConnected",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_isConnected",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (bool)(arg1)->isConnected();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_isLinked(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsILogicSocket::isLinked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::isLinked",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_isLinked",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (bool)(arg1)->isLinked();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getFrom(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::getFrom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getFrom",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getFrom",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (gkILogicSocket *)(arg1)->getFrom();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_removeConnection(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gsILogicSocket *arg2 = (gsILogicSocket *) 0 ;
  
  SWIG_check_num_args("gsILogicSocket::removeConnection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::removeConnection",1,"gsILogicSocket *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsILogicSocket::removeConnection",2,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_removeConnection",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_removeConnection",2,SWIGTYPE_p_gsILogicSocket);
  }
  
  (arg1)->removeConnection(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getOutSocketAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  int result;
  
  SWIG_check_num_args("gsILogicSocket::getOutSocketAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getOutSocketAmount",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getOutSocketAmount",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (int)(arg1)->getOutSocketAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getOutSocketAt(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  int arg2 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::getOutSocketAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getOutSocketAt",1,"gsILogicSocket *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsILogicSocket::getOutSocketAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getOutSocketAt",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkILogicSocket *)(arg1)->getOutSocketAt(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsILogicSocket::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getName",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getName",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getNode(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkLogicNode *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::getNode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getNode",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getNode",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (gkLogicNode *)(arg1)->getNode();
  if (result) {
    SWIG_arg += gsWrapLogicNode(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getGameObject(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::getGameObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getGameObject",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getGameObject",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (gkGameObject *)(arg1)->getGameObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_getVar(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkVariable *result = 0 ;
  
  SWIG_check_num_args("gsILogicSocket::getVar",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::getVar",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_getVar",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (gkVariable *)(arg1)->getVar();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Variable); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_setVar__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsILogicSocket::setVar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::setVar",1,"gsILogicSocket *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsILogicSocket::setVar",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_setVar",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setVar(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_setVar__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsILogicSocket::setVar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::setVar",1,"gsILogicSocket *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsILogicSocket::setVar",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_setVar",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setVar(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_setVar__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gsILogicSocket::setVar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::setVar",1,"gsILogicSocket *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsILogicSocket::setVar",2,"gkString const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_setVar",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  (arg1)->setVar(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_setVar(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsILogicSocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsILogicSocket_setVar__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsILogicSocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsILogicSocket_setVar__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsILogicSocket, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsILogicSocket_setVar__SWIG_2(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsILogicSocket_setVar'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsILogicSocket::setVar(bool)\n"
    "    gsILogicSocket::setVar(float)\n"
    "    gsILogicSocket::setVar(gkString const)\n");
  lua_error(L);return 0;
}


static int _wrap_gsILogicSocket_link(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  gsILogicSocket *arg2 = (gsILogicSocket *) 0 ;
  
  SWIG_check_num_args("gsILogicSocket::link",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::link",1,"gsILogicSocket *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsILogicSocket::link",2,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_link",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_link",2,SWIGTYPE_p_gsILogicSocket);
  }
  
  (arg1)->link(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_isDirty(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsILogicSocket::isDirty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::isDirty",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_isDirty",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  result = (bool)(arg1)->isDirty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsILogicSocket_requestClearDirty(lua_State* L) {
  int SWIG_arg = 0;
  gsILogicSocket *arg1 = (gsILogicSocket *) 0 ;
  
  SWIG_check_num_args("gsILogicSocket::requestClearDirty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsILogicSocket::requestClearDirty",1,"gsILogicSocket *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsILogicSocket,0))){
    SWIG_fail_ptr("gsILogicSocket_requestClearDirty",1,SWIGTYPE_p_gsILogicSocket);
  }
  
  (arg1)->requestClearDirty();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsILogicSocket(void *obj) {
gsILogicSocket *arg1 = (gsILogicSocket *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsILogicSocket(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsILogicSocket);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsILogicSocket_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsILogicSocket_methods[]= {
    { "isConnected", _wrap_gsILogicSocket_isConnected},
    { "isLinked", _wrap_gsILogicSocket_isLinked},
    { "getFrom", _wrap_gsILogicSocket_getFrom},
    { "removeConnection", _wrap_gsILogicSocket_removeConnection},
    { "getOutSocketAmount", _wrap_gsILogicSocket_getOutSocketAmount},
    { "getOutSocketAt", _wrap_gsILogicSocket_getOutSocketAt},
    { "getName", _wrap_gsILogicSocket_getName},
    { "getNode", _wrap_gsILogicSocket_getNode},
    { "getGameObject", _wrap_gsILogicSocket_getGameObject},
    { "getVar", _wrap_gsILogicSocket_getVar},
    { "setVar", _wrap_gsILogicSocket_setVar},
    { "link", _wrap_gsILogicSocket_link},
    { "isDirty", _wrap_gsILogicSocket_isDirty},
    { "requestClearDirty", _wrap_gsILogicSocket_requestClearDirty},
    {0,0}
};
static swig_lua_method swig_gsILogicSocket_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsILogicSocket_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsILogicSocket_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsILogicSocket_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsILogicSocket_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsILogicSocket_Sf_SwigStatic = {
    "gsILogicSocket",
    swig_gsILogicSocket_Sf_SwigStatic_methods,
    swig_gsILogicSocket_Sf_SwigStatic_attributes,
    swig_gsILogicSocket_Sf_SwigStatic_constants,
    swig_gsILogicSocket_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsILogicSocket_bases[] = {0};
static const char *swig_gsILogicSocket_base_names[] = {0};
static swig_lua_class _wrap_class_gsILogicSocket = { "gsILogicSocket", "gsILogicSocket", &SWIGTYPE_p_gsILogicSocket,_proxy__wrap_new_gsILogicSocket, swig_delete_gsILogicSocket, swig_gsILogicSocket_methods, swig_gsILogicSocket_attributes, &swig_gsILogicSocket_Sf_SwigStatic, swig_gsILogicSocket_meta, swig_gsILogicSocket_bases, swig_gsILogicSocket_base_names };

static int _wrap_new_gsVariable(lua_State* L) {
  int SWIG_arg = 0;
  gkVariable *arg1 = (gkVariable *) 0 ;
  gsVariable *result = 0 ;
  
  SWIG_check_num_args("gsVariable::gsVariable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::gsVariable",1,"gkVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVariable,0))){
    SWIG_fail_ptr("new_gsVariable",1,SWIGTYPE_p_gkVariable);
  }
  
  result = (gsVariable *)new gsVariable(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVariable,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getFloat(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVariable::getFloat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getFloat",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getFloat",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (float)(arg1)->getFloat();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getInt(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  int result;
  
  SWIG_check_num_args("gsVariable::getInt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getInt",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getInt",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (int)(arg1)->getInt();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getString(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsVariable::getString",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getString",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getString",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (arg1)->getString();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getBool(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsVariable::getBool",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getBool",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getBool",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (bool)(arg1)->getBool();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getVector2(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gsVector2 result;
  
  SWIG_check_num_args("gsVariable::getVector2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getVector2",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getVector2",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (arg1)->getVector2();
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getVector3(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsVariable::getVector3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getVector3",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getVector3",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (arg1)->getVector3();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_getVector4(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsVariable::getVector4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::getVector4",1,"gsVariable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_getVector4",1,SWIGTYPE_p_gsVariable);
  }
  
  result = (arg1)->getVector4();
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_setFloat(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVariable::setFloat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::setFloat",1,"gsVariable *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVariable::setFloat",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_setFloat",1,SWIGTYPE_p_gsVariable);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setFloat(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_setInt(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVariable::setInt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::setInt",1,"gsVariable *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVariable::setInt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_setInt",1,SWIGTYPE_p_gsVariable);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setInt(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_setBool(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsVariable::setBool",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::setBool",1,"gsVariable *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsVariable::setBool",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_setBool",1,SWIGTYPE_p_gsVariable);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setBool(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_set(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gkVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsVariable::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::set",1,"gsVariable *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVariable::set",2,"gkVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_set",1,SWIGTYPE_p_gsVariable);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gsVariable_set",2,SWIGTYPE_p_gkVector3);
  }
  
  (arg1)->set((gkVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVariable_setString(lua_State* L) {
  int SWIG_arg = 0;
  gsVariable *arg1 = (gsVariable *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsVariable::setString",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVariable::setString",1,"gsVariable *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsVariable::setString",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVariable,0))){
    SWIG_fail_ptr("gsVariable_setString",1,SWIGTYPE_p_gsVariable);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setString((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVariable(void *obj) {
gsVariable *arg1 = (gsVariable *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVariable(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVariable);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVariable_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVariable_methods[]= {
    { "getFloat", _wrap_gsVariable_getFloat},
    { "getInt", _wrap_gsVariable_getInt},
    { "getString", _wrap_gsVariable_getString},
    { "getBool", _wrap_gsVariable_getBool},
    { "getVector2", _wrap_gsVariable_getVector2},
    { "getVector3", _wrap_gsVariable_getVector3},
    { "getVector4", _wrap_gsVariable_getVector4},
    { "setFloat", _wrap_gsVariable_setFloat},
    { "setInt", _wrap_gsVariable_setInt},
    { "setBool", _wrap_gsVariable_setBool},
    { "set", _wrap_gsVariable_set},
    { "setString", _wrap_gsVariable_setString},
    {0,0}
};
static swig_lua_method swig_gsVariable_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVariable_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVariable_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVariable_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVariable_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVariable_Sf_SwigStatic = {
    "gsVariable",
    swig_gsVariable_Sf_SwigStatic_methods,
    swig_gsVariable_Sf_SwigStatic_attributes,
    swig_gsVariable_Sf_SwigStatic_constants,
    swig_gsVariable_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVariable_bases[] = {0};
static const char *swig_gsVariable_base_names[] = {0};
static swig_lua_class _wrap_class_gsVariable = { "gsVariable", "gsVariable", &SWIGTYPE_p_gsVariable,_proxy__wrap_new_gsVariable, swig_delete_gsVariable, swig_gsVariable_methods, swig_gsVariable_attributes, &swig_gsVariable_Sf_SwigStatic, swig_gsVariable_meta, swig_gsVariable_bases, swig_gsVariable_base_names };

static int _wrap_new_gsLogicNode(lua_State* L) {
  int SWIG_arg = 0;
  gkLogicNode *arg1 = (gkLogicNode *) 0 ;
  gsLogicNode *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::gsLogicNode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::gsLogicNode",1,"gkLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLogicNode,0))){
    SWIG_fail_ptr("new_gsLogicNode",1,SWIGTYPE_p_gkLogicNode);
  }
  
  result = (gsLogicNode *)new gsLogicNode(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLogicNode,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getInSocketAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLogicNode::getInSocketAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getInSocketAmount",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getInSocketAmount",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (int)(arg1)->getInSocketAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getOutSocketAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  int result;
  
  SWIG_check_num_args("gsLogicNode::getOutSocketAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getOutSocketAmount",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getOutSocketAmount",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (int)(arg1)->getOutSocketAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getInSocketAt(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  int arg2 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getInSocketAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getInSocketAt",1,"gsLogicNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicNode::getInSocketAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getInSocketAt",1,SWIGTYPE_p_gsLogicNode);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkILogicSocket *)(arg1)->getInSocketAt(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getOutSocketAt(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  int arg2 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getOutSocketAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getOutSocketAt",1,"gsLogicNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicNode::getOutSocketAt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getOutSocketAt",1,SWIGTYPE_p_gsLogicNode);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkILogicSocket *)(arg1)->getOutSocketAt(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLogicNode::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getName",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getName",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (arg1)->getName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLogicNode::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getType",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getType",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (arg1)->getType();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getInSocket(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getInSocket",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getInSocket",1,"gsLogicNode *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicNode::getInSocket",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getInSocket",1,SWIGTYPE_p_gsLogicNode);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkILogicSocket *)(arg1)->getInSocket((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getOutSocket(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkILogicSocket *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getOutSocket",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getOutSocket",1,"gsLogicNode *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicNode::getOutSocket",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getOutSocket",1,SWIGTYPE_p_gsLogicNode);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkILogicSocket *)(arg1)->getOutSocket((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ILogicSocket); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkVariable *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getProperty",1,"gsLogicNode *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLogicNode::getProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getProperty",1,SWIGTYPE_p_gsLogicNode);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkVariable *)(arg1)->getProperty((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Variable); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_getGameObject(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsLogicNode::getGameObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::getGameObject",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_getGameObject",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (gkGameObject *)(arg1)->getGameObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_isValid(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsLogicNode::isValid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::isValid",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_isValid",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (bool)(arg1)->isValid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_attachObject(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("gsLogicNode::attachObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::attachObject",1,"gsLogicNode *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsLogicNode::attachObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_attachObject",1,SWIGTYPE_p_gsLogicNode);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("gsLogicNode_attachObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->attachObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaInit__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaInit",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaInit",1,"gsLogicNode *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsLogicNode::setLuaInit",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsLogicNode::setLuaInit",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaInit",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setLuaInit(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaInit__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaInit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaInit",1,"gsLogicNode *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsLogicNode::setLuaInit",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaInit",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setLuaInit(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaInit(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsLogicNode_setLuaInit__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsLogicNode_setLuaInit__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsLogicNode_setLuaInit'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicNode::setLuaInit(gsSelf,gsFunction)\n"
    "    gsLogicNode::setLuaInit(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsLogicNode_setLuaUpdate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaUpdate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaUpdate",1,"gsLogicNode *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsLogicNode::setLuaUpdate",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsLogicNode::setLuaUpdate",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaUpdate",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setLuaUpdate(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaUpdate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaUpdate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaUpdate",1,"gsLogicNode *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsLogicNode::setLuaUpdate",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaUpdate",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setLuaUpdate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaUpdate(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsLogicNode_setLuaUpdate__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsLogicNode_setLuaUpdate__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsLogicNode_setLuaUpdate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicNode::setLuaUpdate(gsSelf,gsFunction)\n"
    "    gsLogicNode::setLuaUpdate(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsLogicNode_setLuaEval__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaEval",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaEval",1,"gsLogicNode *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsLogicNode::setLuaEval",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsLogicNode::setLuaEval",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaEval",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->setLuaEval(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaEval__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsLogicNode::setLuaEval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::setLuaEval",1,"gsLogicNode *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsLogicNode::setLuaEval",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_setLuaEval",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->setLuaEval(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_setLuaEval(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsLogicNode_setLuaEval__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsLogicNode_setLuaEval__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsLogicNode_setLuaEval'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicNode::setLuaEval(gsSelf,gsFunction)\n"
    "    gsLogicNode::setLuaEval(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_gsLogicNode_callCPPInit(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  
  SWIG_check_num_args("gsLogicNode::callCPPInit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::callCPPInit",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_callCPPInit",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (arg1)->callCPPInit();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_callCPPUpdate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsLogicNode::callCPPUpdate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::callCPPUpdate",1,"gsLogicNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicNode::callCPPUpdate",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_callCPPUpdate",1,SWIGTYPE_p_gsLogicNode);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->callCPPUpdate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_callCPPUpdate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  
  SWIG_check_num_args("gsLogicNode::callCPPUpdate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::callCPPUpdate",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_callCPPUpdate",1,SWIGTYPE_p_gsLogicNode);
  }
  
  (arg1)->callCPPUpdate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_callCPPUpdate(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsLogicNode_callCPPUpdate__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsLogicNode_callCPPUpdate__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsLogicNode_callCPPUpdate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicNode::callCPPUpdate(float)\n"
    "    gsLogicNode::callCPPUpdate()\n");
  lua_error(L);return 0;
}


static int _wrap_gsLogicNode_callCPPEval__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("gsLogicNode::callCPPEval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::callCPPEval",1,"gsLogicNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsLogicNode::callCPPEval",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_callCPPEval",1,SWIGTYPE_p_gsLogicNode);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)(arg1)->callCPPEval(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_callCPPEval__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLogicNode *arg1 = (gsLogicNode *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsLogicNode::callCPPEval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLogicNode::callCPPEval",1,"gsLogicNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLogicNode,0))){
    SWIG_fail_ptr("gsLogicNode_callCPPEval",1,SWIGTYPE_p_gsLogicNode);
  }
  
  result = (bool)(arg1)->callCPPEval();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLogicNode_callCPPEval(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsLogicNode_callCPPEval__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLogicNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsLogicNode_callCPPEval__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsLogicNode_callCPPEval'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLogicNode::callCPPEval(float)\n"
    "    gsLogicNode::callCPPEval()\n");
  lua_error(L);return 0;
}


static void swig_delete_gsLogicNode(void *obj) {
gsLogicNode *arg1 = (gsLogicNode *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsLogicNode(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsLogicNode);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsLogicNode_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsLogicNode_methods[]= {
    { "getInSocketAmount", _wrap_gsLogicNode_getInSocketAmount},
    { "getOutSocketAmount", _wrap_gsLogicNode_getOutSocketAmount},
    { "getInSocketAt", _wrap_gsLogicNode_getInSocketAt},
    { "getOutSocketAt", _wrap_gsLogicNode_getOutSocketAt},
    { "getName", _wrap_gsLogicNode_getName},
    { "getType", _wrap_gsLogicNode_getType},
    { "getInSocket", _wrap_gsLogicNode_getInSocket},
    { "getOutSocket", _wrap_gsLogicNode_getOutSocket},
    { "getProperty", _wrap_gsLogicNode_getProperty},
    { "getGameObject", _wrap_gsLogicNode_getGameObject},
    { "isValid", _wrap_gsLogicNode_isValid},
    { "attachObject", _wrap_gsLogicNode_attachObject},
    { "setLuaInit", _wrap_gsLogicNode_setLuaInit},
    { "setLuaUpdate", _wrap_gsLogicNode_setLuaUpdate},
    { "setLuaEval", _wrap_gsLogicNode_setLuaEval},
    { "callCPPInit", _wrap_gsLogicNode_callCPPInit},
    { "callCPPUpdate", _wrap_gsLogicNode_callCPPUpdate},
    { "callCPPEval", _wrap_gsLogicNode_callCPPEval},
    {0,0}
};
static swig_lua_method swig_gsLogicNode_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsLogicNode_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsLogicNode_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsLogicNode_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsLogicNode_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsLogicNode_Sf_SwigStatic = {
    "gsLogicNode",
    swig_gsLogicNode_Sf_SwigStatic_methods,
    swig_gsLogicNode_Sf_SwigStatic_attributes,
    swig_gsLogicNode_Sf_SwigStatic_constants,
    swig_gsLogicNode_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsLogicNode_bases[] = {0};
static const char *swig_gsLogicNode_base_names[] = {0};
static swig_lua_class _wrap_class_gsLogicNode = { "gsLogicNode", "gsLogicNode", &SWIGTYPE_p_gsLogicNode,_proxy__wrap_new_gsLogicNode, swig_delete_gsLogicNode, swig_gsLogicNode_methods, swig_gsLogicNode_attributes, &swig_gsLogicNode_Sf_SwigStatic, swig_gsLogicNode_meta, swig_gsLogicNode_bases, swig_gsLogicNode_base_names };

static int _wrap_new_gsPickRayNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPickRayNodeAbstract *arg1 = (gkPickRayNodeAbstract *) 0 ;
  gsPickRayNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPickRayNodeAbstract::gsPickRayNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPickRayNodeAbstract::gsPickRayNodeAbstract",1,"gkPickRayNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPickRayNodeAbstract,0))){
    SWIG_fail_ptr("new_gsPickRayNodeAbstract",1,SWIGTYPE_p_gkPickRayNodeAbstract);
  }
  
  result = (gsPickRayNodeAbstract *)new gsPickRayNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPickRayNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPickRayNodeAbstract_getProphitProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsPickRayNodeAbstract *arg1 = (gsPickRayNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPickRayNodeAbstract::getProphitProperty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPickRayNodeAbstract::getProphitProperty",1,"gsPickRayNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPickRayNodeAbstract,0))){
    SWIG_fail_ptr("gsPickRayNodeAbstract_getProphitProperty",1,SWIGTYPE_p_gsPickRayNodeAbstract);
  }
  
  result = (arg1)->getProphitProperty();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPickRayNodeAbstract_setProphitProperty(lua_State* L) {
  int SWIG_arg = 0;
  gsPickRayNodeAbstract *arg1 = (gsPickRayNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPickRayNodeAbstract::setProphitProperty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPickRayNodeAbstract::setProphitProperty",1,"gsPickRayNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPickRayNodeAbstract::setProphitProperty",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPickRayNodeAbstract,0))){
    SWIG_fail_ptr("gsPickRayNodeAbstract_setProphitProperty",1,SWIGTYPE_p_gsPickRayNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setProphitProperty((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPickRayNodeAbstract(void *obj) {
gsPickRayNodeAbstract *arg1 = (gsPickRayNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPickRayNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPickRayNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPickRayNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPickRayNodeAbstract_methods[]= {
    { "getProphitProperty", _wrap_gsPickRayNodeAbstract_getProphitProperty},
    { "setProphitProperty", _wrap_gsPickRayNodeAbstract_setProphitProperty},
    {0,0}
};
static swig_lua_method swig_gsPickRayNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPickRayNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPickRayNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPickRayNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPickRayNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPickRayNodeAbstract_Sf_SwigStatic = {
    "gsPickRayNodeAbstract",
    swig_gsPickRayNodeAbstract_Sf_SwigStatic_methods,
    swig_gsPickRayNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsPickRayNodeAbstract_Sf_SwigStatic_constants,
    swig_gsPickRayNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPickRayNodeAbstract_bases[] = {0,0};
static const char *swig_gsPickRayNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPickRayNodeAbstract = { "gsPickRayNodeAbstract", "gsPickRayNodeAbstract", &SWIGTYPE_p_gsPickRayNodeAbstract,_proxy__wrap_new_gsPickRayNodeAbstract, swig_delete_gsPickRayNodeAbstract, swig_gsPickRayNodeAbstract_methods, swig_gsPickRayNodeAbstract_attributes, &swig_gsPickRayNodeAbstract_Sf_SwigStatic, swig_gsPickRayNodeAbstract_meta, swig_gsPickRayNodeAbstract_bases, swig_gsPickRayNodeAbstract_base_names };

static int _wrap_new_gsTestNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTestNodeAbstract *arg1 = (gkTestNodeAbstract *) 0 ;
  gsTestNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::gsTestNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::gsTestNodeAbstract",1,"gkTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTestNodeAbstract,0))){
    SWIG_fail_ptr("new_gsTestNodeAbstract",1,SWIGTYPE_p_gkTestNodeAbstract);
  }
  
  result = (gsTestNodeAbstract *)new gsTestNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTestNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getPropObjectName(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getPropObjectName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getPropObjectName",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getPropObjectName",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (arg1)->getPropObjectName();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setPropObjectName(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setPropObjectName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setPropObjectName",1,"gsTestNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setPropObjectName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropObjectName",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropObjectName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getPropMode(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getPropMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getPropMode",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getPropMode",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (int)(arg1)->getPropMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setPropMode(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setPropMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setPropMode",1,"gsTestNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setPropMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropMode",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getPropFac(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getPropFac",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getPropFac",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getPropFac",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (float)(arg1)->getPropFac();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setPropFac(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setPropFac",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setPropFac",1,"gsTestNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setPropFac",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropFac",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropFac(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getPropSize(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getPropSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getPropSize",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getPropSize",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (int)(arg1)->getPropSize();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setPropSize(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setPropSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setPropSize",1,"gsTestNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setPropSize",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropSize",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropSize(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getPropDir(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkVector2 result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getPropDir",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getPropDir",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getPropDir",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (arg1)->getPropDir();
  {
    gkVector2 * resultptr = new gkVector2((const gkVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setPropDir(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkVector2 *arg2 = 0 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setPropDir",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setPropDir",1,"gsTestNodeAbstract *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setPropDir",2,"gkVector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropDir",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setPropDir",2,SWIGTYPE_p_gkVector2);
  }
  
  (arg1)->setPropDir((gkVector2 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_getProptest(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkVector2 result;
  
  SWIG_check_num_args("gsTestNodeAbstract::getProptest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::getProptest",1,"gsTestNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_getProptest",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  result = (arg1)->getProptest();
  {
    gkVector2 * resultptr = new gkVector2((const gkVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTestNodeAbstract_setProptest(lua_State* L) {
  int SWIG_arg = 0;
  gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) 0 ;
  gkVector2 *arg2 = 0 ;
  
  SWIG_check_num_args("gsTestNodeAbstract::setProptest",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTestNodeAbstract::setProptest",1,"gsTestNodeAbstract *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsTestNodeAbstract::setProptest",2,"gkVector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTestNodeAbstract,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setProptest",1,SWIGTYPE_p_gsTestNodeAbstract);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector2,0))){
    SWIG_fail_ptr("gsTestNodeAbstract_setProptest",2,SWIGTYPE_p_gkVector2);
  }
  
  (arg1)->setProptest((gkVector2 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTestNodeAbstract(void *obj) {
gsTestNodeAbstract *arg1 = (gsTestNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTestNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTestNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTestNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTestNodeAbstract_methods[]= {
    { "getPropObjectName", _wrap_gsTestNodeAbstract_getPropObjectName},
    { "setPropObjectName", _wrap_gsTestNodeAbstract_setPropObjectName},
    { "getPropMode", _wrap_gsTestNodeAbstract_getPropMode},
    { "setPropMode", _wrap_gsTestNodeAbstract_setPropMode},
    { "getPropFac", _wrap_gsTestNodeAbstract_getPropFac},
    { "setPropFac", _wrap_gsTestNodeAbstract_setPropFac},
    { "getPropSize", _wrap_gsTestNodeAbstract_getPropSize},
    { "setPropSize", _wrap_gsTestNodeAbstract_setPropSize},
    { "getPropDir", _wrap_gsTestNodeAbstract_getPropDir},
    { "setPropDir", _wrap_gsTestNodeAbstract_setPropDir},
    { "getProptest", _wrap_gsTestNodeAbstract_getProptest},
    { "setProptest", _wrap_gsTestNodeAbstract_setProptest},
    {0,0}
};
static swig_lua_method swig_gsTestNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTestNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTestNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTestNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTestNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTestNodeAbstract_Sf_SwigStatic = {
    "gsTestNodeAbstract",
    swig_gsTestNodeAbstract_Sf_SwigStatic_methods,
    swig_gsTestNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsTestNodeAbstract_Sf_SwigStatic_constants,
    swig_gsTestNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTestNodeAbstract_bases[] = {0,0};
static const char *swig_gsTestNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTestNodeAbstract = { "gsTestNodeAbstract", "gsTestNodeAbstract", &SWIGTYPE_p_gsTestNodeAbstract,_proxy__wrap_new_gsTestNodeAbstract, swig_delete_gsTestNodeAbstract, swig_gsTestNodeAbstract_methods, swig_gsTestNodeAbstract_attributes, &swig_gsTestNodeAbstract_Sf_SwigStatic, swig_gsTestNodeAbstract_meta, swig_gsTestNodeAbstract_bases, swig_gsTestNodeAbstract_base_names };

static int _wrap_new_gsMessageSendAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMessageSendAbstract *arg1 = (gkMessageSendAbstract *) 0 ;
  gsMessageSendAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMessageSendAbstract::gsMessageSendAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSendAbstract::gsMessageSendAbstract",1,"gkMessageSendAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMessageSendAbstract,0))){
    SWIG_fail_ptr("new_gsMessageSendAbstract",1,SWIGTYPE_p_gkMessageSendAbstract);
  }
  
  result = (gsMessageSendAbstract *)new gsMessageSendAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageSendAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMessageSendAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSendAbstract *arg1 = (gsMessageSendAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageSendAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSendAbstract::getPropTYPE",1,"gsMessageSendAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSendAbstract,0))){
    SWIG_fail_ptr("gsMessageSendAbstract_getPropTYPE",1,SWIGTYPE_p_gsMessageSendAbstract);
  }
  
  result = (arg1)->getPropTYPE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMessageSendAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageSendAbstract *arg1 = (gsMessageSendAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageSendAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageSendAbstract::setPropTYPE",1,"gsMessageSendAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageSendAbstract::setPropTYPE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageSendAbstract,0))){
    SWIG_fail_ptr("gsMessageSendAbstract_setPropTYPE",1,SWIGTYPE_p_gsMessageSendAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropTYPE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMessageSendAbstract(void *obj) {
gsMessageSendAbstract *arg1 = (gsMessageSendAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMessageSendAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMessageSendAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMessageSendAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMessageSendAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsMessageSendAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsMessageSendAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsMessageSendAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMessageSendAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMessageSendAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMessageSendAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMessageSendAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMessageSendAbstract_Sf_SwigStatic = {
    "gsMessageSendAbstract",
    swig_gsMessageSendAbstract_Sf_SwigStatic_methods,
    swig_gsMessageSendAbstract_Sf_SwigStatic_attributes,
    swig_gsMessageSendAbstract_Sf_SwigStatic_constants,
    swig_gsMessageSendAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMessageSendAbstract_bases[] = {0,0};
static const char *swig_gsMessageSendAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMessageSendAbstract = { "gsMessageSendAbstract", "gsMessageSendAbstract", &SWIGTYPE_p_gsMessageSendAbstract,_proxy__wrap_new_gsMessageSendAbstract, swig_delete_gsMessageSendAbstract, swig_gsMessageSendAbstract_methods, swig_gsMessageSendAbstract_attributes, &swig_gsMessageSendAbstract_Sf_SwigStatic, swig_gsMessageSendAbstract_meta, swig_gsMessageSendAbstract_bases, swig_gsMessageSendAbstract_base_names };

static int _wrap_new_gsMessageGetAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMessageGetAbstract *arg1 = (gkMessageGetAbstract *) 0 ;
  gsMessageGetAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMessageGetAbstract::gsMessageGetAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageGetAbstract::gsMessageGetAbstract",1,"gkMessageGetAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMessageGetAbstract,0))){
    SWIG_fail_ptr("new_gsMessageGetAbstract",1,SWIGTYPE_p_gkMessageGetAbstract);
  }
  
  result = (gsMessageGetAbstract *)new gsMessageGetAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMessageGetAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMessageGetAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageGetAbstract *arg1 = (gsMessageGetAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsMessageGetAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageGetAbstract::getPropTYPE",1,"gsMessageGetAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageGetAbstract,0))){
    SWIG_fail_ptr("gsMessageGetAbstract_getPropTYPE",1,SWIGTYPE_p_gsMessageGetAbstract);
  }
  
  result = (arg1)->getPropTYPE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMessageGetAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsMessageGetAbstract *arg1 = (gsMessageGetAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsMessageGetAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMessageGetAbstract::setPropTYPE",1,"gsMessageGetAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsMessageGetAbstract::setPropTYPE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMessageGetAbstract,0))){
    SWIG_fail_ptr("gsMessageGetAbstract_setPropTYPE",1,SWIGTYPE_p_gsMessageGetAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropTYPE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMessageGetAbstract(void *obj) {
gsMessageGetAbstract *arg1 = (gsMessageGetAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMessageGetAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMessageGetAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMessageGetAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMessageGetAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsMessageGetAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsMessageGetAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsMessageGetAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMessageGetAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMessageGetAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMessageGetAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMessageGetAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMessageGetAbstract_Sf_SwigStatic = {
    "gsMessageGetAbstract",
    swig_gsMessageGetAbstract_Sf_SwigStatic_methods,
    swig_gsMessageGetAbstract_Sf_SwigStatic_attributes,
    swig_gsMessageGetAbstract_Sf_SwigStatic_constants,
    swig_gsMessageGetAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMessageGetAbstract_bases[] = {0,0};
static const char *swig_gsMessageGetAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMessageGetAbstract = { "gsMessageGetAbstract", "gsMessageGetAbstract", &SWIGTYPE_p_gsMessageGetAbstract,_proxy__wrap_new_gsMessageGetAbstract, swig_delete_gsMessageGetAbstract, swig_gsMessageGetAbstract_methods, swig_gsMessageGetAbstract_attributes, &swig_gsMessageGetAbstract_Sf_SwigStatic, swig_gsMessageGetAbstract_meta, swig_gsMessageGetAbstract_bases, swig_gsMessageGetAbstract_base_names };

static int _wrap_new_gsObjectManipulatorAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkObjectManipulatorAbstract *arg1 = (gkObjectManipulatorAbstract *) 0 ;
  gsObjectManipulatorAbstract *result = 0 ;
  
  SWIG_check_num_args("gsObjectManipulatorAbstract::gsObjectManipulatorAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectManipulatorAbstract::gsObjectManipulatorAbstract",1,"gkObjectManipulatorAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkObjectManipulatorAbstract,0))){
    SWIG_fail_ptr("new_gsObjectManipulatorAbstract",1,SWIGTYPE_p_gkObjectManipulatorAbstract);
  }
  
  result = (gsObjectManipulatorAbstract *)new gsObjectManipulatorAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsObjectManipulatorAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectManipulatorAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectManipulatorAbstract *arg1 = (gsObjectManipulatorAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsObjectManipulatorAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectManipulatorAbstract::getPropTYPE",1,"gsObjectManipulatorAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectManipulatorAbstract,0))){
    SWIG_fail_ptr("gsObjectManipulatorAbstract_getPropTYPE",1,SWIGTYPE_p_gsObjectManipulatorAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectManipulatorAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectManipulatorAbstract *arg1 = (gsObjectManipulatorAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsObjectManipulatorAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectManipulatorAbstract::setPropTYPE",1,"gsObjectManipulatorAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsObjectManipulatorAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectManipulatorAbstract,0))){
    SWIG_fail_ptr("gsObjectManipulatorAbstract_setPropTYPE",1,SWIGTYPE_p_gsObjectManipulatorAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsObjectManipulatorAbstract(void *obj) {
gsObjectManipulatorAbstract *arg1 = (gsObjectManipulatorAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsObjectManipulatorAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsObjectManipulatorAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsObjectManipulatorAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsObjectManipulatorAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsObjectManipulatorAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsObjectManipulatorAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsObjectManipulatorAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsObjectManipulatorAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsObjectManipulatorAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsObjectManipulatorAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsObjectManipulatorAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsObjectManipulatorAbstract_Sf_SwigStatic = {
    "gsObjectManipulatorAbstract",
    swig_gsObjectManipulatorAbstract_Sf_SwigStatic_methods,
    swig_gsObjectManipulatorAbstract_Sf_SwigStatic_attributes,
    swig_gsObjectManipulatorAbstract_Sf_SwigStatic_constants,
    swig_gsObjectManipulatorAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsObjectManipulatorAbstract_bases[] = {0,0};
static const char *swig_gsObjectManipulatorAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsObjectManipulatorAbstract = { "gsObjectManipulatorAbstract", "gsObjectManipulatorAbstract", &SWIGTYPE_p_gsObjectManipulatorAbstract,_proxy__wrap_new_gsObjectManipulatorAbstract, swig_delete_gsObjectManipulatorAbstract, swig_gsObjectManipulatorAbstract_methods, swig_gsObjectManipulatorAbstract_attributes, &swig_gsObjectManipulatorAbstract_Sf_SwigStatic, swig_gsObjectManipulatorAbstract_meta, swig_gsObjectManipulatorAbstract_bases, swig_gsObjectManipulatorAbstract_base_names };

static int _wrap_new_gsCharacterNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkCharacterNodeAbstract *arg1 = (gkCharacterNodeAbstract *) 0 ;
  gsCharacterNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsCharacterNodeAbstract::gsCharacterNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacterNodeAbstract::gsCharacterNodeAbstract",1,"gkCharacterNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCharacterNodeAbstract,0))){
    SWIG_fail_ptr("new_gsCharacterNodeAbstract",1,SWIGTYPE_p_gkCharacterNodeAbstract);
  }
  
  result = (gsCharacterNodeAbstract *)new gsCharacterNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCharacterNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsCharacterNodeAbstract(void *obj) {
gsCharacterNodeAbstract *arg1 = (gsCharacterNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsCharacterNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsCharacterNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsCharacterNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsCharacterNodeAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsCharacterNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsCharacterNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsCharacterNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsCharacterNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsCharacterNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsCharacterNodeAbstract_Sf_SwigStatic = {
    "gsCharacterNodeAbstract",
    swig_gsCharacterNodeAbstract_Sf_SwigStatic_methods,
    swig_gsCharacterNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsCharacterNodeAbstract_Sf_SwigStatic_constants,
    swig_gsCharacterNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsCharacterNodeAbstract_bases[] = {0,0};
static const char *swig_gsCharacterNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsCharacterNodeAbstract = { "gsCharacterNodeAbstract", "gsCharacterNodeAbstract", &SWIGTYPE_p_gsCharacterNodeAbstract,_proxy__wrap_new_gsCharacterNodeAbstract, swig_delete_gsCharacterNodeAbstract, swig_gsCharacterNodeAbstract_methods, swig_gsCharacterNodeAbstract_attributes, &swig_gsCharacterNodeAbstract_Sf_SwigStatic, swig_gsCharacterNodeAbstract_meta, swig_gsCharacterNodeAbstract_bases, swig_gsCharacterNodeAbstract_base_names };

static int _wrap_new_gsSequenceAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkSequenceAbstract *arg1 = (gkSequenceAbstract *) 0 ;
  gsSequenceAbstract *result = 0 ;
  
  SWIG_check_num_args("gsSequenceAbstract::gsSequenceAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSequenceAbstract::gsSequenceAbstract",1,"gkSequenceAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSequenceAbstract,0))){
    SWIG_fail_ptr("new_gsSequenceAbstract",1,SWIGTYPE_p_gkSequenceAbstract);
  }
  
  result = (gsSequenceAbstract *)new gsSequenceAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSequenceAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSequenceAbstract(void *obj) {
gsSequenceAbstract *arg1 = (gsSequenceAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSequenceAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSequenceAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSequenceAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSequenceAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsSequenceAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSequenceAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSequenceAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSequenceAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSequenceAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSequenceAbstract_Sf_SwigStatic = {
    "gsSequenceAbstract",
    swig_gsSequenceAbstract_Sf_SwigStatic_methods,
    swig_gsSequenceAbstract_Sf_SwigStatic_attributes,
    swig_gsSequenceAbstract_Sf_SwigStatic_constants,
    swig_gsSequenceAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSequenceAbstract_bases[] = {0,0};
static const char *swig_gsSequenceAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsSequenceAbstract = { "gsSequenceAbstract", "gsSequenceAbstract", &SWIGTYPE_p_gsSequenceAbstract,_proxy__wrap_new_gsSequenceAbstract, swig_delete_gsSequenceAbstract, swig_gsSequenceAbstract_methods, swig_gsSequenceAbstract_attributes, &swig_gsSequenceAbstract_Sf_SwigStatic, swig_gsSequenceAbstract_meta, swig_gsSequenceAbstract_bases, swig_gsSequenceAbstract_base_names };

static int _wrap_new_gsSeqFinishedAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkSeqFinishedAbstract *arg1 = (gkSeqFinishedAbstract *) 0 ;
  gsSeqFinishedAbstract *result = 0 ;
  
  SWIG_check_num_args("gsSeqFinishedAbstract::gsSeqFinishedAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqFinishedAbstract::gsSeqFinishedAbstract",1,"gkSeqFinishedAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSeqFinishedAbstract,0))){
    SWIG_fail_ptr("new_gsSeqFinishedAbstract",1,SWIGTYPE_p_gkSeqFinishedAbstract);
  }
  
  result = (gsSeqFinishedAbstract *)new gsSeqFinishedAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSeqFinishedAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSeqFinishedAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsSeqFinishedAbstract *arg1 = (gsSeqFinishedAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsSeqFinishedAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqFinishedAbstract::getPropTYPE",1,"gsSeqFinishedAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSeqFinishedAbstract,0))){
    SWIG_fail_ptr("gsSeqFinishedAbstract_getPropTYPE",1,SWIGTYPE_p_gsSeqFinishedAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSeqFinishedAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsSeqFinishedAbstract *arg1 = (gsSeqFinishedAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsSeqFinishedAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqFinishedAbstract::setPropTYPE",1,"gsSeqFinishedAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSeqFinishedAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSeqFinishedAbstract,0))){
    SWIG_fail_ptr("gsSeqFinishedAbstract_setPropTYPE",1,SWIGTYPE_p_gsSeqFinishedAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSeqFinishedAbstract(void *obj) {
gsSeqFinishedAbstract *arg1 = (gsSeqFinishedAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSeqFinishedAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSeqFinishedAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSeqFinishedAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSeqFinishedAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsSeqFinishedAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsSeqFinishedAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsSeqFinishedAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSeqFinishedAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSeqFinishedAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSeqFinishedAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSeqFinishedAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSeqFinishedAbstract_Sf_SwigStatic = {
    "gsSeqFinishedAbstract",
    swig_gsSeqFinishedAbstract_Sf_SwigStatic_methods,
    swig_gsSeqFinishedAbstract_Sf_SwigStatic_attributes,
    swig_gsSeqFinishedAbstract_Sf_SwigStatic_constants,
    swig_gsSeqFinishedAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSeqFinishedAbstract_bases[] = {0,0};
static const char *swig_gsSeqFinishedAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsSeqFinishedAbstract = { "gsSeqFinishedAbstract", "gsSeqFinishedAbstract", &SWIGTYPE_p_gsSeqFinishedAbstract,_proxy__wrap_new_gsSeqFinishedAbstract, swig_delete_gsSeqFinishedAbstract, swig_gsSeqFinishedAbstract_methods, swig_gsSeqFinishedAbstract_attributes, &swig_gsSeqFinishedAbstract_Sf_SwigStatic, swig_gsSeqFinishedAbstract_meta, swig_gsSeqFinishedAbstract_bases, swig_gsSeqFinishedAbstract_base_names };

static int _wrap_new_gsSeqTimeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkSeqTimeAbstract *arg1 = (gkSeqTimeAbstract *) 0 ;
  gsSeqTimeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsSeqTimeAbstract::gsSeqTimeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqTimeAbstract::gsSeqTimeAbstract",1,"gkSeqTimeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSeqTimeAbstract,0))){
    SWIG_fail_ptr("new_gsSeqTimeAbstract",1,SWIGTYPE_p_gkSeqTimeAbstract);
  }
  
  result = (gsSeqTimeAbstract *)new gsSeqTimeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSeqTimeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSeqTimeAbstract_getPropWAIT(lua_State* L) {
  int SWIG_arg = 0;
  gsSeqTimeAbstract *arg1 = (gsSeqTimeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSeqTimeAbstract::getPropWAIT",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqTimeAbstract::getPropWAIT",1,"gsSeqTimeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSeqTimeAbstract,0))){
    SWIG_fail_ptr("gsSeqTimeAbstract_getPropWAIT",1,SWIGTYPE_p_gsSeqTimeAbstract);
  }
  
  result = (float)(arg1)->getPropWAIT();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSeqTimeAbstract_setPropWAIT(lua_State* L) {
  int SWIG_arg = 0;
  gsSeqTimeAbstract *arg1 = (gsSeqTimeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSeqTimeAbstract::setPropWAIT",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSeqTimeAbstract::setPropWAIT",1,"gsSeqTimeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSeqTimeAbstract::setPropWAIT",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSeqTimeAbstract,0))){
    SWIG_fail_ptr("gsSeqTimeAbstract_setPropWAIT",1,SWIGTYPE_p_gsSeqTimeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropWAIT(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSeqTimeAbstract(void *obj) {
gsSeqTimeAbstract *arg1 = (gsSeqTimeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSeqTimeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSeqTimeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSeqTimeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSeqTimeAbstract_methods[]= {
    { "getPropWAIT", _wrap_gsSeqTimeAbstract_getPropWAIT},
    { "setPropWAIT", _wrap_gsSeqTimeAbstract_setPropWAIT},
    {0,0}
};
static swig_lua_method swig_gsSeqTimeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSeqTimeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSeqTimeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSeqTimeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSeqTimeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSeqTimeAbstract_Sf_SwigStatic = {
    "gsSeqTimeAbstract",
    swig_gsSeqTimeAbstract_Sf_SwigStatic_methods,
    swig_gsSeqTimeAbstract_Sf_SwigStatic_attributes,
    swig_gsSeqTimeAbstract_Sf_SwigStatic_constants,
    swig_gsSeqTimeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSeqTimeAbstract_bases[] = {0,0};
static const char *swig_gsSeqTimeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsSeqTimeAbstract = { "gsSeqTimeAbstract", "gsSeqTimeAbstract", &SWIGTYPE_p_gsSeqTimeAbstract,_proxy__wrap_new_gsSeqTimeAbstract, swig_delete_gsSeqTimeAbstract, swig_gsSeqTimeAbstract_methods, swig_gsSeqTimeAbstract_attributes, &swig_gsSeqTimeAbstract_Sf_SwigStatic, swig_gsSeqTimeAbstract_meta, swig_gsSeqTimeAbstract_bases, swig_gsSeqTimeAbstract_base_names };

static int _wrap_new_gsMotionNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMotionNodeAbstract *arg1 = (gkMotionNodeAbstract *) 0 ;
  gsMotionNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMotionNodeAbstract::gsMotionNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::gsMotionNodeAbstract",1,"gkMotionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMotionNodeAbstract,0))){
    SWIG_fail_ptr("new_gsMotionNodeAbstract",1,SWIGTYPE_p_gkMotionNodeAbstract);
  }
  
  result = (gsMotionNodeAbstract *)new gsMotionNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMotionNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_getPropMotion(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMotionNodeAbstract::getPropMotion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::getPropMotion",1,"gsMotionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_getPropMotion",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  result = (int)(arg1)->getPropMotion();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_setPropMotion(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMotionNodeAbstract::setPropMotion",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMotion",1,"gsMotionNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMotion",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropMotion",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMotion(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_getPropSpace(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMotionNodeAbstract::getPropSpace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::getPropSpace",1,"gsMotionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_getPropSpace",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  result = (int)(arg1)->getPropSpace();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_setPropSpace(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMotionNodeAbstract::setPropSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::setPropSpace",1,"gsMotionNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMotionNodeAbstract::setPropSpace",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropSpace",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropSpace(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_getPropMaxVec(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  gkVector3 result;
  
  SWIG_check_num_args("gsMotionNodeAbstract::getPropMaxVec",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::getPropMaxVec",1,"gsMotionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_getPropMaxVec",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  result = (arg1)->getPropMaxVec();
  {
    gkVector3 * resultptr = new gkVector3((const gkVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_setPropMaxVec(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  gkVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionNodeAbstract::setPropMaxVec",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMaxVec",1,"gsMotionNodeAbstract *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMaxVec",2,"gkVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropMaxVec",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropMaxVec",2,SWIGTYPE_p_gkVector3);
  }
  
  (arg1)->setPropMaxVec((gkVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_getPropMinVec(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  gkVector3 result;
  
  SWIG_check_num_args("gsMotionNodeAbstract::getPropMinVec",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::getPropMinVec",1,"gsMotionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_getPropMinVec",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  result = (arg1)->getPropMinVec();
  {
    gkVector3 * resultptr = new gkVector3((const gkVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMotionNodeAbstract_setPropMinVec(lua_State* L) {
  int SWIG_arg = 0;
  gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) 0 ;
  gkVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsMotionNodeAbstract::setPropMinVec",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMinVec",1,"gsMotionNodeAbstract *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsMotionNodeAbstract::setPropMinVec",2,"gkVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMotionNodeAbstract,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropMinVec",1,SWIGTYPE_p_gsMotionNodeAbstract);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gsMotionNodeAbstract_setPropMinVec",2,SWIGTYPE_p_gkVector3);
  }
  
  (arg1)->setPropMinVec((gkVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMotionNodeAbstract(void *obj) {
gsMotionNodeAbstract *arg1 = (gsMotionNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMotionNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMotionNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMotionNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMotionNodeAbstract_methods[]= {
    { "getPropMotion", _wrap_gsMotionNodeAbstract_getPropMotion},
    { "setPropMotion", _wrap_gsMotionNodeAbstract_setPropMotion},
    { "getPropSpace", _wrap_gsMotionNodeAbstract_getPropSpace},
    { "setPropSpace", _wrap_gsMotionNodeAbstract_setPropSpace},
    { "getPropMaxVec", _wrap_gsMotionNodeAbstract_getPropMaxVec},
    { "setPropMaxVec", _wrap_gsMotionNodeAbstract_setPropMaxVec},
    { "getPropMinVec", _wrap_gsMotionNodeAbstract_getPropMinVec},
    { "setPropMinVec", _wrap_gsMotionNodeAbstract_setPropMinVec},
    {0,0}
};
static swig_lua_method swig_gsMotionNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMotionNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMotionNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMotionNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMotionNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMotionNodeAbstract_Sf_SwigStatic = {
    "gsMotionNodeAbstract",
    swig_gsMotionNodeAbstract_Sf_SwigStatic_methods,
    swig_gsMotionNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsMotionNodeAbstract_Sf_SwigStatic_constants,
    swig_gsMotionNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMotionNodeAbstract_bases[] = {0,0};
static const char *swig_gsMotionNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMotionNodeAbstract = { "gsMotionNodeAbstract", "gsMotionNodeAbstract", &SWIGTYPE_p_gsMotionNodeAbstract,_proxy__wrap_new_gsMotionNodeAbstract, swig_delete_gsMotionNodeAbstract, swig_gsMotionNodeAbstract_methods, swig_gsMotionNodeAbstract_attributes, &swig_gsMotionNodeAbstract_Sf_SwigStatic, swig_gsMotionNodeAbstract_meta, swig_gsMotionNodeAbstract_bases, swig_gsMotionNodeAbstract_base_names };

static int _wrap_new_gsMouseNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMouseNodeAbstract *arg1 = (gkMouseNodeAbstract *) 0 ;
  gsMouseNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMouseNodeAbstract::gsMouseNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseNodeAbstract::gsMouseNodeAbstract",1,"gkMouseNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMouseNodeAbstract,0))){
    SWIG_fail_ptr("new_gsMouseNodeAbstract",1,SWIGTYPE_p_gkMouseNodeAbstract);
  }
  
  result = (gsMouseNodeAbstract *)new gsMouseNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouseNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMouseNodeAbstract(void *obj) {
gsMouseNodeAbstract *arg1 = (gsMouseNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMouseNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMouseNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMouseNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMouseNodeAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsMouseNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMouseNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMouseNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMouseNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMouseNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMouseNodeAbstract_Sf_SwigStatic = {
    "gsMouseNodeAbstract",
    swig_gsMouseNodeAbstract_Sf_SwigStatic_methods,
    swig_gsMouseNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsMouseNodeAbstract_Sf_SwigStatic_constants,
    swig_gsMouseNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMouseNodeAbstract_bases[] = {0,0};
static const char *swig_gsMouseNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMouseNodeAbstract = { "gsMouseNodeAbstract", "gsMouseNodeAbstract", &SWIGTYPE_p_gsMouseNodeAbstract,_proxy__wrap_new_gsMouseNodeAbstract, swig_delete_gsMouseNodeAbstract, swig_gsMouseNodeAbstract_methods, swig_gsMouseNodeAbstract_attributes, &swig_gsMouseNodeAbstract_Sf_SwigStatic, swig_gsMouseNodeAbstract_meta, swig_gsMouseNodeAbstract_bases, swig_gsMouseNodeAbstract_base_names };

static int _wrap_new_gsBoolNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkBoolNodeAbstract *arg1 = (gkBoolNodeAbstract *) 0 ;
  gsBoolNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsBoolNodeAbstract::gsBoolNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBoolNodeAbstract::gsBoolNodeAbstract",1,"gkBoolNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkBoolNodeAbstract,0))){
    SWIG_fail_ptr("new_gsBoolNodeAbstract",1,SWIGTYPE_p_gkBoolNodeAbstract);
  }
  
  result = (gsBoolNodeAbstract *)new gsBoolNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsBoolNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsBoolNodeAbstract_getPropOperation(lua_State* L) {
  int SWIG_arg = 0;
  gsBoolNodeAbstract *arg1 = (gsBoolNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsBoolNodeAbstract::getPropOperation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBoolNodeAbstract::getPropOperation",1,"gsBoolNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBoolNodeAbstract,0))){
    SWIG_fail_ptr("gsBoolNodeAbstract_getPropOperation",1,SWIGTYPE_p_gsBoolNodeAbstract);
  }
  
  result = (int)(arg1)->getPropOperation();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsBoolNodeAbstract_setPropOperation(lua_State* L) {
  int SWIG_arg = 0;
  gsBoolNodeAbstract *arg1 = (gsBoolNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsBoolNodeAbstract::setPropOperation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsBoolNodeAbstract::setPropOperation",1,"gsBoolNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsBoolNodeAbstract::setPropOperation",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsBoolNodeAbstract,0))){
    SWIG_fail_ptr("gsBoolNodeAbstract_setPropOperation",1,SWIGTYPE_p_gsBoolNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropOperation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsBoolNodeAbstract(void *obj) {
gsBoolNodeAbstract *arg1 = (gsBoolNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsBoolNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsBoolNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsBoolNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsBoolNodeAbstract_methods[]= {
    { "getPropOperation", _wrap_gsBoolNodeAbstract_getPropOperation},
    { "setPropOperation", _wrap_gsBoolNodeAbstract_setPropOperation},
    {0,0}
};
static swig_lua_method swig_gsBoolNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsBoolNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsBoolNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsBoolNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsBoolNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsBoolNodeAbstract_Sf_SwigStatic = {
    "gsBoolNodeAbstract",
    swig_gsBoolNodeAbstract_Sf_SwigStatic_methods,
    swig_gsBoolNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsBoolNodeAbstract_Sf_SwigStatic_constants,
    swig_gsBoolNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsBoolNodeAbstract_bases[] = {0,0};
static const char *swig_gsBoolNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsBoolNodeAbstract = { "gsBoolNodeAbstract", "gsBoolNodeAbstract", &SWIGTYPE_p_gsBoolNodeAbstract,_proxy__wrap_new_gsBoolNodeAbstract, swig_delete_gsBoolNodeAbstract, swig_gsBoolNodeAbstract_methods, swig_gsBoolNodeAbstract_attributes, &swig_gsBoolNodeAbstract_Sf_SwigStatic, swig_gsBoolNodeAbstract_meta, swig_gsBoolNodeAbstract_bases, swig_gsBoolNodeAbstract_base_names };

static int _wrap_new_gsMathNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMathNodeAbstract *arg1 = (gkMathNodeAbstract *) 0 ;
  gsMathNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMathNodeAbstract::gsMathNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMathNodeAbstract::gsMathNodeAbstract",1,"gkMathNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMathNodeAbstract,0))){
    SWIG_fail_ptr("new_gsMathNodeAbstract",1,SWIGTYPE_p_gkMathNodeAbstract);
  }
  
  result = (gsMathNodeAbstract *)new gsMathNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMathNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMathNodeAbstract_getPropOperation(lua_State* L) {
  int SWIG_arg = 0;
  gsMathNodeAbstract *arg1 = (gsMathNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMathNodeAbstract::getPropOperation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMathNodeAbstract::getPropOperation",1,"gsMathNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMathNodeAbstract,0))){
    SWIG_fail_ptr("gsMathNodeAbstract_getPropOperation",1,SWIGTYPE_p_gsMathNodeAbstract);
  }
  
  result = (int)(arg1)->getPropOperation();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMathNodeAbstract_setPropOperation(lua_State* L) {
  int SWIG_arg = 0;
  gsMathNodeAbstract *arg1 = (gsMathNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMathNodeAbstract::setPropOperation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMathNodeAbstract::setPropOperation",1,"gsMathNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMathNodeAbstract::setPropOperation",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMathNodeAbstract,0))){
    SWIG_fail_ptr("gsMathNodeAbstract_setPropOperation",1,SWIGTYPE_p_gsMathNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropOperation(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMathNodeAbstract(void *obj) {
gsMathNodeAbstract *arg1 = (gsMathNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMathNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMathNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMathNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMathNodeAbstract_methods[]= {
    { "getPropOperation", _wrap_gsMathNodeAbstract_getPropOperation},
    { "setPropOperation", _wrap_gsMathNodeAbstract_setPropOperation},
    {0,0}
};
static swig_lua_method swig_gsMathNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMathNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMathNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMathNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMathNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMathNodeAbstract_Sf_SwigStatic = {
    "gsMathNodeAbstract",
    swig_gsMathNodeAbstract_Sf_SwigStatic_methods,
    swig_gsMathNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsMathNodeAbstract_Sf_SwigStatic_constants,
    swig_gsMathNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMathNodeAbstract_bases[] = {0,0};
static const char *swig_gsMathNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMathNodeAbstract = { "gsMathNodeAbstract", "gsMathNodeAbstract", &SWIGTYPE_p_gsMathNodeAbstract,_proxy__wrap_new_gsMathNodeAbstract, swig_delete_gsMathNodeAbstract, swig_gsMathNodeAbstract_methods, swig_gsMathNodeAbstract_attributes, &swig_gsMathNodeAbstract_Sf_SwigStatic, swig_gsMathNodeAbstract_meta, swig_gsMathNodeAbstract_bases, swig_gsMathNodeAbstract_base_names };

static int _wrap_new_gsTimerNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTimerNodeAbstract *arg1 = (gkTimerNodeAbstract *) 0 ;
  gsTimerNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTimerNodeAbstract::gsTimerNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTimerNodeAbstract::gsTimerNodeAbstract",1,"gkTimerNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTimerNodeAbstract,0))){
    SWIG_fail_ptr("new_gsTimerNodeAbstract",1,SWIGTYPE_p_gkTimerNodeAbstract);
  }
  
  result = (gsTimerNodeAbstract *)new gsTimerNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTimerNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTimerNodeAbstract_getPropORDER(lua_State* L) {
  int SWIG_arg = 0;
  gsTimerNodeAbstract *arg1 = (gsTimerNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsTimerNodeAbstract::getPropORDER",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTimerNodeAbstract::getPropORDER",1,"gsTimerNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTimerNodeAbstract,0))){
    SWIG_fail_ptr("gsTimerNodeAbstract_getPropORDER",1,SWIGTYPE_p_gsTimerNodeAbstract);
  }
  
  result = (int)(arg1)->getPropORDER();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTimerNodeAbstract_setPropORDER(lua_State* L) {
  int SWIG_arg = 0;
  gsTimerNodeAbstract *arg1 = (gsTimerNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsTimerNodeAbstract::setPropORDER",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTimerNodeAbstract::setPropORDER",1,"gsTimerNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTimerNodeAbstract::setPropORDER",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTimerNodeAbstract,0))){
    SWIG_fail_ptr("gsTimerNodeAbstract_setPropORDER",1,SWIGTYPE_p_gsTimerNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropORDER(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTimerNodeAbstract(void *obj) {
gsTimerNodeAbstract *arg1 = (gsTimerNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTimerNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTimerNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTimerNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTimerNodeAbstract_methods[]= {
    { "getPropORDER", _wrap_gsTimerNodeAbstract_getPropORDER},
    { "setPropORDER", _wrap_gsTimerNodeAbstract_setPropORDER},
    {0,0}
};
static swig_lua_method swig_gsTimerNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTimerNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTimerNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTimerNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTimerNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTimerNodeAbstract_Sf_SwigStatic = {
    "gsTimerNodeAbstract",
    swig_gsTimerNodeAbstract_Sf_SwigStatic_methods,
    swig_gsTimerNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsTimerNodeAbstract_Sf_SwigStatic_constants,
    swig_gsTimerNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTimerNodeAbstract_bases[] = {0,0};
static const char *swig_gsTimerNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTimerNodeAbstract = { "gsTimerNodeAbstract", "gsTimerNodeAbstract", &SWIGTYPE_p_gsTimerNodeAbstract,_proxy__wrap_new_gsTimerNodeAbstract, swig_delete_gsTimerNodeAbstract, swig_gsTimerNodeAbstract_methods, swig_gsTimerNodeAbstract_attributes, &swig_gsTimerNodeAbstract_Sf_SwigStatic, swig_gsTimerNodeAbstract_meta, swig_gsTimerNodeAbstract_bases, swig_gsTimerNodeAbstract_base_names };

static int _wrap_new_gsObjectNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkObjectNodeAbstract *arg1 = (gkObjectNodeAbstract *) 0 ;
  gsObjectNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsObjectNodeAbstract::gsObjectNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectNodeAbstract::gsObjectNodeAbstract",1,"gkObjectNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkObjectNodeAbstract,0))){
    SWIG_fail_ptr("new_gsObjectNodeAbstract",1,SWIGTYPE_p_gkObjectNodeAbstract);
  }
  
  result = (gsObjectNodeAbstract *)new gsObjectNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsObjectNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectNodeAbstract_getPropObj(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectNodeAbstract *arg1 = (gsObjectNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsObjectNodeAbstract::getPropObj",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectNodeAbstract::getPropObj",1,"gsObjectNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectNodeAbstract,0))){
    SWIG_fail_ptr("gsObjectNodeAbstract_getPropObj",1,SWIGTYPE_p_gsObjectNodeAbstract);
  }
  
  result = (arg1)->getPropObj();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectNodeAbstract_setPropObj(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectNodeAbstract *arg1 = (gsObjectNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsObjectNodeAbstract::setPropObj",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectNodeAbstract::setPropObj",1,"gsObjectNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsObjectNodeAbstract::setPropObj",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectNodeAbstract,0))){
    SWIG_fail_ptr("gsObjectNodeAbstract_setPropObj",1,SWIGTYPE_p_gsObjectNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropObj((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectNodeAbstract_getPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectNodeAbstract *arg1 = (gsObjectNodeAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsObjectNodeAbstract::getPropGLOBAL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectNodeAbstract::getPropGLOBAL",1,"gsObjectNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectNodeAbstract,0))){
    SWIG_fail_ptr("gsObjectNodeAbstract_getPropGLOBAL",1,SWIGTYPE_p_gsObjectNodeAbstract);
  }
  
  result = (bool)(arg1)->getPropGLOBAL();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsObjectNodeAbstract_setPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsObjectNodeAbstract *arg1 = (gsObjectNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsObjectNodeAbstract::setPropGLOBAL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectNodeAbstract::setPropGLOBAL",1,"gsObjectNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsObjectNodeAbstract::setPropGLOBAL",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsObjectNodeAbstract,0))){
    SWIG_fail_ptr("gsObjectNodeAbstract_setPropGLOBAL",1,SWIGTYPE_p_gsObjectNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropGLOBAL(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsObjectNodeAbstract(void *obj) {
gsObjectNodeAbstract *arg1 = (gsObjectNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsObjectNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsObjectNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsObjectNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsObjectNodeAbstract_methods[]= {
    { "getPropObj", _wrap_gsObjectNodeAbstract_getPropObj},
    { "setPropObj", _wrap_gsObjectNodeAbstract_setPropObj},
    { "getPropGLOBAL", _wrap_gsObjectNodeAbstract_getPropGLOBAL},
    { "setPropGLOBAL", _wrap_gsObjectNodeAbstract_setPropGLOBAL},
    {0,0}
};
static swig_lua_method swig_gsObjectNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsObjectNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsObjectNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsObjectNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsObjectNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsObjectNodeAbstract_Sf_SwigStatic = {
    "gsObjectNodeAbstract",
    swig_gsObjectNodeAbstract_Sf_SwigStatic_methods,
    swig_gsObjectNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsObjectNodeAbstract_Sf_SwigStatic_constants,
    swig_gsObjectNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsObjectNodeAbstract_bases[] = {0,0};
static const char *swig_gsObjectNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsObjectNodeAbstract = { "gsObjectNodeAbstract", "gsObjectNodeAbstract", &SWIGTYPE_p_gsObjectNodeAbstract,_proxy__wrap_new_gsObjectNodeAbstract, swig_delete_gsObjectNodeAbstract, swig_gsObjectNodeAbstract_methods, swig_gsObjectNodeAbstract_attributes, &swig_gsObjectNodeAbstract_Sf_SwigStatic, swig_gsObjectNodeAbstract_meta, swig_gsObjectNodeAbstract_bases, swig_gsObjectNodeAbstract_base_names };

static int _wrap_new_gsObjectDataAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkObjectDataAbstract *arg1 = (gkObjectDataAbstract *) 0 ;
  gsObjectDataAbstract *result = 0 ;
  
  SWIG_check_num_args("gsObjectDataAbstract::gsObjectDataAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsObjectDataAbstract::gsObjectDataAbstract",1,"gkObjectDataAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkObjectDataAbstract,0))){
    SWIG_fail_ptr("new_gsObjectDataAbstract",1,SWIGTYPE_p_gkObjectDataAbstract);
  }
  
  result = (gsObjectDataAbstract *)new gsObjectDataAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsObjectDataAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsObjectDataAbstract(void *obj) {
gsObjectDataAbstract *arg1 = (gsObjectDataAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsObjectDataAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsObjectDataAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsObjectDataAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsObjectDataAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsObjectDataAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsObjectDataAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsObjectDataAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsObjectDataAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsObjectDataAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsObjectDataAbstract_Sf_SwigStatic = {
    "gsObjectDataAbstract",
    swig_gsObjectDataAbstract_Sf_SwigStatic_methods,
    swig_gsObjectDataAbstract_Sf_SwigStatic_attributes,
    swig_gsObjectDataAbstract_Sf_SwigStatic_constants,
    swig_gsObjectDataAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsObjectDataAbstract_bases[] = {0,0};
static const char *swig_gsObjectDataAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsObjectDataAbstract = { "gsObjectDataAbstract", "gsObjectDataAbstract", &SWIGTYPE_p_gsObjectDataAbstract,_proxy__wrap_new_gsObjectDataAbstract, swig_delete_gsObjectDataAbstract, swig_gsObjectDataAbstract_methods, swig_gsObjectDataAbstract_attributes, &swig_gsObjectDataAbstract_Sf_SwigStatic, swig_gsObjectDataAbstract_meta, swig_gsObjectDataAbstract_bases, swig_gsObjectDataAbstract_base_names };

static int _wrap_new_gsAccelerometerAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkAccelerometerAbstract *arg1 = (gkAccelerometerAbstract *) 0 ;
  gsAccelerometerAbstract *result = 0 ;
  
  SWIG_check_num_args("gsAccelerometerAbstract::gsAccelerometerAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAccelerometerAbstract::gsAccelerometerAbstract",1,"gkAccelerometerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAccelerometerAbstract,0))){
    SWIG_fail_ptr("new_gsAccelerometerAbstract",1,SWIGTYPE_p_gkAccelerometerAbstract);
  }
  
  result = (gsAccelerometerAbstract *)new gsAccelerometerAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAccelerometerAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAccelerometerAbstract(void *obj) {
gsAccelerometerAbstract *arg1 = (gsAccelerometerAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAccelerometerAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAccelerometerAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAccelerometerAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAccelerometerAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsAccelerometerAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAccelerometerAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAccelerometerAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAccelerometerAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAccelerometerAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAccelerometerAbstract_Sf_SwigStatic = {
    "gsAccelerometerAbstract",
    swig_gsAccelerometerAbstract_Sf_SwigStatic_methods,
    swig_gsAccelerometerAbstract_Sf_SwigStatic_attributes,
    swig_gsAccelerometerAbstract_Sf_SwigStatic_constants,
    swig_gsAccelerometerAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAccelerometerAbstract_bases[] = {0,0};
static const char *swig_gsAccelerometerAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsAccelerometerAbstract = { "gsAccelerometerAbstract", "gsAccelerometerAbstract", &SWIGTYPE_p_gsAccelerometerAbstract,_proxy__wrap_new_gsAccelerometerAbstract, swig_delete_gsAccelerometerAbstract, swig_gsAccelerometerAbstract_methods, swig_gsAccelerometerAbstract_attributes, &swig_gsAccelerometerAbstract_Sf_SwigStatic, swig_gsAccelerometerAbstract_meta, swig_gsAccelerometerAbstract_bases, swig_gsAccelerometerAbstract_base_names };

static int _wrap_new_gsVectorDecompAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkVectorDecompAbstract *arg1 = (gkVectorDecompAbstract *) 0 ;
  gsVectorDecompAbstract *result = 0 ;
  
  SWIG_check_num_args("gsVectorDecompAbstract::gsVectorDecompAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVectorDecompAbstract::gsVectorDecompAbstract",1,"gkVectorDecompAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVectorDecompAbstract,0))){
    SWIG_fail_ptr("new_gsVectorDecompAbstract",1,SWIGTYPE_p_gkVectorDecompAbstract);
  }
  
  result = (gsVectorDecompAbstract *)new gsVectorDecompAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVectorDecompAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVectorDecompAbstract(void *obj) {
gsVectorDecompAbstract *arg1 = (gsVectorDecompAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVectorDecompAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVectorDecompAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVectorDecompAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVectorDecompAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsVectorDecompAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVectorDecompAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVectorDecompAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVectorDecompAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVectorDecompAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVectorDecompAbstract_Sf_SwigStatic = {
    "gsVectorDecompAbstract",
    swig_gsVectorDecompAbstract_Sf_SwigStatic_methods,
    swig_gsVectorDecompAbstract_Sf_SwigStatic_attributes,
    swig_gsVectorDecompAbstract_Sf_SwigStatic_constants,
    swig_gsVectorDecompAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVectorDecompAbstract_bases[] = {0,0};
static const char *swig_gsVectorDecompAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsVectorDecompAbstract = { "gsVectorDecompAbstract", "gsVectorDecompAbstract", &SWIGTYPE_p_gsVectorDecompAbstract,_proxy__wrap_new_gsVectorDecompAbstract, swig_delete_gsVectorDecompAbstract, swig_gsVectorDecompAbstract_methods, swig_gsVectorDecompAbstract_attributes, &swig_gsVectorDecompAbstract_Sf_SwigStatic, swig_gsVectorDecompAbstract_meta, swig_gsVectorDecompAbstract_bases, swig_gsVectorDecompAbstract_base_names };

static int _wrap_new_gsNodeTreeNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkNodeTreeNodeAbstract *arg1 = (gkNodeTreeNodeAbstract *) 0 ;
  gsNodeTreeNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsNodeTreeNodeAbstract::gsNodeTreeNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNodeTreeNodeAbstract::gsNodeTreeNodeAbstract",1,"gkNodeTreeNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkNodeTreeNodeAbstract,0))){
    SWIG_fail_ptr("new_gsNodeTreeNodeAbstract",1,SWIGTYPE_p_gkNodeTreeNodeAbstract);
  }
  
  result = (gsNodeTreeNodeAbstract *)new gsNodeTreeNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNodeTreeNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsNodeTreeNodeAbstract_getPropnodetree(lua_State* L) {
  int SWIG_arg = 0;
  gsNodeTreeNodeAbstract *arg1 = (gsNodeTreeNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsNodeTreeNodeAbstract::getPropnodetree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNodeTreeNodeAbstract::getPropnodetree",1,"gsNodeTreeNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNodeTreeNodeAbstract,0))){
    SWIG_fail_ptr("gsNodeTreeNodeAbstract_getPropnodetree",1,SWIGTYPE_p_gsNodeTreeNodeAbstract);
  }
  
  result = (arg1)->getPropnodetree();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsNodeTreeNodeAbstract_setPropnodetree(lua_State* L) {
  int SWIG_arg = 0;
  gsNodeTreeNodeAbstract *arg1 = (gsNodeTreeNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsNodeTreeNodeAbstract::setPropnodetree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNodeTreeNodeAbstract::setPropnodetree",1,"gsNodeTreeNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsNodeTreeNodeAbstract::setPropnodetree",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsNodeTreeNodeAbstract,0))){
    SWIG_fail_ptr("gsNodeTreeNodeAbstract_setPropnodetree",1,SWIGTYPE_p_gsNodeTreeNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropnodetree((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsNodeTreeNodeAbstract(void *obj) {
gsNodeTreeNodeAbstract *arg1 = (gsNodeTreeNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsNodeTreeNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsNodeTreeNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsNodeTreeNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsNodeTreeNodeAbstract_methods[]= {
    { "getPropnodetree", _wrap_gsNodeTreeNodeAbstract_getPropnodetree},
    { "setPropnodetree", _wrap_gsNodeTreeNodeAbstract_setPropnodetree},
    {0,0}
};
static swig_lua_method swig_gsNodeTreeNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsNodeTreeNodeAbstract_Sf_SwigStatic = {
    "gsNodeTreeNodeAbstract",
    swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_methods,
    swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_constants,
    swig_gsNodeTreeNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsNodeTreeNodeAbstract_bases[] = {0,0};
static const char *swig_gsNodeTreeNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsNodeTreeNodeAbstract = { "gsNodeTreeNodeAbstract", "gsNodeTreeNodeAbstract", &SWIGTYPE_p_gsNodeTreeNodeAbstract,_proxy__wrap_new_gsNodeTreeNodeAbstract, swig_delete_gsNodeTreeNodeAbstract, swig_gsNodeTreeNodeAbstract_methods, swig_gsNodeTreeNodeAbstract_attributes, &swig_gsNodeTreeNodeAbstract_Sf_SwigStatic, swig_gsNodeTreeNodeAbstract_meta, swig_gsNodeTreeNodeAbstract_bases, swig_gsNodeTreeNodeAbstract_base_names };

static int _wrap_new_gsStateMachineAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateMachineAbstract *arg1 = (gkStateMachineAbstract *) 0 ;
  gsStateMachineAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateMachineAbstract::gsStateMachineAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::gsStateMachineAbstract",1,"gkStateMachineAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateMachineAbstract,0))){
    SWIG_fail_ptr("new_gsStateMachineAbstract",1,SWIGTYPE_p_gkStateMachineAbstract);
  }
  
  result = (gsStateMachineAbstract *)new gsStateMachineAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateMachineAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateMachineAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::getPropNAME",1,"gsStateMachineAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_getPropNAME",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateMachineAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::setPropNAME",1,"gsStateMachineAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateMachineAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_setPropNAME",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_getPropINITIAL_STATE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateMachineAbstract::getPropINITIAL_STATE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::getPropINITIAL_STATE",1,"gsStateMachineAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_getPropINITIAL_STATE",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  result = (arg1)->getPropINITIAL_STATE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_setPropINITIAL_STATE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateMachineAbstract::setPropINITIAL_STATE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::setPropINITIAL_STATE",1,"gsStateMachineAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateMachineAbstract::setPropINITIAL_STATE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_setPropINITIAL_STATE",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropINITIAL_STATE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_getPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsStateMachineAbstract::getPropGLOBAL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::getPropGLOBAL",1,"gsStateMachineAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_getPropGLOBAL",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  result = (bool)(arg1)->getPropGLOBAL();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineAbstract_setPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateMachineAbstract::setPropGLOBAL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineAbstract::setPropGLOBAL",1,"gsStateMachineAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateMachineAbstract::setPropGLOBAL",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineAbstract,0))){
    SWIG_fail_ptr("gsStateMachineAbstract_setPropGLOBAL",1,SWIGTYPE_p_gsStateMachineAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropGLOBAL(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateMachineAbstract(void *obj) {
gsStateMachineAbstract *arg1 = (gsStateMachineAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateMachineAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateMachineAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateMachineAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateMachineAbstract_methods[]= {
    { "getPropNAME", _wrap_gsStateMachineAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsStateMachineAbstract_setPropNAME},
    { "getPropINITIAL_STATE", _wrap_gsStateMachineAbstract_getPropINITIAL_STATE},
    { "setPropINITIAL_STATE", _wrap_gsStateMachineAbstract_setPropINITIAL_STATE},
    { "getPropGLOBAL", _wrap_gsStateMachineAbstract_getPropGLOBAL},
    { "setPropGLOBAL", _wrap_gsStateMachineAbstract_setPropGLOBAL},
    {0,0}
};
static swig_lua_method swig_gsStateMachineAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateMachineAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateMachineAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateMachineAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateMachineAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateMachineAbstract_Sf_SwigStatic = {
    "gsStateMachineAbstract",
    swig_gsStateMachineAbstract_Sf_SwigStatic_methods,
    swig_gsStateMachineAbstract_Sf_SwigStatic_attributes,
    swig_gsStateMachineAbstract_Sf_SwigStatic_constants,
    swig_gsStateMachineAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateMachineAbstract_bases[] = {0,0};
static const char *swig_gsStateMachineAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateMachineAbstract = { "gsStateMachineAbstract", "gsStateMachineAbstract", &SWIGTYPE_p_gsStateMachineAbstract,_proxy__wrap_new_gsStateMachineAbstract, swig_delete_gsStateMachineAbstract, swig_gsStateMachineAbstract_methods, swig_gsStateMachineAbstract_attributes, &swig_gsStateMachineAbstract_Sf_SwigStatic, swig_gsStateMachineAbstract_meta, swig_gsStateMachineAbstract_bases, swig_gsStateMachineAbstract_base_names };

static int _wrap_new_gsStateAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateAbstract *arg1 = (gkStateAbstract *) 0 ;
  gsStateAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateAbstract::gsStateAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateAbstract::gsStateAbstract",1,"gkStateAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateAbstract,0))){
    SWIG_fail_ptr("new_gsStateAbstract",1,SWIGTYPE_p_gkStateAbstract);
  }
  
  result = (gsStateAbstract *)new gsStateAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsStateAbstract *arg1 = (gsStateAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateAbstract::getPropNAME",1,"gsStateAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateAbstract,0))){
    SWIG_fail_ptr("gsStateAbstract_getPropNAME",1,SWIGTYPE_p_gsStateAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsStateAbstract *arg1 = (gsStateAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateAbstract::setPropNAME",1,"gsStateAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateAbstract,0))){
    SWIG_fail_ptr("gsStateAbstract_setPropNAME",1,SWIGTYPE_p_gsStateAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateAbstract_getPropID(lua_State* L) {
  int SWIG_arg = 0;
  gsStateAbstract *arg1 = (gsStateAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateAbstract::getPropID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateAbstract::getPropID",1,"gsStateAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateAbstract,0))){
    SWIG_fail_ptr("gsStateAbstract_getPropID",1,SWIGTYPE_p_gsStateAbstract);
  }
  
  result = (int)(arg1)->getPropID();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateAbstract_setPropID(lua_State* L) {
  int SWIG_arg = 0;
  gsStateAbstract *arg1 = (gsStateAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateAbstract::setPropID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateAbstract::setPropID",1,"gsStateAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateAbstract::setPropID",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateAbstract,0))){
    SWIG_fail_ptr("gsStateAbstract_setPropID",1,SWIGTYPE_p_gsStateAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropID(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateAbstract(void *obj) {
gsStateAbstract *arg1 = (gsStateAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateAbstract_methods[]= {
    { "getPropNAME", _wrap_gsStateAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsStateAbstract_setPropNAME},
    { "getPropID", _wrap_gsStateAbstract_getPropID},
    { "setPropID", _wrap_gsStateAbstract_setPropID},
    {0,0}
};
static swig_lua_method swig_gsStateAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateAbstract_Sf_SwigStatic = {
    "gsStateAbstract",
    swig_gsStateAbstract_Sf_SwigStatic_methods,
    swig_gsStateAbstract_Sf_SwigStatic_attributes,
    swig_gsStateAbstract_Sf_SwigStatic_constants,
    swig_gsStateAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateAbstract_bases[] = {0,0};
static const char *swig_gsStateAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateAbstract = { "gsStateAbstract", "gsStateAbstract", &SWIGTYPE_p_gsStateAbstract,_proxy__wrap_new_gsStateAbstract, swig_delete_gsStateAbstract, swig_gsStateAbstract_methods, swig_gsStateAbstract_attributes, &swig_gsStateAbstract_Sf_SwigStatic, swig_gsStateAbstract_meta, swig_gsStateAbstract_bases, swig_gsStateAbstract_base_names };

static int _wrap_new_gsStateTransitionAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateTransitionAbstract *arg1 = (gkStateTransitionAbstract *) 0 ;
  gsStateTransitionAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateTransitionAbstract::gsStateTransitionAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateTransitionAbstract::gsStateTransitionAbstract",1,"gkStateTransitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateTransitionAbstract,0))){
    SWIG_fail_ptr("new_gsStateTransitionAbstract",1,SWIGTYPE_p_gkStateTransitionAbstract);
  }
  
  result = (gsStateTransitionAbstract *)new gsStateTransitionAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateTransitionAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateTransitionAbstract_getPropCOND_TYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateTransitionAbstract *arg1 = (gsStateTransitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateTransitionAbstract::getPropCOND_TYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateTransitionAbstract::getPropCOND_TYPE",1,"gsStateTransitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateTransitionAbstract,0))){
    SWIG_fail_ptr("gsStateTransitionAbstract_getPropCOND_TYPE",1,SWIGTYPE_p_gsStateTransitionAbstract);
  }
  
  result = (int)(arg1)->getPropCOND_TYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateTransitionAbstract_setPropCOND_TYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateTransitionAbstract *arg1 = (gsStateTransitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateTransitionAbstract::setPropCOND_TYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateTransitionAbstract::setPropCOND_TYPE",1,"gsStateTransitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateTransitionAbstract::setPropCOND_TYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateTransitionAbstract,0))){
    SWIG_fail_ptr("gsStateTransitionAbstract_setPropCOND_TYPE",1,SWIGTYPE_p_gsStateTransitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropCOND_TYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateTransitionAbstract_getPropWAIT(lua_State* L) {
  int SWIG_arg = 0;
  gsStateTransitionAbstract *arg1 = (gsStateTransitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateTransitionAbstract::getPropWAIT",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateTransitionAbstract::getPropWAIT",1,"gsStateTransitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateTransitionAbstract,0))){
    SWIG_fail_ptr("gsStateTransitionAbstract_getPropWAIT",1,SWIGTYPE_p_gsStateTransitionAbstract);
  }
  
  result = (int)(arg1)->getPropWAIT();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateTransitionAbstract_setPropWAIT(lua_State* L) {
  int SWIG_arg = 0;
  gsStateTransitionAbstract *arg1 = (gsStateTransitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateTransitionAbstract::setPropWAIT",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateTransitionAbstract::setPropWAIT",1,"gsStateTransitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateTransitionAbstract::setPropWAIT",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateTransitionAbstract,0))){
    SWIG_fail_ptr("gsStateTransitionAbstract_setPropWAIT",1,SWIGTYPE_p_gsStateTransitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropWAIT(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateTransitionAbstract(void *obj) {
gsStateTransitionAbstract *arg1 = (gsStateTransitionAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateTransitionAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateTransitionAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateTransitionAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateTransitionAbstract_methods[]= {
    { "getPropCOND_TYPE", _wrap_gsStateTransitionAbstract_getPropCOND_TYPE},
    { "setPropCOND_TYPE", _wrap_gsStateTransitionAbstract_setPropCOND_TYPE},
    { "getPropWAIT", _wrap_gsStateTransitionAbstract_getPropWAIT},
    { "setPropWAIT", _wrap_gsStateTransitionAbstract_setPropWAIT},
    {0,0}
};
static swig_lua_method swig_gsStateTransitionAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateTransitionAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateTransitionAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateTransitionAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateTransitionAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateTransitionAbstract_Sf_SwigStatic = {
    "gsStateTransitionAbstract",
    swig_gsStateTransitionAbstract_Sf_SwigStatic_methods,
    swig_gsStateTransitionAbstract_Sf_SwigStatic_attributes,
    swig_gsStateTransitionAbstract_Sf_SwigStatic_constants,
    swig_gsStateTransitionAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateTransitionAbstract_bases[] = {0,0};
static const char *swig_gsStateTransitionAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateTransitionAbstract = { "gsStateTransitionAbstract", "gsStateTransitionAbstract", &SWIGTYPE_p_gsStateTransitionAbstract,_proxy__wrap_new_gsStateTransitionAbstract, swig_delete_gsStateTransitionAbstract, swig_gsStateTransitionAbstract_methods, swig_gsStateTransitionAbstract_attributes, &swig_gsStateTransitionAbstract_Sf_SwigStatic, swig_gsStateTransitionAbstract_meta, swig_gsStateTransitionAbstract_bases, swig_gsStateTransitionAbstract_base_names };

static int _wrap_new_gsStateMachineRefAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateMachineRefAbstract *arg1 = (gkStateMachineRefAbstract *) 0 ;
  gsStateMachineRefAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateMachineRefAbstract::gsStateMachineRefAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineRefAbstract::gsStateMachineRefAbstract",1,"gkStateMachineRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateMachineRefAbstract,0))){
    SWIG_fail_ptr("new_gsStateMachineRefAbstract",1,SWIGTYPE_p_gkStateMachineRefAbstract);
  }
  
  result = (gsStateMachineRefAbstract *)new gsStateMachineRefAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateMachineRefAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineRefAbstract_getPropSTM(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineRefAbstract *arg1 = (gsStateMachineRefAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateMachineRefAbstract::getPropSTM",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineRefAbstract::getPropSTM",1,"gsStateMachineRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineRefAbstract,0))){
    SWIG_fail_ptr("gsStateMachineRefAbstract_getPropSTM",1,SWIGTYPE_p_gsStateMachineRefAbstract);
  }
  
  result = (arg1)->getPropSTM();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateMachineRefAbstract_setPropSTM(lua_State* L) {
  int SWIG_arg = 0;
  gsStateMachineRefAbstract *arg1 = (gsStateMachineRefAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateMachineRefAbstract::setPropSTM",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateMachineRefAbstract::setPropSTM",1,"gsStateMachineRefAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateMachineRefAbstract::setPropSTM",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateMachineRefAbstract,0))){
    SWIG_fail_ptr("gsStateMachineRefAbstract_setPropSTM",1,SWIGTYPE_p_gsStateMachineRefAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropSTM((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateMachineRefAbstract(void *obj) {
gsStateMachineRefAbstract *arg1 = (gsStateMachineRefAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateMachineRefAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateMachineRefAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateMachineRefAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateMachineRefAbstract_methods[]= {
    { "getPropSTM", _wrap_gsStateMachineRefAbstract_getPropSTM},
    { "setPropSTM", _wrap_gsStateMachineRefAbstract_setPropSTM},
    {0,0}
};
static swig_lua_method swig_gsStateMachineRefAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateMachineRefAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateMachineRefAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateMachineRefAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateMachineRefAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateMachineRefAbstract_Sf_SwigStatic = {
    "gsStateMachineRefAbstract",
    swig_gsStateMachineRefAbstract_Sf_SwigStatic_methods,
    swig_gsStateMachineRefAbstract_Sf_SwigStatic_attributes,
    swig_gsStateMachineRefAbstract_Sf_SwigStatic_constants,
    swig_gsStateMachineRefAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateMachineRefAbstract_bases[] = {0,0};
static const char *swig_gsStateMachineRefAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateMachineRefAbstract = { "gsStateMachineRefAbstract", "gsStateMachineRefAbstract", &SWIGTYPE_p_gsStateMachineRefAbstract,_proxy__wrap_new_gsStateMachineRefAbstract, swig_delete_gsStateMachineRefAbstract, swig_gsStateMachineRefAbstract_methods, swig_gsStateMachineRefAbstract_attributes, &swig_gsStateMachineRefAbstract_Sf_SwigStatic, swig_gsStateMachineRefAbstract_meta, swig_gsStateMachineRefAbstract_bases, swig_gsStateMachineRefAbstract_base_names };

static int _wrap_new_gsStateRefAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateRefAbstract *arg1 = (gkStateRefAbstract *) 0 ;
  gsStateRefAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateRefAbstract::gsStateRefAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::gsStateRefAbstract",1,"gkStateRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateRefAbstract,0))){
    SWIG_fail_ptr("new_gsStateRefAbstract",1,SWIGTYPE_p_gkStateRefAbstract);
  }
  
  result = (gsStateRefAbstract *)new gsStateRefAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateRefAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_getPropSTM(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateRefAbstract::getPropSTM",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::getPropSTM",1,"gsStateRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_getPropSTM",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  result = (arg1)->getPropSTM();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_setPropSTM(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateRefAbstract::setPropSTM",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::setPropSTM",1,"gsStateRefAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateRefAbstract::setPropSTM",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_setPropSTM",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropSTM((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_getPropSTATE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsStateRefAbstract::getPropSTATE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::getPropSTATE",1,"gsStateRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_getPropSTATE",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  result = (arg1)->getPropSTATE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_setPropSTATE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsStateRefAbstract::setPropSTATE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::setPropSTATE",1,"gsStateRefAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsStateRefAbstract::setPropSTATE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_setPropSTATE",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropSTATE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_getPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsStateRefAbstract::getPropGLOBAL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::getPropGLOBAL",1,"gsStateRefAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_getPropGLOBAL",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  result = (bool)(arg1)->getPropGLOBAL();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateRefAbstract_setPropGLOBAL(lua_State* L) {
  int SWIG_arg = 0;
  gsStateRefAbstract *arg1 = (gsStateRefAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateRefAbstract::setPropGLOBAL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateRefAbstract::setPropGLOBAL",1,"gsStateRefAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateRefAbstract::setPropGLOBAL",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateRefAbstract,0))){
    SWIG_fail_ptr("gsStateRefAbstract_setPropGLOBAL",1,SWIGTYPE_p_gsStateRefAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropGLOBAL(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateRefAbstract(void *obj) {
gsStateRefAbstract *arg1 = (gsStateRefAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateRefAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateRefAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateRefAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateRefAbstract_methods[]= {
    { "getPropSTM", _wrap_gsStateRefAbstract_getPropSTM},
    { "setPropSTM", _wrap_gsStateRefAbstract_setPropSTM},
    { "getPropSTATE", _wrap_gsStateRefAbstract_getPropSTATE},
    { "setPropSTATE", _wrap_gsStateRefAbstract_setPropSTATE},
    { "getPropGLOBAL", _wrap_gsStateRefAbstract_getPropGLOBAL},
    { "setPropGLOBAL", _wrap_gsStateRefAbstract_setPropGLOBAL},
    {0,0}
};
static swig_lua_method swig_gsStateRefAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateRefAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateRefAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateRefAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateRefAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateRefAbstract_Sf_SwigStatic = {
    "gsStateRefAbstract",
    swig_gsStateRefAbstract_Sf_SwigStatic_methods,
    swig_gsStateRefAbstract_Sf_SwigStatic_attributes,
    swig_gsStateRefAbstract_Sf_SwigStatic_constants,
    swig_gsStateRefAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateRefAbstract_bases[] = {0,0};
static const char *swig_gsStateRefAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateRefAbstract = { "gsStateRefAbstract", "gsStateRefAbstract", &SWIGTYPE_p_gsStateRefAbstract,_proxy__wrap_new_gsStateRefAbstract, swig_delete_gsStateRefAbstract, swig_gsStateRefAbstract_methods, swig_gsStateRefAbstract_attributes, &swig_gsStateRefAbstract_Sf_SwigStatic, swig_gsStateRefAbstract_meta, swig_gsStateRefAbstract_bases, swig_gsStateRefAbstract_base_names };

static int _wrap_new_gsStateManipulatorAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkStateManipulatorAbstract *arg1 = (gkStateManipulatorAbstract *) 0 ;
  gsStateManipulatorAbstract *result = 0 ;
  
  SWIG_check_num_args("gsStateManipulatorAbstract::gsStateManipulatorAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateManipulatorAbstract::gsStateManipulatorAbstract",1,"gkStateManipulatorAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkStateManipulatorAbstract,0))){
    SWIG_fail_ptr("new_gsStateManipulatorAbstract",1,SWIGTYPE_p_gkStateManipulatorAbstract);
  }
  
  result = (gsStateManipulatorAbstract *)new gsStateManipulatorAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsStateManipulatorAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateManipulatorAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateManipulatorAbstract *arg1 = (gsStateManipulatorAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsStateManipulatorAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateManipulatorAbstract::getPropTYPE",1,"gsStateManipulatorAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateManipulatorAbstract,0))){
    SWIG_fail_ptr("gsStateManipulatorAbstract_getPropTYPE",1,SWIGTYPE_p_gsStateManipulatorAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsStateManipulatorAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsStateManipulatorAbstract *arg1 = (gsStateManipulatorAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsStateManipulatorAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsStateManipulatorAbstract::setPropTYPE",1,"gsStateManipulatorAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsStateManipulatorAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsStateManipulatorAbstract,0))){
    SWIG_fail_ptr("gsStateManipulatorAbstract_setPropTYPE",1,SWIGTYPE_p_gsStateManipulatorAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsStateManipulatorAbstract(void *obj) {
gsStateManipulatorAbstract *arg1 = (gsStateManipulatorAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsStateManipulatorAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsStateManipulatorAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsStateManipulatorAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsStateManipulatorAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsStateManipulatorAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsStateManipulatorAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsStateManipulatorAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsStateManipulatorAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsStateManipulatorAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsStateManipulatorAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsStateManipulatorAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsStateManipulatorAbstract_Sf_SwigStatic = {
    "gsStateManipulatorAbstract",
    swig_gsStateManipulatorAbstract_Sf_SwigStatic_methods,
    swig_gsStateManipulatorAbstract_Sf_SwigStatic_attributes,
    swig_gsStateManipulatorAbstract_Sf_SwigStatic_constants,
    swig_gsStateManipulatorAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsStateManipulatorAbstract_bases[] = {0,0};
static const char *swig_gsStateManipulatorAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsStateManipulatorAbstract = { "gsStateManipulatorAbstract", "gsStateManipulatorAbstract", &SWIGTYPE_p_gsStateManipulatorAbstract,_proxy__wrap_new_gsStateManipulatorAbstract, swig_delete_gsStateManipulatorAbstract, swig_gsStateManipulatorAbstract_methods, swig_gsStateManipulatorAbstract_attributes, &swig_gsStateManipulatorAbstract_Sf_SwigStatic, swig_gsStateManipulatorAbstract_meta, swig_gsStateManipulatorAbstract_bases, swig_gsStateManipulatorAbstract_base_names };

static int _wrap_new_gsPropertyAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPropertyAbstract *arg1 = (gkPropertyAbstract *) 0 ;
  gsPropertyAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPropertyAbstract::gsPropertyAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::gsPropertyAbstract",1,"gkPropertyAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPropertyAbstract,0))){
    SWIG_fail_ptr("new_gsPropertyAbstract",1,SWIGTYPE_p_gkPropertyAbstract);
  }
  
  result = (gsPropertyAbstract *)new gsPropertyAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertyAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertyAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::getPropNAME",1,"gsPropertyAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_getPropNAME",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertyAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::setPropNAME",1,"gsPropertyAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_setPropNAME",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_getPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPropertyAbstract::getPropMODE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::getPropMODE",1,"gsPropertyAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_getPropMODE",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  result = (int)(arg1)->getPropMODE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_setPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPropertyAbstract::setPropMODE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::setPropMODE",1,"gsPropertyAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPropertyAbstract::setPropMODE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_setPropMODE",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMODE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPropertyAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::getPropTYPE",1,"gsPropertyAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_getPropTYPE",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyAbstract *arg1 = (gsPropertyAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPropertyAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyAbstract::setPropTYPE",1,"gsPropertyAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPropertyAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyAbstract,0))){
    SWIG_fail_ptr("gsPropertyAbstract_setPropTYPE",1,SWIGTYPE_p_gsPropertyAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPropertyAbstract(void *obj) {
gsPropertyAbstract *arg1 = (gsPropertyAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPropertyAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPropertyAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPropertyAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPropertyAbstract_methods[]= {
    { "getPropNAME", _wrap_gsPropertyAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsPropertyAbstract_setPropNAME},
    { "getPropMODE", _wrap_gsPropertyAbstract_getPropMODE},
    { "setPropMODE", _wrap_gsPropertyAbstract_setPropMODE},
    { "getPropTYPE", _wrap_gsPropertyAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsPropertyAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsPropertyAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPropertyAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPropertyAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPropertyAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPropertyAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPropertyAbstract_Sf_SwigStatic = {
    "gsPropertyAbstract",
    swig_gsPropertyAbstract_Sf_SwigStatic_methods,
    swig_gsPropertyAbstract_Sf_SwigStatic_attributes,
    swig_gsPropertyAbstract_Sf_SwigStatic_constants,
    swig_gsPropertyAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPropertyAbstract_bases[] = {0,0};
static const char *swig_gsPropertyAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPropertyAbstract = { "gsPropertyAbstract", "gsPropertyAbstract", &SWIGTYPE_p_gsPropertyAbstract,_proxy__wrap_new_gsPropertyAbstract, swig_delete_gsPropertyAbstract, swig_gsPropertyAbstract_methods, swig_gsPropertyAbstract_attributes, &swig_gsPropertyAbstract_Sf_SwigStatic, swig_gsPropertyAbstract_meta, swig_gsPropertyAbstract_bases, swig_gsPropertyAbstract_base_names };

static int _wrap_new_gsPropertyGetAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPropertyGetAbstract *arg1 = (gkPropertyGetAbstract *) 0 ;
  gsPropertyGetAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPropertyGetAbstract::gsPropertyGetAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyGetAbstract::gsPropertyGetAbstract",1,"gkPropertyGetAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPropertyGetAbstract,0))){
    SWIG_fail_ptr("new_gsPropertyGetAbstract",1,SWIGTYPE_p_gkPropertyGetAbstract);
  }
  
  result = (gsPropertyGetAbstract *)new gsPropertyGetAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPropertyGetAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyGetAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyGetAbstract *arg1 = (gsPropertyGetAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPropertyGetAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyGetAbstract::getPropNAME",1,"gsPropertyGetAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyGetAbstract,0))){
    SWIG_fail_ptr("gsPropertyGetAbstract_getPropNAME",1,SWIGTYPE_p_gsPropertyGetAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyGetAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyGetAbstract *arg1 = (gsPropertyGetAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPropertyGetAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyGetAbstract::setPropNAME",1,"gsPropertyGetAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPropertyGetAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyGetAbstract,0))){
    SWIG_fail_ptr("gsPropertyGetAbstract_setPropNAME",1,SWIGTYPE_p_gsPropertyGetAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyGetAbstract_getPropMANUAL(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyGetAbstract *arg1 = (gsPropertyGetAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsPropertyGetAbstract::getPropMANUAL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyGetAbstract::getPropMANUAL",1,"gsPropertyGetAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyGetAbstract,0))){
    SWIG_fail_ptr("gsPropertyGetAbstract_getPropMANUAL",1,SWIGTYPE_p_gsPropertyGetAbstract);
  }
  
  result = (bool)(arg1)->getPropMANUAL();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPropertyGetAbstract_setPropMANUAL(lua_State* L) {
  int SWIG_arg = 0;
  gsPropertyGetAbstract *arg1 = (gsPropertyGetAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPropertyGetAbstract::setPropMANUAL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPropertyGetAbstract::setPropMANUAL",1,"gsPropertyGetAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPropertyGetAbstract::setPropMANUAL",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPropertyGetAbstract,0))){
    SWIG_fail_ptr("gsPropertyGetAbstract_setPropMANUAL",1,SWIGTYPE_p_gsPropertyGetAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMANUAL(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPropertyGetAbstract(void *obj) {
gsPropertyGetAbstract *arg1 = (gsPropertyGetAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPropertyGetAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPropertyGetAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPropertyGetAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPropertyGetAbstract_methods[]= {
    { "getPropNAME", _wrap_gsPropertyGetAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsPropertyGetAbstract_setPropNAME},
    { "getPropMANUAL", _wrap_gsPropertyGetAbstract_getPropMANUAL},
    { "setPropMANUAL", _wrap_gsPropertyGetAbstract_setPropMANUAL},
    {0,0}
};
static swig_lua_method swig_gsPropertyGetAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPropertyGetAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPropertyGetAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPropertyGetAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPropertyGetAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPropertyGetAbstract_Sf_SwigStatic = {
    "gsPropertyGetAbstract",
    swig_gsPropertyGetAbstract_Sf_SwigStatic_methods,
    swig_gsPropertyGetAbstract_Sf_SwigStatic_attributes,
    swig_gsPropertyGetAbstract_Sf_SwigStatic_constants,
    swig_gsPropertyGetAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPropertyGetAbstract_bases[] = {0,0};
static const char *swig_gsPropertyGetAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPropertyGetAbstract = { "gsPropertyGetAbstract", "gsPropertyGetAbstract", &SWIGTYPE_p_gsPropertyGetAbstract,_proxy__wrap_new_gsPropertyGetAbstract, swig_delete_gsPropertyGetAbstract, swig_gsPropertyGetAbstract_methods, swig_gsPropertyGetAbstract_attributes, &swig_gsPropertyGetAbstract_Sf_SwigStatic, swig_gsPropertyGetAbstract_meta, swig_gsPropertyGetAbstract_bases, swig_gsPropertyGetAbstract_base_names };

static int _wrap_new_gsNoOpAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkNoOpAbstract *arg1 = (gkNoOpAbstract *) 0 ;
  gsNoOpAbstract *result = 0 ;
  
  SWIG_check_num_args("gsNoOpAbstract::gsNoOpAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsNoOpAbstract::gsNoOpAbstract",1,"gkNoOpAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkNoOpAbstract,0))){
    SWIG_fail_ptr("new_gsNoOpAbstract",1,SWIGTYPE_p_gkNoOpAbstract);
  }
  
  result = (gsNoOpAbstract *)new gsNoOpAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsNoOpAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsNoOpAbstract(void *obj) {
gsNoOpAbstract *arg1 = (gsNoOpAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsNoOpAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsNoOpAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsNoOpAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsNoOpAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsNoOpAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsNoOpAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsNoOpAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsNoOpAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsNoOpAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsNoOpAbstract_Sf_SwigStatic = {
    "gsNoOpAbstract",
    swig_gsNoOpAbstract_Sf_SwigStatic_methods,
    swig_gsNoOpAbstract_Sf_SwigStatic_attributes,
    swig_gsNoOpAbstract_Sf_SwigStatic_constants,
    swig_gsNoOpAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsNoOpAbstract_bases[] = {0,0};
static const char *swig_gsNoOpAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsNoOpAbstract = { "gsNoOpAbstract", "gsNoOpAbstract", &SWIGTYPE_p_gsNoOpAbstract,_proxy__wrap_new_gsNoOpAbstract, swig_delete_gsNoOpAbstract, swig_gsNoOpAbstract_methods, swig_gsNoOpAbstract_attributes, &swig_gsNoOpAbstract_Sf_SwigStatic, swig_gsNoOpAbstract_meta, swig_gsNoOpAbstract_bases, swig_gsNoOpAbstract_base_names };

static int _wrap_new_gsTemplaterNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTemplaterNodeAbstract *arg1 = (gkTemplaterNodeAbstract *) 0 ;
  gsTemplaterNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTemplaterNodeAbstract::gsTemplaterNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTemplaterNodeAbstract::gsTemplaterNodeAbstract",1,"gkTemplaterNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTemplaterNodeAbstract,0))){
    SWIG_fail_ptr("new_gsTemplaterNodeAbstract",1,SWIGTYPE_p_gkTemplaterNodeAbstract);
  }
  
  result = (gsTemplaterNodeAbstract *)new gsTemplaterNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTemplaterNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTemplaterNodeAbstract_getPropDOCNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsTemplaterNodeAbstract *arg1 = (gsTemplaterNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsTemplaterNodeAbstract::getPropDOCNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTemplaterNodeAbstract::getPropDOCNAME",1,"gsTemplaterNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTemplaterNodeAbstract,0))){
    SWIG_fail_ptr("gsTemplaterNodeAbstract_getPropDOCNAME",1,SWIGTYPE_p_gsTemplaterNodeAbstract);
  }
  
  result = (arg1)->getPropDOCNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTemplaterNodeAbstract_setPropDOCNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsTemplaterNodeAbstract *arg1 = (gsTemplaterNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTemplaterNodeAbstract::setPropDOCNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTemplaterNodeAbstract::setPropDOCNAME",1,"gsTemplaterNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTemplaterNodeAbstract::setPropDOCNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTemplaterNodeAbstract,0))){
    SWIG_fail_ptr("gsTemplaterNodeAbstract_setPropDOCNAME",1,SWIGTYPE_p_gsTemplaterNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropDOCNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTemplaterNodeAbstract_getPropTEMPLATE(lua_State* L) {
  int SWIG_arg = 0;
  gsTemplaterNodeAbstract *arg1 = (gsTemplaterNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsTemplaterNodeAbstract::getPropTEMPLATE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTemplaterNodeAbstract::getPropTEMPLATE",1,"gsTemplaterNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTemplaterNodeAbstract,0))){
    SWIG_fail_ptr("gsTemplaterNodeAbstract_getPropTEMPLATE",1,SWIGTYPE_p_gsTemplaterNodeAbstract);
  }
  
  result = (arg1)->getPropTEMPLATE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTemplaterNodeAbstract_setPropTEMPLATE(lua_State* L) {
  int SWIG_arg = 0;
  gsTemplaterNodeAbstract *arg1 = (gsTemplaterNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTemplaterNodeAbstract::setPropTEMPLATE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTemplaterNodeAbstract::setPropTEMPLATE",1,"gsTemplaterNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTemplaterNodeAbstract::setPropTEMPLATE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTemplaterNodeAbstract,0))){
    SWIG_fail_ptr("gsTemplaterNodeAbstract_setPropTEMPLATE",1,SWIGTYPE_p_gsTemplaterNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropTEMPLATE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTemplaterNodeAbstract(void *obj) {
gsTemplaterNodeAbstract *arg1 = (gsTemplaterNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTemplaterNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTemplaterNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTemplaterNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTemplaterNodeAbstract_methods[]= {
    { "getPropDOCNAME", _wrap_gsTemplaterNodeAbstract_getPropDOCNAME},
    { "setPropDOCNAME", _wrap_gsTemplaterNodeAbstract_setPropDOCNAME},
    { "getPropTEMPLATE", _wrap_gsTemplaterNodeAbstract_getPropTEMPLATE},
    { "setPropTEMPLATE", _wrap_gsTemplaterNodeAbstract_setPropTEMPLATE},
    {0,0}
};
static swig_lua_method swig_gsTemplaterNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTemplaterNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTemplaterNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTemplaterNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTemplaterNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTemplaterNodeAbstract_Sf_SwigStatic = {
    "gsTemplaterNodeAbstract",
    swig_gsTemplaterNodeAbstract_Sf_SwigStatic_methods,
    swig_gsTemplaterNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsTemplaterNodeAbstract_Sf_SwigStatic_constants,
    swig_gsTemplaterNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTemplaterNodeAbstract_bases[] = {0,0};
static const char *swig_gsTemplaterNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTemplaterNodeAbstract = { "gsTemplaterNodeAbstract", "gsTemplaterNodeAbstract", &SWIGTYPE_p_gsTemplaterNodeAbstract,_proxy__wrap_new_gsTemplaterNodeAbstract, swig_delete_gsTemplaterNodeAbstract, swig_gsTemplaterNodeAbstract_methods, swig_gsTemplaterNodeAbstract_attributes, &swig_gsTemplaterNodeAbstract_Sf_SwigStatic, swig_gsTemplaterNodeAbstract_meta, swig_gsTemplaterNodeAbstract_bases, swig_gsTemplaterNodeAbstract_base_names };

static int _wrap_new_gsScreenActionAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkScreenActionAbstract *arg1 = (gkScreenActionAbstract *) 0 ;
  gsScreenActionAbstract *result = 0 ;
  
  SWIG_check_num_args("gsScreenActionAbstract::gsScreenActionAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::gsScreenActionAbstract",1,"gkScreenActionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkScreenActionAbstract,0))){
    SWIG_fail_ptr("new_gsScreenActionAbstract",1,SWIGTYPE_p_gkScreenActionAbstract);
  }
  
  result = (gsScreenActionAbstract *)new gsScreenActionAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsScreenActionAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_getPropDOC(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsScreenActionAbstract::getPropDOC",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::getPropDOC",1,"gsScreenActionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_getPropDOC",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  result = (arg1)->getPropDOC();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_setPropDOC(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsScreenActionAbstract::setPropDOC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::setPropDOC",1,"gsScreenActionAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScreenActionAbstract::setPropDOC",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_setPropDOC",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropDOC((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_getPropPARAM(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsScreenActionAbstract::getPropPARAM",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::getPropPARAM",1,"gsScreenActionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_getPropPARAM",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  result = (arg1)->getPropPARAM();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_setPropPARAM(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsScreenActionAbstract::setPropPARAM",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::setPropPARAM",1,"gsScreenActionAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsScreenActionAbstract::setPropPARAM",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_setPropPARAM",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPARAM((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsScreenActionAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::getPropTYPE",1,"gsScreenActionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_getPropTYPE",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsScreenActionAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsScreenActionAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsScreenActionAbstract::setPropTYPE",1,"gsScreenActionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsScreenActionAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScreenActionAbstract,0))){
    SWIG_fail_ptr("gsScreenActionAbstract_setPropTYPE",1,SWIGTYPE_p_gsScreenActionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsScreenActionAbstract(void *obj) {
gsScreenActionAbstract *arg1 = (gsScreenActionAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsScreenActionAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsScreenActionAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsScreenActionAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsScreenActionAbstract_methods[]= {
    { "getPropDOC", _wrap_gsScreenActionAbstract_getPropDOC},
    { "setPropDOC", _wrap_gsScreenActionAbstract_setPropDOC},
    { "getPropPARAM", _wrap_gsScreenActionAbstract_getPropPARAM},
    { "setPropPARAM", _wrap_gsScreenActionAbstract_setPropPARAM},
    { "getPropTYPE", _wrap_gsScreenActionAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsScreenActionAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsScreenActionAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsScreenActionAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsScreenActionAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsScreenActionAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsScreenActionAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsScreenActionAbstract_Sf_SwigStatic = {
    "gsScreenActionAbstract",
    swig_gsScreenActionAbstract_Sf_SwigStatic_methods,
    swig_gsScreenActionAbstract_Sf_SwigStatic_attributes,
    swig_gsScreenActionAbstract_Sf_SwigStatic_constants,
    swig_gsScreenActionAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsScreenActionAbstract_bases[] = {0,0};
static const char *swig_gsScreenActionAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsScreenActionAbstract = { "gsScreenActionAbstract", "gsScreenActionAbstract", &SWIGTYPE_p_gsScreenActionAbstract,_proxy__wrap_new_gsScreenActionAbstract, swig_delete_gsScreenActionAbstract, swig_gsScreenActionAbstract_methods, swig_gsScreenActionAbstract_attributes, &swig_gsScreenActionAbstract_Sf_SwigStatic, swig_gsScreenActionAbstract_meta, swig_gsScreenActionAbstract_bases, swig_gsScreenActionAbstract_base_names };

static int _wrap_new_gsElementAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkElementAbstract *arg1 = (gkElementAbstract *) 0 ;
  gsElementAbstract *result = 0 ;
  
  SWIG_check_num_args("gsElementAbstract::gsElementAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsElementAbstract::gsElementAbstract",1,"gkElementAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkElementAbstract,0))){
    SWIG_fail_ptr("new_gsElementAbstract",1,SWIGTYPE_p_gkElementAbstract);
  }
  
  result = (gsElementAbstract *)new gsElementAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsElementAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsElementAbstract_getPropID(lua_State* L) {
  int SWIG_arg = 0;
  gsElementAbstract *arg1 = (gsElementAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsElementAbstract::getPropID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsElementAbstract::getPropID",1,"gsElementAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsElementAbstract,0))){
    SWIG_fail_ptr("gsElementAbstract_getPropID",1,SWIGTYPE_p_gsElementAbstract);
  }
  
  result = (arg1)->getPropID();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsElementAbstract_setPropID(lua_State* L) {
  int SWIG_arg = 0;
  gsElementAbstract *arg1 = (gsElementAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsElementAbstract::setPropID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsElementAbstract::setPropID",1,"gsElementAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsElementAbstract::setPropID",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsElementAbstract,0))){
    SWIG_fail_ptr("gsElementAbstract_setPropID",1,SWIGTYPE_p_gsElementAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropID((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsElementAbstract(void *obj) {
gsElementAbstract *arg1 = (gsElementAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsElementAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsElementAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsElementAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsElementAbstract_methods[]= {
    { "getPropID", _wrap_gsElementAbstract_getPropID},
    { "setPropID", _wrap_gsElementAbstract_setPropID},
    {0,0}
};
static swig_lua_method swig_gsElementAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsElementAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsElementAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsElementAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsElementAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsElementAbstract_Sf_SwigStatic = {
    "gsElementAbstract",
    swig_gsElementAbstract_Sf_SwigStatic_methods,
    swig_gsElementAbstract_Sf_SwigStatic_attributes,
    swig_gsElementAbstract_Sf_SwigStatic_constants,
    swig_gsElementAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsElementAbstract_bases[] = {0,0};
static const char *swig_gsElementAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsElementAbstract = { "gsElementAbstract", "gsElementAbstract", &SWIGTYPE_p_gsElementAbstract,_proxy__wrap_new_gsElementAbstract, swig_delete_gsElementAbstract, swig_gsElementAbstract_methods, swig_gsElementAbstract_attributes, &swig_gsElementAbstract_Sf_SwigStatic, swig_gsElementAbstract_meta, swig_gsElementAbstract_bases, swig_gsElementAbstract_base_names };

static int _wrap_new_gsAnimationDefinitionAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkAnimationDefinitionAbstract *arg1 = (gkAnimationDefinitionAbstract *) 0 ;
  gsAnimationDefinitionAbstract *result = 0 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::gsAnimationDefinitionAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::gsAnimationDefinitionAbstract",1,"gkAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("new_gsAnimationDefinitionAbstract",1,SWIGTYPE_p_gkAnimationDefinitionAbstract);
  }
  
  result = (gsAnimationDefinitionAbstract *)new gsAnimationDefinitionAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAnimationDefinitionAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropNAME",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropNAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropNAME",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropNAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropANIM_NAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropANIM_NAME",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropANIM_NAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (arg1)->getPropANIM_NAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropANIM_NAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropANIM_NAME",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropANIM_NAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropANIM_NAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropANIM_NAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropRAW_ANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropRAW_ANIM_NAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropRAW_ANIM_NAME",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropRAW_ANIM_NAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (arg1)->getPropRAW_ANIM_NAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropRAW_ANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropRAW_ANIM_NAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRAW_ANIM_NAME",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRAW_ANIM_NAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropRAW_ANIM_NAME",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropRAW_ANIM_NAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropMODE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropMODE",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropMODE",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (int)(arg1)->getPropMODE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropMODE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropMODE",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropMODE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropMODE",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMODE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropSPEED(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropSPEED",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropSPEED",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropSPEED",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (float)(arg1)->getPropSPEED();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropSPEED(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropSPEED",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropSPEED",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropSPEED",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropSPEED",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropSPEED(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropFRAME_START(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropFRAME_START",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropFRAME_START",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropFRAME_START",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (int)(arg1)->getPropFRAME_START();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropFRAME_START(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropFRAME_START",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_START",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_START",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropFRAME_START",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropFRAME_START(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropFRAME_END(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropFRAME_END",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropFRAME_END",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropFRAME_END",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (int)(arg1)->getPropFRAME_END();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropFRAME_END(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropFRAME_END",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_END",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_END",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropFRAME_END",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropFRAME_END(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropBLEND(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropBLEND",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropBLEND",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropBLEND",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (int)(arg1)->getPropBLEND();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropBLEND(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropBLEND",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropBLEND",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropBLEND",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropBLEND",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropBLEND(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropFRAME_CUSTOM(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropFRAME_CUSTOM",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropFRAME_CUSTOM",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropFRAME_CUSTOM",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (bool)(arg1)->getPropFRAME_CUSTOM();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropFRAME_CUSTOM(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropFRAME_CUSTOM",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_CUSTOM",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropFRAME_CUSTOM",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropFRAME_CUSTOM",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropFRAME_CUSTOM(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropRESET_ONSTOP(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropRESET_ONSTOP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropRESET_ONSTOP",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropRESET_ONSTOP",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (bool)(arg1)->getPropRESET_ONSTOP();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropRESET_ONSTOP(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropRESET_ONSTOP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRESET_ONSTOP",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRESET_ONSTOP",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropRESET_ONSTOP",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropRESET_ONSTOP(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_getPropRESET_ONSTART(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::getPropRESET_ONSTART",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::getPropRESET_ONSTART",1,"gsAnimationDefinitionAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_getPropRESET_ONSTART",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  result = (bool)(arg1)->getPropRESET_ONSTART();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationDefinitionAbstract_setPropRESET_ONSTART(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationDefinitionAbstract::setPropRESET_ONSTART",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRESET_ONSTART",1,"gsAnimationDefinitionAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationDefinitionAbstract::setPropRESET_ONSTART",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationDefinitionAbstract,0))){
    SWIG_fail_ptr("gsAnimationDefinitionAbstract_setPropRESET_ONSTART",1,SWIGTYPE_p_gsAnimationDefinitionAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropRESET_ONSTART(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAnimationDefinitionAbstract(void *obj) {
gsAnimationDefinitionAbstract *arg1 = (gsAnimationDefinitionAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAnimationDefinitionAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAnimationDefinitionAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAnimationDefinitionAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAnimationDefinitionAbstract_methods[]= {
    { "getPropNAME", _wrap_gsAnimationDefinitionAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsAnimationDefinitionAbstract_setPropNAME},
    { "getPropANIM_NAME", _wrap_gsAnimationDefinitionAbstract_getPropANIM_NAME},
    { "setPropANIM_NAME", _wrap_gsAnimationDefinitionAbstract_setPropANIM_NAME},
    { "getPropRAW_ANIM_NAME", _wrap_gsAnimationDefinitionAbstract_getPropRAW_ANIM_NAME},
    { "setPropRAW_ANIM_NAME", _wrap_gsAnimationDefinitionAbstract_setPropRAW_ANIM_NAME},
    { "getPropMODE", _wrap_gsAnimationDefinitionAbstract_getPropMODE},
    { "setPropMODE", _wrap_gsAnimationDefinitionAbstract_setPropMODE},
    { "getPropSPEED", _wrap_gsAnimationDefinitionAbstract_getPropSPEED},
    { "setPropSPEED", _wrap_gsAnimationDefinitionAbstract_setPropSPEED},
    { "getPropFRAME_START", _wrap_gsAnimationDefinitionAbstract_getPropFRAME_START},
    { "setPropFRAME_START", _wrap_gsAnimationDefinitionAbstract_setPropFRAME_START},
    { "getPropFRAME_END", _wrap_gsAnimationDefinitionAbstract_getPropFRAME_END},
    { "setPropFRAME_END", _wrap_gsAnimationDefinitionAbstract_setPropFRAME_END},
    { "getPropBLEND", _wrap_gsAnimationDefinitionAbstract_getPropBLEND},
    { "setPropBLEND", _wrap_gsAnimationDefinitionAbstract_setPropBLEND},
    { "getPropFRAME_CUSTOM", _wrap_gsAnimationDefinitionAbstract_getPropFRAME_CUSTOM},
    { "setPropFRAME_CUSTOM", _wrap_gsAnimationDefinitionAbstract_setPropFRAME_CUSTOM},
    { "getPropRESET_ONSTOP", _wrap_gsAnimationDefinitionAbstract_getPropRESET_ONSTOP},
    { "setPropRESET_ONSTOP", _wrap_gsAnimationDefinitionAbstract_setPropRESET_ONSTOP},
    { "getPropRESET_ONSTART", _wrap_gsAnimationDefinitionAbstract_getPropRESET_ONSTART},
    { "setPropRESET_ONSTART", _wrap_gsAnimationDefinitionAbstract_setPropRESET_ONSTART},
    {0,0}
};
static swig_lua_method swig_gsAnimationDefinitionAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAnimationDefinitionAbstract_Sf_SwigStatic = {
    "gsAnimationDefinitionAbstract",
    swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_methods,
    swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_attributes,
    swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_constants,
    swig_gsAnimationDefinitionAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAnimationDefinitionAbstract_bases[] = {0,0};
static const char *swig_gsAnimationDefinitionAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsAnimationDefinitionAbstract = { "gsAnimationDefinitionAbstract", "gsAnimationDefinitionAbstract", &SWIGTYPE_p_gsAnimationDefinitionAbstract,_proxy__wrap_new_gsAnimationDefinitionAbstract, swig_delete_gsAnimationDefinitionAbstract, swig_gsAnimationDefinitionAbstract_methods, swig_gsAnimationDefinitionAbstract_attributes, &swig_gsAnimationDefinitionAbstract_Sf_SwigStatic, swig_gsAnimationDefinitionAbstract_meta, swig_gsAnimationDefinitionAbstract_bases, swig_gsAnimationDefinitionAbstract_base_names };

static int _wrap_new_gsAnimationPlayerAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkAnimationPlayerAbstract *arg1 = (gkAnimationPlayerAbstract *) 0 ;
  gsAnimationPlayerAbstract *result = 0 ;
  
  SWIG_check_num_args("gsAnimationPlayerAbstract::gsAnimationPlayerAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayerAbstract::gsAnimationPlayerAbstract",1,"gkAnimationPlayerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAnimationPlayerAbstract,0))){
    SWIG_fail_ptr("new_gsAnimationPlayerAbstract",1,SWIGTYPE_p_gkAnimationPlayerAbstract);
  }
  
  result = (gsAnimationPlayerAbstract *)new gsAnimationPlayerAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAnimationPlayerAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayerAbstract_getPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayerAbstract *arg1 = (gsAnimationPlayerAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAnimationPlayerAbstract::getPropNAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayerAbstract::getPropNAME",1,"gsAnimationPlayerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayerAbstract,0))){
    SWIG_fail_ptr("gsAnimationPlayerAbstract_getPropNAME",1,SWIGTYPE_p_gsAnimationPlayerAbstract);
  }
  
  result = (arg1)->getPropNAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayerAbstract_setPropNAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayerAbstract *arg1 = (gsAnimationPlayerAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAnimationPlayerAbstract::setPropNAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayerAbstract::setPropNAME",1,"gsAnimationPlayerAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAnimationPlayerAbstract::setPropNAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayerAbstract,0))){
    SWIG_fail_ptr("gsAnimationPlayerAbstract_setPropNAME",1,SWIGTYPE_p_gsAnimationPlayerAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayerAbstract_getPropRAW_ANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayerAbstract *arg1 = (gsAnimationPlayerAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAnimationPlayerAbstract::getPropRAW_ANIM_NAME",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayerAbstract::getPropRAW_ANIM_NAME",1,"gsAnimationPlayerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayerAbstract,0))){
    SWIG_fail_ptr("gsAnimationPlayerAbstract_getPropRAW_ANIM_NAME",1,SWIGTYPE_p_gsAnimationPlayerAbstract);
  }
  
  result = (arg1)->getPropRAW_ANIM_NAME();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationPlayerAbstract_setPropRAW_ANIM_NAME(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationPlayerAbstract *arg1 = (gsAnimationPlayerAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAnimationPlayerAbstract::setPropRAW_ANIM_NAME",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationPlayerAbstract::setPropRAW_ANIM_NAME",1,"gsAnimationPlayerAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAnimationPlayerAbstract::setPropRAW_ANIM_NAME",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationPlayerAbstract,0))){
    SWIG_fail_ptr("gsAnimationPlayerAbstract_setPropRAW_ANIM_NAME",1,SWIGTYPE_p_gsAnimationPlayerAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropRAW_ANIM_NAME((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAnimationPlayerAbstract(void *obj) {
gsAnimationPlayerAbstract *arg1 = (gsAnimationPlayerAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAnimationPlayerAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAnimationPlayerAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAnimationPlayerAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAnimationPlayerAbstract_methods[]= {
    { "getPropNAME", _wrap_gsAnimationPlayerAbstract_getPropNAME},
    { "setPropNAME", _wrap_gsAnimationPlayerAbstract_setPropNAME},
    { "getPropRAW_ANIM_NAME", _wrap_gsAnimationPlayerAbstract_getPropRAW_ANIM_NAME},
    { "setPropRAW_ANIM_NAME", _wrap_gsAnimationPlayerAbstract_setPropRAW_ANIM_NAME},
    {0,0}
};
static swig_lua_method swig_gsAnimationPlayerAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAnimationPlayerAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAnimationPlayerAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAnimationPlayerAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAnimationPlayerAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAnimationPlayerAbstract_Sf_SwigStatic = {
    "gsAnimationPlayerAbstract",
    swig_gsAnimationPlayerAbstract_Sf_SwigStatic_methods,
    swig_gsAnimationPlayerAbstract_Sf_SwigStatic_attributes,
    swig_gsAnimationPlayerAbstract_Sf_SwigStatic_constants,
    swig_gsAnimationPlayerAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAnimationPlayerAbstract_bases[] = {0,0};
static const char *swig_gsAnimationPlayerAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsAnimationPlayerAbstract = { "gsAnimationPlayerAbstract", "gsAnimationPlayerAbstract", &SWIGTYPE_p_gsAnimationPlayerAbstract,_proxy__wrap_new_gsAnimationPlayerAbstract, swig_delete_gsAnimationPlayerAbstract, swig_gsAnimationPlayerAbstract_methods, swig_gsAnimationPlayerAbstract_attributes, &swig_gsAnimationPlayerAbstract_Sf_SwigStatic, swig_gsAnimationPlayerAbstract_meta, swig_gsAnimationPlayerAbstract_bases, swig_gsAnimationPlayerAbstract_base_names };

static int _wrap_new_gsAnimationTriggerAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkAnimationTriggerAbstract *arg1 = (gkAnimationTriggerAbstract *) 0 ;
  gsAnimationTriggerAbstract *result = 0 ;
  
  SWIG_check_num_args("gsAnimationTriggerAbstract::gsAnimationTriggerAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationTriggerAbstract::gsAnimationTriggerAbstract",1,"gkAnimationTriggerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAnimationTriggerAbstract,0))){
    SWIG_fail_ptr("new_gsAnimationTriggerAbstract",1,SWIGTYPE_p_gkAnimationTriggerAbstract);
  }
  
  result = (gsAnimationTriggerAbstract *)new gsAnimationTriggerAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAnimationTriggerAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationTriggerAbstract_getPropframe(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationTriggerAbstract *arg1 = (gsAnimationTriggerAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAnimationTriggerAbstract::getPropframe",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationTriggerAbstract::getPropframe",1,"gsAnimationTriggerAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationTriggerAbstract,0))){
    SWIG_fail_ptr("gsAnimationTriggerAbstract_getPropframe",1,SWIGTYPE_p_gsAnimationTriggerAbstract);
  }
  
  result = (int)(arg1)->getPropframe();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAnimationTriggerAbstract_setPropframe(lua_State* L) {
  int SWIG_arg = 0;
  gsAnimationTriggerAbstract *arg1 = (gsAnimationTriggerAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAnimationTriggerAbstract::setPropframe",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAnimationTriggerAbstract::setPropframe",1,"gsAnimationTriggerAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAnimationTriggerAbstract::setPropframe",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAnimationTriggerAbstract,0))){
    SWIG_fail_ptr("gsAnimationTriggerAbstract_setPropframe",1,SWIGTYPE_p_gsAnimationTriggerAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropframe(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAnimationTriggerAbstract(void *obj) {
gsAnimationTriggerAbstract *arg1 = (gsAnimationTriggerAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAnimationTriggerAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAnimationTriggerAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAnimationTriggerAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAnimationTriggerAbstract_methods[]= {
    { "getPropframe", _wrap_gsAnimationTriggerAbstract_getPropframe},
    { "setPropframe", _wrap_gsAnimationTriggerAbstract_setPropframe},
    {0,0}
};
static swig_lua_method swig_gsAnimationTriggerAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAnimationTriggerAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAnimationTriggerAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAnimationTriggerAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAnimationTriggerAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAnimationTriggerAbstract_Sf_SwigStatic = {
    "gsAnimationTriggerAbstract",
    swig_gsAnimationTriggerAbstract_Sf_SwigStatic_methods,
    swig_gsAnimationTriggerAbstract_Sf_SwigStatic_attributes,
    swig_gsAnimationTriggerAbstract_Sf_SwigStatic_constants,
    swig_gsAnimationTriggerAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAnimationTriggerAbstract_bases[] = {0,0};
static const char *swig_gsAnimationTriggerAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsAnimationTriggerAbstract = { "gsAnimationTriggerAbstract", "gsAnimationTriggerAbstract", &SWIGTYPE_p_gsAnimationTriggerAbstract,_proxy__wrap_new_gsAnimationTriggerAbstract, swig_delete_gsAnimationTriggerAbstract, swig_gsAnimationTriggerAbstract_methods, swig_gsAnimationTriggerAbstract_attributes, &swig_gsAnimationTriggerAbstract_Sf_SwigStatic, swig_gsAnimationTriggerAbstract_meta, swig_gsAnimationTriggerAbstract_bases, swig_gsAnimationTriggerAbstract_base_names };

static int _wrap_new_gsCollisionNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkCollisionNodeAbstract *arg1 = (gkCollisionNodeAbstract *) 0 ;
  gsCollisionNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsCollisionNodeAbstract::gsCollisionNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionNodeAbstract::gsCollisionNodeAbstract",1,"gkCollisionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCollisionNodeAbstract,0))){
    SWIG_fail_ptr("new_gsCollisionNodeAbstract",1,SWIGTYPE_p_gkCollisionNodeAbstract);
  }
  
  result = (gsCollisionNodeAbstract *)new gsCollisionNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCollisionNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsCollisionNodeAbstract_getPropPROPERTY(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionNodeAbstract *arg1 = (gsCollisionNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsCollisionNodeAbstract::getPropPROPERTY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionNodeAbstract::getPropPROPERTY",1,"gsCollisionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionNodeAbstract,0))){
    SWIG_fail_ptr("gsCollisionNodeAbstract_getPropPROPERTY",1,SWIGTYPE_p_gsCollisionNodeAbstract);
  }
  
  result = (arg1)->getPropPROPERTY();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsCollisionNodeAbstract_setPropPROPERTY(lua_State* L) {
  int SWIG_arg = 0;
  gsCollisionNodeAbstract *arg1 = (gsCollisionNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsCollisionNodeAbstract::setPropPROPERTY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCollisionNodeAbstract::setPropPROPERTY",1,"gsCollisionNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsCollisionNodeAbstract::setPropPROPERTY",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCollisionNodeAbstract,0))){
    SWIG_fail_ptr("gsCollisionNodeAbstract_setPropPROPERTY",1,SWIGTYPE_p_gsCollisionNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPROPERTY((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsCollisionNodeAbstract(void *obj) {
gsCollisionNodeAbstract *arg1 = (gsCollisionNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsCollisionNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsCollisionNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsCollisionNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsCollisionNodeAbstract_methods[]= {
    { "getPropPROPERTY", _wrap_gsCollisionNodeAbstract_getPropPROPERTY},
    { "setPropPROPERTY", _wrap_gsCollisionNodeAbstract_setPropPROPERTY},
    {0,0}
};
static swig_lua_method swig_gsCollisionNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsCollisionNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsCollisionNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsCollisionNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsCollisionNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsCollisionNodeAbstract_Sf_SwigStatic = {
    "gsCollisionNodeAbstract",
    swig_gsCollisionNodeAbstract_Sf_SwigStatic_methods,
    swig_gsCollisionNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsCollisionNodeAbstract_Sf_SwigStatic_constants,
    swig_gsCollisionNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsCollisionNodeAbstract_bases[] = {0,0};
static const char *swig_gsCollisionNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsCollisionNodeAbstract = { "gsCollisionNodeAbstract", "gsCollisionNodeAbstract", &SWIGTYPE_p_gsCollisionNodeAbstract,_proxy__wrap_new_gsCollisionNodeAbstract, swig_delete_gsCollisionNodeAbstract, swig_gsCollisionNodeAbstract_methods, swig_gsCollisionNodeAbstract_attributes, &swig_gsCollisionNodeAbstract_Sf_SwigStatic, swig_gsCollisionNodeAbstract_meta, swig_gsCollisionNodeAbstract_bases, swig_gsCollisionNodeAbstract_base_names };

static int _wrap_new_gsFileNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkFileNodeAbstract *arg1 = (gkFileNodeAbstract *) 0 ;
  gsFileNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsFileNodeAbstract::gsFileNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFileNodeAbstract::gsFileNodeAbstract",1,"gkFileNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkFileNodeAbstract,0))){
    SWIG_fail_ptr("new_gsFileNodeAbstract",1,SWIGTYPE_p_gkFileNodeAbstract);
  }
  
  result = (gsFileNodeAbstract *)new gsFileNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsFileNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsFileNodeAbstract_getPropFile(lua_State* L) {
  int SWIG_arg = 0;
  gsFileNodeAbstract *arg1 = (gsFileNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsFileNodeAbstract::getPropFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFileNodeAbstract::getPropFile",1,"gsFileNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFileNodeAbstract,0))){
    SWIG_fail_ptr("gsFileNodeAbstract_getPropFile",1,SWIGTYPE_p_gsFileNodeAbstract);
  }
  
  result = (arg1)->getPropFile();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsFileNodeAbstract_setPropFile(lua_State* L) {
  int SWIG_arg = 0;
  gsFileNodeAbstract *arg1 = (gsFileNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsFileNodeAbstract::setPropFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsFileNodeAbstract::setPropFile",1,"gsFileNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsFileNodeAbstract::setPropFile",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsFileNodeAbstract,0))){
    SWIG_fail_ptr("gsFileNodeAbstract_setPropFile",1,SWIGTYPE_p_gsFileNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropFile((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsFileNodeAbstract(void *obj) {
gsFileNodeAbstract *arg1 = (gsFileNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsFileNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsFileNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsFileNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsFileNodeAbstract_methods[]= {
    { "getPropFile", _wrap_gsFileNodeAbstract_getPropFile},
    { "setPropFile", _wrap_gsFileNodeAbstract_setPropFile},
    {0,0}
};
static swig_lua_method swig_gsFileNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsFileNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsFileNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsFileNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsFileNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsFileNodeAbstract_Sf_SwigStatic = {
    "gsFileNodeAbstract",
    swig_gsFileNodeAbstract_Sf_SwigStatic_methods,
    swig_gsFileNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsFileNodeAbstract_Sf_SwigStatic_constants,
    swig_gsFileNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsFileNodeAbstract_bases[] = {0,0};
static const char *swig_gsFileNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsFileNodeAbstract = { "gsFileNodeAbstract", "gsFileNodeAbstract", &SWIGTYPE_p_gsFileNodeAbstract,_proxy__wrap_new_gsFileNodeAbstract, swig_delete_gsFileNodeAbstract, swig_gsFileNodeAbstract_methods, swig_gsFileNodeAbstract_attributes, &swig_gsFileNodeAbstract_Sf_SwigStatic, swig_gsFileNodeAbstract_meta, swig_gsFileNodeAbstract_bases, swig_gsFileNodeAbstract_base_names };

static int _wrap_new_gsLuaNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkLuaNodeAbstract *arg1 = (gkLuaNodeAbstract *) 0 ;
  gsLuaNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsLuaNodeAbstract::gsLuaNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaNodeAbstract::gsLuaNodeAbstract",1,"gkLuaNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkLuaNodeAbstract,0))){
    SWIG_fail_ptr("new_gsLuaNodeAbstract",1,SWIGTYPE_p_gkLuaNodeAbstract);
  }
  
  result = (gsLuaNodeAbstract *)new gsLuaNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLuaNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLuaNodeAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaNodeAbstract *arg1 = (gsLuaNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsLuaNodeAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaNodeAbstract::getPropTYPE",1,"gsLuaNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaNodeAbstract,0))){
    SWIG_fail_ptr("gsLuaNodeAbstract_getPropTYPE",1,SWIGTYPE_p_gsLuaNodeAbstract);
  }
  
  result = (arg1)->getPropTYPE();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsLuaNodeAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaNodeAbstract *arg1 = (gsLuaNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsLuaNodeAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaNodeAbstract::setPropTYPE",1,"gsLuaNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaNodeAbstract::setPropTYPE",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaNodeAbstract,0))){
    SWIG_fail_ptr("gsLuaNodeAbstract_setPropTYPE",1,SWIGTYPE_p_gsLuaNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropTYPE((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsLuaNodeAbstract(void *obj) {
gsLuaNodeAbstract *arg1 = (gsLuaNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsLuaNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsLuaNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsLuaNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsLuaNodeAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsLuaNodeAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsLuaNodeAbstract_setPropTYPE},
    {0,0}
};
static swig_lua_method swig_gsLuaNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsLuaNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsLuaNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsLuaNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsLuaNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsLuaNodeAbstract_Sf_SwigStatic = {
    "gsLuaNodeAbstract",
    swig_gsLuaNodeAbstract_Sf_SwigStatic_methods,
    swig_gsLuaNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsLuaNodeAbstract_Sf_SwigStatic_constants,
    swig_gsLuaNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsLuaNodeAbstract_bases[] = {0,0};
static const char *swig_gsLuaNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsLuaNodeAbstract = { "gsLuaNodeAbstract", "gsLuaNodeAbstract", &SWIGTYPE_p_gsLuaNodeAbstract,_proxy__wrap_new_gsLuaNodeAbstract, swig_delete_gsLuaNodeAbstract, swig_gsLuaNodeAbstract_methods, swig_gsLuaNodeAbstract_attributes, &swig_gsLuaNodeAbstract_Sf_SwigStatic, swig_gsLuaNodeAbstract_meta, swig_gsLuaNodeAbstract_bases, swig_gsLuaNodeAbstract_base_names };

static int _wrap_new_gsAdditionNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkAdditionNodeAbstract *arg1 = (gkAdditionNodeAbstract *) 0 ;
  gsAdditionNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::gsAdditionNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::gsAdditionNodeAbstract",1,"gkAdditionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkAdditionNodeAbstract,0))){
    SWIG_fail_ptr("new_gsAdditionNodeAbstract",1,SWIGTYPE_p_gkAdditionNodeAbstract);
  }
  
  result = (gsAdditionNodeAbstract *)new gsAdditionNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsAdditionNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_getPropLUACLASS(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::getPropLUACLASS",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::getPropLUACLASS",1,"gsAdditionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_getPropLUACLASS",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  result = (arg1)->getPropLUACLASS();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_setPropLUACLASS(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::setPropLUACLASS",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropLUACLASS",1,"gsAdditionNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropLUACLASS",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_setPropLUACLASS",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropLUACLASS((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::getPropTYPE",1,"gsAdditionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_getPropTYPE",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropTYPE",1,"gsAdditionNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_setPropTYPE",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_getPropIVal(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::getPropIVal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::getPropIVal",1,"gsAdditionNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_getPropIVal",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  result = (int)(arg1)->getPropIVal();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsAdditionNodeAbstract_setPropIVal(lua_State* L) {
  int SWIG_arg = 0;
  gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsAdditionNodeAbstract::setPropIVal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropIVal",1,"gsAdditionNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsAdditionNodeAbstract::setPropIVal",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsAdditionNodeAbstract,0))){
    SWIG_fail_ptr("gsAdditionNodeAbstract_setPropIVal",1,SWIGTYPE_p_gsAdditionNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropIVal(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsAdditionNodeAbstract(void *obj) {
gsAdditionNodeAbstract *arg1 = (gsAdditionNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsAdditionNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsAdditionNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsAdditionNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsAdditionNodeAbstract_methods[]= {
    { "getPropLUACLASS", _wrap_gsAdditionNodeAbstract_getPropLUACLASS},
    { "setPropLUACLASS", _wrap_gsAdditionNodeAbstract_setPropLUACLASS},
    { "getPropTYPE", _wrap_gsAdditionNodeAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsAdditionNodeAbstract_setPropTYPE},
    { "getPropIVal", _wrap_gsAdditionNodeAbstract_getPropIVal},
    { "setPropIVal", _wrap_gsAdditionNodeAbstract_setPropIVal},
    {0,0}
};
static swig_lua_method swig_gsAdditionNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsAdditionNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsAdditionNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsAdditionNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsAdditionNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsAdditionNodeAbstract_Sf_SwigStatic = {
    "gsAdditionNodeAbstract",
    swig_gsAdditionNodeAbstract_Sf_SwigStatic_methods,
    swig_gsAdditionNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsAdditionNodeAbstract_Sf_SwigStatic_constants,
    swig_gsAdditionNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsAdditionNodeAbstract_bases[] = {0,0};
static const char *swig_gsAdditionNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsAdditionNodeAbstract = { "gsAdditionNodeAbstract", "gsAdditionNodeAbstract", &SWIGTYPE_p_gsAdditionNodeAbstract,_proxy__wrap_new_gsAdditionNodeAbstract, swig_delete_gsAdditionNodeAbstract, swig_gsAdditionNodeAbstract_methods, swig_gsAdditionNodeAbstract_attributes, &swig_gsAdditionNodeAbstract_Sf_SwigStatic, swig_gsAdditionNodeAbstract_meta, swig_gsAdditionNodeAbstract_bases, swig_gsAdditionNodeAbstract_base_names };

static int _wrap_new_gsPrintNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPrintNodeAbstract *arg1 = (gkPrintNodeAbstract *) 0 ;
  gsPrintNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPrintNodeAbstract::gsPrintNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::gsPrintNodeAbstract",1,"gkPrintNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPrintNodeAbstract,0))){
    SWIG_fail_ptr("new_gsPrintNodeAbstract",1,SWIGTYPE_p_gkPrintNodeAbstract);
  }
  
  result = (gsPrintNodeAbstract *)new gsPrintNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPrintNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_getPropPREFIX(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPrintNodeAbstract::getPropPREFIX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::getPropPREFIX",1,"gsPrintNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_getPropPREFIX",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  result = (arg1)->getPropPREFIX();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_setPropPREFIX(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPrintNodeAbstract::setPropPREFIX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::setPropPREFIX",1,"gsPrintNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPrintNodeAbstract::setPropPREFIX",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_setPropPREFIX",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPREFIX((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_getPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPrintNodeAbstract::getPropMODE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::getPropMODE",1,"gsPrintNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_getPropMODE",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  result = (int)(arg1)->getPropMODE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_setPropMODE(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPrintNodeAbstract::setPropMODE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::setPropMODE",1,"gsPrintNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPrintNodeAbstract::setPropMODE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_setPropMODE",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropMODE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_getPropON_CHANGE(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsPrintNodeAbstract::getPropON_CHANGE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::getPropON_CHANGE",1,"gsPrintNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_getPropON_CHANGE",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  result = (bool)(arg1)->getPropON_CHANGE();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPrintNodeAbstract_setPropON_CHANGE(lua_State* L) {
  int SWIG_arg = 0;
  gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPrintNodeAbstract::setPropON_CHANGE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPrintNodeAbstract::setPropON_CHANGE",1,"gsPrintNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPrintNodeAbstract::setPropON_CHANGE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPrintNodeAbstract,0))){
    SWIG_fail_ptr("gsPrintNodeAbstract_setPropON_CHANGE",1,SWIGTYPE_p_gsPrintNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropON_CHANGE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPrintNodeAbstract(void *obj) {
gsPrintNodeAbstract *arg1 = (gsPrintNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPrintNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPrintNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPrintNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPrintNodeAbstract_methods[]= {
    { "getPropPREFIX", _wrap_gsPrintNodeAbstract_getPropPREFIX},
    { "setPropPREFIX", _wrap_gsPrintNodeAbstract_setPropPREFIX},
    { "getPropMODE", _wrap_gsPrintNodeAbstract_getPropMODE},
    { "setPropMODE", _wrap_gsPrintNodeAbstract_setPropMODE},
    { "getPropON_CHANGE", _wrap_gsPrintNodeAbstract_getPropON_CHANGE},
    { "setPropON_CHANGE", _wrap_gsPrintNodeAbstract_setPropON_CHANGE},
    {0,0}
};
static swig_lua_method swig_gsPrintNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPrintNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPrintNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPrintNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPrintNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPrintNodeAbstract_Sf_SwigStatic = {
    "gsPrintNodeAbstract",
    swig_gsPrintNodeAbstract_Sf_SwigStatic_methods,
    swig_gsPrintNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsPrintNodeAbstract_Sf_SwigStatic_constants,
    swig_gsPrintNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPrintNodeAbstract_bases[] = {0,0};
static const char *swig_gsPrintNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPrintNodeAbstract = { "gsPrintNodeAbstract", "gsPrintNodeAbstract", &SWIGTYPE_p_gsPrintNodeAbstract,_proxy__wrap_new_gsPrintNodeAbstract, swig_delete_gsPrintNodeAbstract, swig_gsPrintNodeAbstract_methods, swig_gsPrintNodeAbstract_attributes, &swig_gsPrintNodeAbstract_Sf_SwigStatic, swig_gsPrintNodeAbstract_meta, swig_gsPrintNodeAbstract_bases, swig_gsPrintNodeAbstract_base_names };

static int _wrap_new_gsKeyNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkKeyNodeAbstract *arg1 = (gkKeyNodeAbstract *) 0 ;
  gsKeyNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsKeyNodeAbstract::gsKeyNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyNodeAbstract::gsKeyNodeAbstract",1,"gkKeyNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkKeyNodeAbstract,0))){
    SWIG_fail_ptr("new_gsKeyNodeAbstract",1,SWIGTYPE_p_gkKeyNodeAbstract);
  }
  
  result = (gsKeyNodeAbstract *)new gsKeyNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsKeyNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsKeyNodeAbstract_getPropKey(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyNodeAbstract *arg1 = (gsKeyNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsKeyNodeAbstract::getPropKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyNodeAbstract::getPropKey",1,"gsKeyNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyNodeAbstract,0))){
    SWIG_fail_ptr("gsKeyNodeAbstract_getPropKey",1,SWIGTYPE_p_gsKeyNodeAbstract);
  }
  
  result = (int)(arg1)->getPropKey();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsKeyNodeAbstract_setPropKey(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyNodeAbstract *arg1 = (gsKeyNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsKeyNodeAbstract::setPropKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyNodeAbstract::setPropKey",1,"gsKeyNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyNodeAbstract::setPropKey",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyNodeAbstract,0))){
    SWIG_fail_ptr("gsKeyNodeAbstract_setPropKey",1,SWIGTYPE_p_gsKeyNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropKey(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsKeyNodeAbstract_getPropDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyNodeAbstract *arg1 = (gsKeyNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsKeyNodeAbstract::getPropDelay",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyNodeAbstract::getPropDelay",1,"gsKeyNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyNodeAbstract,0))){
    SWIG_fail_ptr("gsKeyNodeAbstract_getPropDelay",1,SWIGTYPE_p_gsKeyNodeAbstract);
  }
  
  result = (float)(arg1)->getPropDelay();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsKeyNodeAbstract_setPropDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsKeyNodeAbstract *arg1 = (gsKeyNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsKeyNodeAbstract::setPropDelay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsKeyNodeAbstract::setPropDelay",1,"gsKeyNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsKeyNodeAbstract::setPropDelay",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsKeyNodeAbstract,0))){
    SWIG_fail_ptr("gsKeyNodeAbstract_setPropDelay",1,SWIGTYPE_p_gsKeyNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropDelay(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsKeyNodeAbstract(void *obj) {
gsKeyNodeAbstract *arg1 = (gsKeyNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsKeyNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsKeyNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsKeyNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsKeyNodeAbstract_methods[]= {
    { "getPropKey", _wrap_gsKeyNodeAbstract_getPropKey},
    { "setPropKey", _wrap_gsKeyNodeAbstract_setPropKey},
    { "getPropDelay", _wrap_gsKeyNodeAbstract_getPropDelay},
    { "setPropDelay", _wrap_gsKeyNodeAbstract_setPropDelay},
    {0,0}
};
static swig_lua_method swig_gsKeyNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsKeyNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsKeyNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsKeyNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsKeyNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsKeyNodeAbstract_Sf_SwigStatic = {
    "gsKeyNodeAbstract",
    swig_gsKeyNodeAbstract_Sf_SwigStatic_methods,
    swig_gsKeyNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsKeyNodeAbstract_Sf_SwigStatic_constants,
    swig_gsKeyNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsKeyNodeAbstract_bases[] = {0,0};
static const char *swig_gsKeyNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsKeyNodeAbstract = { "gsKeyNodeAbstract", "gsKeyNodeAbstract", &SWIGTYPE_p_gsKeyNodeAbstract,_proxy__wrap_new_gsKeyNodeAbstract, swig_delete_gsKeyNodeAbstract, swig_gsKeyNodeAbstract_methods, swig_gsKeyNodeAbstract_attributes, &swig_gsKeyNodeAbstract_Sf_SwigStatic, swig_gsKeyNodeAbstract_meta, swig_gsKeyNodeAbstract_bases, swig_gsKeyNodeAbstract_base_names };

static int _wrap_new_gsMouseButtonAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkMouseButtonAbstract *arg1 = (gkMouseButtonAbstract *) 0 ;
  gsMouseButtonAbstract *result = 0 ;
  
  SWIG_check_num_args("gsMouseButtonAbstract::gsMouseButtonAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseButtonAbstract::gsMouseButtonAbstract",1,"gkMouseButtonAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkMouseButtonAbstract,0))){
    SWIG_fail_ptr("new_gsMouseButtonAbstract",1,SWIGTYPE_p_gkMouseButtonAbstract);
  }
  
  result = (gsMouseButtonAbstract *)new gsMouseButtonAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsMouseButtonAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMouseButtonAbstract_getPropButton(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseButtonAbstract *arg1 = (gsMouseButtonAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsMouseButtonAbstract::getPropButton",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseButtonAbstract::getPropButton",1,"gsMouseButtonAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseButtonAbstract,0))){
    SWIG_fail_ptr("gsMouseButtonAbstract_getPropButton",1,SWIGTYPE_p_gsMouseButtonAbstract);
  }
  
  result = (int)(arg1)->getPropButton();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMouseButtonAbstract_setPropButton(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseButtonAbstract *arg1 = (gsMouseButtonAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsMouseButtonAbstract::setPropButton",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseButtonAbstract::setPropButton",1,"gsMouseButtonAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouseButtonAbstract::setPropButton",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseButtonAbstract,0))){
    SWIG_fail_ptr("gsMouseButtonAbstract_setPropButton",1,SWIGTYPE_p_gsMouseButtonAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropButton(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMouseButtonAbstract_getPropDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseButtonAbstract *arg1 = (gsMouseButtonAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsMouseButtonAbstract::getPropDelay",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseButtonAbstract::getPropDelay",1,"gsMouseButtonAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseButtonAbstract,0))){
    SWIG_fail_ptr("gsMouseButtonAbstract_getPropDelay",1,SWIGTYPE_p_gsMouseButtonAbstract);
  }
  
  result = (float)(arg1)->getPropDelay();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsMouseButtonAbstract_setPropDelay(lua_State* L) {
  int SWIG_arg = 0;
  gsMouseButtonAbstract *arg1 = (gsMouseButtonAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsMouseButtonAbstract::setPropDelay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsMouseButtonAbstract::setPropDelay",1,"gsMouseButtonAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsMouseButtonAbstract::setPropDelay",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsMouseButtonAbstract,0))){
    SWIG_fail_ptr("gsMouseButtonAbstract_setPropDelay",1,SWIGTYPE_p_gsMouseButtonAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropDelay(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsMouseButtonAbstract(void *obj) {
gsMouseButtonAbstract *arg1 = (gsMouseButtonAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsMouseButtonAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsMouseButtonAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsMouseButtonAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsMouseButtonAbstract_methods[]= {
    { "getPropButton", _wrap_gsMouseButtonAbstract_getPropButton},
    { "setPropButton", _wrap_gsMouseButtonAbstract_setPropButton},
    { "getPropDelay", _wrap_gsMouseButtonAbstract_getPropDelay},
    { "setPropDelay", _wrap_gsMouseButtonAbstract_setPropDelay},
    {0,0}
};
static swig_lua_method swig_gsMouseButtonAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsMouseButtonAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsMouseButtonAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsMouseButtonAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsMouseButtonAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsMouseButtonAbstract_Sf_SwigStatic = {
    "gsMouseButtonAbstract",
    swig_gsMouseButtonAbstract_Sf_SwigStatic_methods,
    swig_gsMouseButtonAbstract_Sf_SwigStatic_attributes,
    swig_gsMouseButtonAbstract_Sf_SwigStatic_constants,
    swig_gsMouseButtonAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsMouseButtonAbstract_bases[] = {0,0};
static const char *swig_gsMouseButtonAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsMouseButtonAbstract = { "gsMouseButtonAbstract", "gsMouseButtonAbstract", &SWIGTYPE_p_gsMouseButtonAbstract,_proxy__wrap_new_gsMouseButtonAbstract, swig_delete_gsMouseButtonAbstract, swig_gsMouseButtonAbstract_methods, swig_gsMouseButtonAbstract_attributes, &swig_gsMouseButtonAbstract_Sf_SwigStatic, swig_gsMouseButtonAbstract_meta, swig_gsMouseButtonAbstract_bases, swig_gsMouseButtonAbstract_base_names };

static int _wrap_new_gsDeltaNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkDeltaNodeAbstract *arg1 = (gkDeltaNodeAbstract *) 0 ;
  gsDeltaNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsDeltaNodeAbstract::gsDeltaNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDeltaNodeAbstract::gsDeltaNodeAbstract",1,"gkDeltaNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkDeltaNodeAbstract,0))){
    SWIG_fail_ptr("new_gsDeltaNodeAbstract",1,SWIGTYPE_p_gkDeltaNodeAbstract);
  }
  
  result = (gsDeltaNodeAbstract *)new gsDeltaNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDeltaNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsDeltaNodeAbstract_getPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsDeltaNodeAbstract *arg1 = (gsDeltaNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsDeltaNodeAbstract::getPropTYPE",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDeltaNodeAbstract::getPropTYPE",1,"gsDeltaNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDeltaNodeAbstract,0))){
    SWIG_fail_ptr("gsDeltaNodeAbstract_getPropTYPE",1,SWIGTYPE_p_gsDeltaNodeAbstract);
  }
  
  result = (int)(arg1)->getPropTYPE();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsDeltaNodeAbstract_setPropTYPE(lua_State* L) {
  int SWIG_arg = 0;
  gsDeltaNodeAbstract *arg1 = (gsDeltaNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsDeltaNodeAbstract::setPropTYPE",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDeltaNodeAbstract::setPropTYPE",1,"gsDeltaNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsDeltaNodeAbstract::setPropTYPE",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDeltaNodeAbstract,0))){
    SWIG_fail_ptr("gsDeltaNodeAbstract_setPropTYPE",1,SWIGTYPE_p_gsDeltaNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropTYPE(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsDeltaNodeAbstract_getPropDAMPING(lua_State* L) {
  int SWIG_arg = 0;
  gsDeltaNodeAbstract *arg1 = (gsDeltaNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsDeltaNodeAbstract::getPropDAMPING",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDeltaNodeAbstract::getPropDAMPING",1,"gsDeltaNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDeltaNodeAbstract,0))){
    SWIG_fail_ptr("gsDeltaNodeAbstract_getPropDAMPING",1,SWIGTYPE_p_gsDeltaNodeAbstract);
  }
  
  result = (float)(arg1)->getPropDAMPING();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsDeltaNodeAbstract_setPropDAMPING(lua_State* L) {
  int SWIG_arg = 0;
  gsDeltaNodeAbstract *arg1 = (gsDeltaNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsDeltaNodeAbstract::setPropDAMPING",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDeltaNodeAbstract::setPropDAMPING",1,"gsDeltaNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsDeltaNodeAbstract::setPropDAMPING",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDeltaNodeAbstract,0))){
    SWIG_fail_ptr("gsDeltaNodeAbstract_setPropDAMPING",1,SWIGTYPE_p_gsDeltaNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropDAMPING(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsDeltaNodeAbstract(void *obj) {
gsDeltaNodeAbstract *arg1 = (gsDeltaNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsDeltaNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsDeltaNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsDeltaNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsDeltaNodeAbstract_methods[]= {
    { "getPropTYPE", _wrap_gsDeltaNodeAbstract_getPropTYPE},
    { "setPropTYPE", _wrap_gsDeltaNodeAbstract_setPropTYPE},
    { "getPropDAMPING", _wrap_gsDeltaNodeAbstract_getPropDAMPING},
    { "setPropDAMPING", _wrap_gsDeltaNodeAbstract_setPropDAMPING},
    {0,0}
};
static swig_lua_method swig_gsDeltaNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsDeltaNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsDeltaNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsDeltaNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsDeltaNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsDeltaNodeAbstract_Sf_SwigStatic = {
    "gsDeltaNodeAbstract",
    swig_gsDeltaNodeAbstract_Sf_SwigStatic_methods,
    swig_gsDeltaNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsDeltaNodeAbstract_Sf_SwigStatic_constants,
    swig_gsDeltaNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsDeltaNodeAbstract_bases[] = {0,0};
static const char *swig_gsDeltaNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsDeltaNodeAbstract = { "gsDeltaNodeAbstract", "gsDeltaNodeAbstract", &SWIGTYPE_p_gsDeltaNodeAbstract,_proxy__wrap_new_gsDeltaNodeAbstract, swig_delete_gsDeltaNodeAbstract, swig_gsDeltaNodeAbstract_methods, swig_gsDeltaNodeAbstract_attributes, &swig_gsDeltaNodeAbstract_Sf_SwigStatic, swig_gsDeltaNodeAbstract_meta, swig_gsDeltaNodeAbstract_bases, swig_gsDeltaNodeAbstract_base_names };

static int _wrap_new_gsTypeColorAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTypeColorAbstract *arg1 = (gkTypeColorAbstract *) 0 ;
  gsTypeColorAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTypeColorAbstract::gsTypeColorAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTypeColorAbstract::gsTypeColorAbstract",1,"gkTypeColorAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTypeColorAbstract,0))){
    SWIG_fail_ptr("new_gsTypeColorAbstract",1,SWIGTYPE_p_gkTypeColorAbstract);
  }
  
  result = (gsTypeColorAbstract *)new gsTypeColorAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTypeColorAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTypeColorAbstract(void *obj) {
gsTypeColorAbstract *arg1 = (gsTypeColorAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTypeColorAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTypeColorAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTypeColorAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTypeColorAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsTypeColorAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTypeColorAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTypeColorAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTypeColorAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTypeColorAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTypeColorAbstract_Sf_SwigStatic = {
    "gsTypeColorAbstract",
    swig_gsTypeColorAbstract_Sf_SwigStatic_methods,
    swig_gsTypeColorAbstract_Sf_SwigStatic_attributes,
    swig_gsTypeColorAbstract_Sf_SwigStatic_constants,
    swig_gsTypeColorAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTypeColorAbstract_bases[] = {0,0};
static const char *swig_gsTypeColorAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTypeColorAbstract = { "gsTypeColorAbstract", "gsTypeColorAbstract", &SWIGTYPE_p_gsTypeColorAbstract,_proxy__wrap_new_gsTypeColorAbstract, swig_delete_gsTypeColorAbstract, swig_gsTypeColorAbstract_methods, swig_gsTypeColorAbstract_attributes, &swig_gsTypeColorAbstract_Sf_SwigStatic, swig_gsTypeColorAbstract_meta, swig_gsTypeColorAbstract_bases, swig_gsTypeColorAbstract_base_names };

static int _wrap_new_gsTypeIntAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTypeIntAbstract *arg1 = (gkTypeIntAbstract *) 0 ;
  gsTypeIntAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTypeIntAbstract::gsTypeIntAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTypeIntAbstract::gsTypeIntAbstract",1,"gkTypeIntAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTypeIntAbstract,0))){
    SWIG_fail_ptr("new_gsTypeIntAbstract",1,SWIGTYPE_p_gkTypeIntAbstract);
  }
  
  result = (gsTypeIntAbstract *)new gsTypeIntAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTypeIntAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTypeIntAbstract(void *obj) {
gsTypeIntAbstract *arg1 = (gsTypeIntAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTypeIntAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTypeIntAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTypeIntAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTypeIntAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsTypeIntAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTypeIntAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTypeIntAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTypeIntAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTypeIntAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTypeIntAbstract_Sf_SwigStatic = {
    "gsTypeIntAbstract",
    swig_gsTypeIntAbstract_Sf_SwigStatic_methods,
    swig_gsTypeIntAbstract_Sf_SwigStatic_attributes,
    swig_gsTypeIntAbstract_Sf_SwigStatic_constants,
    swig_gsTypeIntAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTypeIntAbstract_bases[] = {0,0};
static const char *swig_gsTypeIntAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTypeIntAbstract = { "gsTypeIntAbstract", "gsTypeIntAbstract", &SWIGTYPE_p_gsTypeIntAbstract,_proxy__wrap_new_gsTypeIntAbstract, swig_delete_gsTypeIntAbstract, swig_gsTypeIntAbstract_methods, swig_gsTypeIntAbstract_attributes, &swig_gsTypeIntAbstract_Sf_SwigStatic, swig_gsTypeIntAbstract_meta, swig_gsTypeIntAbstract_bases, swig_gsTypeIntAbstract_base_names };

static int _wrap_new_gsTypeFloatAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTypeFloatAbstract *arg1 = (gkTypeFloatAbstract *) 0 ;
  gsTypeFloatAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTypeFloatAbstract::gsTypeFloatAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTypeFloatAbstract::gsTypeFloatAbstract",1,"gkTypeFloatAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTypeFloatAbstract,0))){
    SWIG_fail_ptr("new_gsTypeFloatAbstract",1,SWIGTYPE_p_gkTypeFloatAbstract);
  }
  
  result = (gsTypeFloatAbstract *)new gsTypeFloatAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTypeFloatAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTypeFloatAbstract(void *obj) {
gsTypeFloatAbstract *arg1 = (gsTypeFloatAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTypeFloatAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTypeFloatAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTypeFloatAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTypeFloatAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsTypeFloatAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTypeFloatAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTypeFloatAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTypeFloatAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTypeFloatAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTypeFloatAbstract_Sf_SwigStatic = {
    "gsTypeFloatAbstract",
    swig_gsTypeFloatAbstract_Sf_SwigStatic_methods,
    swig_gsTypeFloatAbstract_Sf_SwigStatic_attributes,
    swig_gsTypeFloatAbstract_Sf_SwigStatic_constants,
    swig_gsTypeFloatAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTypeFloatAbstract_bases[] = {0,0};
static const char *swig_gsTypeFloatAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTypeFloatAbstract = { "gsTypeFloatAbstract", "gsTypeFloatAbstract", &SWIGTYPE_p_gsTypeFloatAbstract,_proxy__wrap_new_gsTypeFloatAbstract, swig_delete_gsTypeFloatAbstract, swig_gsTypeFloatAbstract_methods, swig_gsTypeFloatAbstract_attributes, &swig_gsTypeFloatAbstract_Sf_SwigStatic, swig_gsTypeFloatAbstract_meta, swig_gsTypeFloatAbstract_bases, swig_gsTypeFloatAbstract_base_names };

static int _wrap_new_gsTypeBoolAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkTypeBoolAbstract *arg1 = (gkTypeBoolAbstract *) 0 ;
  gsTypeBoolAbstract *result = 0 ;
  
  SWIG_check_num_args("gsTypeBoolAbstract::gsTypeBoolAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTypeBoolAbstract::gsTypeBoolAbstract",1,"gkTypeBoolAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkTypeBoolAbstract,0))){
    SWIG_fail_ptr("new_gsTypeBoolAbstract",1,SWIGTYPE_p_gkTypeBoolAbstract);
  }
  
  result = (gsTypeBoolAbstract *)new gsTypeBoolAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTypeBoolAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTypeBoolAbstract(void *obj) {
gsTypeBoolAbstract *arg1 = (gsTypeBoolAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTypeBoolAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTypeBoolAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTypeBoolAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTypeBoolAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsTypeBoolAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTypeBoolAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTypeBoolAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTypeBoolAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTypeBoolAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTypeBoolAbstract_Sf_SwigStatic = {
    "gsTypeBoolAbstract",
    swig_gsTypeBoolAbstract_Sf_SwigStatic_methods,
    swig_gsTypeBoolAbstract_Sf_SwigStatic_attributes,
    swig_gsTypeBoolAbstract_Sf_SwigStatic_constants,
    swig_gsTypeBoolAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTypeBoolAbstract_bases[] = {0,0};
static const char *swig_gsTypeBoolAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsTypeBoolAbstract = { "gsTypeBoolAbstract", "gsTypeBoolAbstract", &SWIGTYPE_p_gsTypeBoolAbstract,_proxy__wrap_new_gsTypeBoolAbstract, swig_delete_gsTypeBoolAbstract, swig_gsTypeBoolAbstract_methods, swig_gsTypeBoolAbstract_attributes, &swig_gsTypeBoolAbstract_Sf_SwigStatic, swig_gsTypeBoolAbstract_meta, swig_gsTypeBoolAbstract_bases, swig_gsTypeBoolAbstract_base_names };

static int _wrap_new_gsPBSMaterialAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSMaterialAbstract *arg1 = (gkPBSMaterialAbstract *) 0 ;
  gsPBSMaterialAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSMaterialAbstract::gsPBSMaterialAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSMaterialAbstract::gsPBSMaterialAbstract",1,"gkPBSMaterialAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSMaterialAbstract,0))){
    SWIG_fail_ptr("new_gsPBSMaterialAbstract",1,SWIGTYPE_p_gkPBSMaterialAbstract);
  }
  
  result = (gsPBSMaterialAbstract *)new gsPBSMaterialAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSMaterialAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSMaterialAbstract(void *obj) {
gsPBSMaterialAbstract *arg1 = (gsPBSMaterialAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSMaterialAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSMaterialAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSMaterialAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSMaterialAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsPBSMaterialAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSMaterialAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSMaterialAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSMaterialAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSMaterialAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSMaterialAbstract_Sf_SwigStatic = {
    "gsPBSMaterialAbstract",
    swig_gsPBSMaterialAbstract_Sf_SwigStatic_methods,
    swig_gsPBSMaterialAbstract_Sf_SwigStatic_attributes,
    swig_gsPBSMaterialAbstract_Sf_SwigStatic_constants,
    swig_gsPBSMaterialAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSMaterialAbstract_bases[] = {0,0};
static const char *swig_gsPBSMaterialAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSMaterialAbstract = { "gsPBSMaterialAbstract", "gsPBSMaterialAbstract", &SWIGTYPE_p_gsPBSMaterialAbstract,_proxy__wrap_new_gsPBSMaterialAbstract, swig_delete_gsPBSMaterialAbstract, swig_gsPBSMaterialAbstract_methods, swig_gsPBSMaterialAbstract_attributes, &swig_gsPBSMaterialAbstract_Sf_SwigStatic, swig_gsPBSMaterialAbstract_meta, swig_gsPBSMaterialAbstract_bases, swig_gsPBSMaterialAbstract_base_names };

static int _wrap_new_gsPBSSlotAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSSlotAbstract *arg1 = (gkPBSSlotAbstract *) 0 ;
  gsPBSSlotAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSSlotAbstract::gsPBSSlotAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSSlotAbstract::gsPBSSlotAbstract",1,"gkPBSSlotAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSSlotAbstract,0))){
    SWIG_fail_ptr("new_gsPBSSlotAbstract",1,SWIGTYPE_p_gkPBSSlotAbstract);
  }
  
  result = (gsPBSSlotAbstract *)new gsPBSSlotAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSSlotAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSSlotAbstract(void *obj) {
gsPBSSlotAbstract *arg1 = (gsPBSSlotAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSSlotAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSSlotAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSSlotAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSSlotAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsPBSSlotAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSSlotAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSSlotAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSSlotAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSSlotAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSSlotAbstract_Sf_SwigStatic = {
    "gsPBSSlotAbstract",
    swig_gsPBSSlotAbstract_Sf_SwigStatic_methods,
    swig_gsPBSSlotAbstract_Sf_SwigStatic_attributes,
    swig_gsPBSSlotAbstract_Sf_SwigStatic_constants,
    swig_gsPBSSlotAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSSlotAbstract_bases[] = {0,0};
static const char *swig_gsPBSSlotAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSSlotAbstract = { "gsPBSSlotAbstract", "gsPBSSlotAbstract", &SWIGTYPE_p_gsPBSSlotAbstract,_proxy__wrap_new_gsPBSSlotAbstract, swig_delete_gsPBSSlotAbstract, swig_gsPBSSlotAbstract_methods, swig_gsPBSSlotAbstract_attributes, &swig_gsPBSSlotAbstract_Sf_SwigStatic, swig_gsPBSSlotAbstract_meta, swig_gsPBSSlotAbstract_bases, swig_gsPBSSlotAbstract_base_names };

static int _wrap_new_gsPBSTex_AlbedoAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSTex_AlbedoAbstract *arg1 = (gkPBSTex_AlbedoAbstract *) 0 ;
  gsPBSTex_AlbedoAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::gsPBSTex_AlbedoAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::gsPBSTex_AlbedoAbstract",1,"gkPBSTex_AlbedoAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("new_gsPBSTex_AlbedoAbstract",1,SWIGTYPE_p_gkPBSTex_AlbedoAbstract);
  }
  
  result = (gsPBSTex_AlbedoAbstract *)new gsPBSTex_AlbedoAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_getPropALBEDO_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::getPropALBEDO_MAP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::getPropALBEDO_MAP",1,"gsPBSTex_AlbedoAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_getPropALBEDO_MAP",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  result = (arg1)->getPropALBEDO_MAP();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_setPropALBEDO_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::setPropALBEDO_MAP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropALBEDO_MAP",1,"gsPBSTex_AlbedoAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropALBEDO_MAP",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_setPropALBEDO_MAP",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropALBEDO_MAP((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_getPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::getPropPATH",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::getPropPATH",1,"gsPBSTex_AlbedoAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_getPropPATH",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  result = (arg1)->getPropPATH();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_setPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::setPropPATH",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropPATH",1,"gsPBSTex_AlbedoAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropPATH",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_setPropPATH",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPATH((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_getPropBLEND_FUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::getPropBLEND_FUNC",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::getPropBLEND_FUNC",1,"gsPBSTex_AlbedoAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_getPropBLEND_FUNC",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  result = (int)(arg1)->getPropBLEND_FUNC();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_AlbedoAbstract_setPropBLEND_FUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPBSTex_AlbedoAbstract::setPropBLEND_FUNC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropBLEND_FUNC",1,"gsPBSTex_AlbedoAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPBSTex_AlbedoAbstract::setPropBLEND_FUNC",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_AlbedoAbstract_setPropBLEND_FUNC",1,SWIGTYPE_p_gsPBSTex_AlbedoAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropBLEND_FUNC(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSTex_AlbedoAbstract(void *obj) {
gsPBSTex_AlbedoAbstract *arg1 = (gsPBSTex_AlbedoAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSTex_AlbedoAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSTex_AlbedoAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSTex_AlbedoAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSTex_AlbedoAbstract_methods[]= {
    { "getPropALBEDO_MAP", _wrap_gsPBSTex_AlbedoAbstract_getPropALBEDO_MAP},
    { "setPropALBEDO_MAP", _wrap_gsPBSTex_AlbedoAbstract_setPropALBEDO_MAP},
    { "getPropPATH", _wrap_gsPBSTex_AlbedoAbstract_getPropPATH},
    { "setPropPATH", _wrap_gsPBSTex_AlbedoAbstract_setPropPATH},
    { "getPropBLEND_FUNC", _wrap_gsPBSTex_AlbedoAbstract_getPropBLEND_FUNC},
    { "setPropBLEND_FUNC", _wrap_gsPBSTex_AlbedoAbstract_setPropBLEND_FUNC},
    {0,0}
};
static swig_lua_method swig_gsPBSTex_AlbedoAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic = {
    "gsPBSTex_AlbedoAbstract",
    swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_methods,
    swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_attributes,
    swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_constants,
    swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSTex_AlbedoAbstract_bases[] = {0,0};
static const char *swig_gsPBSTex_AlbedoAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSTex_AlbedoAbstract = { "gsPBSTex_AlbedoAbstract", "gsPBSTex_AlbedoAbstract", &SWIGTYPE_p_gsPBSTex_AlbedoAbstract,_proxy__wrap_new_gsPBSTex_AlbedoAbstract, swig_delete_gsPBSTex_AlbedoAbstract, swig_gsPBSTex_AlbedoAbstract_methods, swig_gsPBSTex_AlbedoAbstract_attributes, &swig_gsPBSTex_AlbedoAbstract_Sf_SwigStatic, swig_gsPBSTex_AlbedoAbstract_meta, swig_gsPBSTex_AlbedoAbstract_bases, swig_gsPBSTex_AlbedoAbstract_base_names };

static int _wrap_new_gsPBSTex_EnvAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSTex_EnvAbstract *arg1 = (gkPBSTex_EnvAbstract *) 0 ;
  gsPBSTex_EnvAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSTex_EnvAbstract::gsPBSTex_EnvAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_EnvAbstract::gsPBSTex_EnvAbstract",1,"gkPBSTex_EnvAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSTex_EnvAbstract,0))){
    SWIG_fail_ptr("new_gsPBSTex_EnvAbstract",1,SWIGTYPE_p_gkPBSTex_EnvAbstract);
  }
  
  result = (gsPBSTex_EnvAbstract *)new gsPBSTex_EnvAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSTex_EnvAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_EnvAbstract_getPropENV_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_EnvAbstract *arg1 = (gsPBSTex_EnvAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_EnvAbstract::getPropENV_MAP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_EnvAbstract::getPropENV_MAP",1,"gsPBSTex_EnvAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_EnvAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_EnvAbstract_getPropENV_MAP",1,SWIGTYPE_p_gsPBSTex_EnvAbstract);
  }
  
  result = (arg1)->getPropENV_MAP();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_EnvAbstract_setPropENV_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_EnvAbstract *arg1 = (gsPBSTex_EnvAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_EnvAbstract::setPropENV_MAP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_EnvAbstract::setPropENV_MAP",1,"gsPBSTex_EnvAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_EnvAbstract::setPropENV_MAP",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_EnvAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_EnvAbstract_setPropENV_MAP",1,SWIGTYPE_p_gsPBSTex_EnvAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropENV_MAP((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_EnvAbstract_getPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_EnvAbstract *arg1 = (gsPBSTex_EnvAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_EnvAbstract::getPropPATH",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_EnvAbstract::getPropPATH",1,"gsPBSTex_EnvAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_EnvAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_EnvAbstract_getPropPATH",1,SWIGTYPE_p_gsPBSTex_EnvAbstract);
  }
  
  result = (arg1)->getPropPATH();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_EnvAbstract_setPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_EnvAbstract *arg1 = (gsPBSTex_EnvAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_EnvAbstract::setPropPATH",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_EnvAbstract::setPropPATH",1,"gsPBSTex_EnvAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_EnvAbstract::setPropPATH",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_EnvAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_EnvAbstract_setPropPATH",1,SWIGTYPE_p_gsPBSTex_EnvAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPATH((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSTex_EnvAbstract(void *obj) {
gsPBSTex_EnvAbstract *arg1 = (gsPBSTex_EnvAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSTex_EnvAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSTex_EnvAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSTex_EnvAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSTex_EnvAbstract_methods[]= {
    { "getPropENV_MAP", _wrap_gsPBSTex_EnvAbstract_getPropENV_MAP},
    { "setPropENV_MAP", _wrap_gsPBSTex_EnvAbstract_setPropENV_MAP},
    { "getPropPATH", _wrap_gsPBSTex_EnvAbstract_getPropPATH},
    { "setPropPATH", _wrap_gsPBSTex_EnvAbstract_setPropPATH},
    {0,0}
};
static swig_lua_method swig_gsPBSTex_EnvAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSTex_EnvAbstract_Sf_SwigStatic = {
    "gsPBSTex_EnvAbstract",
    swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_methods,
    swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_attributes,
    swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_constants,
    swig_gsPBSTex_EnvAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSTex_EnvAbstract_bases[] = {0,0};
static const char *swig_gsPBSTex_EnvAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSTex_EnvAbstract = { "gsPBSTex_EnvAbstract", "gsPBSTex_EnvAbstract", &SWIGTYPE_p_gsPBSTex_EnvAbstract,_proxy__wrap_new_gsPBSTex_EnvAbstract, swig_delete_gsPBSTex_EnvAbstract, swig_gsPBSTex_EnvAbstract_methods, swig_gsPBSTex_EnvAbstract_attributes, &swig_gsPBSTex_EnvAbstract_Sf_SwigStatic, swig_gsPBSTex_EnvAbstract_meta, swig_gsPBSTex_EnvAbstract_bases, swig_gsPBSTex_EnvAbstract_base_names };

static int _wrap_new_gsPBSTex_NormalAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSTex_NormalAbstract *arg1 = (gkPBSTex_NormalAbstract *) 0 ;
  gsPBSTex_NormalAbstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSTex_NormalAbstract::gsPBSTex_NormalAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_NormalAbstract::gsPBSTex_NormalAbstract",1,"gkPBSTex_NormalAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSTex_NormalAbstract,0))){
    SWIG_fail_ptr("new_gsPBSTex_NormalAbstract",1,SWIGTYPE_p_gkPBSTex_NormalAbstract);
  }
  
  result = (gsPBSTex_NormalAbstract *)new gsPBSTex_NormalAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSTex_NormalAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_NormalAbstract_getPropNORMAL_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_NormalAbstract *arg1 = (gsPBSTex_NormalAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_NormalAbstract::getPropNORMAL_MAP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_NormalAbstract::getPropNORMAL_MAP",1,"gsPBSTex_NormalAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_NormalAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_NormalAbstract_getPropNORMAL_MAP",1,SWIGTYPE_p_gsPBSTex_NormalAbstract);
  }
  
  result = (arg1)->getPropNORMAL_MAP();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_NormalAbstract_setPropNORMAL_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_NormalAbstract *arg1 = (gsPBSTex_NormalAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_NormalAbstract::setPropNORMAL_MAP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_NormalAbstract::setPropNORMAL_MAP",1,"gsPBSTex_NormalAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_NormalAbstract::setPropNORMAL_MAP",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_NormalAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_NormalAbstract_setPropNORMAL_MAP",1,SWIGTYPE_p_gsPBSTex_NormalAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropNORMAL_MAP((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_NormalAbstract_getPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_NormalAbstract *arg1 = (gsPBSTex_NormalAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_NormalAbstract::getPropPATH",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_NormalAbstract::getPropPATH",1,"gsPBSTex_NormalAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_NormalAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_NormalAbstract_getPropPATH",1,SWIGTYPE_p_gsPBSTex_NormalAbstract);
  }
  
  result = (arg1)->getPropPATH();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_NormalAbstract_setPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_NormalAbstract *arg1 = (gsPBSTex_NormalAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_NormalAbstract::setPropPATH",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_NormalAbstract::setPropPATH",1,"gsPBSTex_NormalAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_NormalAbstract::setPropPATH",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_NormalAbstract,0))){
    SWIG_fail_ptr("gsPBSTex_NormalAbstract_setPropPATH",1,SWIGTYPE_p_gsPBSTex_NormalAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPATH((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSTex_NormalAbstract(void *obj) {
gsPBSTex_NormalAbstract *arg1 = (gsPBSTex_NormalAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSTex_NormalAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSTex_NormalAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSTex_NormalAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSTex_NormalAbstract_methods[]= {
    { "getPropNORMAL_MAP", _wrap_gsPBSTex_NormalAbstract_getPropNORMAL_MAP},
    { "setPropNORMAL_MAP", _wrap_gsPBSTex_NormalAbstract_setPropNORMAL_MAP},
    { "getPropPATH", _wrap_gsPBSTex_NormalAbstract_getPropPATH},
    { "setPropPATH", _wrap_gsPBSTex_NormalAbstract_setPropPATH},
    {0,0}
};
static swig_lua_method swig_gsPBSTex_NormalAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSTex_NormalAbstract_Sf_SwigStatic = {
    "gsPBSTex_NormalAbstract",
    swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_methods,
    swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_attributes,
    swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_constants,
    swig_gsPBSTex_NormalAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSTex_NormalAbstract_bases[] = {0,0};
static const char *swig_gsPBSTex_NormalAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSTex_NormalAbstract = { "gsPBSTex_NormalAbstract", "gsPBSTex_NormalAbstract", &SWIGTYPE_p_gsPBSTex_NormalAbstract,_proxy__wrap_new_gsPBSTex_NormalAbstract, swig_delete_gsPBSTex_NormalAbstract, swig_gsPBSTex_NormalAbstract_methods, swig_gsPBSTex_NormalAbstract_attributes, &swig_gsPBSTex_NormalAbstract_Sf_SwigStatic, swig_gsPBSTex_NormalAbstract_meta, swig_gsPBSTex_NormalAbstract_bases, swig_gsPBSTex_NormalAbstract_base_names };

static int _wrap_new_gsPBSTex_F0Abstract(lua_State* L) {
  int SWIG_arg = 0;
  gkPBSTex_F0Abstract *arg1 = (gkPBSTex_F0Abstract *) 0 ;
  gsPBSTex_F0Abstract *result = 0 ;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::gsPBSTex_F0Abstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::gsPBSTex_F0Abstract",1,"gkPBSTex_F0Abstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("new_gsPBSTex_F0Abstract",1,SWIGTYPE_p_gkPBSTex_F0Abstract);
  }
  
  result = (gsPBSTex_F0Abstract *)new gsPBSTex_F0Abstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsPBSTex_F0Abstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_getPropF0_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::getPropF0_MAP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::getPropF0_MAP",1,"gsPBSTex_F0Abstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_getPropF0_MAP",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  result = (arg1)->getPropF0_MAP();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_setPropF0_MAP(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::setPropF0_MAP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropF0_MAP",1,"gsPBSTex_F0Abstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropF0_MAP",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_setPropF0_MAP",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropF0_MAP((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_getPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::getPropPATH",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::getPropPATH",1,"gsPBSTex_F0Abstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_getPropPATH",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  result = (arg1)->getPropPATH();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_setPropPATH(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::setPropPATH",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropPATH",1,"gsPBSTex_F0Abstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropPATH",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_setPropPATH",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropPATH((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_getPropBLEND_FUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::getPropBLEND_FUNC",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::getPropBLEND_FUNC",1,"gsPBSTex_F0Abstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_getPropBLEND_FUNC",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  result = (int)(arg1)->getPropBLEND_FUNC();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsPBSTex_F0Abstract_setPropBLEND_FUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsPBSTex_F0Abstract::setPropBLEND_FUNC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropBLEND_FUNC",1,"gsPBSTex_F0Abstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsPBSTex_F0Abstract::setPropBLEND_FUNC",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsPBSTex_F0Abstract,0))){
    SWIG_fail_ptr("gsPBSTex_F0Abstract_setPropBLEND_FUNC",1,SWIGTYPE_p_gsPBSTex_F0Abstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropBLEND_FUNC(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsPBSTex_F0Abstract(void *obj) {
gsPBSTex_F0Abstract *arg1 = (gsPBSTex_F0Abstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsPBSTex_F0Abstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsPBSTex_F0Abstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsPBSTex_F0Abstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsPBSTex_F0Abstract_methods[]= {
    { "getPropF0_MAP", _wrap_gsPBSTex_F0Abstract_getPropF0_MAP},
    { "setPropF0_MAP", _wrap_gsPBSTex_F0Abstract_setPropF0_MAP},
    { "getPropPATH", _wrap_gsPBSTex_F0Abstract_getPropPATH},
    { "setPropPATH", _wrap_gsPBSTex_F0Abstract_setPropPATH},
    { "getPropBLEND_FUNC", _wrap_gsPBSTex_F0Abstract_getPropBLEND_FUNC},
    { "setPropBLEND_FUNC", _wrap_gsPBSTex_F0Abstract_setPropBLEND_FUNC},
    {0,0}
};
static swig_lua_method swig_gsPBSTex_F0Abstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsPBSTex_F0Abstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsPBSTex_F0Abstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsPBSTex_F0Abstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsPBSTex_F0Abstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsPBSTex_F0Abstract_Sf_SwigStatic = {
    "gsPBSTex_F0Abstract",
    swig_gsPBSTex_F0Abstract_Sf_SwigStatic_methods,
    swig_gsPBSTex_F0Abstract_Sf_SwigStatic_attributes,
    swig_gsPBSTex_F0Abstract_Sf_SwigStatic_constants,
    swig_gsPBSTex_F0Abstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsPBSTex_F0Abstract_bases[] = {0,0};
static const char *swig_gsPBSTex_F0Abstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsPBSTex_F0Abstract = { "gsPBSTex_F0Abstract", "gsPBSTex_F0Abstract", &SWIGTYPE_p_gsPBSTex_F0Abstract,_proxy__wrap_new_gsPBSTex_F0Abstract, swig_delete_gsPBSTex_F0Abstract, swig_gsPBSTex_F0Abstract_methods, swig_gsPBSTex_F0Abstract_attributes, &swig_gsPBSTex_F0Abstract_Sf_SwigStatic, swig_gsPBSTex_F0Abstract_meta, swig_gsPBSTex_F0Abstract_bases, swig_gsPBSTex_F0Abstract_base_names };

static int _wrap_new_gsEngineNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkEngineNodeAbstract *arg1 = (gkEngineNodeAbstract *) 0 ;
  gsEngineNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsEngineNodeAbstract::gsEngineNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsEngineNodeAbstract::gsEngineNodeAbstract",1,"gkEngineNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkEngineNodeAbstract,0))){
    SWIG_fail_ptr("new_gsEngineNodeAbstract",1,SWIGTYPE_p_gkEngineNodeAbstract);
  }
  
  result = (gsEngineNodeAbstract *)new gsEngineNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsEngineNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsEngineNodeAbstract(void *obj) {
gsEngineNodeAbstract *arg1 = (gsEngineNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsEngineNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsEngineNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsEngineNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsEngineNodeAbstract_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsEngineNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsEngineNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsEngineNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsEngineNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsEngineNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsEngineNodeAbstract_Sf_SwigStatic = {
    "gsEngineNodeAbstract",
    swig_gsEngineNodeAbstract_Sf_SwigStatic_methods,
    swig_gsEngineNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsEngineNodeAbstract_Sf_SwigStatic_constants,
    swig_gsEngineNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsEngineNodeAbstract_bases[] = {0,0};
static const char *swig_gsEngineNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsEngineNodeAbstract = { "gsEngineNodeAbstract", "gsEngineNodeAbstract", &SWIGTYPE_p_gsEngineNodeAbstract,_proxy__wrap_new_gsEngineNodeAbstract, swig_delete_gsEngineNodeAbstract, swig_gsEngineNodeAbstract_methods, swig_gsEngineNodeAbstract_attributes, &swig_gsEngineNodeAbstract_Sf_SwigStatic, swig_gsEngineNodeAbstract_meta, swig_gsEngineNodeAbstract_bases, swig_gsEngineNodeAbstract_base_names };

static int _wrap_new_gsIfNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkIfNodeAbstract *arg1 = (gkIfNodeAbstract *) 0 ;
  gsIfNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsIfNodeAbstract::gsIfNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsIfNodeAbstract::gsIfNodeAbstract",1,"gkIfNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkIfNodeAbstract,0))){
    SWIG_fail_ptr("new_gsIfNodeAbstract",1,SWIGTYPE_p_gkIfNodeAbstract);
  }
  
  result = (gsIfNodeAbstract *)new gsIfNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsIfNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsIfNodeAbstract_getPropFUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsIfNodeAbstract *arg1 = (gsIfNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsIfNodeAbstract::getPropFUNC",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsIfNodeAbstract::getPropFUNC",1,"gsIfNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsIfNodeAbstract,0))){
    SWIG_fail_ptr("gsIfNodeAbstract_getPropFUNC",1,SWIGTYPE_p_gsIfNodeAbstract);
  }
  
  result = (int)(arg1)->getPropFUNC();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsIfNodeAbstract_setPropFUNC(lua_State* L) {
  int SWIG_arg = 0;
  gsIfNodeAbstract *arg1 = (gsIfNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsIfNodeAbstract::setPropFUNC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsIfNodeAbstract::setPropFUNC",1,"gsIfNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsIfNodeAbstract::setPropFUNC",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsIfNodeAbstract,0))){
    SWIG_fail_ptr("gsIfNodeAbstract_setPropFUNC",1,SWIGTYPE_p_gsIfNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropFUNC(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsIfNodeAbstract(void *obj) {
gsIfNodeAbstract *arg1 = (gsIfNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsIfNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsIfNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsIfNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsIfNodeAbstract_methods[]= {
    { "getPropFUNC", _wrap_gsIfNodeAbstract_getPropFUNC},
    { "setPropFUNC", _wrap_gsIfNodeAbstract_setPropFUNC},
    {0,0}
};
static swig_lua_method swig_gsIfNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsIfNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsIfNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsIfNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsIfNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsIfNodeAbstract_Sf_SwigStatic = {
    "gsIfNodeAbstract",
    swig_gsIfNodeAbstract_Sf_SwigStatic_methods,
    swig_gsIfNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsIfNodeAbstract_Sf_SwigStatic_constants,
    swig_gsIfNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsIfNodeAbstract_bases[] = {0,0};
static const char *swig_gsIfNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsIfNodeAbstract = { "gsIfNodeAbstract", "gsIfNodeAbstract", &SWIGTYPE_p_gsIfNodeAbstract,_proxy__wrap_new_gsIfNodeAbstract, swig_delete_gsIfNodeAbstract, swig_gsIfNodeAbstract_methods, swig_gsIfNodeAbstract_attributes, &swig_gsIfNodeAbstract_Sf_SwigStatic, swig_gsIfNodeAbstract_meta, swig_gsIfNodeAbstract_bases, swig_gsIfNodeAbstract_base_names };

static int _wrap_new_gsSoundNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkSoundNodeAbstract *arg1 = (gkSoundNodeAbstract *) 0 ;
  gsSoundNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsSoundNodeAbstract::gsSoundNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundNodeAbstract::gsSoundNodeAbstract",1,"gkSoundNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSoundNodeAbstract,0))){
    SWIG_fail_ptr("new_gsSoundNodeAbstract",1,SWIGTYPE_p_gkSoundNodeAbstract);
  }
  
  result = (gsSoundNodeAbstract *)new gsSoundNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSoundNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSoundNodeAbstract_getPropFILEP(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundNodeAbstract *arg1 = (gsSoundNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsSoundNodeAbstract::getPropFILEP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundNodeAbstract::getPropFILEP",1,"gsSoundNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundNodeAbstract,0))){
    SWIG_fail_ptr("gsSoundNodeAbstract_getPropFILEP",1,SWIGTYPE_p_gsSoundNodeAbstract);
  }
  
  result = (arg1)->getPropFILEP();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsSoundNodeAbstract_setPropFILEP(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundNodeAbstract *arg1 = (gsSoundNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsSoundNodeAbstract::setPropFILEP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundNodeAbstract::setPropFILEP",1,"gsSoundNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundNodeAbstract::setPropFILEP",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundNodeAbstract,0))){
    SWIG_fail_ptr("gsSoundNodeAbstract_setPropFILEP",1,SWIGTYPE_p_gsSoundNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropFILEP((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSoundNodeAbstract(void *obj) {
gsSoundNodeAbstract *arg1 = (gsSoundNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSoundNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSoundNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSoundNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSoundNodeAbstract_methods[]= {
    { "getPropFILEP", _wrap_gsSoundNodeAbstract_getPropFILEP},
    { "setPropFILEP", _wrap_gsSoundNodeAbstract_setPropFILEP},
    {0,0}
};
static swig_lua_method swig_gsSoundNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSoundNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSoundNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSoundNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSoundNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSoundNodeAbstract_Sf_SwigStatic = {
    "gsSoundNodeAbstract",
    swig_gsSoundNodeAbstract_Sf_SwigStatic_methods,
    swig_gsSoundNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsSoundNodeAbstract_Sf_SwigStatic_constants,
    swig_gsSoundNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSoundNodeAbstract_bases[] = {0,0};
static const char *swig_gsSoundNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsSoundNodeAbstract = { "gsSoundNodeAbstract", "gsSoundNodeAbstract", &SWIGTYPE_p_gsSoundNodeAbstract,_proxy__wrap_new_gsSoundNodeAbstract, swig_delete_gsSoundNodeAbstract, swig_gsSoundNodeAbstract_methods, swig_gsSoundNodeAbstract_attributes, &swig_gsSoundNodeAbstract_Sf_SwigStatic, swig_gsSoundNodeAbstract_meta, swig_gsSoundNodeAbstract_bases, swig_gsSoundNodeAbstract_base_names };

static int _wrap_new_gsJoystickNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkJoystickNodeAbstract *arg1 = (gkJoystickNodeAbstract *) 0 ;
  gsJoystickNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsJoystickNodeAbstract::gsJoystickNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickNodeAbstract::gsJoystickNodeAbstract",1,"gkJoystickNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkJoystickNodeAbstract,0))){
    SWIG_fail_ptr("new_gsJoystickNodeAbstract",1,SWIGTYPE_p_gkJoystickNodeAbstract);
  }
  
  result = (gsJoystickNodeAbstract *)new gsJoystickNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsJoystickNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickNodeAbstract_getPropdeathZoneMin(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickNodeAbstract *arg1 = (gsJoystickNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystickNodeAbstract::getPropdeathZoneMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickNodeAbstract::getPropdeathZoneMin",1,"gsJoystickNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickNodeAbstract,0))){
    SWIG_fail_ptr("gsJoystickNodeAbstract_getPropdeathZoneMin",1,SWIGTYPE_p_gsJoystickNodeAbstract);
  }
  
  result = (int)(arg1)->getPropdeathZoneMin();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickNodeAbstract_setPropdeathZoneMin(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickNodeAbstract *arg1 = (gsJoystickNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsJoystickNodeAbstract::setPropdeathZoneMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickNodeAbstract::setPropdeathZoneMin",1,"gsJoystickNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystickNodeAbstract::setPropdeathZoneMin",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickNodeAbstract,0))){
    SWIG_fail_ptr("gsJoystickNodeAbstract_setPropdeathZoneMin",1,SWIGTYPE_p_gsJoystickNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropdeathZoneMin(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickNodeAbstract_getPropdeathZoneMax(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickNodeAbstract *arg1 = (gsJoystickNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystickNodeAbstract::getPropdeathZoneMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickNodeAbstract::getPropdeathZoneMax",1,"gsJoystickNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickNodeAbstract,0))){
    SWIG_fail_ptr("gsJoystickNodeAbstract_getPropdeathZoneMax",1,SWIGTYPE_p_gsJoystickNodeAbstract);
  }
  
  result = (int)(arg1)->getPropdeathZoneMax();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickNodeAbstract_setPropdeathZoneMax(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickNodeAbstract *arg1 = (gsJoystickNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsJoystickNodeAbstract::setPropdeathZoneMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickNodeAbstract::setPropdeathZoneMax",1,"gsJoystickNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystickNodeAbstract::setPropdeathZoneMax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickNodeAbstract,0))){
    SWIG_fail_ptr("gsJoystickNodeAbstract_setPropdeathZoneMax",1,SWIGTYPE_p_gsJoystickNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropdeathZoneMax(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsJoystickNodeAbstract(void *obj) {
gsJoystickNodeAbstract *arg1 = (gsJoystickNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsJoystickNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsJoystickNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsJoystickNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsJoystickNodeAbstract_methods[]= {
    { "getPropdeathZoneMin", _wrap_gsJoystickNodeAbstract_getPropdeathZoneMin},
    { "setPropdeathZoneMin", _wrap_gsJoystickNodeAbstract_setPropdeathZoneMin},
    { "getPropdeathZoneMax", _wrap_gsJoystickNodeAbstract_getPropdeathZoneMax},
    { "setPropdeathZoneMax", _wrap_gsJoystickNodeAbstract_setPropdeathZoneMax},
    {0,0}
};
static swig_lua_method swig_gsJoystickNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsJoystickNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsJoystickNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsJoystickNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsJoystickNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsJoystickNodeAbstract_Sf_SwigStatic = {
    "gsJoystickNodeAbstract",
    swig_gsJoystickNodeAbstract_Sf_SwigStatic_methods,
    swig_gsJoystickNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsJoystickNodeAbstract_Sf_SwigStatic_constants,
    swig_gsJoystickNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsJoystickNodeAbstract_bases[] = {0,0};
static const char *swig_gsJoystickNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsJoystickNodeAbstract = { "gsJoystickNodeAbstract", "gsJoystickNodeAbstract", &SWIGTYPE_p_gsJoystickNodeAbstract,_proxy__wrap_new_gsJoystickNodeAbstract, swig_delete_gsJoystickNodeAbstract, swig_gsJoystickNodeAbstract_methods, swig_gsJoystickNodeAbstract_attributes, &swig_gsJoystickNodeAbstract_Sf_SwigStatic, swig_gsJoystickNodeAbstract_meta, swig_gsJoystickNodeAbstract_bases, swig_gsJoystickNodeAbstract_base_names };

static int _wrap_new_gsJoystickButtonAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkJoystickButtonAbstract *arg1 = (gkJoystickButtonAbstract *) 0 ;
  gsJoystickButtonAbstract *result = 0 ;
  
  SWIG_check_num_args("gsJoystickButtonAbstract::gsJoystickButtonAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickButtonAbstract::gsJoystickButtonAbstract",1,"gkJoystickButtonAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkJoystickButtonAbstract,0))){
    SWIG_fail_ptr("new_gsJoystickButtonAbstract",1,SWIGTYPE_p_gkJoystickButtonAbstract);
  }
  
  result = (gsJoystickButtonAbstract *)new gsJoystickButtonAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsJoystickButtonAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickButtonAbstract_getPropbuttonNr(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickButtonAbstract *arg1 = (gsJoystickButtonAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsJoystickButtonAbstract::getPropbuttonNr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickButtonAbstract::getPropbuttonNr",1,"gsJoystickButtonAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickButtonAbstract,0))){
    SWIG_fail_ptr("gsJoystickButtonAbstract_getPropbuttonNr",1,SWIGTYPE_p_gsJoystickButtonAbstract);
  }
  
  result = (int)(arg1)->getPropbuttonNr();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsJoystickButtonAbstract_setPropbuttonNr(lua_State* L) {
  int SWIG_arg = 0;
  gsJoystickButtonAbstract *arg1 = (gsJoystickButtonAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsJoystickButtonAbstract::setPropbuttonNr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsJoystickButtonAbstract::setPropbuttonNr",1,"gsJoystickButtonAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsJoystickButtonAbstract::setPropbuttonNr",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsJoystickButtonAbstract,0))){
    SWIG_fail_ptr("gsJoystickButtonAbstract_setPropbuttonNr",1,SWIGTYPE_p_gsJoystickButtonAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropbuttonNr(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsJoystickButtonAbstract(void *obj) {
gsJoystickButtonAbstract *arg1 = (gsJoystickButtonAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsJoystickButtonAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsJoystickButtonAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsJoystickButtonAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsJoystickButtonAbstract_methods[]= {
    { "getPropbuttonNr", _wrap_gsJoystickButtonAbstract_getPropbuttonNr},
    { "setPropbuttonNr", _wrap_gsJoystickButtonAbstract_setPropbuttonNr},
    {0,0}
};
static swig_lua_method swig_gsJoystickButtonAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsJoystickButtonAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsJoystickButtonAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsJoystickButtonAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsJoystickButtonAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsJoystickButtonAbstract_Sf_SwigStatic = {
    "gsJoystickButtonAbstract",
    swig_gsJoystickButtonAbstract_Sf_SwigStatic_methods,
    swig_gsJoystickButtonAbstract_Sf_SwigStatic_attributes,
    swig_gsJoystickButtonAbstract_Sf_SwigStatic_constants,
    swig_gsJoystickButtonAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsJoystickButtonAbstract_bases[] = {0,0};
static const char *swig_gsJoystickButtonAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsJoystickButtonAbstract = { "gsJoystickButtonAbstract", "gsJoystickButtonAbstract", &SWIGTYPE_p_gsJoystickButtonAbstract,_proxy__wrap_new_gsJoystickButtonAbstract, swig_delete_gsJoystickButtonAbstract, swig_gsJoystickButtonAbstract_methods, swig_gsJoystickButtonAbstract_attributes, &swig_gsJoystickButtonAbstract_Sf_SwigStatic, swig_gsJoystickButtonAbstract_meta, swig_gsJoystickButtonAbstract_bases, swig_gsJoystickButtonAbstract_base_names };

static int _wrap_new_gsVehicleNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkVehicleNodeAbstract *arg1 = (gkVehicleNodeAbstract *) 0 ;
  gsVehicleNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::gsVehicleNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::gsVehicleNodeAbstract",1,"gkVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVehicleNodeAbstract,0))){
    SWIG_fail_ptr("new_gsVehicleNodeAbstract",1,SWIGTYPE_p_gkVehicleNodeAbstract);
  }
  
  result = (gsVehicleNodeAbstract *)new gsVehicleNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVehicleNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropType(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropType",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropType",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (int)(arg1)->getPropType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropType(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropType",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropType",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropType(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropEngineTorque(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropEngineTorque",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropEngineTorque",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropEngineTorque",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (float)(arg1)->getPropEngineTorque();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropEngineTorque(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropEngineTorque",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropEngineTorque",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropEngineTorque",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropEngineTorque",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropEngineTorque(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropBreakPower(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropBreakPower",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropBreakPower",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropBreakPower",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (float)(arg1)->getPropBreakPower();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropBreakPower(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropBreakPower",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropBreakPower",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropBreakPower",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropBreakPower",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropBreakPower(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropRearBreakRatio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropRearBreakRatio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropRearBreakRatio",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropRearBreakRatio",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (float)(arg1)->getPropRearBreakRatio();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropRearBreakRatio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropRearBreakRatio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropRearBreakRatio",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropRearBreakRatio",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropRearBreakRatio",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropRearBreakRatio(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropMaxSteeringAngle(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropMaxSteeringAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropMaxSteeringAngle",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropMaxSteeringAngle",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (float)(arg1)->getPropMaxSteeringAngle();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropMaxSteeringAngle(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropMaxSteeringAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropMaxSteeringAngle",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropMaxSteeringAngle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropMaxSteeringAngle",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropMaxSteeringAngle(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_getPropRuptorRpm(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::getPropRuptorRpm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::getPropRuptorRpm",1,"gsVehicleNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_getPropRuptorRpm",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  result = (float)(arg1)->getPropRuptorRpm();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleNodeAbstract_setPropRuptorRpm(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleNodeAbstract::setPropRuptorRpm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropRuptorRpm",1,"gsVehicleNodeAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleNodeAbstract::setPropRuptorRpm",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleNodeAbstract,0))){
    SWIG_fail_ptr("gsVehicleNodeAbstract_setPropRuptorRpm",1,SWIGTYPE_p_gsVehicleNodeAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropRuptorRpm(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVehicleNodeAbstract(void *obj) {
gsVehicleNodeAbstract *arg1 = (gsVehicleNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVehicleNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVehicleNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVehicleNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVehicleNodeAbstract_methods[]= {
    { "getPropType", _wrap_gsVehicleNodeAbstract_getPropType},
    { "setPropType", _wrap_gsVehicleNodeAbstract_setPropType},
    { "getPropEngineTorque", _wrap_gsVehicleNodeAbstract_getPropEngineTorque},
    { "setPropEngineTorque", _wrap_gsVehicleNodeAbstract_setPropEngineTorque},
    { "getPropBreakPower", _wrap_gsVehicleNodeAbstract_getPropBreakPower},
    { "setPropBreakPower", _wrap_gsVehicleNodeAbstract_setPropBreakPower},
    { "getPropRearBreakRatio", _wrap_gsVehicleNodeAbstract_getPropRearBreakRatio},
    { "setPropRearBreakRatio", _wrap_gsVehicleNodeAbstract_setPropRearBreakRatio},
    { "getPropMaxSteeringAngle", _wrap_gsVehicleNodeAbstract_getPropMaxSteeringAngle},
    { "setPropMaxSteeringAngle", _wrap_gsVehicleNodeAbstract_setPropMaxSteeringAngle},
    { "getPropRuptorRpm", _wrap_gsVehicleNodeAbstract_getPropRuptorRpm},
    { "setPropRuptorRpm", _wrap_gsVehicleNodeAbstract_setPropRuptorRpm},
    {0,0}
};
static swig_lua_method swig_gsVehicleNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVehicleNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVehicleNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVehicleNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVehicleNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVehicleNodeAbstract_Sf_SwigStatic = {
    "gsVehicleNodeAbstract",
    swig_gsVehicleNodeAbstract_Sf_SwigStatic_methods,
    swig_gsVehicleNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsVehicleNodeAbstract_Sf_SwigStatic_constants,
    swig_gsVehicleNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVehicleNodeAbstract_bases[] = {0,0};
static const char *swig_gsVehicleNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsVehicleNodeAbstract = { "gsVehicleNodeAbstract", "gsVehicleNodeAbstract", &SWIGTYPE_p_gsVehicleNodeAbstract,_proxy__wrap_new_gsVehicleNodeAbstract, swig_delete_gsVehicleNodeAbstract, swig_gsVehicleNodeAbstract_methods, swig_gsVehicleNodeAbstract_attributes, &swig_gsVehicleNodeAbstract_Sf_SwigStatic, swig_gsVehicleNodeAbstract_meta, swig_gsVehicleNodeAbstract_bases, swig_gsVehicleNodeAbstract_base_names };

static int _wrap_new_gsVehicleGearboxAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkVehicleGearboxAbstract *arg1 = (gkVehicleGearboxAbstract *) 0 ;
  gsVehicleGearboxAbstract *result = 0 ;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::gsVehicleGearboxAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::gsVehicleGearboxAbstract",1,"gkVehicleGearboxAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("new_gsVehicleGearboxAbstract",1,SWIGTYPE_p_gkVehicleGearboxAbstract);
  }
  
  result = (gsVehicleGearboxAbstract *)new gsVehicleGearboxAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVehicleGearboxAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_getPropshiftTime(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::getPropshiftTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::getPropshiftTime",1,"gsVehicleGearboxAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_getPropshiftTime",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  result = (float)(arg1)->getPropshiftTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_setPropshiftTime(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::setPropshiftTime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropshiftTime",1,"gsVehicleGearboxAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropshiftTime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_setPropshiftTime",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropshiftTime(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_getPropreverseRatio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::getPropreverseRatio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::getPropreverseRatio",1,"gsVehicleGearboxAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_getPropreverseRatio",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  result = (float)(arg1)->getPropreverseRatio();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_setPropreverseRatio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::setPropreverseRatio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropreverseRatio",1,"gsVehicleGearboxAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropreverseRatio",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_setPropreverseRatio",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropreverseRatio(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_getPropautomatic(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::getPropautomatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::getPropautomatic",1,"gsVehicleGearboxAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_getPropautomatic",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  result = (bool)(arg1)->getPropautomatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearboxAbstract_setPropautomatic(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVehicleGearboxAbstract::setPropautomatic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropautomatic",1,"gsVehicleGearboxAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearboxAbstract::setPropautomatic",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearboxAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearboxAbstract_setPropautomatic",1,SWIGTYPE_p_gsVehicleGearboxAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropautomatic(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVehicleGearboxAbstract(void *obj) {
gsVehicleGearboxAbstract *arg1 = (gsVehicleGearboxAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVehicleGearboxAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVehicleGearboxAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVehicleGearboxAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVehicleGearboxAbstract_methods[]= {
    { "getPropshiftTime", _wrap_gsVehicleGearboxAbstract_getPropshiftTime},
    { "setPropshiftTime", _wrap_gsVehicleGearboxAbstract_setPropshiftTime},
    { "getPropreverseRatio", _wrap_gsVehicleGearboxAbstract_getPropreverseRatio},
    { "setPropreverseRatio", _wrap_gsVehicleGearboxAbstract_setPropreverseRatio},
    { "getPropautomatic", _wrap_gsVehicleGearboxAbstract_getPropautomatic},
    { "setPropautomatic", _wrap_gsVehicleGearboxAbstract_setPropautomatic},
    {0,0}
};
static swig_lua_method swig_gsVehicleGearboxAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVehicleGearboxAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVehicleGearboxAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVehicleGearboxAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVehicleGearboxAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVehicleGearboxAbstract_Sf_SwigStatic = {
    "gsVehicleGearboxAbstract",
    swig_gsVehicleGearboxAbstract_Sf_SwigStatic_methods,
    swig_gsVehicleGearboxAbstract_Sf_SwigStatic_attributes,
    swig_gsVehicleGearboxAbstract_Sf_SwigStatic_constants,
    swig_gsVehicleGearboxAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVehicleGearboxAbstract_bases[] = {0,0};
static const char *swig_gsVehicleGearboxAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsVehicleGearboxAbstract = { "gsVehicleGearboxAbstract", "gsVehicleGearboxAbstract", &SWIGTYPE_p_gsVehicleGearboxAbstract,_proxy__wrap_new_gsVehicleGearboxAbstract, swig_delete_gsVehicleGearboxAbstract, swig_gsVehicleGearboxAbstract_methods, swig_gsVehicleGearboxAbstract_attributes, &swig_gsVehicleGearboxAbstract_Sf_SwigStatic, swig_gsVehicleGearboxAbstract_meta, swig_gsVehicleGearboxAbstract_bases, swig_gsVehicleGearboxAbstract_base_names };

static int _wrap_new_gsVehicleGearAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkVehicleGearAbstract *arg1 = (gkVehicleGearAbstract *) 0 ;
  gsVehicleGearAbstract *result = 0 ;
  
  SWIG_check_num_args("gsVehicleGearAbstract::gsVehicleGearAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::gsVehicleGearAbstract",1,"gkVehicleGearAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVehicleGearAbstract,0))){
    SWIG_fail_ptr("new_gsVehicleGearAbstract",1,SWIGTYPE_p_gkVehicleGearAbstract);
  }
  
  result = (gsVehicleGearAbstract *)new gsVehicleGearAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVehicleGearAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_getPropratio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleGearAbstract::getPropratio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::getPropratio",1,"gsVehicleGearAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_getPropratio",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  result = (float)(arg1)->getPropratio();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_setPropratio(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleGearAbstract::setPropratio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::setPropratio",1,"gsVehicleGearAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearAbstract::setPropratio",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_setPropratio",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropratio(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_getProprpmLow(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleGearAbstract::getProprpmLow",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::getProprpmLow",1,"gsVehicleGearAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_getProprpmLow",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  result = (float)(arg1)->getProprpmLow();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_setProprpmLow(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleGearAbstract::setProprpmLow",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::setProprpmLow",1,"gsVehicleGearAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearAbstract::setProprpmLow",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_setProprpmLow",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setProprpmLow(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_getProprpmHigh(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleGearAbstract::getProprpmHigh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::getProprpmHigh",1,"gsVehicleGearAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_getProprpmHigh",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  result = (float)(arg1)->getProprpmHigh();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_setProprpmHigh(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleGearAbstract::setProprpmHigh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::setProprpmHigh",1,"gsVehicleGearAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearAbstract::setProprpmHigh",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_setProprpmHigh",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setProprpmHigh(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_getPropgearNr(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  int result;
  
  SWIG_check_num_args("gsVehicleGearAbstract::getPropgearNr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::getPropgearNr",1,"gsVehicleGearAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_getPropgearNr",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  result = (int)(arg1)->getPropgearNr();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleGearAbstract_setPropgearNr(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVehicleGearAbstract::setPropgearNr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleGearAbstract::setPropgearNr",1,"gsVehicleGearAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleGearAbstract::setPropgearNr",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleGearAbstract,0))){
    SWIG_fail_ptr("gsVehicleGearAbstract_setPropgearNr",1,SWIGTYPE_p_gsVehicleGearAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropgearNr(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVehicleGearAbstract(void *obj) {
gsVehicleGearAbstract *arg1 = (gsVehicleGearAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVehicleGearAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVehicleGearAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVehicleGearAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVehicleGearAbstract_methods[]= {
    { "getPropratio", _wrap_gsVehicleGearAbstract_getPropratio},
    { "setPropratio", _wrap_gsVehicleGearAbstract_setPropratio},
    { "getProprpmLow", _wrap_gsVehicleGearAbstract_getProprpmLow},
    { "setProprpmLow", _wrap_gsVehicleGearAbstract_setProprpmLow},
    { "getProprpmHigh", _wrap_gsVehicleGearAbstract_getProprpmHigh},
    { "setProprpmHigh", _wrap_gsVehicleGearAbstract_setProprpmHigh},
    { "getPropgearNr", _wrap_gsVehicleGearAbstract_getPropgearNr},
    { "setPropgearNr", _wrap_gsVehicleGearAbstract_setPropgearNr},
    {0,0}
};
static swig_lua_method swig_gsVehicleGearAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVehicleGearAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVehicleGearAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVehicleGearAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVehicleGearAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVehicleGearAbstract_Sf_SwigStatic = {
    "gsVehicleGearAbstract",
    swig_gsVehicleGearAbstract_Sf_SwigStatic_methods,
    swig_gsVehicleGearAbstract_Sf_SwigStatic_attributes,
    swig_gsVehicleGearAbstract_Sf_SwigStatic_constants,
    swig_gsVehicleGearAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVehicleGearAbstract_bases[] = {0,0};
static const char *swig_gsVehicleGearAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsVehicleGearAbstract = { "gsVehicleGearAbstract", "gsVehicleGearAbstract", &SWIGTYPE_p_gsVehicleGearAbstract,_proxy__wrap_new_gsVehicleGearAbstract, swig_delete_gsVehicleGearAbstract, swig_gsVehicleGearAbstract_methods, swig_gsVehicleGearAbstract_attributes, &swig_gsVehicleGearAbstract_Sf_SwigStatic, swig_gsVehicleGearAbstract_meta, swig_gsVehicleGearAbstract_bases, swig_gsVehicleGearAbstract_base_names };

static int _wrap_new_gsVehicleWheelAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkVehicleWheelAbstract *arg1 = (gkVehicleWheelAbstract *) 0 ;
  gsVehicleWheelAbstract *result = 0 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::gsVehicleWheelAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::gsVehicleWheelAbstract",1,"gkVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVehicleWheelAbstract,0))){
    SWIG_fail_ptr("new_gsVehicleWheelAbstract",1,SWIGTYPE_p_gkVehicleWheelAbstract);
  }
  
  result = (gsVehicleWheelAbstract *)new gsVehicleWheelAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVehicleWheelAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropwheelObject(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropwheelObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropwheelObject",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropwheelObject",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (arg1)->getPropwheelObject();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropwheelObject(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropwheelObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropwheelObject",1,"gsVehicleWheelAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropwheelObject",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropwheelObject",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropwheelObject((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropsuspensionTravelCm(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropsuspensionTravelCm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropsuspensionTravelCm",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropsuspensionTravelCm",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (float)(arg1)->getPropsuspensionTravelCm();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropsuspensionTravelCm(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropsuspensionTravelCm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionTravelCm",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionTravelCm",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropsuspensionTravelCm",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropsuspensionTravelCm(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropsuspensionRestLength(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropsuspensionRestLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropsuspensionRestLength",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropsuspensionRestLength",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (float)(arg1)->getPropsuspensionRestLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropsuspensionRestLength(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropsuspensionRestLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionRestLength",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionRestLength",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropsuspensionRestLength",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropsuspensionRestLength(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropsuspensionStiffness(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropsuspensionStiffness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropsuspensionStiffness",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropsuspensionStiffness",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (float)(arg1)->getPropsuspensionStiffness();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropsuspensionStiffness(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropsuspensionStiffness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionStiffness",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropsuspensionStiffness",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropsuspensionStiffness",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropsuspensionStiffness(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropfriction(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropfriction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropfriction",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropfriction",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (float)(arg1)->getPropfriction();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropfriction(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropfriction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropfriction",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropfriction",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropfriction",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPropfriction(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getProprollInfluence(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getProprollInfluence",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getProprollInfluence",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getProprollInfluence",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (float)(arg1)->getProprollInfluence();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setProprollInfluence(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setProprollInfluence",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setProprollInfluence",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setProprollInfluence",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setProprollInfluence",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setProprollInfluence(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropisFront(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropisFront",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropisFront",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropisFront",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (bool)(arg1)->getPropisFront();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropisFront(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropisFront",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropisFront",1,"gsVehicleWheelAbstract *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropisFront",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropisFront",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPropisFront(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_getPropaxis(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  gkVector3 result;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::getPropaxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::getPropaxis",1,"gsVehicleWheelAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_getPropaxis",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  result = (arg1)->getPropaxis();
  {
    gkVector3 * resultptr = new gkVector3((const gkVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gkVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicleWheelAbstract_setPropaxis(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) 0 ;
  gkVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsVehicleWheelAbstract::setPropaxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropaxis",1,"gsVehicleWheelAbstract *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsVehicleWheelAbstract::setPropaxis",2,"gkVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicleWheelAbstract,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropaxis",1,SWIGTYPE_p_gsVehicleWheelAbstract);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkVector3,0))){
    SWIG_fail_ptr("gsVehicleWheelAbstract_setPropaxis",2,SWIGTYPE_p_gkVector3);
  }
  
  (arg1)->setPropaxis((gkVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVehicleWheelAbstract(void *obj) {
gsVehicleWheelAbstract *arg1 = (gsVehicleWheelAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVehicleWheelAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVehicleWheelAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVehicleWheelAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVehicleWheelAbstract_methods[]= {
    { "getPropwheelObject", _wrap_gsVehicleWheelAbstract_getPropwheelObject},
    { "setPropwheelObject", _wrap_gsVehicleWheelAbstract_setPropwheelObject},
    { "getPropsuspensionTravelCm", _wrap_gsVehicleWheelAbstract_getPropsuspensionTravelCm},
    { "setPropsuspensionTravelCm", _wrap_gsVehicleWheelAbstract_setPropsuspensionTravelCm},
    { "getPropsuspensionRestLength", _wrap_gsVehicleWheelAbstract_getPropsuspensionRestLength},
    { "setPropsuspensionRestLength", _wrap_gsVehicleWheelAbstract_setPropsuspensionRestLength},
    { "getPropsuspensionStiffness", _wrap_gsVehicleWheelAbstract_getPropsuspensionStiffness},
    { "setPropsuspensionStiffness", _wrap_gsVehicleWheelAbstract_setPropsuspensionStiffness},
    { "getPropfriction", _wrap_gsVehicleWheelAbstract_getPropfriction},
    { "setPropfriction", _wrap_gsVehicleWheelAbstract_setPropfriction},
    { "getProprollInfluence", _wrap_gsVehicleWheelAbstract_getProprollInfluence},
    { "setProprollInfluence", _wrap_gsVehicleWheelAbstract_setProprollInfluence},
    { "getPropisFront", _wrap_gsVehicleWheelAbstract_getPropisFront},
    { "setPropisFront", _wrap_gsVehicleWheelAbstract_setPropisFront},
    { "getPropaxis", _wrap_gsVehicleWheelAbstract_getPropaxis},
    { "setPropaxis", _wrap_gsVehicleWheelAbstract_setPropaxis},
    {0,0}
};
static swig_lua_method swig_gsVehicleWheelAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVehicleWheelAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVehicleWheelAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVehicleWheelAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVehicleWheelAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVehicleWheelAbstract_Sf_SwigStatic = {
    "gsVehicleWheelAbstract",
    swig_gsVehicleWheelAbstract_Sf_SwigStatic_methods,
    swig_gsVehicleWheelAbstract_Sf_SwigStatic_attributes,
    swig_gsVehicleWheelAbstract_Sf_SwigStatic_constants,
    swig_gsVehicleWheelAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVehicleWheelAbstract_bases[] = {0,0};
static const char *swig_gsVehicleWheelAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsVehicleWheelAbstract = { "gsVehicleWheelAbstract", "gsVehicleWheelAbstract", &SWIGTYPE_p_gsVehicleWheelAbstract,_proxy__wrap_new_gsVehicleWheelAbstract, swig_delete_gsVehicleWheelAbstract, swig_gsVehicleWheelAbstract_methods, swig_gsVehicleWheelAbstract_attributes, &swig_gsVehicleWheelAbstract_Sf_SwigStatic, swig_gsVehicleWheelAbstract_meta, swig_gsVehicleWheelAbstract_bases, swig_gsVehicleWheelAbstract_base_names };

static int _wrap_new_gsCameraNodeAbstract(lua_State* L) {
  int SWIG_arg = 0;
  gkCameraNodeAbstract *arg1 = (gkCameraNodeAbstract *) 0 ;
  gsCameraNodeAbstract *result = 0 ;
  
  SWIG_check_num_args("gsCameraNodeAbstract::gsCameraNodeAbstract",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCameraNodeAbstract::gsCameraNodeAbstract",1,"gkCameraNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCameraNodeAbstract,0))){
    SWIG_fail_ptr("new_gsCameraNodeAbstract",1,SWIGTYPE_p_gkCameraNodeAbstract);
  }
  
  result = (gsCameraNodeAbstract *)new gsCameraNodeAbstract(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCameraNodeAbstract,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsCameraNodeAbstract_getPropCAMERA_OBJ(lua_State* L) {
  int SWIG_arg = 0;
  gsCameraNodeAbstract *arg1 = (gsCameraNodeAbstract *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsCameraNodeAbstract::getPropCAMERA_OBJ",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCameraNodeAbstract::getPropCAMERA_OBJ",1,"gsCameraNodeAbstract *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCameraNodeAbstract,0))){
    SWIG_fail_ptr("gsCameraNodeAbstract_getPropCAMERA_OBJ",1,SWIGTYPE_p_gsCameraNodeAbstract);
  }
  
  result = (arg1)->getPropCAMERA_OBJ();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsCameraNodeAbstract_setPropCAMERA_OBJ(lua_State* L) {
  int SWIG_arg = 0;
  gsCameraNodeAbstract *arg1 = (gsCameraNodeAbstract *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsCameraNodeAbstract::setPropCAMERA_OBJ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCameraNodeAbstract::setPropCAMERA_OBJ",1,"gsCameraNodeAbstract *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsCameraNodeAbstract::setPropCAMERA_OBJ",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCameraNodeAbstract,0))){
    SWIG_fail_ptr("gsCameraNodeAbstract_setPropCAMERA_OBJ",1,SWIGTYPE_p_gsCameraNodeAbstract);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setPropCAMERA_OBJ((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsCameraNodeAbstract(void *obj) {
gsCameraNodeAbstract *arg1 = (gsCameraNodeAbstract *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsCameraNodeAbstract(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsCameraNodeAbstract);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsCameraNodeAbstract_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsCameraNodeAbstract_methods[]= {
    { "getPropCAMERA_OBJ", _wrap_gsCameraNodeAbstract_getPropCAMERA_OBJ},
    { "setPropCAMERA_OBJ", _wrap_gsCameraNodeAbstract_setPropCAMERA_OBJ},
    {0,0}
};
static swig_lua_method swig_gsCameraNodeAbstract_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsCameraNodeAbstract_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsCameraNodeAbstract_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsCameraNodeAbstract_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsCameraNodeAbstract_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsCameraNodeAbstract_Sf_SwigStatic = {
    "gsCameraNodeAbstract",
    swig_gsCameraNodeAbstract_Sf_SwigStatic_methods,
    swig_gsCameraNodeAbstract_Sf_SwigStatic_attributes,
    swig_gsCameraNodeAbstract_Sf_SwigStatic_constants,
    swig_gsCameraNodeAbstract_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsCameraNodeAbstract_bases[] = {0,0};
static const char *swig_gsCameraNodeAbstract_base_names[] = {"gsLogicNode *",0};
static swig_lua_class _wrap_class_gsCameraNodeAbstract = { "gsCameraNodeAbstract", "gsCameraNodeAbstract", &SWIGTYPE_p_gsCameraNodeAbstract,_proxy__wrap_new_gsCameraNodeAbstract, swig_delete_gsCameraNodeAbstract, swig_gsCameraNodeAbstract_methods, swig_gsCameraNodeAbstract_attributes, &swig_gsCameraNodeAbstract_Sf_SwigStatic, swig_gsCameraNodeAbstract_meta, swig_gsCameraNodeAbstract_bases, swig_gsCameraNodeAbstract_base_names };

static int _wrap_new_DynamicsWorld(lua_State* L) {
  int SWIG_arg = 0;
  gkDynamicsWorld *arg1 = (gkDynamicsWorld *) 0 ;
  gsDynamicsWorld *result = 0 ;
  
  SWIG_check_num_args("gsDynamicsWorld::gsDynamicsWorld",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDynamicsWorld::gsDynamicsWorld",1,"gkDynamicsWorld *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkDynamicsWorld,0))){
    SWIG_fail_ptr("new_DynamicsWorld",1,SWIGTYPE_p_gkDynamicsWorld);
  }
  
  result = (gsDynamicsWorld *)new gsDynamicsWorld(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsDynamicsWorld,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DynamicsWorld_exportBullet(lua_State* L) {
  int SWIG_arg = 0;
  gsDynamicsWorld *arg1 = (gsDynamicsWorld *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsDynamicsWorld::exportBullet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDynamicsWorld::exportBullet",1,"gsDynamicsWorld *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsDynamicsWorld::exportBullet",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDynamicsWorld,0))){
    SWIG_fail_ptr("DynamicsWorld_exportBullet",1,SWIGTYPE_p_gsDynamicsWorld);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->exportBullet((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DynamicsWorld_setGravity(lua_State* L) {
  int SWIG_arg = 0;
  gsDynamicsWorld *arg1 = (gsDynamicsWorld *) 0 ;
  gsVector3 *arg2 = 0 ;
  
  SWIG_check_num_args("gsDynamicsWorld::setGravity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDynamicsWorld::setGravity",1,"gsDynamicsWorld *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsDynamicsWorld::setGravity",2,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDynamicsWorld,0))){
    SWIG_fail_ptr("DynamicsWorld_setGravity",1,SWIGTYPE_p_gsDynamicsWorld);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("DynamicsWorld_setGravity",2,SWIGTYPE_p_gsVector3);
  }
  
  (arg1)->setGravity((gsVector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DynamicsWorld_getGravity(lua_State* L) {
  int SWIG_arg = 0;
  gsDynamicsWorld *arg1 = (gsDynamicsWorld *) 0 ;
  gsVector3 *result = 0 ;
  
  SWIG_check_num_args("gsDynamicsWorld::getGravity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsDynamicsWorld::getGravity",1,"gsDynamicsWorld *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsDynamicsWorld,0))){
    SWIG_fail_ptr("DynamicsWorld_getGravity",1,SWIGTYPE_p_gsDynamicsWorld);
  }
  
  result = (gsVector3 *)(arg1)->getGravity();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_DynamicsWorld(void *obj) {
gsDynamicsWorld *arg1 = (gsDynamicsWorld *) obj;
delete arg1;
}
static int _proxy__wrap_new_DynamicsWorld(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_DynamicsWorld);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_DynamicsWorld_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_DynamicsWorld_methods[]= {
    { "exportBullet", _wrap_DynamicsWorld_exportBullet},
    { "setGravity", _wrap_DynamicsWorld_setGravity},
    { "getGravity", _wrap_DynamicsWorld_getGravity},
    {0,0}
};
static swig_lua_method swig_DynamicsWorld_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_DynamicsWorld_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_DynamicsWorld_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_DynamicsWorld_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_DynamicsWorld_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_DynamicsWorld_Sf_SwigStatic = {
    "DynamicsWorld",
    swig_DynamicsWorld_Sf_SwigStatic_methods,
    swig_DynamicsWorld_Sf_SwigStatic_attributes,
    swig_DynamicsWorld_Sf_SwigStatic_constants,
    swig_DynamicsWorld_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_DynamicsWorld_bases[] = {0};
static const char *swig_DynamicsWorld_base_names[] = {0};
static swig_lua_class _wrap_class_DynamicsWorld = { "DynamicsWorld", "DynamicsWorld", &SWIGTYPE_p_gsDynamicsWorld,_proxy__wrap_new_DynamicsWorld, swig_delete_DynamicsWorld, swig_DynamicsWorld_methods, swig_DynamicsWorld_attributes, &swig_DynamicsWorld_Sf_SwigStatic, swig_DynamicsWorld_meta, swig_DynamicsWorld_bases, swig_DynamicsWorld_base_names };

static int _wrap_new_gsVehicle(lua_State* L) {
  int SWIG_arg = 0;
  gkVehicle *arg1 = (gkVehicle *) 0 ;
  gsVehicle *result = 0 ;
  
  SWIG_check_num_args("gsVehicle::gsVehicle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::gsVehicle",1,"gkVehicle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkVehicle,0))){
    SWIG_fail_ptr("new_gsVehicle",1,SWIGTYPE_p_gkVehicle);
  }
  
  result = (gsVehicle *)new gsVehicle(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsVehicle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_getSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  float result;
  
  SWIG_check_num_args("gsVehicle::getSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::getSpeed",1,"gsVehicle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_getSpeed",1,SWIGTYPE_p_gsVehicle);
  }
  
  result = (float)(arg1)->getSpeed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_setGaz(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicle::setGaz",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::setGaz",1,"gsVehicle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicle::setGaz",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_setGaz",1,SWIGTYPE_p_gsVehicle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setGaz(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_setBrake(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicle::setBrake",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::setBrake",1,"gsVehicle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicle::setBrake",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_setBrake",1,SWIGTYPE_p_gsVehicle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setBrake(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_setSteer(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsVehicle::setSteer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::setSteer",1,"gsVehicle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicle::setSteer",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_setSteer",1,SWIGTYPE_p_gsVehicle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSteer(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_setGear(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsVehicle::setGear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::setGear",1,"gsVehicle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsVehicle::setGear",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_setGear",1,SWIGTYPE_p_gsVehicle);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setGear(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsVehicle_getGear(lua_State* L) {
  int SWIG_arg = 0;
  gsVehicle *arg1 = (gsVehicle *) 0 ;
  int result;
  
  SWIG_check_num_args("gsVehicle::getGear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsVehicle::getGear",1,"gsVehicle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsVehicle,0))){
    SWIG_fail_ptr("gsVehicle_getGear",1,SWIGTYPE_p_gsVehicle);
  }
  
  result = (int)(arg1)->getGear();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsVehicle(void *obj) {
gsVehicle *arg1 = (gsVehicle *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsVehicle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsVehicle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsVehicle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsVehicle_methods[]= {
    { "getSpeed", _wrap_gsVehicle_getSpeed},
    { "setGaz", _wrap_gsVehicle_setGaz},
    { "setBrake", _wrap_gsVehicle_setBrake},
    { "setSteer", _wrap_gsVehicle_setSteer},
    { "setGear", _wrap_gsVehicle_setGear},
    { "getGear", _wrap_gsVehicle_getGear},
    {0,0}
};
static swig_lua_method swig_gsVehicle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsVehicle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsVehicle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsVehicle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsVehicle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsVehicle_Sf_SwigStatic = {
    "gsVehicle",
    swig_gsVehicle_Sf_SwigStatic_methods,
    swig_gsVehicle_Sf_SwigStatic_attributes,
    swig_gsVehicle_Sf_SwigStatic_constants,
    swig_gsVehicle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsVehicle_bases[] = {0};
static const char *swig_gsVehicle_base_names[] = {0};
static swig_lua_class _wrap_class_gsVehicle = { "gsVehicle", "gsVehicle", &SWIGTYPE_p_gsVehicle,_proxy__wrap_new_gsVehicle, swig_delete_gsVehicle, swig_gsVehicle_methods, swig_gsVehicle_attributes, &swig_gsVehicle_Sf_SwigStatic, swig_gsVehicle_meta, swig_gsVehicle_bases, swig_gsVehicle_base_names };

static int _wrap_new_RayTest__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsScene *arg1 = (gsScene *) 0 ;
  gsRayTest *result = 0 ;
  
  SWIG_check_num_args("gsRayTest::gsRayTest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::gsRayTest",1,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_RayTest",1,SWIGTYPE_p_gsScene);
  }
  
  result = (gsRayTest *)new gsRayTest(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRayTest,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RayTest__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *result = 0 ;
  
  SWIG_check_num_args("gsRayTest::gsRayTest",0,0)
  result = (gsRayTest *)new gsRayTest();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRayTest,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RayTest(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RayTest__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RayTest__SWIG_0(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_RayTest'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRayTest::gsRayTest(gsScene *)\n"
    "    gsRayTest::gsRayTest()\n");
  lua_error(L);return 0;
}


static int _wrap_RayTest_cast__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gsRay *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gsGameObject *arg4 = (gsGameObject *) 0 ;
  gkString temp3 ;
  bool result;
  
  SWIG_check_num_args("gsRayTest::cast",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::cast",1,"gsRayTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRayTest::cast",2,"gsRay &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsRayTest::cast",3,"gkString const &");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("gsRayTest::cast",4,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_cast",1,SWIGTYPE_p_gsRayTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("RayTest_cast",2,SWIGTYPE_p_gsRay);
  }
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("RayTest_cast",4,SWIGTYPE_p_gsGameObject);
  }
  
  result = (bool)(arg1)->cast(*arg2,(gkString const &)*arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_cast__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gsRay *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  bool result;
  
  SWIG_check_num_args("gsRayTest::cast",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::cast",1,"gsRayTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRayTest::cast",2,"gsRay &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsRayTest::cast",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_cast",1,SWIGTYPE_p_gsRayTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("RayTest_cast",2,SWIGTYPE_p_gsRay);
  }
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (bool)(arg1)->cast(*arg2,(gkString const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_cast__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gsRay *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("gsRayTest::cast",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::cast",1,"gsRayTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRayTest::cast",2,"gsRay &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_cast",1,SWIGTYPE_p_gsRayTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("RayTest_cast",2,SWIGTYPE_p_gsRay);
  }
  
  result = (bool)(arg1)->cast(*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_cast(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRayTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RayTest_cast__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRayTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_RayTest_cast__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRayTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_RayTest_cast__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'RayTest_cast'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRayTest::cast(gsRay &,gkString const &,gsGameObject *)\n"
    "    gsRayTest::cast(gsRay &,gkString const &)\n"
    "    gsRayTest::cast(gsRay &)\n");
  lua_error(L);return 0;
}


static int _wrap_RayTest_getHitPoint(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRayTest::getHitPoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::getHitPoint",1,"gsRayTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_getHitPoint",1,SWIGTYPE_p_gsRayTest);
  }
  
  result = (arg1)->getHitPoint();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_getHitNormal(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsRayTest::getHitNormal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::getHitNormal",1,"gsRayTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_getHitNormal",1,SWIGTYPE_p_gsRayTest);
  }
  
  result = (arg1)->getHitNormal();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsRayTest::getHitObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::getHitObject",1,"gsRayTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_getHitObject",1,SWIGTYPE_p_gsRayTest);
  }
  
  result = (gkGameObject *)(arg1)->getHitObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RayTest_getHitFraction(lua_State* L) {
  int SWIG_arg = 0;
  gsRayTest *arg1 = (gsRayTest *) 0 ;
  float result;
  
  SWIG_check_num_args("gsRayTest::getHitFraction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRayTest::getHitFraction",1,"gsRayTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRayTest,0))){
    SWIG_fail_ptr("RayTest_getHitFraction",1,SWIGTYPE_p_gsRayTest);
  }
  
  result = (float)(arg1)->getHitFraction();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RayTest(void *obj) {
gsRayTest *arg1 = (gsRayTest *) obj;
delete arg1;
}
static int _proxy__wrap_new_RayTest(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_RayTest);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_RayTest_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_RayTest_methods[]= {
    { "cast", _wrap_RayTest_cast},
    { "getHitPoint", _wrap_RayTest_getHitPoint},
    { "getHitNormal", _wrap_RayTest_getHitNormal},
    { "getHitObject", _wrap_RayTest_getHitObject},
    { "getHitFraction", _wrap_RayTest_getHitFraction},
    {0,0}
};
static swig_lua_method swig_RayTest_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_RayTest_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_RayTest_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_RayTest_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_RayTest_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_RayTest_Sf_SwigStatic = {
    "RayTest",
    swig_RayTest_Sf_SwigStatic_methods,
    swig_RayTest_Sf_SwigStatic_attributes,
    swig_RayTest_Sf_SwigStatic_constants,
    swig_RayTest_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_RayTest_bases[] = {0};
static const char *swig_RayTest_base_names[] = {0};
static swig_lua_class _wrap_class_RayTest = { "RayTest", "RayTest", &SWIGTYPE_p_gsRayTest,_proxy__wrap_new_RayTest, swig_delete_RayTest, swig_RayTest_methods, swig_RayTest_attributes, &swig_RayTest_Sf_SwigStatic, swig_RayTest_meta, swig_RayTest_bases, swig_RayTest_base_names };

static int _wrap_new_SweptTest__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *result = 0 ;
  
  SWIG_check_num_args("gsSweptTest::gsSweptTest",0,0)
  result = (gsSweptTest *)new gsSweptTest();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSweptTest,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SweptTest__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsArray< gsGameObject,gkGameObject > *arg1 = 0 ;
  gsSweptTest *result = 0 ;
  
  SWIG_check_num_args("gsSweptTest::gsSweptTest",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("gsSweptTest::gsSweptTest",1,"gsArray< gsGameObject,gkGameObject > &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t,0))){
    SWIG_fail_ptr("new_SweptTest",1,SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t);
  }
  
  result = (gsSweptTest *)new gsSweptTest(*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSweptTest,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SweptTest(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SweptTest__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsArrayT_gsGameObject_gkGameObject_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_SweptTest__SWIG_1(L);
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SweptTest'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSweptTest::gsSweptTest()\n"
    "    gsSweptTest::gsSweptTest(gsArray< gsGameObject,gkGameObject > &)\n");
  lua_error(L);return 0;
}


static int _wrap_SweptTest_collides__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsRay *arg2 = 0 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  bool result;
  
  SWIG_check_num_args("gsSweptTest::collides",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::collides",1,"gsSweptTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSweptTest::collides",2,"gsRay const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSweptTest::collides",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsSweptTest::collides",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsSweptTest::collides",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_collides",1,SWIGTYPE_p_gsSweptTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("SweptTest_collides",2,SWIGTYPE_p_gsRay);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (bool)(arg1)->collides((gsRay const &)*arg2,arg3,arg4,arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_collides__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsRay *arg2 = 0 ;
  float arg3 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("gsSweptTest::collides",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::collides",1,"gsSweptTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSweptTest::collides",2,"gsRay const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSweptTest::collides",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsSweptTest::collides",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_collides",1,SWIGTYPE_p_gsSweptTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("SweptTest_collides",2,SWIGTYPE_p_gsRay);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)(arg1)->collides((gsRay const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_collides__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsRay *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  SWIG_check_num_args("gsSweptTest::collides",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::collides",1,"gsSweptTest *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsSweptTest::collides",2,"gsRay const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsSweptTest::collides",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_collides",1,SWIGTYPE_p_gsSweptTest);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsRay,0))){
    SWIG_fail_ptr("SweptTest_collides",2,SWIGTYPE_p_gsRay);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)(arg1)->collides((gsRay const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_collides(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSweptTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_SweptTest_collides__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSweptTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_SweptTest_collides__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSweptTest, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsRay, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_SweptTest_collides__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SweptTest_collides'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSweptTest::collides(gsRay const &,float,int,int)\n"
    "    gsSweptTest::collides(gsRay const &,float,int)\n"
    "    gsSweptTest::collides(gsRay const &,float)\n");
  lua_error(L);return 0;
}


static int _wrap_SweptTest_getHitPoint(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSweptTest::getHitPoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::getHitPoint",1,"gsSweptTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_getHitPoint",1,SWIGTYPE_p_gsSweptTest);
  }
  
  result = (arg1)->getHitPoint();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_getHitNormal(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSweptTest::getHitNormal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::getHitNormal",1,"gsSweptTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_getHitNormal",1,SWIGTYPE_p_gsSweptTest);
  }
  
  result = (arg1)->getHitNormal();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_getReflection(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSweptTest::getReflection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::getReflection",1,"gsSweptTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_getReflection",1,SWIGTYPE_p_gsSweptTest);
  }
  
  result = (arg1)->getReflection();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_getSliding(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsSweptTest::getSliding",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::getSliding",1,"gsSweptTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_getSliding",1,SWIGTYPE_p_gsSweptTest);
  }
  
  result = (arg1)->getSliding();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SweptTest_getHitObject(lua_State* L) {
  int SWIG_arg = 0;
  gsSweptTest *arg1 = (gsSweptTest *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsSweptTest::getHitObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSweptTest::getHitObject",1,"gsSweptTest *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSweptTest,0))){
    SWIG_fail_ptr("SweptTest_getHitObject",1,SWIGTYPE_p_gsSweptTest);
  }
  
  result = (gkGameObject *)(arg1)->getHitObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SweptTest(void *obj) {
gsSweptTest *arg1 = (gsSweptTest *) obj;
delete arg1;
}
static int _proxy__wrap_new_SweptTest(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SweptTest);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SweptTest_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SweptTest_methods[]= {
    { "collides", _wrap_SweptTest_collides},
    { "getHitPoint", _wrap_SweptTest_getHitPoint},
    { "getHitNormal", _wrap_SweptTest_getHitNormal},
    { "getReflection", _wrap_SweptTest_getReflection},
    { "getSliding", _wrap_SweptTest_getSliding},
    { "getHitObject", _wrap_SweptTest_getHitObject},
    {0,0}
};
static swig_lua_method swig_SweptTest_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SweptTest_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SweptTest_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SweptTest_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SweptTest_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SweptTest_Sf_SwigStatic = {
    "SweptTest",
    swig_SweptTest_Sf_SwigStatic_methods,
    swig_SweptTest_Sf_SwigStatic_attributes,
    swig_SweptTest_Sf_SwigStatic_constants,
    swig_SweptTest_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SweptTest_bases[] = {0};
static const char *swig_SweptTest_base_names[] = {0};
static swig_lua_class _wrap_class_SweptTest = { "SweptTest", "SweptTest", &SWIGTYPE_p_gsSweptTest,_proxy__wrap_new_SweptTest, swig_delete_SweptTest, swig_SweptTest_methods, swig_SweptTest_attributes, &swig_SweptTest_Sf_SwigStatic, swig_SweptTest_meta, swig_SweptTest_bases, swig_SweptTest_base_names };

static int _wrap_new_Character(lua_State* L) {
  int SWIG_arg = 0;
  gkCharacter *arg1 = (gkCharacter *) 0 ;
  gsCharacter *result = 0 ;
  
  SWIG_check_num_args("gsCharacter::gsCharacter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::gsCharacter",1,"gkCharacter *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkCharacter,0))){
    SWIG_fail_ptr("new_Character",1,SWIGTYPE_p_gkCharacter);
  }
  
  result = (gsCharacter *)new gsCharacter(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsCharacter,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_getObject(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  gkGameObject *result = 0 ;
  
  SWIG_check_num_args("gsCharacter::getObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::getObject",1,"gsCharacter *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_getObject",1,SWIGTYPE_p_gsCharacter);
  }
  
  result = (gkGameObject *)(arg1)->getObject();
  if (result) {
    SWIG_arg += gsWrapGameObject(L, result); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_setLinearVelocity(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  
  SWIG_check_num_args("gsCharacter::setLinearVelocity",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::setLinearVelocity",1,"gsCharacter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCharacter::setLinearVelocity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsCharacter::setLinearVelocity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsCharacter::setLinearVelocity",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsCharacter::setLinearVelocity",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsCharacter::setLinearVelocity",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_setLinearVelocity",1,SWIGTYPE_p_gsCharacter);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->setLinearVelocity(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_setGravity(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsCharacter::setGravity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::setGravity",1,"gsCharacter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCharacter::setGravity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_setGravity",1,SWIGTYPE_p_gsCharacter);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setGravity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_setRotation(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  gsVector3 *arg2 = 0 ;
  float arg3 ;
  
  SWIG_check_num_args("gsCharacter::setRotation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::setRotation",1,"gsCharacter *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsCharacter::setRotation",2,"gsVector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsCharacter::setRotation",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_setRotation",1,SWIGTYPE_p_gsCharacter);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("Character_setRotation",2,SWIGTYPE_p_gsVector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setRotation((gsVector3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_setJumpSpeed(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsCharacter::setJumpSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::setJumpSpeed",1,"gsCharacter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsCharacter::setJumpSpeed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_setJumpSpeed",1,SWIGTYPE_p_gsCharacter);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setJumpSpeed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_jump(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  
  SWIG_check_num_args("gsCharacter::jump",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::jump",1,"gsCharacter *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_jump",1,SWIGTYPE_p_gsCharacter);
  }
  
  (arg1)->jump();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Character_isOnGround(lua_State* L) {
  int SWIG_arg = 0;
  gsCharacter *arg1 = (gsCharacter *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsCharacter::isOnGround",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsCharacter::isOnGround",1,"gsCharacter *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsCharacter,0))){
    SWIG_fail_ptr("Character_isOnGround",1,SWIGTYPE_p_gsCharacter);
  }
  
  result = (bool)(arg1)->isOnGround();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Character(void *obj) {
gsCharacter *arg1 = (gsCharacter *) obj;
delete arg1;
}
static int _proxy__wrap_new_Character(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Character);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Character_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Character_methods[]= {
    { "getObject", _wrap_Character_getObject},
    { "setLinearVelocity", _wrap_Character_setLinearVelocity},
    { "setGravity", _wrap_Character_setGravity},
    { "setRotation", _wrap_Character_setRotation},
    { "setJumpSpeed", _wrap_Character_setJumpSpeed},
    { "jump", _wrap_Character_jump},
    { "isOnGround", _wrap_Character_isOnGround},
    {0,0}
};
static swig_lua_method swig_Character_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Character_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Character_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Character_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Character_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Character_Sf_SwigStatic = {
    "Character",
    swig_Character_Sf_SwigStatic_methods,
    swig_Character_Sf_SwigStatic_attributes,
    swig_Character_Sf_SwigStatic_constants,
    swig_Character_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Character_bases[] = {0};
static const char *swig_Character_base_names[] = {0};
static swig_lua_class _wrap_class_Character = { "Character", "Character", &SWIGTYPE_p_gsCharacter,_proxy__wrap_new_Character, swig_delete_Character, swig_Character_methods, swig_Character_attributes, &swig_Character_Sf_SwigStatic, swig_Character_meta, swig_Character_bases, swig_Character_base_names };

static int _wrap_setGlobalVolume(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  
  SWIG_check_num_args("setGlobalVolume",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("setGlobalVolume",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  setGlobalVolume(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getGlobalVolume(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("getGlobalVolume",0,0)
  result = (float)getGlobalVolume();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SoundManager(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *result = 0 ;
  
  SWIG_check_num_args("gsSoundManager::gsSoundManager",0,0)
  result = (gsSoundManager *)new gsSoundManager();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSoundManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundManager_loadSound__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *arg1 = (gsSoundManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  bool result;
  
  SWIG_check_num_args("gsSoundManager::loadSound",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundManager::loadSound",1,"gsSoundManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundManager::loadSound",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsSoundManager::loadSound",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsSoundManager::loadSound",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundManager,0))){
    SWIG_fail_ptr("SoundManager_loadSound",1,SWIGTYPE_p_gsSoundManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  result = (bool)(arg1)->loadSound((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundManager_loadSound__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *arg1 = (gsSoundManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  bool result;
  
  SWIG_check_num_args("gsSoundManager::loadSound",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundManager::loadSound",1,"gsSoundManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundManager::loadSound",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsSoundManager::loadSound",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundManager,0))){
    SWIG_fail_ptr("SoundManager_loadSound",1,SWIGTYPE_p_gsSoundManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (bool)(arg1)->loadSound((gkString const &)*arg2,(gkString const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundManager_loadSound__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *arg1 = (gsSoundManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  bool result;
  
  SWIG_check_num_args("gsSoundManager::loadSound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundManager::loadSound",1,"gsSoundManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundManager::loadSound",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundManager,0))){
    SWIG_fail_ptr("SoundManager_loadSound",1,SWIGTYPE_p_gsSoundManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (bool)(arg1)->loadSound((gkString const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundManager_loadSound(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSoundManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_SoundManager_loadSound__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSoundManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_SoundManager_loadSound__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsSoundManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_SoundManager_loadSound__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SoundManager_loadSound'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsSoundManager::loadSound(gkString const &,gkString const &,gkString const &)\n"
    "    gsSoundManager::loadSound(gkString const &,gkString const &)\n"
    "    gsSoundManager::loadSound(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_SoundManager_createSource(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *arg1 = (gsSoundManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkSource *result = 0 ;
  
  SWIG_check_num_args("gsSoundManager::createSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundManager::createSource",1,"gsSoundManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsSoundManager::createSource",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundManager,0))){
    SWIG_fail_ptr("SoundManager_createSource",1,SWIGTYPE_p_gsSoundManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkSource *)(arg1)->createSource((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Source); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SoundManager_destroySource(lua_State* L) {
  int SWIG_arg = 0;
  gsSoundManager *arg1 = (gsSoundManager *) 0 ;
  gsSource *arg2 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSoundManager::destroySource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSoundManager::destroySource",1,"gsSoundManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsSoundManager::destroySource",2,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSoundManager,0))){
    SWIG_fail_ptr("SoundManager_destroySource",1,SWIGTYPE_p_gsSoundManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("SoundManager_destroySource",2,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->destroySource(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SoundManager(void *obj) {
gsSoundManager *arg1 = (gsSoundManager *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundManager(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundManager);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundManager_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SoundManager_methods[]= {
    { "loadSound", _wrap_SoundManager_loadSound},
    { "createSource", _wrap_SoundManager_createSource},
    { "destroySource", _wrap_SoundManager_destroySource},
    {0,0}
};
static swig_lua_method swig_SoundManager_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundManager_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundManager_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundManager_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundManager_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundManager_Sf_SwigStatic = {
    "SoundManager",
    swig_SoundManager_Sf_SwigStatic_methods,
    swig_SoundManager_Sf_SwigStatic_attributes,
    swig_SoundManager_Sf_SwigStatic_constants,
    swig_SoundManager_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundManager_bases[] = {0};
static const char *swig_SoundManager_base_names[] = {0};
static swig_lua_class _wrap_class_SoundManager = { "SoundManager", "SoundManager", &SWIGTYPE_p_gsSoundManager,_proxy__wrap_new_SoundManager, swig_delete_SoundManager, swig_SoundManager_methods, swig_SoundManager_attributes, &swig_SoundManager_Sf_SwigStatic, swig_SoundManager_meta, swig_SoundManager_bases, swig_SoundManager_base_names };

static int _wrap_new_Source(lua_State* L) {
  int SWIG_arg = 0;
  gkSource *arg1 = (gkSource *) 0 ;
  gsSource *result = 0 ;
  
  SWIG_check_num_args("gsSource::gsSource",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::gsSource",1,"gkSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkSource,0))){
    SWIG_fail_ptr("new_Source",1,SWIGTYPE_p_gkSource);
  }
  
  result = (gsSource *)new gsSource(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSource,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_play(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::play",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::play",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_play",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->play();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_isPlaying(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSource::isPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::isPlaying",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_isPlaying",1,SWIGTYPE_p_gsSource);
  }
  
  result = (bool)(arg1)->isPlaying();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_pause(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::pause",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::pause",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_pause",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->pause();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_isPaused(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsSource::isPaused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::isPaused",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_isPaused",1,SWIGTYPE_p_gsSource);
  }
  
  result = (bool)(arg1)->isPaused();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_stop(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::stop",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_stop",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->stop();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_getPitch(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSource::getPitch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::getPitch",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_getPitch",1,SWIGTYPE_p_gsSource);
  }
  
  result = (float)(arg1)->getPitch();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_setPitch(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSource::setPitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::setPitch",1,"gsSource *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSource::setPitch",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_setPitch",1,SWIGTYPE_p_gsSource);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPitch(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_changePitch(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("gsSource::changePitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::changePitch",1,"gsSource *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSource::changePitch",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_changePitch",1,SWIGTYPE_p_gsSource);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->changePitch(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_getVolume(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float result;
  
  SWIG_check_num_args("gsSource::getVolume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::getVolume",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_getVolume",1,SWIGTYPE_p_gsSource);
  }
  
  result = (float)(arg1)->getVolume();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_setVolume(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsSource::setVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::setVolume",1,"gsSource *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSource::setVolume",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_setVolume",1,SWIGTYPE_p_gsSource);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setVolume(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_changeVolume(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("gsSource::changeVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::changeVolume",1,"gsSource *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsSource::changeVolume",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_changeVolume",1,SWIGTYPE_p_gsSource);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->changeVolume(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_destroy(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::destroy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::destroy",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_destroy",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->destroy();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source_recreate(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::recreate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::recreate",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source_recreate",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->recreate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source__getProperties(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  gkSoundProperties *result = 0 ;
  
  SWIG_check_num_args("gsSource::_getProperties",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::_getProperties",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source__getProperties",1,SWIGTYPE_p_gsSource);
  }
  
  result = (gkSoundProperties *) &(arg1)->_getProperties();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkSoundProperties,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Source__updateProperties(lua_State* L) {
  int SWIG_arg = 0;
  gsSource *arg1 = (gsSource *) 0 ;
  
  SWIG_check_num_args("gsSource::_updateProperties",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSource::_updateProperties",1,"gsSource *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsSource,0))){
    SWIG_fail_ptr("Source__updateProperties",1,SWIGTYPE_p_gsSource);
  }
  
  (arg1)->_updateProperties();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Source(void *obj) {
gsSource *arg1 = (gsSource *) obj;
delete arg1;
}
static int _proxy__wrap_new_Source(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Source);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Source_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Source_methods[]= {
    { "play", _wrap_Source_play},
    { "isPlaying", _wrap_Source_isPlaying},
    { "pause", _wrap_Source_pause},
    { "isPaused", _wrap_Source_isPaused},
    { "stop", _wrap_Source_stop},
    { "getPitch", _wrap_Source_getPitch},
    { "setPitch", _wrap_Source_setPitch},
    { "changePitch", _wrap_Source_changePitch},
    { "getVolume", _wrap_Source_getVolume},
    { "setVolume", _wrap_Source_setVolume},
    { "changeVolume", _wrap_Source_changeVolume},
    { "destroy", _wrap_Source_destroy},
    { "recreate", _wrap_Source_recreate},
    { "_getProperties", _wrap_Source__getProperties},
    { "_updateProperties", _wrap_Source__updateProperties},
    {0,0}
};
static swig_lua_method swig_Source_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Source_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Source_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Source_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Source_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Source_Sf_SwigStatic = {
    "Source",
    swig_Source_Sf_SwigStatic_methods,
    swig_Source_Sf_SwigStatic_attributes,
    swig_Source_Sf_SwigStatic_constants,
    swig_Source_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Source_bases[] = {0};
static const char *swig_Source_base_names[] = {0};
static swig_lua_class _wrap_class_Source = { "Source", "Source", &SWIGTYPE_p_gsSource,_proxy__wrap_new_Source, swig_delete_Source, swig_Source_methods, swig_Source_attributes, &swig_Source_Sf_SwigStatic, swig_Source_meta, swig_Source_bases, swig_Source_base_names };

static int _wrap_LuaScript_execute(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaScript *arg1 = (gsLuaScript *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsLuaScript::execute",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaScript::execute",1,"gsLuaScript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaScript,0))){
    SWIG_fail_ptr("LuaScript_execute",1,SWIGTYPE_p_gsLuaScript);
  }
  
  result = (bool)(arg1)->execute();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaScript_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaScript *arg1 = (gsLuaScript *) 0 ;
  gkString *result = 0 ;
  
  SWIG_check_num_args("gsLuaScript::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaScript::getName",1,"gsLuaScript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaScript,0))){
    SWIG_fail_ptr("LuaScript_getName",1,SWIGTYPE_p_gsLuaScript);
  }
  
  result = (gkString *) &(arg1)->getName();
  
  lua_pushlstring(L, result->data(),result->size()); SWIG_arg++;
  //    lua_pushstring(L, result->c_str()); SWIG_arg++;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LuaScript(void *obj) {
gsLuaScript *arg1 = (gsLuaScript *) obj;
delete arg1;
}
static swig_lua_attribute swig_LuaScript_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LuaScript_methods[]= {
    { "execute", _wrap_LuaScript_execute},
    { "getName", _wrap_LuaScript_getName},
    {0,0}
};
static swig_lua_method swig_LuaScript_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LuaScript_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LuaScript_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LuaScript_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LuaScript_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LuaScript_Sf_SwigStatic = {
    "LuaScript",
    swig_LuaScript_Sf_SwigStatic_methods,
    swig_LuaScript_Sf_SwigStatic_attributes,
    swig_LuaScript_Sf_SwigStatic_constants,
    swig_LuaScript_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LuaScript_bases[] = {0};
static const char *swig_LuaScript_base_names[] = {0};
static swig_lua_class _wrap_class_LuaScript = { "LuaScript", "LuaScript", &SWIGTYPE_p_gsLuaScript,0, swig_delete_LuaScript, swig_LuaScript_methods, swig_LuaScript_attributes, &swig_LuaScript_Sf_SwigStatic, swig_LuaScript_meta, swig_LuaScript_bases, swig_LuaScript_base_names };

static int _wrap_new_LuaManager(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *result = 0 ;
  
  SWIG_check_num_args("gsLuaManager::gsLuaManager",0,0)
  result = (gsLuaManager *)new gsLuaManager();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsLuaManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaManager_getScript(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *arg1 = (gsLuaManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLuaScript *result = 0 ;
  
  SWIG_check_num_args("gsLuaManager::getScript",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaManager::getScript",1,"gsLuaManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaManager::getScript",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaManager,0))){
    SWIG_fail_ptr("LuaManager_getScript",1,SWIGTYPE_p_gsLuaManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLuaScript *)(arg1)->getScript((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LuaScript); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaManager_create(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *arg1 = (gsLuaManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkLuaScript *result = 0 ;
  
  SWIG_check_num_args("gsLuaManager::create",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaManager::create",1,"gsLuaManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaManager::create",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsLuaManager::create",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaManager,0))){
    SWIG_fail_ptr("LuaManager_create",1,SWIGTYPE_p_gsLuaManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (gkLuaScript *)(arg1)->create((gkString const &)*arg2,(gkString const &)*arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, LuaScript); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaManager_registerFunction__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *arg1 = (gsLuaManager *) 0 ;
  gkString *arg2 = 0 ;
  gsFunction arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsLuaManager::registerFunction",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaManager::registerFunction",1,"gsLuaManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaManager::registerFunction",2,"gkString const &");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsLuaManager::registerFunction",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaManager,0))){
    SWIG_fail_ptr("LuaManager_registerFunction",1,SWIGTYPE_p_gsLuaManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->registerFunction((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaManager_registerFunction__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *arg1 = (gsLuaManager *) 0 ;
  gkString *arg2 = 0 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsLuaManager::registerFunction",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaManager::registerFunction",1,"gsLuaManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaManager::registerFunction",2,"gkString const &");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsLuaManager::registerFunction",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsLuaManager::registerFunction",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaManager,0))){
    SWIG_fail_ptr("LuaManager_registerFunction",1,SWIGTYPE_p_gsLuaManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->registerFunction((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LuaManager_registerFunction(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLuaManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_LuaManager_registerFunction__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsLuaManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_istable(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_LuaManager_registerFunction__SWIG_1(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'LuaManager_registerFunction'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsLuaManager::registerFunction(gkString const &,gsFunction)\n"
    "    gsLuaManager::registerFunction(gkString const &,gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_LuaManager_getFunction(lua_State* L) {
  int SWIG_arg = 0;
  gsLuaManager *arg1 = (gsLuaManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkLuaEvent *result = 0 ;
  
  SWIG_check_num_args("gsLuaManager::getFunction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsLuaManager::getFunction",1,"gsLuaManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsLuaManager::getFunction",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsLuaManager,0))){
    SWIG_fail_ptr("LuaManager_getFunction",1,SWIGTYPE_p_gsLuaManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkLuaEvent *)(arg1)->getFunction((gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gkLuaEvent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LuaManager(void *obj) {
gsLuaManager *arg1 = (gsLuaManager *) obj;
delete arg1;
}
static int _proxy__wrap_new_LuaManager(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_LuaManager);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_LuaManager_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_LuaManager_methods[]= {
    { "getScript", _wrap_LuaManager_getScript},
    { "create", _wrap_LuaManager_create},
    { "registerFunction", _wrap_LuaManager_registerFunction},
    { "getFunction", _wrap_LuaManager_getFunction},
    {0,0}
};
static swig_lua_method swig_LuaManager_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_LuaManager_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_LuaManager_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_LuaManager_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_LuaManager_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_LuaManager_Sf_SwigStatic = {
    "LuaManager",
    swig_LuaManager_Sf_SwigStatic_methods,
    swig_LuaManager_Sf_SwigStatic_attributes,
    swig_LuaManager_Sf_SwigStatic_constants,
    swig_LuaManager_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_LuaManager_bases[] = {0};
static const char *swig_LuaManager_base_names[] = {0};
static swig_lua_class _wrap_class_LuaManager = { "LuaManager", "LuaManager", &SWIGTYPE_p_gsLuaManager,_proxy__wrap_new_LuaManager, swig_delete_LuaManager, swig_LuaManager_methods, swig_LuaManager_attributes, &swig_LuaManager_Sf_SwigStatic, swig_LuaManager_meta, swig_LuaManager_bases, swig_LuaManager_base_names };

static int _wrap_new_Process__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::gsProcess",0,0)
  result = (gsProcess *)new gsProcess();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Process__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsFunction arg1 ;
  gsFunction arg2 ;
  gsFunction arg3 ;
  gsFunction arg4 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::gsProcess",4,4)
  if(!lua_isfunction(L,1)) SWIG_fail_arg("gsProcess::gsProcess",1,"gsFunction");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsProcess::gsProcess",2,"gsFunction");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsProcess::gsProcess",3,"gsFunction");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsProcess::gsProcess",4,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  result = (gsProcess *)new gsProcess(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Process__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsSelf arg1 ;
  gsFunction arg2 ;
  gsFunction arg3 ;
  gsFunction arg4 ;
  gsFunction arg5 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::gsProcess",5,5)
  if(!lua_istable(L,1)) SWIG_fail_arg("gsProcess::gsProcess",1,"gsSelf");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsProcess::gsProcess",2,"gsFunction");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsProcess::gsProcess",3,"gsFunction");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsProcess::gsProcess",4,"gsFunction");
  if(!lua_isfunction(L,5)) SWIG_fail_arg("gsProcess::gsProcess",5,"gsFunction");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (&arg5)->m_id = 5; (&arg5)->L = L; 
  result = (gsProcess *)new gsProcess(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Process(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Process__SWIG_0(L);
  }
  if (argc == 4) {
    int _v;
    _v = lua_isfunction(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_new_Process__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = lua_istable(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            _v = lua_isfunction(L, argv[4]); 
            if (_v) {
              return _wrap_new_Process__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Process'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcess::gsProcess()\n"
    "    gsProcess::gsProcess(gsFunction,gsFunction,gsFunction,gsFunction)\n"
    "    gsProcess::gsProcess(gsSelf,gsFunction,gsFunction,gsFunction,gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Process_setInit__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setInit",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setInit",1,"gsProcess *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsProcess::setInit",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsProcess::setInit",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setInit",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsProcess *)(arg1)->setInit(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setUpdate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setUpdate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setUpdate",1,"gsProcess *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsProcess::setUpdate",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsProcess::setUpdate",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setUpdate",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsProcess *)(arg1)->setUpdate(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setIsFinished__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setIsFinished",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setIsFinished",1,"gsProcess *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsProcess::setIsFinished",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsProcess::setIsFinished",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setIsFinished",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  result = (gsProcess *)(arg1)->setIsFinished(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setInit__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsFunction arg2 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setInit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setInit",1,"gsProcess *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsProcess::setInit",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setInit",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  result = (gsProcess *)(arg1)->setInit(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setInit(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Process_setInit__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Process_setInit__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Process_setInit'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcess::setInit(gsSelf,gsFunction)\n"
    "    gsProcess::setInit(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Process_setUpdate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsFunction arg2 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setUpdate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setUpdate",1,"gsProcess *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsProcess::setUpdate",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setUpdate",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  result = (gsProcess *)(arg1)->setUpdate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setUpdate(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Process_setUpdate__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Process_setUpdate__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Process_setUpdate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcess::setUpdate(gsSelf,gsFunction)\n"
    "    gsProcess::setUpdate(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Process_setIsFinished__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsFunction arg2 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::setIsFinished",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setIsFinished",1,"gsProcess *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsProcess::setIsFinished",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setIsFinished",1,SWIGTYPE_p_gsProcess);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  result = (gsProcess *)(arg1)->setIsFinished(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_setIsFinished(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_Process_setIsFinished__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcess, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_Process_setIsFinished__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Process_setIsFinished'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcess::setIsFinished(gsSelf,gsFunction)\n"
    "    gsProcess::setIsFinished(gsFunction)\n");
  lua_error(L);return 0;
}


static int _wrap_Process_setLoopCount(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsProcess::setLoopCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::setLoopCount",1,"gsProcess *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsProcess::setLoopCount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_setLoopCount",1,SWIGTYPE_p_gsProcess);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setLoopCount(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_getLoopCount(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  int result;
  
  SWIG_check_num_args("gsProcess::getLoopCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::getLoopCount",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_getLoopCount",1,SWIGTYPE_p_gsProcess);
  }
  
  result = (int)(arg1)->getLoopCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_suspend(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsProcess::suspend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::suspend",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_suspend",1,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->suspend();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_resume(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsProcess::resume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::resume",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_resume",1,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->resume();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_isSuspended(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsProcess::isSuspended",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::isSuspended",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_isSuspended",1,SWIGTYPE_p_gsProcess);
  }
  
  result = (bool)(arg1)->isSuspended();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_isFinished(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsProcess::isFinished",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::isFinished",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_isFinished",1,SWIGTYPE_p_gsProcess);
  }
  
  result = (bool)(arg1)->isFinished();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_init(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsProcess::init",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::init",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_init",1,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->init();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_update(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsProcess::update",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::update",1,"gsProcess *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsProcess::update",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_update",1,SWIGTYPE_p_gsProcess);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->update(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Process_get(lua_State* L) {
  int SWIG_arg = 0;
  gsProcess *arg1 = (gsProcess *) 0 ;
  gsProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcess::get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcess::get",1,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("Process_get",1,SWIGTYPE_p_gsProcess);
  }
  
  result = (gsProcess *)(arg1)->get();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcess,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Process(void *obj) {
gsProcess *arg1 = (gsProcess *) obj;
delete arg1;
}
static int _proxy__wrap_new_Process(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Process);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Process_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Process_methods[]= {
    { "setInit", _wrap_Process_setInit},
    { "setUpdate", _wrap_Process_setUpdate},
    { "setIsFinished", _wrap_Process_setIsFinished},
    { "setLoopCount", _wrap_Process_setLoopCount},
    { "getLoopCount", _wrap_Process_getLoopCount},
    { "suspend", _wrap_Process_suspend},
    { "resume", _wrap_Process_resume},
    { "isSuspended", _wrap_Process_isSuspended},
    { "isFinished", _wrap_Process_isFinished},
    { "init", _wrap_Process_init},
    { "update", _wrap_Process_update},
    { "get", _wrap_Process_get},
    {0,0}
};
static swig_lua_method swig_Process_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Process_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Process_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Process_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Process_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Process_Sf_SwigStatic = {
    "Process",
    swig_Process_Sf_SwigStatic_methods,
    swig_Process_Sf_SwigStatic_attributes,
    swig_Process_Sf_SwigStatic_constants,
    swig_Process_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Process_bases[] = {0};
static const char *swig_Process_base_names[] = {0};
static swig_lua_class _wrap_class_Process = { "Process", "Process", &SWIGTYPE_p_gsProcess,_proxy__wrap_new_Process, swig_delete_Process, swig_Process_methods, swig_Process_attributes, &swig_Process_Sf_SwigStatic, swig_Process_meta, swig_Process_bases, swig_Process_base_names };

static int _wrap_new_ProcessManager(lua_State* L) {
  int SWIG_arg = 0;
  gkProcessManager *arg1 = (gkProcessManager *) 0 ;
  gsProcessManager *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::gsProcessManager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::gsProcessManager",1,"gkProcessManager *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkProcessManager,0))){
    SWIG_fail_ptr("new_ProcessManager",1,SWIGTYPE_p_gkProcessManager);
  }
  
  result = (gsProcessManager *)new gsProcessManager(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsProcessManager,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_addProcess(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsProcess *arg2 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsProcessManager::addProcess",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::addProcess",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::addProcess",2,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_addProcess",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("ProcessManager_addProcess",2,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->addProcess(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_removeProcess(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsProcess *arg2 = (gsProcess *) 0 ;
  
  SWIG_check_num_args("gsProcessManager::removeProcess",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::removeProcess",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::removeProcess",2,"gsProcess *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_removeProcess",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsProcess,0))){
    SWIG_fail_ptr("ProcessManager_removeProcess",2,SWIGTYPE_p_gsProcess);
  }
  
  (arg1)->removeProcess(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createWait(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  float arg2 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createWait",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createWait",1,"gsProcessManager *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsProcessManager::createWait",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createWait",1,SWIGTYPE_p_gsProcessManager);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (gkProcess *)(arg1)->createWait(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createTranslation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  float arg3 ;
  gsVector3 *arg4 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createTranslation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createTranslation",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::createTranslation",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createTranslation",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcessManager::createTranslation",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",4,SWIGTYPE_p_gsVector3);
  }
  
  result = (gkProcess *)(arg1)->createTranslation(arg2,arg3,(gsVector3 const &)*arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createTranslation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  float arg3 ;
  gsVector3 *arg4 = 0 ;
  gsVector3 *arg5 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createTranslation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createTranslation",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::createTranslation",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createTranslation",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcessManager::createTranslation",4,"gsVector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcessManager::createTranslation",5,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",4,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createTranslation",5,SWIGTYPE_p_gsVector3);
  }
  
  result = (gkProcess *)(arg1)->createTranslation(arg2,arg3,(gsVector3 const &)*arg4,(gsVector3 const &)*arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createTranslation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_ProcessManager_createTranslation__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_ProcessManager_createTranslation__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ProcessManager_createTranslation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcessManager::createTranslation(gsGameObject *,float,gsVector3 const &)\n"
    "    gsProcessManager::createTranslation(gsGameObject *,float,gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_ProcessManager_createOrientation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  float arg3 ;
  gsVector3 *arg4 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createOrientation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createOrientation",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::createOrientation",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createOrientation",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcessManager::createOrientation",4,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",4,SWIGTYPE_p_gsVector3);
  }
  
  result = (gkProcess *)(arg1)->createOrientation(arg2,arg3,(gsVector3 const &)*arg4);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createOrientation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  float arg3 ;
  gsVector3 *arg4 = 0 ;
  gsVector3 *arg5 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createOrientation",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createOrientation",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::createOrientation",2,"gsGameObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createOrientation",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("gsProcessManager::createOrientation",4,"gsVector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("gsProcessManager::createOrientation",5,"gsVector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",2,SWIGTYPE_p_gsGameObject);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",4,SWIGTYPE_p_gsVector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_gsVector3,0))){
    SWIG_fail_ptr("ProcessManager_createOrientation",5,SWIGTYPE_p_gsVector3);
  }
  
  result = (gkProcess *)(arg1)->createOrientation(arg2,arg3,(gsVector3 const &)*arg4,(gsVector3 const &)*arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createOrientation(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_ProcessManager_createOrientation__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_gsVector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_ProcessManager_createOrientation__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ProcessManager_createOrientation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcessManager::createOrientation(gsGameObject *,float,gsVector3 const &)\n"
    "    gsProcessManager::createOrientation(gsGameObject *,float,gsVector3 const &,gsVector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_ProcessManager_createParallel__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsArray< gsProcess,gkProcess > *arg2 = 0 ;
  float arg3 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createParallel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createParallel",1,"gsProcessManager *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsProcessManager::createParallel",2,"gsArray< gsProcess,gkProcess > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createParallel",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createParallel",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessManager_createParallel",2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (gkProcess *)(arg1)->createParallel(*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createParallel__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsArray< gsProcess,gkProcess > *arg2 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createParallel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createParallel",1,"gsProcessManager *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsProcessManager::createParallel",2,"gsArray< gsProcess,gkProcess > &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createParallel",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessManager_createParallel",2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  result = (gkProcess *)(arg1)->createParallel(*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createParallel(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_ProcessManager_createParallel__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_ProcessManager_createParallel__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ProcessManager_createParallel'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcessManager::createParallel(gsArray< gsProcess,gkProcess > &,float)\n"
    "    gsProcessManager::createParallel(gsArray< gsProcess,gkProcess > &)\n");
  lua_error(L);return 0;
}


static int _wrap_ProcessManager_createSequence__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsArray< gsProcess,gkProcess > *arg2 = 0 ;
  float arg3 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createSequence",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createSequence",1,"gsProcessManager *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsProcessManager::createSequence",2,"gsArray< gsProcess,gkProcess > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsProcessManager::createSequence",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createSequence",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessManager_createSequence",2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (gkProcess *)(arg1)->createSequence(*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createSequence__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gsArray< gsProcess,gkProcess > *arg2 = 0 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createSequence",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createSequence",1,"gsProcessManager *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsProcessManager::createSequence",2,"gsArray< gsProcess,gkProcess > &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createSequence",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t,0))){
    SWIG_fail_ptr("ProcessManager_createSequence",2,SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t);
  }
  
  result = (gkProcess *)(arg1)->createSequence(*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_createSequence(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_ProcessManager_createSequence__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsProcessManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsArrayT_gsProcess_gkProcess_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_ProcessManager_createSequence__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ProcessManager_createSequence'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsProcessManager::createSequence(gsArray< gsProcess,gkProcess > &,float)\n"
    "    gsProcessManager::createSequence(gsArray< gsProcess,gkProcess > &)\n");
  lua_error(L);return 0;
}


static int _wrap_ProcessManager_createSound(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkProcess *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::createSound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::createSound",1,"gsProcessManager *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsProcessManager::createSound",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_createSound",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkProcess *)(arg1)->createSound((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Process); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_m_processManager_set(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gkProcessManager *arg2 = (gkProcessManager *) 0 ;
  
  SWIG_check_num_args("gsProcessManager::m_processManager",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::m_processManager",1,"gsProcessManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsProcessManager::m_processManager",2,"gkProcessManager *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_m_processManager_set",1,SWIGTYPE_p_gsProcessManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkProcessManager,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ProcessManager_m_processManager_set",2,SWIGTYPE_p_gkProcessManager);
  }
  
  if (arg1) (arg1)->m_processManager = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessManager_m_processManager_get(lua_State* L) {
  int SWIG_arg = 0;
  gsProcessManager *arg1 = (gsProcessManager *) 0 ;
  gkProcessManager *result = 0 ;
  
  SWIG_check_num_args("gsProcessManager::m_processManager",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsProcessManager::m_processManager",1,"gsProcessManager *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsProcessManager,0))){
    SWIG_fail_ptr("ProcessManager_m_processManager_get",1,SWIGTYPE_p_gsProcessManager);
  }
  
  result = (gkProcessManager *) ((arg1)->m_processManager);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, ProcessManager); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ProcessManager(void *obj) {
gsProcessManager *arg1 = (gsProcessManager *) obj;
delete arg1;
}
static int _proxy__wrap_new_ProcessManager(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ProcessManager);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ProcessManager_attributes[] = {
    { "m_processManager", _wrap_ProcessManager_m_processManager_get, _wrap_ProcessManager_m_processManager_set },
    {0,0,0}
};
static swig_lua_method swig_ProcessManager_methods[]= {
    { "addProcess", _wrap_ProcessManager_addProcess},
    { "removeProcess", _wrap_ProcessManager_removeProcess},
    { "createWait", _wrap_ProcessManager_createWait},
    { "createTranslation", _wrap_ProcessManager_createTranslation},
    { "createOrientation", _wrap_ProcessManager_createOrientation},
    { "createParallel", _wrap_ProcessManager_createParallel},
    { "createSequence", _wrap_ProcessManager_createSequence},
    { "createSound", _wrap_ProcessManager_createSound},
    {0,0}
};
static swig_lua_method swig_ProcessManager_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ProcessManager_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ProcessManager_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ProcessManager_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ProcessManager_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ProcessManager_Sf_SwigStatic = {
    "ProcessManager",
    swig_ProcessManager_Sf_SwigStatic_methods,
    swig_ProcessManager_Sf_SwigStatic_attributes,
    swig_ProcessManager_Sf_SwigStatic_constants,
    swig_ProcessManager_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ProcessManager_bases[] = {0};
static const char *swig_ProcessManager_base_names[] = {0};
static swig_lua_class _wrap_class_ProcessManager = { "ProcessManager", "ProcessManager", &SWIGTYPE_p_gsProcessManager,_proxy__wrap_new_ProcessManager, swig_delete_ProcessManager, swig_ProcessManager_methods, swig_ProcessManager_attributes, &swig_ProcessManager_Sf_SwigStatic, swig_ProcessManager_meta, swig_ProcessManager_bases, swig_ProcessManager_base_names };

static int _wrap_new_PanelColors(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::PanelColors",0,0)
  result = (Gui3D::PanelColors *)new Gui3D::PanelColors();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Gui3D__PanelColors,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_transparent_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::transparent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::transparent",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::transparent",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_transparent_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_transparent_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->transparent = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_transparent_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::transparent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::transparent",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_transparent_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->transparent);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->panelBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->panelBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->panelCursorSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->panelCursorSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteSizeX_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteSizeX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeX",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeX",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteSizeX_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->panelCursorSpriteSizeX = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteSizeX_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteSizeX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeX",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteSizeX_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->panelCursorSpriteSizeX);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteSizeY_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteSizeY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeY",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeY",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteSizeY_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->panelCursorSpriteSizeY = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelCursorSpriteSizeY_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelCursorSpriteSizeY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelCursorSpriteSizeY",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelCursorSpriteSizeY_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->panelCursorSpriteSizeY);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->panelGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->panelGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientColorStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientColorStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->panelGradientColorStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientColorStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientColorStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->panelGradientColorStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientColorEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientColorEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->panelGradientColorEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelGradientColorEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelGradientColorEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelGradientColorEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelGradientColorEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->panelGradientColorEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_panelBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->panelBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->panelBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::panelBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->panelBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_panelBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::panelBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::panelBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_panelBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->panelBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->buttonOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->buttonNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->buttonInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->buttonClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonBackgroundClickedGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->buttonBackgroundClickedGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundClickedGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundClickedGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundClickedGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundClickedGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundClickedGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundClickedGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundClickedGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundClickedGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonBackgroundOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->buttonBackgroundOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonBackgroundNotOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->buttonBackgroundNotOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundNotOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundNotOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundNotOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundNotOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundNotOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundNotOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundNotOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonBackgroundInactiveGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->buttonBackgroundInactiveGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundInactiveGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundInactiveGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBackgroundInactiveGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBackgroundInactiveGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBackgroundInactiveGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBackgroundInactiveGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBackgroundInactiveGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBackgroundInactiveGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonTextInactive_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonTextInactive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextInactive",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextInactive",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonTextInactive_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonTextInactive_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonTextInactive = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonTextInactive_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonTextInactive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextInactive",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonTextInactive_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonTextInactive);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderInactive_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderInactive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderInactive",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderInactive",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderInactive_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderInactive_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->buttonBorderInactive = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderInactive_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderInactive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderInactive",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderInactive_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->buttonBorderInactive);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->buttonBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_buttonBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::buttonBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::buttonBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_buttonBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->buttonBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->checkboxOveredBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxOveredBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->checkboxNotOveredBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxNotOveredBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedNotOveredBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedNotOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedNotOveredBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->checkboxCheckedNotOveredBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedNotOveredBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedNotOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxCheckedNotOveredBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedOveredBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedOveredBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedOveredBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedOveredBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->checkboxCheckedOveredBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedOveredBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedOveredBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedOveredBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedOveredBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxCheckedOveredBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedSymbol_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  char arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedSymbol",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedSymbol",1,"Gui3D::PanelColors *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedSymbol",2,"char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedSymbol_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (lua_tostring(L, 2))[0];
  if (arg1) (arg1)->checkboxCheckedSymbol = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxCheckedSymbol_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  char result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxCheckedSymbol",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxCheckedSymbol",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxCheckedSymbol_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (char) ((arg1)->checkboxCheckedSymbol);
  lua_pushfstring(L,"%c",result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->checkboxOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxNotOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->checkboxNotOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxNotOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxNotOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxNotOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxNotOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxNotOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxNotOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxNotOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxSelectedOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->checkboxSelectedOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxSelectedOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxSelectedOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxSelectedOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxSelectedOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxSelectedNotOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->checkboxSelectedNotOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxSelectedNotOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxSelectedNotOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxSelectedNotOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxSelectedNotOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxSelectedNotOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxSelectedNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxSelectedNotOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxSelectedNotOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->checkboxBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->checkboxBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->checkboxBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_checkboxBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::checkboxBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::checkboxBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_checkboxBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->checkboxBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonPreviousOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonPreviousOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonPreviousNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonPreviousNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonPreviousInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonPreviousInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonPreviousClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonPreviousClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonPreviousClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonPreviousClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonPreviousClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonNextOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonNextOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonNextNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonNextNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonNextInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonNextInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->comboboxButtonNextClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxButtonNextClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxButtonNextClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxButtonNextClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxButtonNextClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->comboboxBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->comboboxBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxOveredElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxOveredElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxOveredElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxOveredElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxOveredElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxOveredElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxOveredElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxOveredElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxOveredElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxOveredElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxOveredElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxOveredElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxNotOveredElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxNotOveredElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxNotOveredElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxNotOveredElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxNotOveredElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxNotOveredElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxNotOveredElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxNotOveredElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxNotOveredElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxNotOveredElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxNotOveredElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxNotOveredElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxSelectedElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxSelectedElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxSelectedElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxSelectedElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxSelectedElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxSelectedElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxSelectedElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxSelectedElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxSelectedElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxSelectedElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxSelectedElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxSelectedElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->comboboxTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->comboboxBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->comboboxBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->comboboxBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_comboboxBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::comboboxBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::comboboxBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_comboboxBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->comboboxBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonPreviousOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonPreviousOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonPreviousNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonPreviousNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonPreviousInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonPreviousInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonPreviousClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonPreviousClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonPreviousClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonPreviousClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonPreviousClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonNextOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonNextOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonNextNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonNextNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonNextInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonNextInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->inlineselectorButtonNextClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorButtonNextClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorButtonNextClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorButtonNextClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorButtonNextClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->inlineselectorBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->inlineselectorBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->inlineselectorBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->inlineselectorBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->inlineselectorBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->inlineselectorBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->inlineselectorText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->inlineselectorText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->inlineselectorTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->inlineselectorBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->inlineselectorBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->inlineselectorBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->inlineselectorBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->inlineselectorBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_inlineselectorBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::inlineselectorBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::inlineselectorBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_inlineselectorBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->inlineselectorBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonPreviousOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonPreviousOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonPreviousNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonPreviousNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonPreviousInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonPreviousInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonPreviousClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonPreviousClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonPreviousClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonPreviousClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonPreviousClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonPreviousClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonNextOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonNextOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonNextNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonNextNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextInactiveSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextInactiveSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextInactiveSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextInactiveSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonNextInactiveSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextInactiveSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextInactiveSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextInactiveSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextInactiveSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonNextInactiveSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextClickedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextClickedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextClickedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextClickedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->listboxButtonNextClickedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxButtonNextClickedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxButtonNextClickedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxButtonNextClickedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxButtonNextClickedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxButtonNextClickedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->listboxBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->listboxBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxOveredElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxOveredElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxOveredElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxOveredElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxOveredElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxOveredElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxNotOveredElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxNotOveredElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxNotOveredElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxNotOveredElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxNotOveredElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxNotOveredElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxOveredSelectedElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxOveredSelectedElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredSelectedElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredSelectedElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredSelectedElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredSelectedElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxOveredSelectedElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxOveredSelectedElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxOveredSelectedElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxOveredSelectedElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxOveredSelectedElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxOveredSelectedElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxNotOveredSelectedElement_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxNotOveredSelectedElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredSelectedElement",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredSelectedElement",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredSelectedElement_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredSelectedElement_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxNotOveredSelectedElement = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxNotOveredSelectedElement_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxNotOveredSelectedElement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxNotOveredSelectedElement",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxNotOveredSelectedElement_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxNotOveredSelectedElement);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->listboxTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_listboxBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->listboxBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->listboxBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->listboxBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_listboxBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::listboxBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::listboxBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_listboxBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->listboxBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->scrollbarCursorNotOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarCursorNotOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->scrollbarCursorOveredSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarCursorOveredSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->scrollbarCursorSelectedSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarCursorSelectedSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->scrollbarBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarProgressbarGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->scrollbarProgressbarGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarProgressbarGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarProgressbarGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarProgressbarGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarProgressbarGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarProgressbarGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarProgressbarGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarProgressbarGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarProgressbarGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarCursorOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->scrollbarCursorOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarCursorNotOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->scrollbarCursorNotOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorNotOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorNotOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorNotOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorNotOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorNotOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorNotOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorNotOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarCursorSelectedGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->scrollbarCursorSelectedGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorSelectedGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorSelectedGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorSelectedGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorSelectedGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorSelectedGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorSelectedGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorSelectedGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorSelectedGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->scrollbarCursorBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->scrollbarCursorBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->scrollbarCursorBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_scrollbarCursorBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::scrollbarCursorBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::scrollbarCursorBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_scrollbarCursorBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->scrollbarCursorBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->textzoneBackgroundOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->textzoneBackgroundOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->textzoneBackgroundNotOveredGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->textzoneBackgroundNotOveredGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundNotOveredGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundNotOveredGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundNotOveredGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundNotOveredGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundNotOveredGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundNotOveredGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundNotOveredGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->textzoneBackgroundSelectedGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->textzoneBackgroundSelectedGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundSelectedGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundSelectedGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBackgroundSelectedGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBackgroundSelectedGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBackgroundSelectedGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBackgroundSelectedGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBackgroundSelectedGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBackgroundSelectedGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->textzoneTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->textzoneTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderSelected_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderSelected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSelected",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSelected",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderSelected_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderSelected_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->textzoneBorderSelected = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderSelected_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderSelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSelected",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderSelected_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->textzoneBorderSelected);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->textzoneBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_textzoneBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::textzoneBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::textzoneBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_textzoneBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->textzoneBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundSpriteName_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundSpriteName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundSpriteName",1,"Gui3D::PanelColors *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundSpriteName",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundSpriteName_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  if (arg1) (arg1)->captionBackgroundSpriteName = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundSpriteName_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  gkString result;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundSpriteName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundSpriteName",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundSpriteName_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->captionBackgroundSpriteName);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->captionBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->captionBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->captionBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->captionBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->captionBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->captionBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_captionText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->captionText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->captionText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->captionTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->captionTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_captionBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->captionBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->captionBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::captionBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->captionBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_captionBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::captionBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::captionBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_captionBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->captionBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->progressbarBackgroundGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->progressbarBackgroundGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarBackgroundGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarBackgroundGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarBackgroundGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBackgroundGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBackgroundGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBackgroundGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBackgroundGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarBackgroundGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientType_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientType",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientType",2,"Gorilla::Gradient");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientType_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  arg2 = (Gorilla::Gradient)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->progressbarLoadingBarGradientType = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientType_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Gorilla::Gradient result;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientType",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientType_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Gorilla::Gradient) ((arg1)->progressbarLoadingBarGradientType);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientStart_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientStart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientStart",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientStart",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientStart_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientStart_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarLoadingBarGradientStart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientStart_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientStart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientStart",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientStart_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarLoadingBarGradientStart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientEnd_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientEnd",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientEnd",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientEnd_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientEnd_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarLoadingBarGradientEnd = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarLoadingBarGradientEnd_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarLoadingBarGradientEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarLoadingBarGradientEnd",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarLoadingBarGradientEnd_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarLoadingBarGradientEnd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarText_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarText",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarText",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarText_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarText_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarText = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarText_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarText",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarText_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarText);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarTextSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarTextSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarTextSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarTextSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarTextSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->progressbarTextSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarTextSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarTextSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarTextSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarTextSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->progressbarTextSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorder_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorder",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorder",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorder_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorder_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarBorder = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorder_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorder",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorder_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarBorder);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorderHighlight_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *arg2 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorderHighlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderHighlight",1,"Gui3D::PanelColors *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderHighlight",2,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorderHighlight_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorderHighlight_set",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  if (arg1) (arg1)->progressbarBorderHighlight = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorderHighlight_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorderHighlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderHighlight",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorderHighlight_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result = (Ogre::ColourValue *)& ((arg1)->progressbarBorderHighlight);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorderSize_set(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorderSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderSize",1,"Gui3D::PanelColors *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderSize",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorderSize_set",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->progressbarBorderSize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PanelColors_progressbarBorderSize_get(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Gui3D::PanelColors::progressbarBorderSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Gui3D::PanelColors::progressbarBorderSize",1,"Gui3D::PanelColors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelColors,0))){
    SWIG_fail_ptr("PanelColors_progressbarBorderSize_get",1,SWIGTYPE_p_Gui3D__PanelColors);
  }
  
  result =  ((arg1)->progressbarBorderSize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PanelColors(void *obj) {
Gui3D::PanelColors *arg1 = (Gui3D::PanelColors *) obj;
delete arg1;
}
static int _proxy__wrap_new_PanelColors(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_PanelColors);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_PanelColors_attributes[] = {
    { "transparent", _wrap_PanelColors_transparent_get, _wrap_PanelColors_transparent_set },
    { "panelBackgroundSpriteName", _wrap_PanelColors_panelBackgroundSpriteName_get, _wrap_PanelColors_panelBackgroundSpriteName_set },
    { "panelCursorSpriteName", _wrap_PanelColors_panelCursorSpriteName_get, _wrap_PanelColors_panelCursorSpriteName_set },
    { "panelCursorSpriteSizeX", _wrap_PanelColors_panelCursorSpriteSizeX_get, _wrap_PanelColors_panelCursorSpriteSizeX_set },
    { "panelCursorSpriteSizeY", _wrap_PanelColors_panelCursorSpriteSizeY_get, _wrap_PanelColors_panelCursorSpriteSizeY_set },
    { "panelGradientType", _wrap_PanelColors_panelGradientType_get, _wrap_PanelColors_panelGradientType_set },
    { "panelGradientColorStart", _wrap_PanelColors_panelGradientColorStart_get, _wrap_PanelColors_panelGradientColorStart_set },
    { "panelGradientColorEnd", _wrap_PanelColors_panelGradientColorEnd_get, _wrap_PanelColors_panelGradientColorEnd_set },
    { "panelBorder", _wrap_PanelColors_panelBorder_get, _wrap_PanelColors_panelBorder_set },
    { "panelBorderSize", _wrap_PanelColors_panelBorderSize_get, _wrap_PanelColors_panelBorderSize_set },
    { "buttonOveredSpriteName", _wrap_PanelColors_buttonOveredSpriteName_get, _wrap_PanelColors_buttonOveredSpriteName_set },
    { "buttonNotOveredSpriteName", _wrap_PanelColors_buttonNotOveredSpriteName_get, _wrap_PanelColors_buttonNotOveredSpriteName_set },
    { "buttonInactiveSpriteName", _wrap_PanelColors_buttonInactiveSpriteName_get, _wrap_PanelColors_buttonInactiveSpriteName_set },
    { "buttonClickedSpriteName", _wrap_PanelColors_buttonClickedSpriteName_get, _wrap_PanelColors_buttonClickedSpriteName_set },
    { "buttonBackgroundClickedGradientType", _wrap_PanelColors_buttonBackgroundClickedGradientType_get, _wrap_PanelColors_buttonBackgroundClickedGradientType_set },
    { "buttonBackgroundClickedGradientStart", _wrap_PanelColors_buttonBackgroundClickedGradientStart_get, _wrap_PanelColors_buttonBackgroundClickedGradientStart_set },
    { "buttonBackgroundClickedGradientEnd", _wrap_PanelColors_buttonBackgroundClickedGradientEnd_get, _wrap_PanelColors_buttonBackgroundClickedGradientEnd_set },
    { "buttonBackgroundOveredGradientType", _wrap_PanelColors_buttonBackgroundOveredGradientType_get, _wrap_PanelColors_buttonBackgroundOveredGradientType_set },
    { "buttonBackgroundOveredGradientStart", _wrap_PanelColors_buttonBackgroundOveredGradientStart_get, _wrap_PanelColors_buttonBackgroundOveredGradientStart_set },
    { "buttonBackgroundOveredGradientEnd", _wrap_PanelColors_buttonBackgroundOveredGradientEnd_get, _wrap_PanelColors_buttonBackgroundOveredGradientEnd_set },
    { "buttonBackgroundNotOveredGradientType", _wrap_PanelColors_buttonBackgroundNotOveredGradientType_get, _wrap_PanelColors_buttonBackgroundNotOveredGradientType_set },
    { "buttonBackgroundNotOveredGradientStart", _wrap_PanelColors_buttonBackgroundNotOveredGradientStart_get, _wrap_PanelColors_buttonBackgroundNotOveredGradientStart_set },
    { "buttonBackgroundNotOveredGradientEnd", _wrap_PanelColors_buttonBackgroundNotOveredGradientEnd_get, _wrap_PanelColors_buttonBackgroundNotOveredGradientEnd_set },
    { "buttonBackgroundInactiveGradientType", _wrap_PanelColors_buttonBackgroundInactiveGradientType_get, _wrap_PanelColors_buttonBackgroundInactiveGradientType_set },
    { "buttonBackgroundInactiveGradientStart", _wrap_PanelColors_buttonBackgroundInactiveGradientStart_get, _wrap_PanelColors_buttonBackgroundInactiveGradientStart_set },
    { "buttonBackgroundInactiveGradientEnd", _wrap_PanelColors_buttonBackgroundInactiveGradientEnd_get, _wrap_PanelColors_buttonBackgroundInactiveGradientEnd_set },
    { "buttonText", _wrap_PanelColors_buttonText_get, _wrap_PanelColors_buttonText_set },
    { "buttonTextInactive", _wrap_PanelColors_buttonTextInactive_get, _wrap_PanelColors_buttonTextInactive_set },
    { "buttonTextSize", _wrap_PanelColors_buttonTextSize_get, _wrap_PanelColors_buttonTextSize_set },
    { "buttonBorder", _wrap_PanelColors_buttonBorder_get, _wrap_PanelColors_buttonBorder_set },
    { "buttonBorderHighlight", _wrap_PanelColors_buttonBorderHighlight_get, _wrap_PanelColors_buttonBorderHighlight_set },
    { "buttonBorderInactive", _wrap_PanelColors_buttonBorderInactive_get, _wrap_PanelColors_buttonBorderInactive_set },
    { "buttonBorderSize", _wrap_PanelColors_buttonBorderSize_get, _wrap_PanelColors_buttonBorderSize_set },
    { "checkboxOveredBackgroundSpriteName", _wrap_PanelColors_checkboxOveredBackgroundSpriteName_get, _wrap_PanelColors_checkboxOveredBackgroundSpriteName_set },
    { "checkboxNotOveredBackgroundSpriteName", _wrap_PanelColors_checkboxNotOveredBackgroundSpriteName_get, _wrap_PanelColors_checkboxNotOveredBackgroundSpriteName_set },
    { "checkboxCheckedNotOveredBackgroundSpriteName", _wrap_PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_get, _wrap_PanelColors_checkboxCheckedNotOveredBackgroundSpriteName_set },
    { "checkboxCheckedOveredBackgroundSpriteName", _wrap_PanelColors_checkboxCheckedOveredBackgroundSpriteName_get, _wrap_PanelColors_checkboxCheckedOveredBackgroundSpriteName_set },
    { "checkboxCheckedSymbol", _wrap_PanelColors_checkboxCheckedSymbol_get, _wrap_PanelColors_checkboxCheckedSymbol_set },
    { "checkboxOveredGradientType", _wrap_PanelColors_checkboxOveredGradientType_get, _wrap_PanelColors_checkboxOveredGradientType_set },
    { "checkboxOveredGradientStart", _wrap_PanelColors_checkboxOveredGradientStart_get, _wrap_PanelColors_checkboxOveredGradientStart_set },
    { "checkboxOveredGradientEnd", _wrap_PanelColors_checkboxOveredGradientEnd_get, _wrap_PanelColors_checkboxOveredGradientEnd_set },
    { "checkboxNotOveredGradientType", _wrap_PanelColors_checkboxNotOveredGradientType_get, _wrap_PanelColors_checkboxNotOveredGradientType_set },
    { "checkboxNotOveredGradientStart", _wrap_PanelColors_checkboxNotOveredGradientStart_get, _wrap_PanelColors_checkboxNotOveredGradientStart_set },
    { "checkboxNotOveredGradientEnd", _wrap_PanelColors_checkboxNotOveredGradientEnd_get, _wrap_PanelColors_checkboxNotOveredGradientEnd_set },
    { "checkboxSelectedOveredGradientType", _wrap_PanelColors_checkboxSelectedOveredGradientType_get, _wrap_PanelColors_checkboxSelectedOveredGradientType_set },
    { "checkboxSelectedOveredGradientStart", _wrap_PanelColors_checkboxSelectedOveredGradientStart_get, _wrap_PanelColors_checkboxSelectedOveredGradientStart_set },
    { "checkboxSelectedOveredGradientEnd", _wrap_PanelColors_checkboxSelectedOveredGradientEnd_get, _wrap_PanelColors_checkboxSelectedOveredGradientEnd_set },
    { "checkboxSelectedNotOveredGradientType", _wrap_PanelColors_checkboxSelectedNotOveredGradientType_get, _wrap_PanelColors_checkboxSelectedNotOveredGradientType_set },
    { "checkboxSelectedNotOveredGradientStart", _wrap_PanelColors_checkboxSelectedNotOveredGradientStart_get, _wrap_PanelColors_checkboxSelectedNotOveredGradientStart_set },
    { "checkboxSelectedNotOveredGradientEnd", _wrap_PanelColors_checkboxSelectedNotOveredGradientEnd_get, _wrap_PanelColors_checkboxSelectedNotOveredGradientEnd_set },
    { "checkboxText", _wrap_PanelColors_checkboxText_get, _wrap_PanelColors_checkboxText_set },
    { "checkboxTextSize", _wrap_PanelColors_checkboxTextSize_get, _wrap_PanelColors_checkboxTextSize_set },
    { "checkboxBorder", _wrap_PanelColors_checkboxBorder_get, _wrap_PanelColors_checkboxBorder_set },
    { "checkboxBorderHighlight", _wrap_PanelColors_checkboxBorderHighlight_get, _wrap_PanelColors_checkboxBorderHighlight_set },
    { "checkboxBorderSize", _wrap_PanelColors_checkboxBorderSize_get, _wrap_PanelColors_checkboxBorderSize_set },
    { "comboboxButtonPreviousOveredSpriteName", _wrap_PanelColors_comboboxButtonPreviousOveredSpriteName_get, _wrap_PanelColors_comboboxButtonPreviousOveredSpriteName_set },
    { "comboboxButtonPreviousNotOveredSpriteName", _wrap_PanelColors_comboboxButtonPreviousNotOveredSpriteName_get, _wrap_PanelColors_comboboxButtonPreviousNotOveredSpriteName_set },
    { "comboboxButtonPreviousInactiveSpriteName", _wrap_PanelColors_comboboxButtonPreviousInactiveSpriteName_get, _wrap_PanelColors_comboboxButtonPreviousInactiveSpriteName_set },
    { "comboboxButtonPreviousClickedSpriteName", _wrap_PanelColors_comboboxButtonPreviousClickedSpriteName_get, _wrap_PanelColors_comboboxButtonPreviousClickedSpriteName_set },
    { "comboboxButtonNextOveredSpriteName", _wrap_PanelColors_comboboxButtonNextOveredSpriteName_get, _wrap_PanelColors_comboboxButtonNextOveredSpriteName_set },
    { "comboboxButtonNextNotOveredSpriteName", _wrap_PanelColors_comboboxButtonNextNotOveredSpriteName_get, _wrap_PanelColors_comboboxButtonNextNotOveredSpriteName_set },
    { "comboboxButtonNextInactiveSpriteName", _wrap_PanelColors_comboboxButtonNextInactiveSpriteName_get, _wrap_PanelColors_comboboxButtonNextInactiveSpriteName_set },
    { "comboboxButtonNextClickedSpriteName", _wrap_PanelColors_comboboxButtonNextClickedSpriteName_get, _wrap_PanelColors_comboboxButtonNextClickedSpriteName_set },
    { "comboboxBackgroundGradientType", _wrap_PanelColors_comboboxBackgroundGradientType_get, _wrap_PanelColors_comboboxBackgroundGradientType_set },
    { "comboboxBackgroundGradientStart", _wrap_PanelColors_comboboxBackgroundGradientStart_get, _wrap_PanelColors_comboboxBackgroundGradientStart_set },
    { "comboboxBackgroundGradientEnd", _wrap_PanelColors_comboboxBackgroundGradientEnd_get, _wrap_PanelColors_comboboxBackgroundGradientEnd_set },
    { "comboboxOveredElement", _wrap_PanelColors_comboboxOveredElement_get, _wrap_PanelColors_comboboxOveredElement_set },
    { "comboboxNotOveredElement", _wrap_PanelColors_comboboxNotOveredElement_get, _wrap_PanelColors_comboboxNotOveredElement_set },
    { "comboboxSelectedElement", _wrap_PanelColors_comboboxSelectedElement_get, _wrap_PanelColors_comboboxSelectedElement_set },
    { "comboboxText", _wrap_PanelColors_comboboxText_get, _wrap_PanelColors_comboboxText_set },
    { "comboboxTextSize", _wrap_PanelColors_comboboxTextSize_get, _wrap_PanelColors_comboboxTextSize_set },
    { "comboboxBorder", _wrap_PanelColors_comboboxBorder_get, _wrap_PanelColors_comboboxBorder_set },
    { "comboboxBorderHighlight", _wrap_PanelColors_comboboxBorderHighlight_get, _wrap_PanelColors_comboboxBorderHighlight_set },
    { "comboboxBorderSize", _wrap_PanelColors_comboboxBorderSize_get, _wrap_PanelColors_comboboxBorderSize_set },
    { "inlineselectorButtonPreviousOveredSpriteName", _wrap_PanelColors_inlineselectorButtonPreviousOveredSpriteName_get, _wrap_PanelColors_inlineselectorButtonPreviousOveredSpriteName_set },
    { "inlineselectorButtonPreviousNotOveredSpriteName", _wrap_PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_get, _wrap_PanelColors_inlineselectorButtonPreviousNotOveredSpriteName_set },
    { "inlineselectorButtonPreviousInactiveSpriteName", _wrap_PanelColors_inlineselectorButtonPreviousInactiveSpriteName_get, _wrap_PanelColors_inlineselectorButtonPreviousInactiveSpriteName_set },
    { "inlineselectorButtonPreviousClickedSpriteName", _wrap_PanelColors_inlineselectorButtonPreviousClickedSpriteName_get, _wrap_PanelColors_inlineselectorButtonPreviousClickedSpriteName_set },
    { "inlineselectorButtonNextOveredSpriteName", _wrap_PanelColors_inlineselectorButtonNextOveredSpriteName_get, _wrap_PanelColors_inlineselectorButtonNextOveredSpriteName_set },
    { "inlineselectorButtonNextNotOveredSpriteName", _wrap_PanelColors_inlineselectorButtonNextNotOveredSpriteName_get, _wrap_PanelColors_inlineselectorButtonNextNotOveredSpriteName_set },
    { "inlineselectorButtonNextInactiveSpriteName", _wrap_PanelColors_inlineselectorButtonNextInactiveSpriteName_get, _wrap_PanelColors_inlineselectorButtonNextInactiveSpriteName_set },
    { "inlineselectorButtonNextClickedSpriteName", _wrap_PanelColors_inlineselectorButtonNextClickedSpriteName_get, _wrap_PanelColors_inlineselectorButtonNextClickedSpriteName_set },
    { "inlineselectorBackgroundGradientType", _wrap_PanelColors_inlineselectorBackgroundGradientType_get, _wrap_PanelColors_inlineselectorBackgroundGradientType_set },
    { "inlineselectorBackgroundGradientStart", _wrap_PanelColors_inlineselectorBackgroundGradientStart_get, _wrap_PanelColors_inlineselectorBackgroundGradientStart_set },
    { "inlineselectorBackgroundGradientEnd", _wrap_PanelColors_inlineselectorBackgroundGradientEnd_get, _wrap_PanelColors_inlineselectorBackgroundGradientEnd_set },
    { "inlineselectorText", _wrap_PanelColors_inlineselectorText_get, _wrap_PanelColors_inlineselectorText_set },
    { "inlineselectorTextSize", _wrap_PanelColors_inlineselectorTextSize_get, _wrap_PanelColors_inlineselectorTextSize_set },
    { "inlineselectorBorder", _wrap_PanelColors_inlineselectorBorder_get, _wrap_PanelColors_inlineselectorBorder_set },
    { "inlineselectorBorderHighlight", _wrap_PanelColors_inlineselectorBorderHighlight_get, _wrap_PanelColors_inlineselectorBorderHighlight_set },
    { "inlineselectorBorderSize", _wrap_PanelColors_inlineselectorBorderSize_get, _wrap_PanelColors_inlineselectorBorderSize_set },
    { "listboxButtonPreviousOveredSpriteName", _wrap_PanelColors_listboxButtonPreviousOveredSpriteName_get, _wrap_PanelColors_listboxButtonPreviousOveredSpriteName_set },
    { "listboxButtonPreviousNotOveredSpriteName", _wrap_PanelColors_listboxButtonPreviousNotOveredSpriteName_get, _wrap_PanelColors_listboxButtonPreviousNotOveredSpriteName_set },
    { "listboxButtonPreviousInactiveSpriteName", _wrap_PanelColors_listboxButtonPreviousInactiveSpriteName_get, _wrap_PanelColors_listboxButtonPreviousInactiveSpriteName_set },
    { "listboxButtonPreviousClickedSpriteName", _wrap_PanelColors_listboxButtonPreviousClickedSpriteName_get, _wrap_PanelColors_listboxButtonPreviousClickedSpriteName_set },
    { "listboxButtonNextOveredSpriteName", _wrap_PanelColors_listboxButtonNextOveredSpriteName_get, _wrap_PanelColors_listboxButtonNextOveredSpriteName_set },
    { "listboxButtonNextNotOveredSpriteName", _wrap_PanelColors_listboxButtonNextNotOveredSpriteName_get, _wrap_PanelColors_listboxButtonNextNotOveredSpriteName_set },
    { "listboxButtonNextInactiveSpriteName", _wrap_PanelColors_listboxButtonNextInactiveSpriteName_get, _wrap_PanelColors_listboxButtonNextInactiveSpriteName_set },
    { "listboxButtonNextClickedSpriteName", _wrap_PanelColors_listboxButtonNextClickedSpriteName_get, _wrap_PanelColors_listboxButtonNextClickedSpriteName_set },
    { "listboxBackgroundGradientType", _wrap_PanelColors_listboxBackgroundGradientType_get, _wrap_PanelColors_listboxBackgroundGradientType_set },
    { "listboxBackgroundGradientStart", _wrap_PanelColors_listboxBackgroundGradientStart_get, _wrap_PanelColors_listboxBackgroundGradientStart_set },
    { "listboxBackgroundGradientEnd", _wrap_PanelColors_listboxBackgroundGradientEnd_get, _wrap_PanelColors_listboxBackgroundGradientEnd_set },
    { "listboxOveredElement", _wrap_PanelColors_listboxOveredElement_get, _wrap_PanelColors_listboxOveredElement_set },
    { "listboxNotOveredElement", _wrap_PanelColors_listboxNotOveredElement_get, _wrap_PanelColors_listboxNotOveredElement_set },
    { "listboxOveredSelectedElement", _wrap_PanelColors_listboxOveredSelectedElement_get, _wrap_PanelColors_listboxOveredSelectedElement_set },
    { "listboxNotOveredSelectedElement", _wrap_PanelColors_listboxNotOveredSelectedElement_get, _wrap_PanelColors_listboxNotOveredSelectedElement_set },
    { "listboxText", _wrap_PanelColors_listboxText_get, _wrap_PanelColors_listboxText_set },
    { "listboxTextSize", _wrap_PanelColors_listboxTextSize_get, _wrap_PanelColors_listboxTextSize_set },
    { "listboxBorder", _wrap_PanelColors_listboxBorder_get, _wrap_PanelColors_listboxBorder_set },
    { "listboxBorderHighlight", _wrap_PanelColors_listboxBorderHighlight_get, _wrap_PanelColors_listboxBorderHighlight_set },
    { "listboxBorderSize", _wrap_PanelColors_listboxBorderSize_get, _wrap_PanelColors_listboxBorderSize_set },
    { "scrollbarCursorNotOveredSpriteName", _wrap_PanelColors_scrollbarCursorNotOveredSpriteName_get, _wrap_PanelColors_scrollbarCursorNotOveredSpriteName_set },
    { "scrollbarCursorOveredSpriteName", _wrap_PanelColors_scrollbarCursorOveredSpriteName_get, _wrap_PanelColors_scrollbarCursorOveredSpriteName_set },
    { "scrollbarCursorSelectedSpriteName", _wrap_PanelColors_scrollbarCursorSelectedSpriteName_get, _wrap_PanelColors_scrollbarCursorSelectedSpriteName_set },
    { "scrollbarBackgroundGradientType", _wrap_PanelColors_scrollbarBackgroundGradientType_get, _wrap_PanelColors_scrollbarBackgroundGradientType_set },
    { "scrollbarBackgroundGradientStart", _wrap_PanelColors_scrollbarBackgroundGradientStart_get, _wrap_PanelColors_scrollbarBackgroundGradientStart_set },
    { "scrollbarBackgroundGradientEnd", _wrap_PanelColors_scrollbarBackgroundGradientEnd_get, _wrap_PanelColors_scrollbarBackgroundGradientEnd_set },
    { "scrollbarProgressbarGradientType", _wrap_PanelColors_scrollbarProgressbarGradientType_get, _wrap_PanelColors_scrollbarProgressbarGradientType_set },
    { "scrollbarProgressbarGradientStart", _wrap_PanelColors_scrollbarProgressbarGradientStart_get, _wrap_PanelColors_scrollbarProgressbarGradientStart_set },
    { "scrollbarProgressbarGradientEnd", _wrap_PanelColors_scrollbarProgressbarGradientEnd_get, _wrap_PanelColors_scrollbarProgressbarGradientEnd_set },
    { "scrollbarCursorOveredGradientType", _wrap_PanelColors_scrollbarCursorOveredGradientType_get, _wrap_PanelColors_scrollbarCursorOveredGradientType_set },
    { "scrollbarCursorOveredGradientStart", _wrap_PanelColors_scrollbarCursorOveredGradientStart_get, _wrap_PanelColors_scrollbarCursorOveredGradientStart_set },
    { "scrollbarCursorOveredGradientEnd", _wrap_PanelColors_scrollbarCursorOveredGradientEnd_get, _wrap_PanelColors_scrollbarCursorOveredGradientEnd_set },
    { "scrollbarCursorNotOveredGradientType", _wrap_PanelColors_scrollbarCursorNotOveredGradientType_get, _wrap_PanelColors_scrollbarCursorNotOveredGradientType_set },
    { "scrollbarCursorNotOveredGradientStart", _wrap_PanelColors_scrollbarCursorNotOveredGradientStart_get, _wrap_PanelColors_scrollbarCursorNotOveredGradientStart_set },
    { "scrollbarCursorNotOveredGradientEnd", _wrap_PanelColors_scrollbarCursorNotOveredGradientEnd_get, _wrap_PanelColors_scrollbarCursorNotOveredGradientEnd_set },
    { "scrollbarCursorSelectedGradientType", _wrap_PanelColors_scrollbarCursorSelectedGradientType_get, _wrap_PanelColors_scrollbarCursorSelectedGradientType_set },
    { "scrollbarCursorSelectedGradientStart", _wrap_PanelColors_scrollbarCursorSelectedGradientStart_get, _wrap_PanelColors_scrollbarCursorSelectedGradientStart_set },
    { "scrollbarCursorSelectedGradientEnd", _wrap_PanelColors_scrollbarCursorSelectedGradientEnd_get, _wrap_PanelColors_scrollbarCursorSelectedGradientEnd_set },
    { "scrollbarText", _wrap_PanelColors_scrollbarText_get, _wrap_PanelColors_scrollbarText_set },
    { "scrollbarTextSize", _wrap_PanelColors_scrollbarTextSize_get, _wrap_PanelColors_scrollbarTextSize_set },
    { "scrollbarBorder", _wrap_PanelColors_scrollbarBorder_get, _wrap_PanelColors_scrollbarBorder_set },
    { "scrollbarBorderHighlight", _wrap_PanelColors_scrollbarBorderHighlight_get, _wrap_PanelColors_scrollbarBorderHighlight_set },
    { "scrollbarCursorBorder", _wrap_PanelColors_scrollbarCursorBorder_get, _wrap_PanelColors_scrollbarCursorBorder_set },
    { "scrollbarBorderSize", _wrap_PanelColors_scrollbarBorderSize_get, _wrap_PanelColors_scrollbarBorderSize_set },
    { "scrollbarCursorBorderSize", _wrap_PanelColors_scrollbarCursorBorderSize_get, _wrap_PanelColors_scrollbarCursorBorderSize_set },
    { "textzoneBackgroundOveredGradientType", _wrap_PanelColors_textzoneBackgroundOveredGradientType_get, _wrap_PanelColors_textzoneBackgroundOveredGradientType_set },
    { "textzoneBackgroundOveredGradientStart", _wrap_PanelColors_textzoneBackgroundOveredGradientStart_get, _wrap_PanelColors_textzoneBackgroundOveredGradientStart_set },
    { "textzoneBackgroundOveredGradientEnd", _wrap_PanelColors_textzoneBackgroundOveredGradientEnd_get, _wrap_PanelColors_textzoneBackgroundOveredGradientEnd_set },
    { "textzoneBackgroundNotOveredGradientType", _wrap_PanelColors_textzoneBackgroundNotOveredGradientType_get, _wrap_PanelColors_textzoneBackgroundNotOveredGradientType_set },
    { "textzoneBackgroundNotOveredGradientStart", _wrap_PanelColors_textzoneBackgroundNotOveredGradientStart_get, _wrap_PanelColors_textzoneBackgroundNotOveredGradientStart_set },
    { "textzoneBackgroundNotOveredGradientEnd", _wrap_PanelColors_textzoneBackgroundNotOveredGradientEnd_get, _wrap_PanelColors_textzoneBackgroundNotOveredGradientEnd_set },
    { "textzoneBackgroundSelectedGradientType", _wrap_PanelColors_textzoneBackgroundSelectedGradientType_get, _wrap_PanelColors_textzoneBackgroundSelectedGradientType_set },
    { "textzoneBackgroundSelectedGradientStart", _wrap_PanelColors_textzoneBackgroundSelectedGradientStart_get, _wrap_PanelColors_textzoneBackgroundSelectedGradientStart_set },
    { "textzoneBackgroundSelectedGradientEnd", _wrap_PanelColors_textzoneBackgroundSelectedGradientEnd_get, _wrap_PanelColors_textzoneBackgroundSelectedGradientEnd_set },
    { "textzoneText", _wrap_PanelColors_textzoneText_get, _wrap_PanelColors_textzoneText_set },
    { "textzoneTextSize", _wrap_PanelColors_textzoneTextSize_get, _wrap_PanelColors_textzoneTextSize_set },
    { "textzoneBorder", _wrap_PanelColors_textzoneBorder_get, _wrap_PanelColors_textzoneBorder_set },
    { "textzoneBorderHighlight", _wrap_PanelColors_textzoneBorderHighlight_get, _wrap_PanelColors_textzoneBorderHighlight_set },
    { "textzoneBorderSelected", _wrap_PanelColors_textzoneBorderSelected_get, _wrap_PanelColors_textzoneBorderSelected_set },
    { "textzoneBorderSize", _wrap_PanelColors_textzoneBorderSize_get, _wrap_PanelColors_textzoneBorderSize_set },
    { "captionBackgroundSpriteName", _wrap_PanelColors_captionBackgroundSpriteName_get, _wrap_PanelColors_captionBackgroundSpriteName_set },
    { "captionBackgroundGradientType", _wrap_PanelColors_captionBackgroundGradientType_get, _wrap_PanelColors_captionBackgroundGradientType_set },
    { "captionBackgroundGradientStart", _wrap_PanelColors_captionBackgroundGradientStart_get, _wrap_PanelColors_captionBackgroundGradientStart_set },
    { "captionBackgroundGradientEnd", _wrap_PanelColors_captionBackgroundGradientEnd_get, _wrap_PanelColors_captionBackgroundGradientEnd_set },
    { "captionText", _wrap_PanelColors_captionText_get, _wrap_PanelColors_captionText_set },
    { "captionTextSize", _wrap_PanelColors_captionTextSize_get, _wrap_PanelColors_captionTextSize_set },
    { "captionBorder", _wrap_PanelColors_captionBorder_get, _wrap_PanelColors_captionBorder_set },
    { "captionBorderSize", _wrap_PanelColors_captionBorderSize_get, _wrap_PanelColors_captionBorderSize_set },
    { "progressbarBackgroundGradientType", _wrap_PanelColors_progressbarBackgroundGradientType_get, _wrap_PanelColors_progressbarBackgroundGradientType_set },
    { "progressbarBackgroundGradientStart", _wrap_PanelColors_progressbarBackgroundGradientStart_get, _wrap_PanelColors_progressbarBackgroundGradientStart_set },
    { "progressbarBackgroundGradientEnd", _wrap_PanelColors_progressbarBackgroundGradientEnd_get, _wrap_PanelColors_progressbarBackgroundGradientEnd_set },
    { "progressbarLoadingBarGradientType", _wrap_PanelColors_progressbarLoadingBarGradientType_get, _wrap_PanelColors_progressbarLoadingBarGradientType_set },
    { "progressbarLoadingBarGradientStart", _wrap_PanelColors_progressbarLoadingBarGradientStart_get, _wrap_PanelColors_progressbarLoadingBarGradientStart_set },
    { "progressbarLoadingBarGradientEnd", _wrap_PanelColors_progressbarLoadingBarGradientEnd_get, _wrap_PanelColors_progressbarLoadingBarGradientEnd_set },
    { "progressbarText", _wrap_PanelColors_progressbarText_get, _wrap_PanelColors_progressbarText_set },
    { "progressbarTextSize", _wrap_PanelColors_progressbarTextSize_get, _wrap_PanelColors_progressbarTextSize_set },
    { "progressbarBorder", _wrap_PanelColors_progressbarBorder_get, _wrap_PanelColors_progressbarBorder_set },
    { "progressbarBorderHighlight", _wrap_PanelColors_progressbarBorderHighlight_get, _wrap_PanelColors_progressbarBorderHighlight_set },
    { "progressbarBorderSize", _wrap_PanelColors_progressbarBorderSize_get, _wrap_PanelColors_progressbarBorderSize_set },
    {0,0,0}
};
static swig_lua_method swig_PanelColors_methods[]= {
    {0,0}
};
static swig_lua_method swig_PanelColors_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_PanelColors_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_PanelColors_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_PanelColors_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_PanelColors_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_PanelColors_Sf_SwigStatic = {
    "PanelColors",
    swig_PanelColors_Sf_SwigStatic_methods,
    swig_PanelColors_Sf_SwigStatic_attributes,
    swig_PanelColors_Sf_SwigStatic_constants,
    swig_PanelColors_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_PanelColors_bases[] = {0};
static const char *swig_PanelColors_base_names[] = {0};
static swig_lua_class _wrap_class_PanelColors = { "PanelColors", "PanelColors", &SWIGTYPE_p_Gui3D__PanelColors,_proxy__wrap_new_PanelColors, swig_delete_PanelColors, swig_PanelColors_methods, swig_PanelColors_attributes, &swig_PanelColors_Sf_SwigStatic, swig_PanelColors_meta, swig_PanelColors_bases, swig_PanelColors_base_names };

static int _wrap_new_gsGUI3DScriptCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsFunction arg1 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gsGUI3DScriptCallback *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DScriptCallback::gsGUI3DScriptCallback",2,2)
  if(!lua_isfunction(L,1)) SWIG_fail_arg("gsGUI3DScriptCallback::gsGUI3DScriptCallback",1,"gsFunction");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DScriptCallback::gsGUI3DScriptCallback",2,"gkString const &");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gsGUI3DScriptCallback *)new gsGUI3DScriptCallback(arg1,(gkString const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScriptCallback,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGUI3DScriptCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsSelf arg1 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  gsGUI3DScriptCallback *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DScriptCallback::gsGUI3DScriptCallback",3,3)
  if(!lua_istable(L,1)) SWIG_fail_arg("gsGUI3DScriptCallback::gsGUI3DScriptCallback",1,"gsSelf");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DScriptCallback::gsGUI3DScriptCallback",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DScriptCallback::gsGUI3DScriptCallback",3,"gkString const &");
  (&arg1)->m_id = 1; (&arg1)->L = L; 
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  result = (gsGUI3DScriptCallback *)new gsGUI3DScriptCallback(arg1,arg2,(gkString const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScriptCallback,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGUI3DScriptCallback(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    _v = lua_isfunction(L, argv[0]); 
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_gsGUI3DScriptCallback__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = lua_istable(L, argv[0]); 
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_gsGUI3DScriptCallback__SWIG_1(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsGUI3DScriptCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DScriptCallback::gsGUI3DScriptCallback(gsFunction,gkString const &)\n"
    "    gsGUI3DScriptCallback::gsGUI3DScriptCallback(gsSelf,gsFunction,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3DScriptCallback_execute(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScriptCallback *arg1 = (gsGUI3DScriptCallback *) 0 ;
  Gui3D::PanelElement *arg2 = (Gui3D::PanelElement *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGUI3DScriptCallback::execute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScriptCallback::execute",1,"gsGUI3DScriptCallback *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DScriptCallback::execute",2,"Gui3D::PanelElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScriptCallback,0))){
    SWIG_fail_ptr("gsGUI3DScriptCallback_execute",1,SWIGTYPE_p_gsGUI3DScriptCallback);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__PanelElement,0))){
    SWIG_fail_ptr("gsGUI3DScriptCallback_execute",2,SWIGTYPE_p_Gui3D__PanelElement);
  }
  
  result = (bool)(arg1)->execute(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGUI3DScriptCallback(void *obj) {
gsGUI3DScriptCallback *arg1 = (gsGUI3DScriptCallback *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DScriptCallback(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DScriptCallback);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DScriptCallback_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DScriptCallback_methods[]= {
    { "execute", _wrap_gsGUI3DScriptCallback_execute},
    {0,0}
};
static swig_lua_method swig_gsGUI3DScriptCallback_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DScriptCallback_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DScriptCallback_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DScriptCallback_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DScriptCallback_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DScriptCallback_Sf_SwigStatic = {
    "gsGUI3DScriptCallback",
    swig_gsGUI3DScriptCallback_Sf_SwigStatic_methods,
    swig_gsGUI3DScriptCallback_Sf_SwigStatic_attributes,
    swig_gsGUI3DScriptCallback_Sf_SwigStatic_constants,
    swig_gsGUI3DScriptCallback_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DScriptCallback_bases[] = {0};
static const char *swig_gsGUI3DScriptCallback_base_names[] = {0};
static swig_lua_class _wrap_class_gsGUI3DScriptCallback = { "gsGUI3DScriptCallback", "gsGUI3DScriptCallback", &SWIGTYPE_p_gsGUI3DScriptCallback,_proxy__wrap_new_gsGUI3DScriptCallback, swig_delete_gsGUI3DScriptCallback, swig_gsGUI3DScriptCallback_methods, swig_gsGUI3DScriptCallback_attributes, &swig_gsGUI3DScriptCallback_Sf_SwigStatic, swig_gsGUI3DScriptCallback_meta, swig_gsGUI3DScriptCallback_bases, swig_gsGUI3DScriptCallback_base_names };

static int _wrap_new_tsPanel(lua_State* L) {
  int SWIG_arg = 0;
  Gui3D::PanelContainer *arg1 = (Gui3D::PanelContainer *) 0 ;
  bool arg2 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("tsPanel::tsPanel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::tsPanel",1,"Gui3D::PanelContainer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("tsPanel::tsPanel",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gui3D__PanelContainer,0))){
    SWIG_fail_ptr("new_tsPanel",1,SWIGTYPE_p_Gui3D__PanelContainer);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (tsPanel *)new tsPanel(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setVisible(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("tsPanel::setVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setVisible",1,"tsPanel *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("tsPanel::setVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setVisible",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setVisible(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_isVisible(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  bool result;
  
  SWIG_check_num_args("tsPanel::isVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::isVisible",1,"tsPanel *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_isVisible",1,SWIGTYPE_p_tsPanel);
  }
  
  result = (bool)(arg1)->isVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_mouseIntersection(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  bool result;
  
  SWIG_check_num_args("tsPanel::mouseIntersection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::mouseIntersection",1,"tsPanel *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_mouseIntersection",1,SWIGTYPE_p_tsPanel);
  }
  
  result = (bool)(arg1)->mouseIntersection();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_attachToObject(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  
  SWIG_check_num_args("tsPanel::attachToObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::attachToObject",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("tsPanel::attachToObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_attachToObject",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("tsPanel_attachToObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  (arg1)->attachToObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setPosition(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("tsPanel::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setPosition",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::setPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::setPosition",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setPosition",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setPosition(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setScale(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("tsPanel::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setScale",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::setScale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::setScale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::setScale",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setScale",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setScale(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setRotation(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("tsPanel::setRotation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setRotation",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::setRotation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::setRotation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::setRotation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setRotation",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setRotation(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_getSize(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  gsVector2 result;
  
  SWIG_check_num_args("tsPanel::getSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::getSize",1,"tsPanel *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_getSize",1,SWIGTYPE_p_tsPanel);
  }
  
  result = (arg1)->getSize();
  {
    gsVector2 * resultptr = new gsVector2((const gsVector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_getSettings(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::PanelColors *result = 0 ;
  
  SWIG_check_num_args("tsPanel::getSettings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::getSettings",1,"tsPanel *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_getSettings",1,SWIGTYPE_p_tsPanel);
  }
  
  result = (Gui3D::PanelColors *)(arg1)->getSettings();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Gui3D__PanelColors,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCaption__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  gkString temp6 ;
  gsGUI3DCaption *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCaption",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCaption",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCaption",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCaption",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCaption",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCaption",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createCaption",6,"gkString const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("tsPanel::createCaption",7,"int");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("tsPanel::createCaption",8,"int");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("tsPanel::createCaption",9,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCaption",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  arg7 = (int)lua_tonumber(L, 7);
  arg8 = (int)lua_tonumber(L, 8);
  arg9 = (int)lua_tonumber(L, 9);
  result = (gsGUI3DCaption *)(arg1)->createCaption(arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7,arg8,arg9);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCaption,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCaption__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  int arg7 ;
  int arg8 ;
  gkString temp6 ;
  gsGUI3DCaption *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCaption",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCaption",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCaption",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCaption",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCaption",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCaption",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createCaption",6,"gkString const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("tsPanel::createCaption",7,"int");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("tsPanel::createCaption",8,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCaption",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  arg7 = (int)lua_tonumber(L, 7);
  arg8 = (int)lua_tonumber(L, 8);
  result = (gsGUI3DCaption *)(arg1)->createCaption(arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7,arg8);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCaption,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCaption__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  int arg7 ;
  gkString temp6 ;
  gsGUI3DCaption *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCaption",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCaption",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCaption",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCaption",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCaption",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCaption",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createCaption",6,"gkString const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("tsPanel::createCaption",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCaption",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  arg7 = (int)lua_tonumber(L, 7);
  result = (gsGUI3DCaption *)(arg1)->createCaption(arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCaption,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCaption__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  gsGUI3DCaption *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCaption",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCaption",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCaption",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCaption",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCaption",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCaption",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createCaption",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCaption",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gsGUI3DCaption *)(arg1)->createCaption(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCaption,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCaption(lua_State* L) {
  int argc;
  int argv[10]={
    1,2,3,4,5,6,7,8,9,10
  };
  
  argc = lua_gettop(L);
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createCaption__SWIG_3(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_tsPanel_createCaption__SWIG_2(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_tsPanel_createCaption__SWIG_1(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      return _wrap_tsPanel_createCaption__SWIG_0(L);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createCaption'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createCaption(float,float,int,int,gkString const &,int,int,int)\n"
    "    tsPanel::createCaption(float,float,int,int,gkString const &,int,int)\n"
    "    tsPanel::createCaption(float,float,int,int,gkString const &,int)\n"
    "    tsPanel::createCaption(float,float,int,int,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createButton__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  int arg7 ;
  gkString temp6 ;
  gsGUI3DButton *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createButton",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createButton",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createButton",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createButton",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createButton",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createButton",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createButton",6,"gkString const &");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("tsPanel::createButton",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createButton",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  arg7 = (int)lua_tonumber(L, 7);
  result = (gsGUI3DButton *)(arg1)->createButton(arg2,arg3,arg4,arg5,(gkString const &)*arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DButton,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createButton__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  gsGUI3DButton *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createButton",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createButton",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createButton",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createButton",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createButton",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createButton",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createButton",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createButton",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gsGUI3DButton *)(arg1)->createButton(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DButton,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createButton(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createButton__SWIG_1(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_tsPanel_createButton__SWIG_0(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createButton'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createButton(float,float,int,int,gkString const &,int)\n"
    "    tsPanel::createButton(float,float,int,int,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createCheckbox(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DCheckbox *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCheckbox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCheckbox",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCheckbox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCheckbox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCheckbox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCheckbox",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCheckbox",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DCheckbox *)(arg1)->createCheckbox(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCheckbox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCombobox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  gsGUI3DCombobox *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCombobox",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCombobox",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCombobox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCombobox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCombobox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCombobox",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("tsPanel::createCombobox",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCombobox",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (gsGUI3DCombobox *)(arg1)->createCombobox(arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCombobox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCombobox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DCombobox *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createCombobox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createCombobox",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createCombobox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createCombobox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createCombobox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createCombobox",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createCombobox",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DCombobox *)(arg1)->createCombobox(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCombobox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createCombobox(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_createCombobox__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createCombobox__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createCombobox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createCombobox(float,float,int,int,int)\n"
    "    tsPanel::createCombobox(float,float,int,int)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createListbox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  gsGUI3DListbox *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createListbox",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createListbox",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createListbox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createListbox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createListbox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createListbox",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("tsPanel::createListbox",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createListbox",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (gsGUI3DListbox *)(arg1)->createListbox(arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DListbox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createListbox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DListbox *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createListbox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createListbox",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createListbox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createListbox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createListbox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createListbox",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createListbox",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DListbox *)(arg1)->createListbox(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DListbox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createListbox(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_createListbox__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createListbox__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createListbox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createListbox(float,float,int,int,int)\n"
    "    tsPanel::createListbox(float,float,int,int)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createProgressbar(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DProgressbar *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createProgressbar",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createProgressbar",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createProgressbar",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createProgressbar",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createProgressbar",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createProgressbar",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createProgressbar",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DProgressbar *)(arg1)->createProgressbar(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DProgressbar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createScrollbar__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  float arg6 ;
  float arg7 ;
  gsGUI3DScrollbar *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createScrollbar",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createScrollbar",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createScrollbar",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createScrollbar",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createScrollbar",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createScrollbar",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("tsPanel::createScrollbar",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("tsPanel::createScrollbar",7,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createScrollbar",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  result = (gsGUI3DScrollbar *)(arg1)->createScrollbar(arg2,arg3,arg4,arg5,arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScrollbar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createScrollbar__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  float arg6 ;
  gsGUI3DScrollbar *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createScrollbar",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createScrollbar",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createScrollbar",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createScrollbar",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createScrollbar",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createScrollbar",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("tsPanel::createScrollbar",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createScrollbar",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  result = (gsGUI3DScrollbar *)(arg1)->createScrollbar(arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScrollbar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createScrollbar__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DScrollbar *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createScrollbar",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createScrollbar",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createScrollbar",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createScrollbar",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createScrollbar",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createScrollbar",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createScrollbar",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DScrollbar *)(arg1)->createScrollbar(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScrollbar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createScrollbar(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_createScrollbar__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createScrollbar__SWIG_1(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_tsPanel_createScrollbar__SWIG_0(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createScrollbar'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createScrollbar(float,float,int,int,float,float)\n"
    "    tsPanel::createScrollbar(float,float,int,int,float)\n"
    "    tsPanel::createScrollbar(float,float,int,int)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createTextfield__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  gsGUI3DTextField *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createTextfield",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createTextfield",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createTextfield",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createTextfield",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createTextfield",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createTextfield",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createTextfield",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createTextfield",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gsGUI3DTextField *)(arg1)->createTextfield(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DTextField,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createTextfield__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DTextField *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createTextfield",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createTextfield",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createTextfield",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createTextfield",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createTextfield",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createTextfield",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createTextfield",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DTextField *)(arg1)->createTextfield(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DTextField,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createTextfield(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_createTextfield__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createTextfield__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createTextfield'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createTextfield(float,float,int,int,gkString const &)\n"
    "    tsPanel::createTextfield(float,float,int,int)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_createRectangle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsVector4 *arg6 = 0 ;
  gsGUI3DRectangle *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createRectangle",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createRectangle",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createRectangle",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createRectangle",5,"int");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("tsPanel::createRectangle",6,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createRectangle",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("tsPanel_createRectangle",6,SWIGTYPE_p_gsVector4);
  }
  
  result = (gsGUI3DRectangle *)(arg1)->createRectangle(arg2,arg3,arg4,arg5,(gsVector4 const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DRectangle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createRectangle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gsGUI3DRectangle *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createRectangle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createRectangle",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createRectangle",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createRectangle",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createRectangle",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (gsGUI3DRectangle *)(arg1)->createRectangle(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DRectangle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createRectangle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  int arg4 ;
  int arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  gsGUI3DRectangle *result = 0 ;
  
  SWIG_check_num_args("tsPanel::createRectangle",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::createRectangle",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::createRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::createRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::createRectangle",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::createRectangle",5,"int");
  if(!lua_isstring(L,6)) SWIG_fail_arg("tsPanel::createRectangle",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_createRectangle",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gsGUI3DRectangle *)(arg1)->createRectangle(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DRectangle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_createRectangle(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_createRectangle__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                return _wrap_tsPanel_createRectangle__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_tsPanel_createRectangle__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_createRectangle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::createRectangle(float,float,int,int,gsVector4 const &)\n"
    "    tsPanel::createRectangle(float,float,int,int)\n"
    "    tsPanel::createRectangle(float,float,int,int,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_setBackgroundColor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("tsPanel::setBackgroundColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setBackgroundColor",1,"tsPanel *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("tsPanel::setBackgroundColor",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setBackgroundColor",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("tsPanel_setBackgroundColor",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackgroundColor((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setBackgroundColor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("tsPanel::setBackgroundColor",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setBackgroundColor",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::setBackgroundColor",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("tsPanel::setBackgroundColor",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("tsPanel::setBackgroundColor",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("tsPanel::setBackgroundColor",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setBackgroundColor",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setBackgroundColor(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_setBackgroundColor(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_tsPanel_setBackgroundColor__SWIG_0(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_tsPanel, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_tsPanel_setBackgroundColor__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'tsPanel_setBackgroundColor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    tsPanel::setBackgroundColor(gsVector4 const &)\n"
    "    tsPanel::setBackgroundColor(float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_tsPanel_setBackgroundBorder(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = 0 ;
  
  SWIG_check_num_args("tsPanel::setBackgroundBorder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::setBackgroundBorder",1,"tsPanel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tsPanel::setBackgroundBorder",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("tsPanel::setBackgroundBorder",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_setBackgroundBorder",1,SWIGTYPE_p_tsPanel);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("tsPanel_setBackgroundBorder",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackgroundBorder(arg2,(gsVector4 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_tsPanel_destroy(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  gsGUI3DRectangle *arg2 = (gsGUI3DRectangle *) 0 ;
  
  SWIG_check_num_args("tsPanel::destroy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tsPanel::destroy",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("tsPanel::destroy",2,"gsGUI3DRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("tsPanel_destroy",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("tsPanel_destroy",2,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  (arg1)->destroy(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_tsPanel(void *obj) {
tsPanel *arg1 = (tsPanel *) obj;
delete arg1;
}
static int _proxy__wrap_new_tsPanel(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_tsPanel);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_tsPanel_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_tsPanel_methods[]= {
    { "setVisible", _wrap_tsPanel_setVisible},
    { "isVisible", _wrap_tsPanel_isVisible},
    { "mouseIntersection", _wrap_tsPanel_mouseIntersection},
    { "attachToObject", _wrap_tsPanel_attachToObject},
    { "setPosition", _wrap_tsPanel_setPosition},
    { "setScale", _wrap_tsPanel_setScale},
    { "setRotation", _wrap_tsPanel_setRotation},
    { "getSize", _wrap_tsPanel_getSize},
    { "getSettings", _wrap_tsPanel_getSettings},
    { "createCaption", _wrap_tsPanel_createCaption},
    { "createButton", _wrap_tsPanel_createButton},
    { "createCheckbox", _wrap_tsPanel_createCheckbox},
    { "createCombobox", _wrap_tsPanel_createCombobox},
    { "createListbox", _wrap_tsPanel_createListbox},
    { "createProgressbar", _wrap_tsPanel_createProgressbar},
    { "createScrollbar", _wrap_tsPanel_createScrollbar},
    { "createTextfield", _wrap_tsPanel_createTextfield},
    { "createRectangle", _wrap_tsPanel_createRectangle},
    { "setBackgroundColor", _wrap_tsPanel_setBackgroundColor},
    { "setBackgroundBorder", _wrap_tsPanel_setBackgroundBorder},
    { "destroy", _wrap_tsPanel_destroy},
    {0,0}
};
static swig_lua_method swig_tsPanel_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_tsPanel_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_tsPanel_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_tsPanel_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_tsPanel_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_tsPanel_Sf_SwigStatic = {
    "tsPanel",
    swig_tsPanel_Sf_SwigStatic_methods,
    swig_tsPanel_Sf_SwigStatic_attributes,
    swig_tsPanel_Sf_SwigStatic_constants,
    swig_tsPanel_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_tsPanel_bases[] = {0};
static const char *swig_tsPanel_base_names[] = {0};
static swig_lua_class _wrap_class_tsPanel = { "tsPanel", "tsPanel", &SWIGTYPE_p_tsPanel,_proxy__wrap_new_tsPanel, swig_delete_tsPanel, swig_tsPanel_methods, swig_tsPanel_attributes, &swig_tsPanel_Sf_SwigStatic, swig_tsPanel_meta, swig_tsPanel_bases, swig_tsPanel_base_names };

static int _wrap_new_gsGUI3DElement(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::PanelElement *arg2 = (Gui3D::PanelElement *) 0 ;
  gsGUI3DElement *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DElement::gsGUI3DElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::gsGUI3DElement",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DElement::gsGUI3DElement",2,"Gui3D::PanelElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DElement",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__PanelElement,0))){
    SWIG_fail_ptr("new_gsGUI3DElement",2,SWIGTYPE_p_Gui3D__PanelElement);
  }
  
  result = (gsGUI3DElement *)new gsGUI3DElement(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DElement,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_setSize(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("gsGUI3DElement::setSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::setSize",1,"gsGUI3DElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DElement::setSize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DElement::setSize",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_setSize",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setSize(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_setPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("gsGUI3DElement::setPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::setPosition",1,"gsGUI3DElement *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DElement::setPosition",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DElement::setPosition",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_setPosition",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setPosition(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_getPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  gsVector3 result;
  
  SWIG_check_num_args("gsGUI3DElement::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::getPosition",1,"gsGUI3DElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_getPosition",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  result = (arg1)->getPosition();
  {
    gsVector3 * resultptr = new gsVector3((const gsVector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_setName(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DElement::setName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::setName",1,"gsGUI3DElement *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DElement::setName",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_setName",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setName((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_getName(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  gkString *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DElement::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::getName",1,"gsGUI3DElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_getName",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  result = (gkString *) &(arg1)->getName();
  
  lua_pushlstring(L, result->data(),result->size()); SWIG_arg++;
  //    lua_pushstring(L, result->c_str()); SWIG_arg++;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_isHovered(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGUI3DElement::isHovered",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::isHovered",1,"gsGUI3DElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_isHovered",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  result = (bool)(arg1)->isHovered();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_isFocused(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGUI3DElement::isFocused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::isFocused",1,"gsGUI3DElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_isFocused",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  result = (bool)(arg1)->isFocused();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_setFocus(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI3DElement::setFocus",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::setFocus",1,"gsGUI3DElement *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI3DElement::setFocus",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_setFocus",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setFocus(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DElement_getType(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DElement *arg1 = (gsGUI3DElement *) 0 ;
  GuiType result;
  
  SWIG_check_num_args("gsGUI3DElement::getType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DElement::getType",1,"gsGUI3DElement *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DElement,0))){
    SWIG_fail_ptr("gsGUI3DElement_getType",1,SWIGTYPE_p_gsGUI3DElement);
  }
  
  result = (GuiType)(arg1)->getType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGUI3DElement(void *obj) {
gsGUI3DElement *arg1 = (gsGUI3DElement *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DElement(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DElement);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DElement_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DElement_methods[]= {
    { "setSize", _wrap_gsGUI3DElement_setSize},
    { "setPosition", _wrap_gsGUI3DElement_setPosition},
    { "getPosition", _wrap_gsGUI3DElement_getPosition},
    { "setName", _wrap_gsGUI3DElement_setName},
    { "getName", _wrap_gsGUI3DElement_getName},
    { "isHovered", _wrap_gsGUI3DElement_isHovered},
    { "isFocused", _wrap_gsGUI3DElement_isFocused},
    { "setFocus", _wrap_gsGUI3DElement_setFocus},
    { "getType", _wrap_gsGUI3DElement_getType},
    {0,0}
};
static swig_lua_method swig_gsGUI3DElement_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DElement_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DElement_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DElement_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DElement_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DElement_Sf_SwigStatic = {
    "gsGUI3DElement",
    swig_gsGUI3DElement_Sf_SwigStatic_methods,
    swig_gsGUI3DElement_Sf_SwigStatic_attributes,
    swig_gsGUI3DElement_Sf_SwigStatic_constants,
    swig_gsGUI3DElement_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DElement_bases[] = {0};
static const char *swig_gsGUI3DElement_base_names[] = {0};
static swig_lua_class _wrap_class_gsGUI3DElement = { "gsGUI3DElement", "gsGUI3DElement", &SWIGTYPE_p_gsGUI3DElement,_proxy__wrap_new_gsGUI3DElement, swig_delete_gsGUI3DElement, swig_gsGUI3DElement_methods, swig_gsGUI3DElement_attributes, &swig_gsGUI3DElement_Sf_SwigStatic, swig_gsGUI3DElement_meta, swig_gsGUI3DElement_bases, swig_gsGUI3DElement_base_names };

static int _wrap_new_gsRectangleDesigned(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::Rectangle *arg1 = (Gorilla::Rectangle *) 0 ;
  gsRectangleDesigned *result = 0 ;
  
  SWIG_check_num_args("gsRectangleDesigned::gsRectangleDesigned",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::gsRectangleDesigned",1,"Gorilla::Rectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Rectangle,0))){
    SWIG_fail_ptr("new_gsRectangleDesigned",1,SWIGTYPE_p_Gorilla__Rectangle);
  }
  
  result = (gsRectangleDesigned *)new gsRectangleDesigned(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsRectangleDesigned,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBackground__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRectangleDesigned *arg1 = (gsRectangleDesigned *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsRectangleDesigned::setBackground",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::setBackground",1,"gsRectangleDesigned *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsRectangleDesigned::setBackground",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRectangleDesigned,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBackground",1,SWIGTYPE_p_gsRectangleDesigned);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBackground",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackground((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBackground__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRectangleDesigned *arg1 = (gsRectangleDesigned *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsRectangleDesigned::setBackground",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::setBackground",1,"gsRectangleDesigned *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRectangleDesigned::setBackground",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRectangleDesigned::setBackground",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsRectangleDesigned::setBackground",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsRectangleDesigned::setBackground",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRectangleDesigned,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBackground",1,SWIGTYPE_p_gsRectangleDesigned);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setBackground(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBackground__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsRectangleDesigned *arg1 = (gsRectangleDesigned *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsRectangleDesigned::setBackground",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::setBackground",1,"gsRectangleDesigned *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsRectangleDesigned::setBackground",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRectangleDesigned,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBackground",1,SWIGTYPE_p_gsRectangleDesigned);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setBackground((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBackground(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRectangleDesigned, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsRectangleDesigned_setBackground__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRectangleDesigned, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsRectangleDesigned_setBackground__SWIG_2(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRectangleDesigned, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsRectangleDesigned_setBackground__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRectangleDesigned_setBackground'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRectangleDesigned::setBackground(gsVector4 const &)\n"
    "    gsRectangleDesigned::setBackground(float,float,float,float)\n"
    "    gsRectangleDesigned::setBackground(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsRectangleDesigned_setBorder__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsRectangleDesigned *arg1 = (gsRectangleDesigned *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = 0 ;
  
  SWIG_check_num_args("gsRectangleDesigned::setBorder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::setBorder",1,"gsRectangleDesigned *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRectangleDesigned::setBorder",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsRectangleDesigned::setBorder",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRectangleDesigned,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBorder",1,SWIGTYPE_p_gsRectangleDesigned);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBorder",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBorder(arg2,(gsVector4 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBorder__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsRectangleDesigned *arg1 = (gsRectangleDesigned *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  
  SWIG_check_num_args("gsRectangleDesigned::setBorder",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsRectangleDesigned::setBorder",1,"gsRectangleDesigned *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsRectangleDesigned::setBorder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsRectangleDesigned::setBorder",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsRectangleDesigned::setBorder",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsRectangleDesigned::setBorder",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsRectangleDesigned::setBorder",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsRectangleDesigned,0))){
    SWIG_fail_ptr("gsRectangleDesigned_setBorder",1,SWIGTYPE_p_gsRectangleDesigned);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->setBorder(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsRectangleDesigned_setBorder(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRectangleDesigned, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsRectangleDesigned_setBorder__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsRectangleDesigned, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsRectangleDesigned_setBorder__SWIG_1(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsRectangleDesigned_setBorder'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsRectangleDesigned::setBorder(float,gsVector4 const &)\n"
    "    gsRectangleDesigned::setBorder(float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsRectangleDesigned(void *obj) {
gsRectangleDesigned *arg1 = (gsRectangleDesigned *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsRectangleDesigned(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsRectangleDesigned);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsRectangleDesigned_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsRectangleDesigned_methods[]= {
    { "setBackground", _wrap_gsRectangleDesigned_setBackground},
    { "setBorder", _wrap_gsRectangleDesigned_setBorder},
    {0,0}
};
static swig_lua_method swig_gsRectangleDesigned_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsRectangleDesigned_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsRectangleDesigned_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsRectangleDesigned_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsRectangleDesigned_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsRectangleDesigned_Sf_SwigStatic = {
    "gsRectangleDesigned",
    swig_gsRectangleDesigned_Sf_SwigStatic_methods,
    swig_gsRectangleDesigned_Sf_SwigStatic_attributes,
    swig_gsRectangleDesigned_Sf_SwigStatic_constants,
    swig_gsRectangleDesigned_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsRectangleDesigned_bases[] = {0};
static const char *swig_gsRectangleDesigned_base_names[] = {0};
static swig_lua_class _wrap_class_gsRectangleDesigned = { "gsRectangleDesigned", "gsRectangleDesigned", &SWIGTYPE_p_gsRectangleDesigned,_proxy__wrap_new_gsRectangleDesigned, swig_delete_gsRectangleDesigned, swig_gsRectangleDesigned_methods, swig_gsRectangleDesigned_attributes, &swig_gsRectangleDesigned_Sf_SwigStatic, swig_gsRectangleDesigned_meta, swig_gsRectangleDesigned_bases, swig_gsRectangleDesigned_base_names };

static int _wrap_new_gsGUI3DButton(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Button *arg2 = (Gui3D::Button *) 0 ;
  gsGUI3DButton *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DButton::gsGUI3DButton",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::gsGUI3DButton",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DButton::gsGUI3DButton",2,"Gui3D::Button *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DButton",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Button,0))){
    SWIG_fail_ptr("new_gsGUI3DButton",2,SWIGTYPE_p_Gui3D__Button);
  }
  
  result = (gsGUI3DButton *)new gsGUI3DButton(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DButton,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_setText(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DButton::setText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::setText",1,"gsGUI3DButton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DButton::setText",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_setText",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setText((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_setBackgroundImage(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gkString *arg2 = 0 ;
  gkString *arg3 = 0 ;
  gkString *arg4 = 0 ;
  gkString *arg5 = 0 ;
  gkString temp2 ;
  gkString temp3 ;
  gkString temp4 ;
  gkString temp5 ;
  
  SWIG_check_num_args("gsGUI3DButton::setBackgroundImage",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::setBackgroundImage",1,"gsGUI3DButton *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DButton::setBackgroundImage",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DButton::setBackgroundImage",3,"gkString const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DButton::setBackgroundImage",4,"gkString const &");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGUI3DButton::setBackgroundImage",5,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_setBackgroundImage",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  (arg1)->setBackgroundImage((gkString const &)*arg2,(gkString const &)*arg3,(gkString const &)*arg4,(gkString const &)*arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_setTextColor(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGUI3DButton::setTextColor",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::setTextColor",1,"gsGUI3DButton *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DButton::setTextColor",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DButton::setTextColor",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3DButton::setTextColor",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3DButton::setTextColor",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_setTextColor",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setTextColor(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_setFont(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGUI3DButton::setFont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::setFont",1,"gsGUI3DButton *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DButton::setFont",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_setFont",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setFont(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_onClicked__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DButton::onClicked",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::onClicked",1,"gsGUI3DButton *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DButton::onClicked",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DButton::onClicked",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_onClicked",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onClicked(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_onClicked__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DButton::onClicked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::onClicked",1,"gsGUI3DButton *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DButton::onClicked",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_onClicked",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onClicked(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_onClicked__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DButton::onClicked",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::onClicked",1,"gsGUI3DButton *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DButton::onClicked",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DButton::onClicked",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DButton::onClicked",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_onClicked",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onClicked(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_onClicked__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DButton *arg1 = (gsGUI3DButton *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DButton::onClicked",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DButton::onClicked",1,"gsGUI3DButton *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DButton::onClicked",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DButton::onClicked",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DButton,0))){
    SWIG_fail_ptr("gsGUI3DButton_onClicked",1,SWIGTYPE_p_gsGUI3DButton);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onClicked(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DButton_onClicked(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DButton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DButton_onClicked__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DButton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DButton_onClicked__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DButton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DButton_onClicked__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DButton, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DButton_onClicked__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DButton_onClicked'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DButton::onClicked(gsFunction,gkString const &)\n"
    "    gsGUI3DButton::onClicked(gsFunction)\n"
    "    gsGUI3DButton::onClicked(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DButton::onClicked(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DButton(void *obj) {
gsGUI3DButton *arg1 = (gsGUI3DButton *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DButton(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DButton);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DButton_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DButton_methods[]= {
    { "setText", _wrap_gsGUI3DButton_setText},
    { "setBackgroundImage", _wrap_gsGUI3DButton_setBackgroundImage},
    { "setTextColor", _wrap_gsGUI3DButton_setTextColor},
    { "setFont", _wrap_gsGUI3DButton_setFont},
    { "onClicked", _wrap_gsGUI3DButton_onClicked},
    {0,0}
};
static swig_lua_method swig_gsGUI3DButton_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DButton_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DButton_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DButton_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DButton_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DButton_Sf_SwigStatic = {
    "gsGUI3DButton",
    swig_gsGUI3DButton_Sf_SwigStatic_methods,
    swig_gsGUI3DButton_Sf_SwigStatic_attributes,
    swig_gsGUI3DButton_Sf_SwigStatic_constants,
    swig_gsGUI3DButton_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DButton_bases[] = {0,0,0};
static const char *swig_gsGUI3DButton_base_names[] = {"gsGUI3DElement *","gsRectangleDesigned *",0};
static swig_lua_class _wrap_class_gsGUI3DButton = { "gsGUI3DButton", "gsGUI3DButton", &SWIGTYPE_p_gsGUI3DButton,_proxy__wrap_new_gsGUI3DButton, swig_delete_gsGUI3DButton, swig_gsGUI3DButton_methods, swig_gsGUI3DButton_attributes, &swig_gsGUI3DButton_Sf_SwigStatic, swig_gsGUI3DButton_meta, swig_gsGUI3DButton_bases, swig_gsGUI3DButton_base_names };

static int _wrap_new_gsGUI3DCaption(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Caption *arg2 = (Gui3D::Caption *) 0 ;
  gsGUI3DCaption *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DCaption::gsGUI3DCaption",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::gsGUI3DCaption",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DCaption::gsGUI3DCaption",2,"Gui3D::Caption *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DCaption",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Caption,0))){
    SWIG_fail_ptr("new_gsGUI3DCaption",2,SWIGTYPE_p_Gui3D__Caption);
  }
  
  result = (gsGUI3DCaption *)new gsGUI3DCaption(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCaption,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCaption_setText(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCaption *arg1 = (gsGUI3DCaption *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DCaption::setText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::setText",1,"gsGUI3DCaption *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DCaption::setText",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCaption,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setText",1,SWIGTYPE_p_gsGUI3DCaption);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setText((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCaption_setBackgroundImage(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCaption *arg1 = (gsGUI3DCaption *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DCaption::setBackgroundImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::setBackgroundImage",1,"gsGUI3DCaption *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DCaption::setBackgroundImage",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCaption,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setBackgroundImage",1,SWIGTYPE_p_gsGUI3DCaption);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setBackgroundImage((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCaption_setTextColor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCaption *arg1 = (gsGUI3DCaption *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGUI3DCaption::setTextColor",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",1,"gsGUI3DCaption *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCaption,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setTextColor",1,SWIGTYPE_p_gsGUI3DCaption);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setTextColor(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCaption_setTextColor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCaption *arg1 = (gsGUI3DCaption *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGUI3DCaption::setTextColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",1,"gsGUI3DCaption *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGUI3DCaption::setTextColor",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCaption,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setTextColor",1,SWIGTYPE_p_gsGUI3DCaption);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setTextColor",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setTextColor((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCaption_setTextColor(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCaption, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGUI3DCaption_setTextColor__SWIG_1(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCaption, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGUI3DCaption_setTextColor__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DCaption_setTextColor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DCaption::setTextColor(float,float,float,float)\n"
    "    gsGUI3DCaption::setTextColor(gsVector4 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3DCaption_setFont(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCaption *arg1 = (gsGUI3DCaption *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGUI3DCaption::setFont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCaption::setFont",1,"gsGUI3DCaption *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DCaption::setFont",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCaption,0))){
    SWIG_fail_ptr("gsGUI3DCaption_setFont",1,SWIGTYPE_p_gsGUI3DCaption);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setFont(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGUI3DCaption(void *obj) {
gsGUI3DCaption *arg1 = (gsGUI3DCaption *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DCaption(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DCaption);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DCaption_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DCaption_methods[]= {
    { "setText", _wrap_gsGUI3DCaption_setText},
    { "setBackgroundImage", _wrap_gsGUI3DCaption_setBackgroundImage},
    { "setTextColor", _wrap_gsGUI3DCaption_setTextColor},
    { "setFont", _wrap_gsGUI3DCaption_setFont},
    {0,0}
};
static swig_lua_method swig_gsGUI3DCaption_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DCaption_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DCaption_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DCaption_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DCaption_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DCaption_Sf_SwigStatic = {
    "gsGUI3DCaption",
    swig_gsGUI3DCaption_Sf_SwigStatic_methods,
    swig_gsGUI3DCaption_Sf_SwigStatic_attributes,
    swig_gsGUI3DCaption_Sf_SwigStatic_constants,
    swig_gsGUI3DCaption_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DCaption_bases[] = {0,0};
static const char *swig_gsGUI3DCaption_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DCaption = { "gsGUI3DCaption", "gsGUI3DCaption", &SWIGTYPE_p_gsGUI3DCaption,_proxy__wrap_new_gsGUI3DCaption, swig_delete_gsGUI3DCaption, swig_gsGUI3DCaption_methods, swig_gsGUI3DCaption_attributes, &swig_gsGUI3DCaption_Sf_SwigStatic, swig_gsGUI3DCaption_meta, swig_gsGUI3DCaption_bases, swig_gsGUI3DCaption_base_names };

static int _wrap_new_gsGUI3DCheckbox(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Checkbox *arg2 = (Gui3D::Checkbox *) 0 ;
  gsGUI3DCheckbox *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::gsGUI3DCheckbox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::gsGUI3DCheckbox",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::gsGUI3DCheckbox",2,"Gui3D::Checkbox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DCheckbox",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Checkbox,0))){
    SWIG_fail_ptr("new_gsGUI3DCheckbox",2,SWIGTYPE_p_Gui3D__Checkbox);
  }
  
  result = (gsGUI3DCheckbox *)new gsGUI3DCheckbox(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCheckbox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_setChecked(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::setChecked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::setChecked",1,"gsGUI3DCheckbox *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::setChecked",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_setChecked",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setChecked(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_isChecked(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  bool result;
  
  SWIG_check_num_args("gsGUI3DCheckbox::isChecked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::isChecked",1,"gsGUI3DCheckbox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_isChecked",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  result = (bool)(arg1)->isChecked();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_onChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",1,"gsGUI3DCheckbox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_onChanged",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_onChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::onChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",1,"gsGUI3DCheckbox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_onChanged",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_onChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::onChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",1,"gsGUI3DCheckbox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_onChanged",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_onChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DCheckbox::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",1,"gsGUI3DCheckbox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DCheckbox::onChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCheckbox,0))){
    SWIG_fail_ptr("gsGUI3DCheckbox_onChanged",1,SWIGTYPE_p_gsGUI3DCheckbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCheckbox_onChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCheckbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DCheckbox_onChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCheckbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DCheckbox_onChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCheckbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DCheckbox_onChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCheckbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DCheckbox_onChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DCheckbox_onChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DCheckbox::onChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DCheckbox::onChanged(gsFunction)\n"
    "    gsGUI3DCheckbox::onChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DCheckbox::onChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DCheckbox(void *obj) {
gsGUI3DCheckbox *arg1 = (gsGUI3DCheckbox *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DCheckbox(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DCheckbox);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DCheckbox_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DCheckbox_methods[]= {
    { "setChecked", _wrap_gsGUI3DCheckbox_setChecked},
    { "isChecked", _wrap_gsGUI3DCheckbox_isChecked},
    { "onChanged", _wrap_gsGUI3DCheckbox_onChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DCheckbox_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DCheckbox_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DCheckbox_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DCheckbox_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DCheckbox_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DCheckbox_Sf_SwigStatic = {
    "gsGUI3DCheckbox",
    swig_gsGUI3DCheckbox_Sf_SwigStatic_methods,
    swig_gsGUI3DCheckbox_Sf_SwigStatic_attributes,
    swig_gsGUI3DCheckbox_Sf_SwigStatic_constants,
    swig_gsGUI3DCheckbox_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DCheckbox_bases[] = {0,0};
static const char *swig_gsGUI3DCheckbox_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DCheckbox = { "gsGUI3DCheckbox", "gsGUI3DCheckbox", &SWIGTYPE_p_gsGUI3DCheckbox,_proxy__wrap_new_gsGUI3DCheckbox, swig_delete_gsGUI3DCheckbox, swig_gsGUI3DCheckbox_methods, swig_gsGUI3DCheckbox_attributes, &swig_gsGUI3DCheckbox_Sf_SwigStatic, swig_gsGUI3DCheckbox_meta, swig_gsGUI3DCheckbox_bases, swig_gsGUI3DCheckbox_base_names };

static int _wrap_new_gsGUI3DTextField(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::TextZone *arg2 = (Gui3D::TextZone *) 0 ;
  gsGUI3DTextField *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DTextField::gsGUI3DTextField",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::gsGUI3DTextField",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DTextField::gsGUI3DTextField",2,"Gui3D::TextZone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DTextField",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__TextZone,0))){
    SWIG_fail_ptr("new_gsGUI3DTextField",2,SWIGTYPE_p_Gui3D__TextZone);
  }
  
  result = (gsGUI3DTextField *)new gsGUI3DTextField(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DTextField,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DTextField::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::setValue",1,"gsGUI3DTextField *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DTextField::setValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_setValue",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGUI3DTextField::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::getValue",1,"gsGUI3DTextField *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_getValue",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_setMaxLength(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGUI3DTextField::setMaxLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::setMaxLength",1,"gsGUI3DTextField *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DTextField::setMaxLength",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_setMaxLength",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setMaxLength(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_setFont(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gsGUI3DTextField::setFont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::setFont",1,"gsGUI3DTextField *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DTextField::setFont",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_setFont",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setFont(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_onChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DTextField::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::onChanged",1,"gsGUI3DTextField *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DTextField::onChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DTextField::onChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_onChanged",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_onChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DTextField::onChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::onChanged",1,"gsGUI3DTextField *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DTextField::onChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_onChanged",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_onChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DTextField::onChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::onChanged",1,"gsGUI3DTextField *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DTextField::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DTextField::onChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DTextField::onChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_onChanged",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_onChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DTextField *arg1 = (gsGUI3DTextField *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DTextField::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DTextField::onChanged",1,"gsGUI3DTextField *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DTextField::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DTextField::onChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DTextField,0))){
    SWIG_fail_ptr("gsGUI3DTextField_onChanged",1,SWIGTYPE_p_gsGUI3DTextField);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DTextField_onChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DTextField, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DTextField_onChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DTextField, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DTextField_onChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DTextField, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DTextField_onChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DTextField, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DTextField_onChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DTextField_onChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DTextField::onChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DTextField::onChanged(gsFunction)\n"
    "    gsGUI3DTextField::onChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DTextField::onChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DTextField(void *obj) {
gsGUI3DTextField *arg1 = (gsGUI3DTextField *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DTextField(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DTextField);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DTextField_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DTextField_methods[]= {
    { "setValue", _wrap_gsGUI3DTextField_setValue},
    { "getValue", _wrap_gsGUI3DTextField_getValue},
    { "setMaxLength", _wrap_gsGUI3DTextField_setMaxLength},
    { "setFont", _wrap_gsGUI3DTextField_setFont},
    { "onChanged", _wrap_gsGUI3DTextField_onChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DTextField_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DTextField_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DTextField_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DTextField_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DTextField_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DTextField_Sf_SwigStatic = {
    "gsGUI3DTextField",
    swig_gsGUI3DTextField_Sf_SwigStatic_methods,
    swig_gsGUI3DTextField_Sf_SwigStatic_attributes,
    swig_gsGUI3DTextField_Sf_SwigStatic_constants,
    swig_gsGUI3DTextField_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DTextField_bases[] = {0,0};
static const char *swig_gsGUI3DTextField_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DTextField = { "gsGUI3DTextField", "gsGUI3DTextField", &SWIGTYPE_p_gsGUI3DTextField,_proxy__wrap_new_gsGUI3DTextField, swig_delete_gsGUI3DTextField, swig_gsGUI3DTextField_methods, swig_gsGUI3DTextField_attributes, &swig_gsGUI3DTextField_Sf_SwigStatic, swig_gsGUI3DTextField_meta, swig_gsGUI3DTextField_bases, swig_gsGUI3DTextField_base_names };

static int _wrap_new_gsGUI3DRectangle(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Rectangle *arg2 = (Gui3D::Rectangle *) 0 ;
  gsGUI3DRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::gsGUI3DRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::gsGUI3DRectangle",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DRectangle::gsGUI3DRectangle",2,"Gui3D::Rectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DRectangle",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Rectangle,0))){
    SWIG_fail_ptr("new_gsGUI3DRectangle",2,SWIGTYPE_p_Gui3D__Rectangle);
  }
  
  result = (gsGUI3DRectangle *)new gsGUI3DRectangle(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DRectangle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBackground__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::setBackground",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",1,"gsGUI3DRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBackground",1,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBackground",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackground((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBackground__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::setBackground",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",1,"gsGUI3DRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBackground",1,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setBackground(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBackground__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::setBackground",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",1,"gsGUI3DRectangle *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DRectangle::setBackground",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBackground",1,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setBackground((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBackground(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGUI3DRectangle_setBackground__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGUI3DRectangle_setBackground__SWIG_2(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGUI3DRectangle_setBackground__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DRectangle_setBackground'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DRectangle::setBackground(gsVector4 const &)\n"
    "    gsGUI3DRectangle::setBackground(float,float,float,float)\n"
    "    gsGUI3DRectangle::setBackground(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3DRectangle_setBorder__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = 0 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::setBorder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",1,"gsGUI3DRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBorder",1,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBorder",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBorder(arg2,(gsVector4 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBorder__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  
  SWIG_check_num_args("gsGUI3DRectangle::setBorder",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",1,"gsGUI3DRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsGUI3DRectangle::setBorder",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DRectangle,0))){
    SWIG_fail_ptr("gsGUI3DRectangle_setBorder",1,SWIGTYPE_p_gsGUI3DRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->setBorder(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DRectangle_setBorder(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsGUI3DRectangle_setBorder__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsGUI3DRectangle_setBorder__SWIG_1(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DRectangle_setBorder'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DRectangle::setBorder(float,gsVector4 const &)\n"
    "    gsGUI3DRectangle::setBorder(float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DRectangle(void *obj) {
gsGUI3DRectangle *arg1 = (gsGUI3DRectangle *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DRectangle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DRectangle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DRectangle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DRectangle_methods[]= {
    { "setBackground", _wrap_gsGUI3DRectangle_setBackground},
    { "setBorder", _wrap_gsGUI3DRectangle_setBorder},
    {0,0}
};
static swig_lua_method swig_gsGUI3DRectangle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DRectangle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DRectangle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DRectangle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DRectangle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DRectangle_Sf_SwigStatic = {
    "gsGUI3DRectangle",
    swig_gsGUI3DRectangle_Sf_SwigStatic_methods,
    swig_gsGUI3DRectangle_Sf_SwigStatic_attributes,
    swig_gsGUI3DRectangle_Sf_SwigStatic_constants,
    swig_gsGUI3DRectangle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DRectangle_bases[] = {0,0};
static const char *swig_gsGUI3DRectangle_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DRectangle = { "gsGUI3DRectangle", "gsGUI3DRectangle", &SWIGTYPE_p_gsGUI3DRectangle,_proxy__wrap_new_gsGUI3DRectangle, swig_delete_gsGUI3DRectangle, swig_gsGUI3DRectangle_methods, swig_gsGUI3DRectangle_attributes, &swig_gsGUI3DRectangle_Sf_SwigStatic, swig_gsGUI3DRectangle_meta, swig_gsGUI3DRectangle_bases, swig_gsGUI3DRectangle_base_names };

static int _wrap_new_gsGUI3DProgressbar(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::ProgressBar *arg2 = (Gui3D::ProgressBar *) 0 ;
  gsGUI3DProgressbar *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::gsGUI3DProgressbar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::gsGUI3DProgressbar",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::gsGUI3DProgressbar",2,"Gui3D::ProgressBar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DProgressbar",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__ProgressBar,0))){
    SWIG_fail_ptr("new_gsGUI3DProgressbar",2,SWIGTYPE_p_Gui3D__ProgressBar);
  }
  
  result = (gsGUI3DProgressbar *)new gsGUI3DProgressbar(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DProgressbar,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_setBackground__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::setBackground",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",1,"gsGUI3DProgressbar *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_setBackground",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_setBackground",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackground((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_setBackground__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::setBackground",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",1,"gsGUI3DProgressbar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3DProgressbar::setBackground",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_setBackground",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setBackground(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_setBackground(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGUI3DProgressbar_setBackground__SWIG_0(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGUI3DProgressbar_setBackground__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DProgressbar_setBackground'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DProgressbar::setBackground(gsVector4 const &)\n"
    "    gsGUI3DProgressbar::setBackground(float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3DProgressbar_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::setValue",1,"gsGUI3DProgressbar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::setValue",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_setValue",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setValue(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGUI3DProgressbar::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::getValue",1,"gsGUI3DProgressbar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_getValue",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  result = (float)(arg1)->getValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_onChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",1,"gsGUI3DProgressbar *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_onChanged",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_onChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::onChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",1,"gsGUI3DProgressbar *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_onChanged",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_onChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::onChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",1,"gsGUI3DProgressbar *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_onChanged",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_onChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DProgressbar::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",1,"gsGUI3DProgressbar *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DProgressbar::onChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DProgressbar,0))){
    SWIG_fail_ptr("gsGUI3DProgressbar_onChanged",1,SWIGTYPE_p_gsGUI3DProgressbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DProgressbar_onChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DProgressbar_onChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DProgressbar_onChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DProgressbar_onChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DProgressbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DProgressbar_onChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DProgressbar_onChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DProgressbar::onChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DProgressbar::onChanged(gsFunction)\n"
    "    gsGUI3DProgressbar::onChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DProgressbar::onChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DProgressbar(void *obj) {
gsGUI3DProgressbar *arg1 = (gsGUI3DProgressbar *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DProgressbar(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DProgressbar);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DProgressbar_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DProgressbar_methods[]= {
    { "setBackground", _wrap_gsGUI3DProgressbar_setBackground},
    { "setValue", _wrap_gsGUI3DProgressbar_setValue},
    { "getValue", _wrap_gsGUI3DProgressbar_getValue},
    { "onChanged", _wrap_gsGUI3DProgressbar_onChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DProgressbar_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DProgressbar_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DProgressbar_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DProgressbar_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DProgressbar_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DProgressbar_Sf_SwigStatic = {
    "gsGUI3DProgressbar",
    swig_gsGUI3DProgressbar_Sf_SwigStatic_methods,
    swig_gsGUI3DProgressbar_Sf_SwigStatic_attributes,
    swig_gsGUI3DProgressbar_Sf_SwigStatic_constants,
    swig_gsGUI3DProgressbar_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DProgressbar_bases[] = {0,0};
static const char *swig_gsGUI3DProgressbar_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DProgressbar = { "gsGUI3DProgressbar", "gsGUI3DProgressbar", &SWIGTYPE_p_gsGUI3DProgressbar,_proxy__wrap_new_gsGUI3DProgressbar, swig_delete_gsGUI3DProgressbar, swig_gsGUI3DProgressbar_methods, swig_gsGUI3DProgressbar_attributes, &swig_gsGUI3DProgressbar_Sf_SwigStatic, swig_gsGUI3DProgressbar_meta, swig_gsGUI3DProgressbar_bases, swig_gsGUI3DProgressbar_base_names };

static int _wrap_new_gsGUI3DScrollbar(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::ScrollBar *arg2 = (Gui3D::ScrollBar *) 0 ;
  gsGUI3DScrollbar *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::gsGUI3DScrollbar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::gsGUI3DScrollbar",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::gsGUI3DScrollbar",2,"Gui3D::ScrollBar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DScrollbar",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__ScrollBar,0))){
    SWIG_fail_ptr("new_gsGUI3DScrollbar",2,SWIGTYPE_p_Gui3D__ScrollBar);
  }
  
  result = (gsGUI3DScrollbar *)new gsGUI3DScrollbar(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DScrollbar,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::setValue",1,"gsGUI3DScrollbar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::setValue",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_setValue",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setValue(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGUI3DScrollbar::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::getValue",1,"gsGUI3DScrollbar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_getValue",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  result = (float)(arg1)->getValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_setStep(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::setStep",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::setStep",1,"gsGUI3DScrollbar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::setStep",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_setStep",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setStep(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_onChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",1,"gsGUI3DScrollbar *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_onChanged",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_onChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::onChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",1,"gsGUI3DScrollbar *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_onChanged",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_onChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::onChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",1,"gsGUI3DScrollbar *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_onChanged",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_onChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DScrollbar::onChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",1,"gsGUI3DScrollbar *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DScrollbar::onChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DScrollbar,0))){
    SWIG_fail_ptr("gsGUI3DScrollbar_onChanged",1,SWIGTYPE_p_gsGUI3DScrollbar);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DScrollbar_onChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DScrollbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DScrollbar_onChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DScrollbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DScrollbar_onChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DScrollbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DScrollbar_onChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DScrollbar, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DScrollbar_onChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DScrollbar_onChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DScrollbar::onChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DScrollbar::onChanged(gsFunction)\n"
    "    gsGUI3DScrollbar::onChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DScrollbar::onChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DScrollbar(void *obj) {
gsGUI3DScrollbar *arg1 = (gsGUI3DScrollbar *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DScrollbar(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DScrollbar);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DScrollbar_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DScrollbar_methods[]= {
    { "setValue", _wrap_gsGUI3DScrollbar_setValue},
    { "getValue", _wrap_gsGUI3DScrollbar_getValue},
    { "setStep", _wrap_gsGUI3DScrollbar_setStep},
    { "onChanged", _wrap_gsGUI3DScrollbar_onChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DScrollbar_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DScrollbar_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DScrollbar_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DScrollbar_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DScrollbar_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DScrollbar_Sf_SwigStatic = {
    "gsGUI3DScrollbar",
    swig_gsGUI3DScrollbar_Sf_SwigStatic_methods,
    swig_gsGUI3DScrollbar_Sf_SwigStatic_attributes,
    swig_gsGUI3DScrollbar_Sf_SwigStatic_constants,
    swig_gsGUI3DScrollbar_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DScrollbar_bases[] = {0,0};
static const char *swig_gsGUI3DScrollbar_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DScrollbar = { "gsGUI3DScrollbar", "gsGUI3DScrollbar", &SWIGTYPE_p_gsGUI3DScrollbar,_proxy__wrap_new_gsGUI3DScrollbar, swig_delete_gsGUI3DScrollbar, swig_gsGUI3DScrollbar_methods, swig_gsGUI3DScrollbar_attributes, &swig_gsGUI3DScrollbar_Sf_SwigStatic, swig_gsGUI3DScrollbar_meta, swig_gsGUI3DScrollbar_bases, swig_gsGUI3DScrollbar_base_names };

static int _wrap_new_gsGUI3DCombobox(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Combobox *arg2 = (Gui3D::Combobox *) 0 ;
  gsGUI3DCombobox *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::gsGUI3DCombobox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::gsGUI3DCombobox",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DCombobox::gsGUI3DCombobox",2,"Gui3D::Combobox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DCombobox",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Combobox,0))){
    SWIG_fail_ptr("new_gsGUI3DCombobox",2,SWIGTYPE_p_Gui3D__Combobox);
  }
  
  result = (gsGUI3DCombobox *)new gsGUI3DCombobox(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DCombobox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::setValue",1,"gsGUI3DCombobox *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DCombobox::setValue",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_setValue",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  (arg1)->setValue(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_getValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGUI3DCombobox::getValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::getValue",1,"gsGUI3DCombobox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_getValue",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  result = (arg1)->getValue();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_addValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::addValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::addValue",1,"gsGUI3DCombobox *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DCombobox::addValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_addValue",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->addValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_onValueChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::onValueChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",1,"gsGUI3DCombobox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_onValueChanged",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onValueChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_onValueChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::onValueChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",1,"gsGUI3DCombobox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_onValueChanged",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onValueChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_onValueChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::onValueChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",1,"gsGUI3DCombobox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_onValueChanged",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onValueChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_onValueChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DCombobox::onValueChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",1,"gsGUI3DCombobox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DCombobox::onValueChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DCombobox,0))){
    SWIG_fail_ptr("gsGUI3DCombobox_onValueChanged",1,SWIGTYPE_p_gsGUI3DCombobox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onValueChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DCombobox_onValueChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCombobox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DCombobox_onValueChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCombobox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DCombobox_onValueChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCombobox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DCombobox_onValueChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DCombobox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DCombobox_onValueChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DCombobox_onValueChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DCombobox::onValueChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DCombobox::onValueChanged(gsFunction)\n"
    "    gsGUI3DCombobox::onValueChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DCombobox::onValueChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DCombobox(void *obj) {
gsGUI3DCombobox *arg1 = (gsGUI3DCombobox *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DCombobox(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DCombobox);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DCombobox_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DCombobox_methods[]= {
    { "setValue", _wrap_gsGUI3DCombobox_setValue},
    { "getValue", _wrap_gsGUI3DCombobox_getValue},
    { "addValue", _wrap_gsGUI3DCombobox_addValue},
    { "onValueChanged", _wrap_gsGUI3DCombobox_onValueChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DCombobox_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DCombobox_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DCombobox_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DCombobox_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DCombobox_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DCombobox_Sf_SwigStatic = {
    "gsGUI3DCombobox",
    swig_gsGUI3DCombobox_Sf_SwigStatic_methods,
    swig_gsGUI3DCombobox_Sf_SwigStatic_attributes,
    swig_gsGUI3DCombobox_Sf_SwigStatic_constants,
    swig_gsGUI3DCombobox_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DCombobox_bases[] = {0,0};
static const char *swig_gsGUI3DCombobox_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DCombobox = { "gsGUI3DCombobox", "gsGUI3DCombobox", &SWIGTYPE_p_gsGUI3DCombobox,_proxy__wrap_new_gsGUI3DCombobox, swig_delete_gsGUI3DCombobox, swig_gsGUI3DCombobox_methods, swig_gsGUI3DCombobox_attributes, &swig_gsGUI3DCombobox_Sf_SwigStatic, swig_gsGUI3DCombobox_meta, swig_gsGUI3DCombobox_bases, swig_gsGUI3DCombobox_base_names };

static int _wrap_new_gsGUI3DListbox(lua_State* L) {
  int SWIG_arg = 0;
  tsPanel *arg1 = (tsPanel *) 0 ;
  Gui3D::Listbox *arg2 = (Gui3D::Listbox *) 0 ;
  gsGUI3DListbox *result = 0 ;
  
  SWIG_check_num_args("gsGUI3DListbox::gsGUI3DListbox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::gsGUI3DListbox",1,"tsPanel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3DListbox::gsGUI3DListbox",2,"Gui3D::Listbox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tsPanel,0))){
    SWIG_fail_ptr("new_gsGUI3DListbox",1,SWIGTYPE_p_tsPanel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Gui3D__Listbox,0))){
    SWIG_fail_ptr("new_gsGUI3DListbox",2,SWIGTYPE_p_Gui3D__Listbox);
  }
  
  result = (gsGUI3DListbox *)new gsGUI3DListbox(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3DListbox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_setValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gkString arg2 ;
  
  SWIG_check_num_args("gsGUI3DListbox::setValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::setValue",1,"gsGUI3DListbox *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DListbox::setValue",2,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_setValue",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  
  arg2 = gkString((const char*)lua_tostring(L, 2));
  
  (arg1)->setValue(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_addValue(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3DListbox::addValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::addValue",1,"gsGUI3DListbox *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3DListbox::addValue",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_addValue",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->addValue((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_amountSelected(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGUI3DListbox::amountSelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::amountSelected",1,"gsGUI3DListbox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_amountSelected",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  result = (int)(arg1)->amountSelected();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_getSelected(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  int arg2 ;
  gkString result;
  
  SWIG_check_num_args("gsGUI3DListbox::getSelected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::getSelected",1,"gsGUI3DListbox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DListbox::getSelected",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_getSelected",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (arg1)->getSelected(arg2);
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_getSelectedIdx(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("gsGUI3DListbox::getSelectedIdx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::getSelectedIdx",1,"gsGUI3DListbox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3DListbox::getSelectedIdx",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_getSelectedIdx",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->getSelectedIdx(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_clear(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  
  SWIG_check_num_args("gsGUI3DListbox::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::clear",1,"gsGUI3DListbox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_clear",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_onValueChanged__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gsFunction arg2 ;
  gkString *arg3 = 0 ;
  gkString temp3 ;
  
  SWIG_check_num_args("gsGUI3DListbox::onValueChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",1,"gsGUI3DListbox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",2,"gsFunction");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",3,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_onValueChanged",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  
  temp3 = gkString((const char*)lua_tostring(L, 3));
  arg3 = &temp3;
  
  (arg1)->onValueChanged(arg2,(gkString const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_onValueChanged__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gsFunction arg2 ;
  
  SWIG_check_num_args("gsGUI3DListbox::onValueChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",1,"gsGUI3DListbox *");
  if(!lua_isfunction(L,2)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",2,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_onValueChanged",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (arg1)->onValueChanged(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_onValueChanged__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  
  SWIG_check_num_args("gsGUI3DListbox::onValueChanged",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",1,"gsGUI3DListbox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",3,"gsFunction");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_onValueChanged",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  (arg1)->onValueChanged(arg2,arg3,(gkString const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_onValueChanged__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3DListbox *arg1 = (gsGUI3DListbox *) 0 ;
  gsSelf arg2 ;
  gsFunction arg3 ;
  
  SWIG_check_num_args("gsGUI3DListbox::onValueChanged",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",1,"gsGUI3DListbox *");
  if(!lua_istable(L,2)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",2,"gsSelf");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3DListbox::onValueChanged",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3DListbox,0))){
    SWIG_fail_ptr("gsGUI3DListbox_onValueChanged",1,SWIGTYPE_p_gsGUI3DListbox);
  }
  
  (&arg2)->m_id = 2; (&arg2)->L = L; 
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->onValueChanged(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3DListbox_onValueChanged(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DListbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        return _wrap_gsGUI3DListbox_onValueChanged__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DListbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_isfunction(L, argv[1]); 
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGUI3DListbox_onValueChanged__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DListbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3DListbox_onValueChanged__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3DListbox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      _v = lua_istable(L, argv[1]); 
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3DListbox_onValueChanged__SWIG_2(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3DListbox_onValueChanged'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3DListbox::onValueChanged(gsFunction,gkString const &)\n"
    "    gsGUI3DListbox::onValueChanged(gsFunction)\n"
    "    gsGUI3DListbox::onValueChanged(gsSelf,gsFunction,gkString const &)\n"
    "    gsGUI3DListbox::onValueChanged(gsSelf,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3DListbox(void *obj) {
gsGUI3DListbox *arg1 = (gsGUI3DListbox *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3DListbox(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3DListbox);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3DListbox_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3DListbox_methods[]= {
    { "setValue", _wrap_gsGUI3DListbox_setValue},
    { "addValue", _wrap_gsGUI3DListbox_addValue},
    { "amountSelected", _wrap_gsGUI3DListbox_amountSelected},
    { "getSelected", _wrap_gsGUI3DListbox_getSelected},
    { "getSelectedIdx", _wrap_gsGUI3DListbox_getSelectedIdx},
    { "clear", _wrap_gsGUI3DListbox_clear},
    { "onValueChanged", _wrap_gsGUI3DListbox_onValueChanged},
    {0,0}
};
static swig_lua_method swig_gsGUI3DListbox_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3DListbox_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3DListbox_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3DListbox_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3DListbox_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3DListbox_Sf_SwigStatic = {
    "gsGUI3DListbox",
    swig_gsGUI3DListbox_Sf_SwigStatic_methods,
    swig_gsGUI3DListbox_Sf_SwigStatic_attributes,
    swig_gsGUI3DListbox_Sf_SwigStatic_constants,
    swig_gsGUI3DListbox_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3DListbox_bases[] = {0,0};
static const char *swig_gsGUI3DListbox_base_names[] = {"gsGUI3DElement *",0};
static swig_lua_class _wrap_class_gsGUI3DListbox = { "gsGUI3DListbox", "gsGUI3DListbox", &SWIGTYPE_p_gsGUI3DListbox,_proxy__wrap_new_gsGUI3DListbox, swig_delete_gsGUI3DListbox, swig_gsGUI3DListbox_methods, swig_gsGUI3DListbox_attributes, &swig_gsGUI3DListbox_Sf_SwigStatic, swig_gsGUI3DListbox_meta, swig_gsGUI3DListbox_bases, swig_gsGUI3DListbox_base_names };

static int _wrap_new_gsGUI3D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkString temp1 ;
  gsGUI3D *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::gsGUI3D",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGUI3D::gsGUI3D",1,"gkString const &");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGUI3D::gsGUI3D",2,"gsScene *");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("new_gsGUI3D",2,SWIGTYPE_p_gsScene);
  }
  
  result = (gsGUI3D *)new gsGUI3D((gkString const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGUI3D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gkString *arg1 = 0 ;
  gkString temp1 ;
  gsGUI3D *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::gsGUI3D",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("gsGUI3D::gsGUI3D",1,"gkString const &");
  
  temp1 = gkString((const char*)lua_tostring(L, 1));
  arg1 = &temp1;
  
  result = (gsGUI3D *)new gsGUI3D((gkString const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGUI3D__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::gsGUI3D",0,0)
  result = (gsGUI3D *)new gsGUI3D();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGUI3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gsGUI3D(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_gsGUI3D__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_gsGUI3D__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_gsGUI3D__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gsGUI3D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3D::gsGUI3D(gkString const &,gsScene *)\n"
    "    gsGUI3D::gsGUI3D(gkString const &)\n"
    "    gsGUI3D::gsGUI3D()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3D_showGUI(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  
  SWIG_check_num_args("gsGUI3D::showGUI",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::showGUI",1,"gsGUI3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_showGUI",1,SWIGTYPE_p_gsGUI3D);
  }
  
  (arg1)->showGUI();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_hideGUI(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  
  SWIG_check_num_args("gsGUI3D::hideGUI",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::hideGUI",1,"gsGUI3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_hideGUI",1,SWIGTYPE_p_gsGUI3D);
  }
  
  (arg1)->hideGUI();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_showConsole(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI3D::showConsole",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::showConsole",1,"gsGUI3D *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI3D::showConsole",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_showConsole",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->showConsole(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_getPanelColors(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  Gui3D::PanelColors *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::getPanelColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::getPanelColors",1,"gsGUI3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_getPanelColors",1,SWIGTYPE_p_gsGUI3D);
  }
  
  result = (Gui3D::PanelColors *)(arg1)->getPanelColors();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Gui3D__PanelColors,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  gkString *arg6 = 0 ;
  gkString *arg7 = 0 ;
  bool arg8 ;
  gkString temp6 ;
  gkString temp7 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3D::createPanel",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3D::createPanel",5,"float");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsGUI3D::createPanel",6,"gkString const &");
  if(!lua_isstring(L,7)) SWIG_fail_arg("gsGUI3D::createPanel",7,"gkString const &");
  if(!lua_isboolean(L,8)) SWIG_fail_arg("gsGUI3D::createPanel",8,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  temp7 = gkString((const char*)lua_tostring(L, 7));
  arg7 = &temp7;
  
  arg8 = (lua_toboolean(L, 8)!=0);
  result = (tsPanel *)(arg1)->createPanel(arg2,arg3,arg4,arg5,(gkString const &)*arg6,(gkString const &)*arg7,arg8);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  gkString *arg6 = 0 ;
  gkString *arg7 = 0 ;
  gkString temp6 ;
  gkString temp7 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3D::createPanel",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3D::createPanel",5,"float");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsGUI3D::createPanel",6,"gkString const &");
  if(!lua_isstring(L,7)) SWIG_fail_arg("gsGUI3D::createPanel",7,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  
  temp7 = gkString((const char*)lua_tostring(L, 7));
  arg7 = &temp7;
  
  result = (tsPanel *)(arg1)->createPanel(arg2,arg3,arg4,arg5,(gkString const &)*arg6,(gkString const &)*arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGUI3D::createPanel",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGUI3D::createPanel",5,"float");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsGUI3D::createPanel",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (tsPanel *)(arg1)->createPanel(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsGUI3D_createPanel__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isstring(L,argv[6]);
                }
                if (_v) {
                  return _wrap_gsGUI3D_createPanel__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isstring(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isboolean(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_gsGUI3D_createPanel__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3D_createPanel'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3D::createPanel(float,float,float,float,gkString const &,gkString const &,bool)\n"
    "    gsGUI3D::createPanel(float,float,float,float,gkString const &,gkString const &)\n"
    "    gsGUI3D::createPanel(float,float,float,float,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3D_createPanel3D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  gkString *arg4 = 0 ;
  gkString *arg5 = 0 ;
  float arg6 ;
  bool arg7 ;
  gkString *arg8 = 0 ;
  gkString temp4 ;
  gkString temp5 ;
  gkString temp8 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel3D",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel3D",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel3D",3,"float");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3D::createPanel3D",4,"gkString const &");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGUI3D::createPanel3D",5,"gkString const &");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsGUI3D::createPanel3D",6,"float");
  if(!lua_isboolean(L,7)) SWIG_fail_arg("gsGUI3D::createPanel3D",7,"bool");
  if(!lua_isstring(L,8)) SWIG_fail_arg("gsGUI3D::createPanel3D",8,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel3D",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (lua_toboolean(L, 7)!=0);
  
  temp8 = gkString((const char*)lua_tostring(L, 8));
  arg8 = &temp8;
  
  result = (tsPanel *)(arg1)->createPanel3D(arg2,arg3,(gkString const &)*arg4,(gkString const &)*arg5,arg6,arg7,(gkString const &)*arg8);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel3D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  gkString *arg4 = 0 ;
  gkString *arg5 = 0 ;
  float arg6 ;
  bool arg7 ;
  gkString temp4 ;
  gkString temp5 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel3D",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel3D",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel3D",3,"float");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3D::createPanel3D",4,"gkString const &");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGUI3D::createPanel3D",5,"gkString const &");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsGUI3D::createPanel3D",6,"float");
  if(!lua_isboolean(L,7)) SWIG_fail_arg("gsGUI3D::createPanel3D",7,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel3D",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (lua_toboolean(L, 7)!=0);
  result = (tsPanel *)(arg1)->createPanel3D(arg2,arg3,(gkString const &)*arg4,(gkString const &)*arg5,arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel3D__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  gkString *arg4 = 0 ;
  gkString *arg5 = 0 ;
  float arg6 ;
  gkString temp4 ;
  gkString temp5 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel3D",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel3D",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel3D",3,"float");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3D::createPanel3D",4,"gkString const &");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGUI3D::createPanel3D",5,"gkString const &");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsGUI3D::createPanel3D",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel3D",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  arg6 = (float)lua_tonumber(L, 6);
  result = (tsPanel *)(arg1)->createPanel3D(arg2,arg3,(gkString const &)*arg4,(gkString const &)*arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel3D__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  gkString *arg4 = 0 ;
  gkString *arg5 = 0 ;
  gkString temp4 ;
  gkString temp5 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel3D",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel3D",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel3D",3,"float");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3D::createPanel3D",4,"gkString const &");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGUI3D::createPanel3D",5,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel3D",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  result = (tsPanel *)(arg1)->createPanel3D(arg2,arg3,(gkString const &)*arg4,(gkString const &)*arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel3D__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  float arg2 ;
  float arg3 ;
  gkString *arg4 = 0 ;
  gkString temp4 ;
  tsPanel *result = 0 ;
  
  SWIG_check_num_args("gsGUI3D::createPanel3D",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::createPanel3D",1,"gsGUI3D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGUI3D::createPanel3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGUI3D::createPanel3D",3,"float");
  if(!lua_isstring(L,4)) SWIG_fail_arg("gsGUI3D::createPanel3D",4,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_createPanel3D",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  temp4 = gkString((const char*)lua_tostring(L, 4));
  arg4 = &temp4;
  
  result = (tsPanel *)(arg1)->createPanel3D(arg2,arg3,(gkString const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tsPanel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_createPanel3D(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_gsGUI3D_createPanel3D__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGUI3D_createPanel3D__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsGUI3D_createPanel3D__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isboolean(L,argv[6]);
                }
                if (_v) {
                  return _wrap_gsGUI3D_createPanel3D__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isstring(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isboolean(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isstring(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_gsGUI3D_createPanel3D__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3D_createPanel3D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3D::createPanel3D(float,float,gkString const &,gkString const &,float,bool,gkString const &)\n"
    "    gsGUI3D::createPanel3D(float,float,gkString const &,gkString const &,float,bool)\n"
    "    gsGUI3D::createPanel3D(float,float,gkString const &,gkString const &,float)\n"
    "    gsGUI3D::createPanel3D(float,float,gkString const &,gkString const &)\n"
    "    gsGUI3D::createPanel3D(float,float,gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGUI3D_setMousePointer(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3D::setMousePointer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::setMousePointer",1,"gsGUI3D *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3D::setMousePointer",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_setMousePointer",1,SWIGTYPE_p_gsGUI3D);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setMousePointer((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_showCursor(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGUI3D::showCursor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::showCursor",1,"gsGUI3D *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGUI3D::showCursor",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_showCursor",1,SWIGTYPE_p_gsGUI3D);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->showCursor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_addConsoleCommand__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  gkString *arg2 = 0 ;
  gsSelf arg3 ;
  gsFunction arg4 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3D::addConsoleCommand",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",1,"gsGUI3D *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",2,"gkString const &");
  if(!lua_istable(L,3)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",3,"gsSelf");
  if(!lua_isfunction(L,4)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",4,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_addConsoleCommand",1,SWIGTYPE_p_gsGUI3D);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (&arg4)->m_id = 4; (&arg4)->L = L; 
  (arg1)->addConsoleCommand((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_addConsoleCommand__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGUI3D *arg1 = (gsGUI3D *) 0 ;
  gkString *arg2 = 0 ;
  gsFunction arg3 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGUI3D::addConsoleCommand",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",1,"gsGUI3D *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",2,"gkString const &");
  if(!lua_isfunction(L,3)) SWIG_fail_arg("gsGUI3D::addConsoleCommand",3,"gsFunction");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGUI3D,0))){
    SWIG_fail_ptr("gsGUI3D_addConsoleCommand",1,SWIGTYPE_p_gsGUI3D);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (&arg3)->m_id = 3; (&arg3)->L = L; 
  (arg1)->addConsoleCommand((gkString const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGUI3D_addConsoleCommand(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_isfunction(L, argv[2]); 
        if (_v) {
          return _wrap_gsGUI3D_addConsoleCommand__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGUI3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        _v = lua_istable(L, argv[2]); 
        if (_v) {
          _v = lua_isfunction(L, argv[3]); 
          if (_v) {
            return _wrap_gsGUI3D_addConsoleCommand__SWIG_0(L);
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGUI3D_addConsoleCommand'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGUI3D::addConsoleCommand(gkString const &,gsSelf,gsFunction)\n"
    "    gsGUI3D::addConsoleCommand(gkString const &,gsFunction)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGUI3D(void *obj) {
gsGUI3D *arg1 = (gsGUI3D *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGUI3D(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGUI3D);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGUI3D_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGUI3D_methods[]= {
    { "showGUI", _wrap_gsGUI3D_showGUI},
    { "hideGUI", _wrap_gsGUI3D_hideGUI},
    { "showConsole", _wrap_gsGUI3D_showConsole},
    { "getPanelColors", _wrap_gsGUI3D_getPanelColors},
    { "createPanel", _wrap_gsGUI3D_createPanel},
    { "createPanel3D", _wrap_gsGUI3D_createPanel3D},
    { "setMousePointer", _wrap_gsGUI3D_setMousePointer},
    { "showCursor", _wrap_gsGUI3D_showCursor},
    { "addConsoleCommand", _wrap_gsGUI3D_addConsoleCommand},
    {0,0}
};
static swig_lua_method swig_gsGUI3D_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGUI3D_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGUI3D_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGUI3D_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGUI3D_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGUI3D_Sf_SwigStatic = {
    "gsGUI3D",
    swig_gsGUI3D_Sf_SwigStatic_methods,
    swig_gsGUI3D_Sf_SwigStatic_attributes,
    swig_gsGUI3D_Sf_SwigStatic_constants,
    swig_gsGUI3D_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGUI3D_bases[] = {0};
static const char *swig_gsGUI3D_base_names[] = {0};
static swig_lua_class _wrap_class_gsGUI3D = { "gsGUI3D", "gsGUI3D", &SWIGTYPE_p_gsGUI3D,_proxy__wrap_new_gsGUI3D, swig_delete_gsGUI3D, swig_gsGUI3D_methods, swig_gsGUI3D_attributes, &swig_gsGUI3D_Sf_SwigStatic, swig_gsGUI3D_meta, swig_gsGUI3D_bases, swig_gsGUI3D_base_names };

static int _wrap_new_gsSprite(lua_State* L) {
  int SWIG_arg = 0;
  gkSprite *arg1 = (gkSprite *) 0 ;
  gsSprite *result = 0 ;
  
  SWIG_check_num_args("gsSprite::gsSprite",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsSprite::gsSprite",1,"gkSprite *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Sprite,0))){
    SWIG_fail_ptr("new_gsSprite",1,SWIGTYPE_p_Gorilla__Sprite);
  }
  
  result = (gsSprite *)new gsSprite(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsSprite,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsSprite(void *obj) {
gsSprite *arg1 = (gsSprite *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsSprite(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsSprite);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsSprite_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsSprite_methods[]= {
    {0,0}
};
static swig_lua_method swig_gsSprite_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsSprite_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsSprite_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsSprite_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsSprite_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsSprite_Sf_SwigStatic = {
    "gsSprite",
    swig_gsSprite_Sf_SwigStatic_methods,
    swig_gsSprite_Sf_SwigStatic_attributes,
    swig_gsSprite_Sf_SwigStatic_constants,
    swig_gsSprite_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsSprite_bases[] = {0};
static const char *swig_gsSprite_base_names[] = {0};
static swig_lua_class _wrap_class_gsSprite = { "gsSprite", "gsSprite", &SWIGTYPE_p_gsSprite,_proxy__wrap_new_gsSprite, swig_delete_gsSprite, swig_gsSprite_methods, swig_gsSprite_attributes, &swig_gsSprite_Sf_SwigStatic, swig_gsSprite_meta, swig_gsSprite_bases, swig_gsSprite_base_names };

static int _wrap_new_gsGorillaText(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::MarkupText *arg1 = (Gorilla::MarkupText *) 0 ;
  gsGorillaText *result = 0 ;
  
  SWIG_check_num_args("gsGorillaText::gsGorillaText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::gsGorillaText",1,"Gorilla::MarkupText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__MarkupText,0))){
    SWIG_fail_ptr("new_gsGorillaText",1,SWIGTYPE_p_Gorilla__MarkupText);
  }
  
  result = (gsGorillaText *)new gsGorillaText(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaText,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getText(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  gkString result;
  
  SWIG_check_num_args("gsGorillaText::getText",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getText",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getText",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (arg1)->getText();
  
  //    lua_pushstring(L, (&result)->c_str()); SWIG_arg++;
  lua_pushlstring(L, (&result)->data(),(&result)->size()); SWIG_arg++;
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_setText(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGorillaText::setText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::setText",1,"gsGorillaText *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGorillaText::setText",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_setText",1,SWIGTYPE_p_gsGorillaText);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setText((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_setSize(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGorillaText::setSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::setSize",1,"gsGorillaText *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaText::setSize",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaText::setSize",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_setSize",1,SWIGTYPE_p_gsGorillaText);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setSize(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getWidth(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaText::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getWidth",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getWidth",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (float)(arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getHeight(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaText::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getHeight",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getHeight",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (float)(arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_setBackgroundColor(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  gsVector4 arg2 ;
  gsVector4 *argp2 ;
  
  SWIG_check_num_args("gsGorillaText::setBackgroundColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::setBackgroundColor",1,"gsGorillaText *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGorillaText::setBackgroundColor",2,"gsVector4");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_setBackgroundColor",1,SWIGTYPE_p_gsGorillaText);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGorillaText_setBackgroundColor",2,SWIGTYPE_p_gsVector4);
  }
  arg2 = *argp2;
  
  (arg1)->setBackgroundColor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getBackgroundColor(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  gsVector4 result;
  
  SWIG_check_num_args("gsGorillaText::getBackgroundColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getBackgroundColor",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getBackgroundColor",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (arg1)->getBackgroundColor();
  {
    gsVector4 * resultptr = new gsVector4((const gsVector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_gsVector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_setPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGorillaText::setPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::setPosition",1,"gsGorillaText *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaText::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaText::setPosition",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_setPosition",1,SWIGTYPE_p_gsGorillaText);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setPosition(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getX(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaText::getX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getX",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getX",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (float)(arg1)->getX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaText_getY(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaText *arg1 = (gsGorillaText *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaText::getY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaText::getY",1,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaText_getY",1,SWIGTYPE_p_gsGorillaText);
  }
  
  result = (float)(arg1)->getY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGorillaText(void *obj) {
gsGorillaText *arg1 = (gsGorillaText *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaText(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaText);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaText_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaText_methods[]= {
    { "getText", _wrap_gsGorillaText_getText},
    { "setText", _wrap_gsGorillaText_setText},
    { "setSize", _wrap_gsGorillaText_setSize},
    { "getWidth", _wrap_gsGorillaText_getWidth},
    { "getHeight", _wrap_gsGorillaText_getHeight},
    { "setBackgroundColor", _wrap_gsGorillaText_setBackgroundColor},
    { "getBackgroundColor", _wrap_gsGorillaText_getBackgroundColor},
    { "setPosition", _wrap_gsGorillaText_setPosition},
    { "getX", _wrap_gsGorillaText_getX},
    { "getY", _wrap_gsGorillaText_getY},
    {0,0}
};
static swig_lua_method swig_gsGorillaText_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaText_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaText_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaText_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaText_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaText_Sf_SwigStatic = {
    "gsGorillaText",
    swig_gsGorillaText_Sf_SwigStatic_methods,
    swig_gsGorillaText_Sf_SwigStatic_attributes,
    swig_gsGorillaText_Sf_SwigStatic_constants,
    swig_gsGorillaText_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaText_bases[] = {0};
static const char *swig_gsGorillaText_base_names[] = {0};
static swig_lua_class _wrap_class_gsGorillaText = { "gsGorillaText", "gsGorillaText", &SWIGTYPE_p_gsGorillaText,_proxy__wrap_new_gsGorillaText, swig_delete_gsGorillaText, swig_gsGorillaText_methods, swig_gsGorillaText_attributes, &swig_gsGorillaText_Sf_SwigStatic, swig_gsGorillaText_meta, swig_gsGorillaText_bases, swig_gsGorillaText_base_names };

static int _wrap_new_gsGorillaLineList(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::LineList *arg1 = (Gorilla::LineList *) 0 ;
  gsGorillaLineList *result = 0 ;
  
  SWIG_check_num_args("gsGorillaLineList::gsGorillaLineList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::gsGorillaLineList",1,"Gorilla::LineList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__LineList,0))){
    SWIG_fail_ptr("new_gsGorillaLineList",1,SWIGTYPE_p_Gorilla__LineList);
  }
  
  result = (gsGorillaLineList *)new gsGorillaLineList(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaLineList,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_begin__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaLineList *arg1 = (gsGorillaLineList *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = 0 ;
  
  SWIG_check_num_args("gsGorillaLineList::begin",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::begin",1,"gsGorillaLineList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaLineList::begin",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGorillaLineList::begin",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaLineList_begin",1,SWIGTYPE_p_gsGorillaLineList);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGorillaLineList_begin",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->begin(arg2,(gsVector4 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_begin__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaLineList *arg1 = (gsGorillaLineList *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGorillaLineList::begin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::begin",1,"gsGorillaLineList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaLineList::begin",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaLineList_begin",1,SWIGTYPE_p_gsGorillaLineList);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->begin(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_begin(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaLineList, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGorillaLineList_begin__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaLineList, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsGorillaLineList_begin__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaLineList_begin'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaLineList::begin(float,gsVector4 const &)\n"
    "    gsGorillaLineList::begin(float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorillaLineList_position(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaLineList *arg1 = (gsGorillaLineList *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGorillaLineList::position",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::position",1,"gsGorillaLineList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaLineList::position",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaLineList::position",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaLineList_position",1,SWIGTYPE_p_gsGorillaLineList);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->position(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_endLine__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaLineList *arg1 = (gsGorillaLineList *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGorillaLineList::endLine",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::endLine",1,"gsGorillaLineList *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGorillaLineList::endLine",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaLineList_endLine",1,SWIGTYPE_p_gsGorillaLineList);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->endLine(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_endLine__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaLineList *arg1 = (gsGorillaLineList *) 0 ;
  
  SWIG_check_num_args("gsGorillaLineList::endLine",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaLineList::endLine",1,"gsGorillaLineList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaLineList_endLine",1,SWIGTYPE_p_gsGorillaLineList);
  }
  
  (arg1)->endLine();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaLineList_endLine(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaLineList, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGorillaLineList_endLine__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaLineList, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGorillaLineList_endLine__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaLineList_endLine'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaLineList::endLine(bool)\n"
    "    gsGorillaLineList::endLine()\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGorillaLineList(void *obj) {
gsGorillaLineList *arg1 = (gsGorillaLineList *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaLineList(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaLineList);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaLineList_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaLineList_methods[]= {
    { "begin", _wrap_gsGorillaLineList_begin},
    { "position", _wrap_gsGorillaLineList_position},
    { "endLine", _wrap_gsGorillaLineList_endLine},
    {0,0}
};
static swig_lua_method swig_gsGorillaLineList_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaLineList_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaLineList_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaLineList_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaLineList_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaLineList_Sf_SwigStatic = {
    "gsGorillaLineList",
    swig_gsGorillaLineList_Sf_SwigStatic_methods,
    swig_gsGorillaLineList_Sf_SwigStatic_attributes,
    swig_gsGorillaLineList_Sf_SwigStatic_constants,
    swig_gsGorillaLineList_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaLineList_bases[] = {0};
static const char *swig_gsGorillaLineList_base_names[] = {0};
static swig_lua_class _wrap_class_gsGorillaLineList = { "gsGorillaLineList", "gsGorillaLineList", &SWIGTYPE_p_gsGorillaLineList,_proxy__wrap_new_gsGorillaLineList, swig_delete_gsGorillaLineList, swig_gsGorillaLineList_methods, swig_gsGorillaLineList_attributes, &swig_gsGorillaLineList_Sf_SwigStatic, swig_gsGorillaLineList_meta, swig_gsGorillaLineList_bases, swig_gsGorillaLineList_base_names };

static int _wrap_new_gkGorillaRectangle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::Rectangle *arg1 = (Gorilla::Rectangle *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gkGorillaRectangle::gkGorillaRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",1,"Gorilla::Rectangle *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Rectangle,0))){
    SWIG_fail_ptr("new_gkGorillaRectangle",1,SWIGTYPE_p_Gorilla__Rectangle);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkGorillaRectangle *)new gkGorillaRectangle(arg1,(gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkGorillaRectangle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::Rectangle *arg1 = (Gorilla::Rectangle *) 0 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gkGorillaRectangle::gkGorillaRectangle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",1,"Gorilla::Rectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Rectangle,0))){
    SWIG_fail_ptr("new_gkGorillaRectangle",1,SWIGTYPE_p_Gorilla__Rectangle);
  }
  
  result = (gkGorillaRectangle *)new gkGorillaRectangle(arg1);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkGorillaRectangle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::Rectangle *arg1 = (Gorilla::Rectangle *) 0 ;
  gkString *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  float arg5 ;
  gkString temp2 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gkGorillaRectangle::gkGorillaRectangle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",1,"Gorilla::Rectangle *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gkGorillaRectangle::gkGorillaRectangle",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Rectangle,0))){
    SWIG_fail_ptr("new_gkGorillaRectangle",1,SWIGTYPE_p_Gorilla__Rectangle);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  result = (gkGorillaRectangle *)new gkGorillaRectangle(arg1,(gkString const &)*arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gkGorillaRectangle(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Gorilla__Rectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_gkGorillaRectangle__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Gorilla__Rectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_gkGorillaRectangle__SWIG_0(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Gorilla__Rectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_gkGorillaRectangle__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_gkGorillaRectangle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gkGorillaRectangle::gkGorillaRectangle(Gorilla::Rectangle *,gkString const &)\n"
    "    gkGorillaRectangle::gkGorillaRectangle(Gorilla::Rectangle *)\n"
    "    gkGorillaRectangle::gkGorillaRectangle(Gorilla::Rectangle *,gkString const &,int,int,float)\n");
  lua_error(L);return 0;
}


static int _wrap_gkGorillaRectangle_update(lua_State* L) {
  int SWIG_arg = 0;
  gkGorillaRectangle *arg1 = (gkGorillaRectangle *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gkGorillaRectangle::update",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGorillaRectangle::update",1,"gkGorillaRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gkGorillaRectangle::update",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGorillaRectangle,0))){
    SWIG_fail_ptr("gkGorillaRectangle_update",1,SWIGTYPE_p_gkGorillaRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->update(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gkGorillaRectangle_getRect(lua_State* L) {
  int SWIG_arg = 0;
  gkGorillaRectangle *arg1 = (gkGorillaRectangle *) 0 ;
  Gorilla::Rectangle *result = 0 ;
  
  SWIG_check_num_args("gkGorillaRectangle::getRect",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gkGorillaRectangle::getRect",1,"gkGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGorillaRectangle,0))){
    SWIG_fail_ptr("gkGorillaRectangle_getRect",1,SWIGTYPE_p_gkGorillaRectangle);
  }
  
  result = (Gorilla::Rectangle *)(arg1)->getRect();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Gorilla__Rectangle,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gkGorillaRectangle(void *obj) {
gkGorillaRectangle *arg1 = (gkGorillaRectangle *) obj;
delete arg1;
}
static int _proxy__wrap_new_gkGorillaRectangle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gkGorillaRectangle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gkGorillaRectangle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gkGorillaRectangle_methods[]= {
    { "update", _wrap_gkGorillaRectangle_update},
    { "getRect", _wrap_gkGorillaRectangle_getRect},
    {0,0}
};
static swig_lua_method swig_gkGorillaRectangle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gkGorillaRectangle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gkGorillaRectangle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gkGorillaRectangle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gkGorillaRectangle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gkGorillaRectangle_Sf_SwigStatic = {
    "gkGorillaRectangle",
    swig_gkGorillaRectangle_Sf_SwigStatic_methods,
    swig_gkGorillaRectangle_Sf_SwigStatic_attributes,
    swig_gkGorillaRectangle_Sf_SwigStatic_constants,
    swig_gkGorillaRectangle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gkGorillaRectangle_bases[] = {0};
static const char *swig_gkGorillaRectangle_base_names[] = {0};
static swig_lua_class _wrap_class_gkGorillaRectangle = { "gkGorillaRectangle", "gkGorillaRectangle", &SWIGTYPE_p_gkGorillaRectangle,_proxy__wrap_new_gkGorillaRectangle, swig_delete_gkGorillaRectangle, swig_gkGorillaRectangle_methods, swig_gkGorillaRectangle_attributes, &swig_gkGorillaRectangle_Sf_SwigStatic, swig_gkGorillaRectangle_meta, swig_gkGorillaRectangle_bases, swig_gkGorillaRectangle_base_names };

static int _wrap_new_gsGorillaRectangle(lua_State* L) {
  int SWIG_arg = 0;
  gkGorillaRectangle *arg1 = (gkGorillaRectangle *) 0 ;
  gsGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaRectangle::gsGorillaRectangle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::gsGorillaRectangle",1,"gkGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gkGorillaRectangle,0))){
    SWIG_fail_ptr("new_gsGorillaRectangle",1,SWIGTYPE_p_gkGorillaRectangle);
  }
  
  result = (gsGorillaRectangle *)new gsGorillaRectangle(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaRectangle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_setBackgroundColor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("gsGorillaRectangle::setBackgroundColor",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",1,"gsGorillaRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setBackgroundColor",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setBackgroundColor(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_setBackgroundColor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  gsVector4 *arg2 = 0 ;
  
  SWIG_check_num_args("gsGorillaRectangle::setBackgroundColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",1,"gsGorillaRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("gsGorillaRectangle::setBackgroundColor",2,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setBackgroundColor",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setBackgroundColor",2,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBackgroundColor((gsVector4 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_setBackgroundColor(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGorillaRectangle_setBackgroundColor__SWIG_1(L);
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGorillaRectangle_setBackgroundColor__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaRectangle_setBackgroundColor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaRectangle::setBackgroundColor(float,float,float,float)\n"
    "    gsGorillaRectangle::setBackgroundColor(gsVector4 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorillaRectangle_getPosX(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaRectangle::getPosX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::getPosX",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_getPosX",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  result = (float)(arg1)->getPosX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_getPosY(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaRectangle::getPosY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::getPosY",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_getPosY",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  result = (float)(arg1)->getPosY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_getWidth(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaRectangle::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::getWidth",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_getWidth",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  result = (float)(arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_getHeight(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float result;
  
  SWIG_check_num_args("gsGorillaRectangle::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::getHeight",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_getHeight",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  result = (float)(arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_setPosition(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("gsGorillaRectangle::setPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::setPosition",1,"gsGorillaRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaRectangle::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaRectangle::setPosition",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setPosition",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setPosition(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_setSprite(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsGorillaRectangle::setSprite",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::setSprite",1,"gsGorillaRectangle *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGorillaRectangle::setSprite",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setSprite",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->setSprite((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_update__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gsGorillaRectangle::update",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::update",1,"gsGorillaRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaRectangle::update",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_update",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->update(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_update__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  
  SWIG_check_num_args("gsGorillaRectangle::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::update",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_update",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  (arg1)->update();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle_update(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_gsGorillaRectangle_update__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaRectangle, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGorillaRectangle_update__SWIG_0(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaRectangle_update'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaRectangle::update(float)\n"
    "    gsGorillaRectangle::update()\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorillaRectangle_setBorder(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = (gsVector4 *) 0 ;
  
  SWIG_check_num_args("gsGorillaRectangle::setBorder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::setBorder",1,"gsGorillaRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaRectangle::setBorder",2,"float");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("gsGorillaRectangle::setBorder",3,"gsVector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setBorder",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGorillaRectangle_setBorder",3,SWIGTYPE_p_gsVector4);
  }
  
  (arg1)->setBorder(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaRectangle__get(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaRectangle *arg1 = (gsGorillaRectangle *) 0 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaRectangle::_get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaRectangle::_get",1,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaRectangle__get",1,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  result = (gkGorillaRectangle *)(arg1)->_get();
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGorillaRectangle(void *obj) {
gsGorillaRectangle *arg1 = (gsGorillaRectangle *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaRectangle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaRectangle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaRectangle_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaRectangle_methods[]= {
    { "setBackgroundColor", _wrap_gsGorillaRectangle_setBackgroundColor},
    { "getPosX", _wrap_gsGorillaRectangle_getPosX},
    { "getPosY", _wrap_gsGorillaRectangle_getPosY},
    { "getWidth", _wrap_gsGorillaRectangle_getWidth},
    { "getHeight", _wrap_gsGorillaRectangle_getHeight},
    { "setPosition", _wrap_gsGorillaRectangle_setPosition},
    { "setSprite", _wrap_gsGorillaRectangle_setSprite},
    { "update", _wrap_gsGorillaRectangle_update},
    { "setBorder", _wrap_gsGorillaRectangle_setBorder},
    { "_get", _wrap_gsGorillaRectangle__get},
    {0,0}
};
static swig_lua_method swig_gsGorillaRectangle_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaRectangle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaRectangle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaRectangle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaRectangle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaRectangle_Sf_SwigStatic = {
    "gsGorillaRectangle",
    swig_gsGorillaRectangle_Sf_SwigStatic_methods,
    swig_gsGorillaRectangle_Sf_SwigStatic_attributes,
    swig_gsGorillaRectangle_Sf_SwigStatic_constants,
    swig_gsGorillaRectangle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaRectangle_bases[] = {0};
static const char *swig_gsGorillaRectangle_base_names[] = {0};
static swig_lua_class _wrap_class_gsGorillaRectangle = { "gsGorillaRectangle", "gsGorillaRectangle", &SWIGTYPE_p_gsGorillaRectangle,_proxy__wrap_new_gsGorillaRectangle, swig_delete_gsGorillaRectangle, swig_gsGorillaRectangle_methods, swig_gsGorillaRectangle_attributes, &swig_gsGorillaRectangle_Sf_SwigStatic, swig_gsGorillaRectangle_meta, swig_gsGorillaRectangle_bases, swig_gsGorillaRectangle_base_names };

static int _wrap_new_gsTextureAtlas(lua_State* L) {
  int SWIG_arg = 0;
  gkTextureAtlas *arg1 = (gkTextureAtlas *) 0 ;
  gsTextureAtlas *result = 0 ;
  
  SWIG_check_num_args("gsTextureAtlas::gsTextureAtlas",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::gsTextureAtlas",1,"gkTextureAtlas *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__TextureAtlas,0))){
    SWIG_fail_ptr("new_gsTextureAtlas",1,SWIGTYPE_p_Gorilla__TextureAtlas);
  }
  
  result = (gsTextureAtlas *)new gsTextureAtlas(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsTextureAtlas,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_createSprite(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  gkString *arg2 = 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  gkString temp2 ;
  gkSprite *result = 0 ;
  
  SWIG_check_num_args("gsTextureAtlas::createSprite",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::createSprite",1,"gsTextureAtlas *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTextureAtlas::createSprite",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsTextureAtlas::createSprite",3,"float const");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsTextureAtlas::createSprite",4,"float const");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsTextureAtlas::createSprite",5,"float const");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("gsTextureAtlas::createSprite",6,"float const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_createSprite",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (float const)lua_tonumber(L, 3);
  arg4 = (float const)lua_tonumber(L, 4);
  arg5 = (float const)lua_tonumber(L, 5);
  arg6 = (float const)lua_tonumber(L, 6);
  result = (gkSprite *)(arg1)->createSprite((gkString const &)*arg2,arg3,arg4,arg5,arg6);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Sprite); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_createSpriteTiles(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  gkString *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTextureAtlas::createSpriteTiles",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::createSpriteTiles",1,"gsTextureAtlas *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTextureAtlas::createSpriteTiles",2,"gkString const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsTextureAtlas::createSpriteTiles",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsTextureAtlas::createSpriteTiles",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_createSpriteTiles",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->createSpriteTiles((gkString const &)*arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_getSprite(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkSprite *result = 0 ;
  
  SWIG_check_num_args("gsTextureAtlas::getSprite",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::getSprite",1,"gsTextureAtlas *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTextureAtlas::getSprite",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_getSprite",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkSprite *)(arg1)->getSprite((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, Sprite); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_getTexSizeX(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  float result;
  
  SWIG_check_num_args("gsTextureAtlas::getTexSizeX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::getTexSizeX",1,"gsTextureAtlas *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_getTexSizeX",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  result = (float)(arg1)->getTexSizeX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_getTexSizeY(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  float result;
  
  SWIG_check_num_args("gsTextureAtlas::getTexSizeY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::getTexSizeY",1,"gsTextureAtlas *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_getTexSizeY",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  result = (float)(arg1)->getTexSizeY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_setFontOffset(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  int arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("gsTextureAtlas::setFontOffset",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::setFontOffset",1,"gsTextureAtlas *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsTextureAtlas::setFontOffset",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsTextureAtlas::setFontOffset",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsTextureAtlas::setFontOffset",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_setFontOffset",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setFontOffset(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsTextureAtlas_loadPackfile(lua_State* L) {
  int SWIG_arg = 0;
  gsTextureAtlas *arg1 = (gsTextureAtlas *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  
  SWIG_check_num_args("gsTextureAtlas::loadPackfile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsTextureAtlas::loadPackfile",1,"gsTextureAtlas *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsTextureAtlas::loadPackfile",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsTextureAtlas,0))){
    SWIG_fail_ptr("gsTextureAtlas_loadPackfile",1,SWIGTYPE_p_gsTextureAtlas);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  (arg1)->loadPackfile((gkString const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsTextureAtlas(void *obj) {
gsTextureAtlas *arg1 = (gsTextureAtlas *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsTextureAtlas(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsTextureAtlas);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsTextureAtlas_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsTextureAtlas_methods[]= {
    { "createSprite", _wrap_gsTextureAtlas_createSprite},
    { "createSpriteTiles", _wrap_gsTextureAtlas_createSpriteTiles},
    { "getSprite", _wrap_gsTextureAtlas_getSprite},
    { "getTexSizeX", _wrap_gsTextureAtlas_getTexSizeX},
    { "getTexSizeY", _wrap_gsTextureAtlas_getTexSizeY},
    { "setFontOffset", _wrap_gsTextureAtlas_setFontOffset},
    { "loadPackfile", _wrap_gsTextureAtlas_loadPackfile},
    {0,0}
};
static swig_lua_method swig_gsTextureAtlas_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsTextureAtlas_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsTextureAtlas_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsTextureAtlas_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsTextureAtlas_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsTextureAtlas_Sf_SwigStatic = {
    "gsTextureAtlas",
    swig_gsTextureAtlas_Sf_SwigStatic_methods,
    swig_gsTextureAtlas_Sf_SwigStatic_attributes,
    swig_gsTextureAtlas_Sf_SwigStatic_constants,
    swig_gsTextureAtlas_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsTextureAtlas_bases[] = {0};
static const char *swig_gsTextureAtlas_base_names[] = {0};
static swig_lua_class _wrap_class_gsTextureAtlas = { "gsTextureAtlas", "gsTextureAtlas", &SWIGTYPE_p_gsTextureAtlas,_proxy__wrap_new_gsTextureAtlas, swig_delete_gsTextureAtlas, swig_gsTextureAtlas_methods, swig_gsTextureAtlas_attributes, &swig_gsTextureAtlas_Sf_SwigStatic, swig_gsTextureAtlas_meta, swig_gsTextureAtlas_bases, swig_gsTextureAtlas_base_names };

static int _wrap_new_gsGorillaScreenFunctions(lua_State* L) {
  int SWIG_arg = 0;
  Gorilla::Layer *arg1 = (Gorilla::Layer *) 0 ;
  gsGorillaScreenFunctions *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::gsGorillaScreenFunctions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::gsGorillaScreenFunctions",1,"Gorilla::Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Layer,0))){
    SWIG_fail_ptr("new_gsGorillaScreenFunctions",1,SWIGTYPE_p_Gorilla__Layer);
  }
  
  result = (gsGorillaScreenFunctions *)new gsGorillaScreenFunctions(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaScreenFunctions,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createRectangle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  gkString *arg6 = 0 ;
  gkString temp6 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::createRectangle",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",5,"float");
  if(!lua_isstring(L,6)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",6,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createRectangle",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  temp6 = gkString((const char*)lua_tostring(L, 6));
  arg6 = &temp6;
  
  result = (gkGorillaRectangle *)(arg1)->createRectangle(arg2,arg3,arg4,arg5,(gkString const &)*arg6);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createRectangle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::createRectangle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("gsGorillaScreenFunctions::createRectangle",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createRectangle",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  result = (gkGorillaRectangle *)(arg1)->createRectangle(arg2,arg3,arg4,arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createRectangle(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreenFunctions, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_gsGorillaScreenFunctions_createRectangle__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreenFunctions, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_gsGorillaScreenFunctions_createRectangle__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaScreenFunctions_createRectangle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaScreenFunctions::createRectangle(float,float,float,float,gkString const &)\n"
    "    gsGorillaScreenFunctions::createRectangle(float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorillaScreenFunctions_createMarkupText(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  int arg2 ;
  float arg3 ;
  float arg4 ;
  gkString *arg5 = 0 ;
  gkString temp5 ;
  gkGorillaText *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::createMarkupText",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::createMarkupText",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::createMarkupText",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("gsGorillaScreenFunctions::createMarkupText",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("gsGorillaScreenFunctions::createMarkupText",4,"float");
  if(!lua_isstring(L,5)) SWIG_fail_arg("gsGorillaScreenFunctions::createMarkupText",5,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createMarkupText",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  temp5 = gkString((const char*)lua_tostring(L, 5));
  arg5 = &temp5;
  
  result = (gkGorillaText *)(arg1)->createMarkupText(arg2,arg3,arg4,(gkString const &)*arg5);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaText); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createLineList__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  float arg2 ;
  gsVector4 *arg3 = 0 ;
  gkGorillaLineList *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::createLineList",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::createLineList",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::createLineList",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("gsGorillaScreenFunctions::createLineList",3,"gsVector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createLineList",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_gsVector4,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createLineList",3,SWIGTYPE_p_gsVector4);
  }
  
  result = (gkGorillaLineList *)(arg1)->createLineList(arg2,(gsVector4 const &)*arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaLineList); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createLineList__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  float arg2 ;
  gkGorillaLineList *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::createLineList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::createLineList",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::createLineList",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_createLineList",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (gkGorillaLineList *)(arg1)->createLineList(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaLineList); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_createLineList(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreenFunctions, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGorillaScreenFunctions_createLineList__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreenFunctions, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_gsVector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_gsGorillaScreenFunctions_createLineList__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaScreenFunctions_createLineList'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaScreenFunctions::createLineList(float,gsVector4 const &)\n"
    "    gsGorillaScreenFunctions::createLineList(float)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorillaScreenFunctions_destroyRectangle(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  gsGorillaRectangle *arg2 = (gsGorillaRectangle *) 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::destroyRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyRectangle",1,"gsGorillaScreenFunctions *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyRectangle",2,"gsGorillaRectangle *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyRectangle",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGorillaRectangle,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyRectangle",2,SWIGTYPE_p_gsGorillaRectangle);
  }
  
  (arg1)->destroyRectangle(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_destroyMarkup(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  gsGorillaText *arg2 = (gsGorillaText *) 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::destroyMarkup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyMarkup",1,"gsGorillaScreenFunctions *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyMarkup",2,"gsGorillaText *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyMarkup",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGorillaText,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyMarkup",2,SWIGTYPE_p_gsGorillaText);
  }
  
  (arg1)->destroyMarkup(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_destroyLineList(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  gsGorillaLineList *arg2 = (gsGorillaLineList *) 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::destroyLineList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyLineList",1,"gsGorillaScreenFunctions *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::destroyLineList",2,"gsGorillaLineList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyLineList",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGorillaLineList,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_destroyLineList",2,SWIGTYPE_p_gsGorillaLineList);
  }
  
  (arg1)->destroyLineList(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_getRectAmount(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  int result;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::getRectAmount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::getRectAmount",1,"gsGorillaScreenFunctions *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_getRectAmount",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  result = (int)(arg1)->getRectAmount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreenFunctions_getRect(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) 0 ;
  int arg2 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreenFunctions::getRect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreenFunctions::getRect",1,"gsGorillaScreenFunctions *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gsGorillaScreenFunctions::getRect",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreenFunctions,0))){
    SWIG_fail_ptr("gsGorillaScreenFunctions_getRect",1,SWIGTYPE_p_gsGorillaScreenFunctions);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (gkGorillaRectangle *)(arg1)->getRect(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGorillaScreenFunctions(void *obj) {
gsGorillaScreenFunctions *arg1 = (gsGorillaScreenFunctions *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaScreenFunctions(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaScreenFunctions);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaScreenFunctions_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaScreenFunctions_methods[]= {
    { "createRectangle", _wrap_gsGorillaScreenFunctions_createRectangle},
    { "createMarkupText", _wrap_gsGorillaScreenFunctions_createMarkupText},
    { "createLineList", _wrap_gsGorillaScreenFunctions_createLineList},
    { "destroyRectangle", _wrap_gsGorillaScreenFunctions_destroyRectangle},
    { "destroyMarkup", _wrap_gsGorillaScreenFunctions_destroyMarkup},
    { "destroyLineList", _wrap_gsGorillaScreenFunctions_destroyLineList},
    { "getRectAmount", _wrap_gsGorillaScreenFunctions_getRectAmount},
    { "getRect", _wrap_gsGorillaScreenFunctions_getRect},
    {0,0}
};
static swig_lua_method swig_gsGorillaScreenFunctions_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaScreenFunctions_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaScreenFunctions_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaScreenFunctions_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaScreenFunctions_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaScreenFunctions_Sf_SwigStatic = {
    "gsGorillaScreenFunctions",
    swig_gsGorillaScreenFunctions_Sf_SwigStatic_methods,
    swig_gsGorillaScreenFunctions_Sf_SwigStatic_attributes,
    swig_gsGorillaScreenFunctions_Sf_SwigStatic_constants,
    swig_gsGorillaScreenFunctions_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaScreenFunctions_bases[] = {0};
static const char *swig_gsGorillaScreenFunctions_base_names[] = {0};
static swig_lua_class _wrap_class_gsGorillaScreenFunctions = { "gsGorillaScreenFunctions", "gsGorillaScreenFunctions", &SWIGTYPE_p_gsGorillaScreenFunctions,_proxy__wrap_new_gsGorillaScreenFunctions, swig_delete_gsGorillaScreenFunctions, swig_gsGorillaScreenFunctions_methods, swig_gsGorillaScreenFunctions_attributes, &swig_gsGorillaScreenFunctions_Sf_SwigStatic, swig_gsGorillaScreenFunctions_meta, swig_gsGorillaScreenFunctions_bases, swig_gsGorillaScreenFunctions_base_names };

static int _wrap_new_gsGorillaScreen(lua_State* L) {
  int SWIG_arg = 0;
  gkGorillaScreen *arg1 = (gkGorillaScreen *) 0 ;
  gsGorillaScreen *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreen::gsGorillaScreen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen::gsGorillaScreen",1,"gkGorillaScreen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__Screen,0))){
    SWIG_fail_ptr("new_gsGorillaScreen",1,SWIGTYPE_p_Gorilla__Screen);
  }
  
  result = (gsGorillaScreen *)new gsGorillaScreen(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaScreen,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreen_setVisible(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreen *arg1 = (gsGorillaScreen *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("gsGorillaScreen::setVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen::setVisible",1,"gsGorillaScreen *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("gsGorillaScreen::setVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreen,0))){
    SWIG_fail_ptr("gsGorillaScreen_setVisible",1,SWIGTYPE_p_gsGorillaScreen);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setVisible(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGorillaScreen(void *obj) {
gsGorillaScreen *arg1 = (gsGorillaScreen *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaScreen(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaScreen);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaScreen_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaScreen_methods[]= {
    { "setVisible", _wrap_gsGorillaScreen_setVisible},
    {0,0}
};
static swig_lua_method swig_gsGorillaScreen_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaScreen_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaScreen_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaScreen_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaScreen_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaScreen_Sf_SwigStatic = {
    "gsGorillaScreen",
    swig_gsGorillaScreen_Sf_SwigStatic_methods,
    swig_gsGorillaScreen_Sf_SwigStatic_attributes,
    swig_gsGorillaScreen_Sf_SwigStatic_constants,
    swig_gsGorillaScreen_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaScreen_bases[] = {0,0};
static const char *swig_gsGorillaScreen_base_names[] = {"gsGorillaScreenFunctions *",0};
static swig_lua_class _wrap_class_gsGorillaScreen = { "gsGorillaScreen", "gsGorillaScreen", &SWIGTYPE_p_gsGorillaScreen,_proxy__wrap_new_gsGorillaScreen, swig_delete_gsGorillaScreen, swig_gsGorillaScreen_methods, swig_gsGorillaScreen_attributes, &swig_gsGorillaScreen_Sf_SwigStatic, swig_gsGorillaScreen_meta, swig_gsGorillaScreen_bases, swig_gsGorillaScreen_base_names };

static int _wrap_new_gsGorillaScreen3D(lua_State* L) {
  int SWIG_arg = 0;
  gkGorillaScreen3D *arg1 = (gkGorillaScreen3D *) 0 ;
  gsGorillaScreen3D *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreen3D::gsGorillaScreen3D",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen3D::gsGorillaScreen3D",1,"gkGorillaScreen3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Gorilla__ScreenRenderable,0))){
    SWIG_fail_ptr("new_gsGorillaScreen3D",1,SWIGTYPE_p_Gorilla__ScreenRenderable);
  }
  
  result = (gsGorillaScreen3D *)new gsGorillaScreen3D(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorillaScreen3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreen3D_generateFromScene(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreen3D *arg1 = (gsGorillaScreen3D *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  
  SWIG_check_num_args("gsGorillaScreen3D::generateFromScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen3D::generateFromScene",1,"gsGorillaScreen3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreen3D::generateFromScene",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreen3D,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromScene",1,SWIGTYPE_p_gsGorillaScreen3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromScene",2,SWIGTYPE_p_gsScene);
  }
  
  (arg1)->generateFromScene(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreen3D_generateFromObject__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreen3D *arg1 = (gsGorillaScreen3D *) 0 ;
  gkGameObject *arg2 = (gkGameObject *) 0 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreen3D::generateFromObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen3D::generateFromObject",1,"gsGorillaScreen3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreen3D::generateFromObject",2,"gkGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreen3D,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromObject",1,SWIGTYPE_p_gsGorillaScreen3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gkGameObject,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromObject",2,SWIGTYPE_p_gkGameObject);
  }
  
  result = (gkGorillaRectangle *)(arg1)->generateFromObject(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreen3D_generateFromObject__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorillaScreen3D *arg1 = (gsGorillaScreen3D *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  gkGorillaRectangle *result = 0 ;
  
  SWIG_check_num_args("gsGorillaScreen3D::generateFromObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorillaScreen3D::generateFromObject",1,"gsGorillaScreen3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorillaScreen3D::generateFromObject",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorillaScreen3D,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromObject",1,SWIGTYPE_p_gsGorillaScreen3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("gsGorillaScreen3D_generateFromObject",2,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkGorillaRectangle *)(arg1)->generateFromObject(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaRectangle); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorillaScreen3D_generateFromObject(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreen3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gkGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGorillaScreen3D_generateFromObject__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorillaScreen3D, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGorillaScreen3D_generateFromObject__SWIG_1(L);
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorillaScreen3D_generateFromObject'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorillaScreen3D::generateFromObject(gkGameObject *)\n"
    "    gsGorillaScreen3D::generateFromObject(gsGameObject *)\n");
  lua_error(L);return 0;
}


static void swig_delete_gsGorillaScreen3D(void *obj) {
gsGorillaScreen3D *arg1 = (gsGorillaScreen3D *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorillaScreen3D(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorillaScreen3D);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorillaScreen3D_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorillaScreen3D_methods[]= {
    { "generateFromScene", _wrap_gsGorillaScreen3D_generateFromScene},
    { "generateFromObject", _wrap_gsGorillaScreen3D_generateFromObject},
    {0,0}
};
static swig_lua_method swig_gsGorillaScreen3D_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorillaScreen3D_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorillaScreen3D_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorillaScreen3D_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorillaScreen3D_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorillaScreen3D_Sf_SwigStatic = {
    "gsGorillaScreen3D",
    swig_gsGorillaScreen3D_Sf_SwigStatic_methods,
    swig_gsGorillaScreen3D_Sf_SwigStatic_attributes,
    swig_gsGorillaScreen3D_Sf_SwigStatic_constants,
    swig_gsGorillaScreen3D_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorillaScreen3D_bases[] = {0,0};
static const char *swig_gsGorillaScreen3D_base_names[] = {"gsGorillaScreenFunctions *",0};
static swig_lua_class _wrap_class_gsGorillaScreen3D = { "gsGorillaScreen3D", "gsGorillaScreen3D", &SWIGTYPE_p_gsGorillaScreen3D,_proxy__wrap_new_gsGorillaScreen3D, swig_delete_gsGorillaScreen3D, swig_gsGorillaScreen3D_methods, swig_gsGorillaScreen3D_attributes, &swig_gsGorillaScreen3D_Sf_SwigStatic, swig_gsGorillaScreen3D_meta, swig_gsGorillaScreen3D_bases, swig_gsGorillaScreen3D_base_names };

static int _wrap_new_gsGorilla(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::gsGorilla",0,0)
  result = (gsGorilla *)new gsGorilla();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gsGorilla,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_loadAtlas__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gkString *arg2 = 0 ;
  gkString arg3 ;
  gkString temp2 ;
  gkTextureAtlas *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::loadAtlas",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::loadAtlas",1,"gsGorilla *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGorilla::loadAtlas",2,"gkString const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGorilla::loadAtlas",3,"gkString const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_loadAtlas",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  
  arg3 = gkString((const char*)lua_tostring(L, 3));
  
  result = (gkTextureAtlas *)(arg1)->loadAtlas((gkString const &)*arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, TextureAtlas); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_loadAtlas__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gkString *arg2 = 0 ;
  gkString temp2 ;
  gkTextureAtlas *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::loadAtlas",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::loadAtlas",1,"gsGorilla *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("gsGorilla::loadAtlas",2,"gkString const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_loadAtlas",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  temp2 = gkString((const char*)lua_tostring(L, 2));
  arg2 = &temp2;
  
  result = (gkTextureAtlas *)(arg1)->loadAtlas((gkString const &)*arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, TextureAtlas); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_loadAtlas(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_gsGorilla_loadAtlas__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGorilla_loadAtlas__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorilla_loadAtlas'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorilla::loadAtlas(gkString const &,gkString const)\n"
    "    gsGorilla::loadAtlas(gkString const &)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorilla_createScreen__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkString arg3 ;
  gkGorillaScreen *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::createScreen",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::createScreen",1,"gsGorilla *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorilla::createScreen",2,"gsScene *");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGorilla::createScreen",3,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_createScreen",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("gsGorilla_createScreen",2,SWIGTYPE_p_gsScene);
  }
  
  
  arg3 = gkString((const char*)lua_tostring(L, 3));
  
  result = (gkGorillaScreen *)(arg1)->createScreen(arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaScreen); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_createScreen__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gsScene *arg2 = (gsScene *) 0 ;
  gkGorillaScreen *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::createScreen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::createScreen",1,"gsGorilla *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorilla::createScreen",2,"gsScene *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_createScreen",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsScene,0))){
    SWIG_fail_ptr("gsGorilla_createScreen",2,SWIGTYPE_p_gsScene);
  }
  
  result = (gkGorillaScreen *)(arg1)->createScreen(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaScreen); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_createScreen(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGorilla_createScreen__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsScene, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGorilla_createScreen__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorilla_createScreen'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorilla::createScreen(gsScene *,gkString)\n"
    "    gsGorilla::createScreen(gsScene *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorilla_createScreen3D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  gkString arg3 ;
  gkGorillaScreen3D *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::createScreen3D",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::createScreen3D",1,"gsGorilla *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorilla::createScreen3D",2,"gsGameObject *");
  if(!lua_isstring(L,3)) SWIG_fail_arg("gsGorilla::createScreen3D",3,"gkString");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_createScreen3D",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("gsGorilla_createScreen3D",2,SWIGTYPE_p_gsGameObject);
  }
  
  
  arg3 = gkString((const char*)lua_tostring(L, 3));
  
  result = (gkGorillaScreen3D *)(arg1)->createScreen3D(arg2,arg3);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaScreen3D); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_createScreen3D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gsGameObject *arg2 = (gsGameObject *) 0 ;
  gkGorillaScreen3D *result = 0 ;
  
  SWIG_check_num_args("gsGorilla::createScreen3D",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::createScreen3D",1,"gsGorilla *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorilla::createScreen3D",2,"gsGameObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_createScreen3D",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGameObject,0))){
    SWIG_fail_ptr("gsGorilla_createScreen3D",2,SWIGTYPE_p_gsGameObject);
  }
  
  result = (gkGorillaScreen3D *)(arg1)->createScreen3D(arg2);
  if (result) {
    SWIG_arg += GS_LUA_OBJECT_STORE(result, GorillaScreen3D); 
  } 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gsGorilla_createScreen3D(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_gsGorilla_createScreen3D__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_gsGorilla, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_gsGameObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_gsGorilla_createScreen3D__SWIG_0(L);
        }
      }
    }
  }
  
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'gsGorilla_createScreen3D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    gsGorilla::createScreen3D(gsGameObject *,gkString)\n"
    "    gsGorilla::createScreen3D(gsGameObject *)\n");
  lua_error(L);return 0;
}


static int _wrap_gsGorilla_destroyScreen(lua_State* L) {
  int SWIG_arg = 0;
  gsGorilla *arg1 = (gsGorilla *) 0 ;
  gsGorillaScreen *arg2 = (gsGorillaScreen *) 0 ;
  
  SWIG_check_num_args("gsGorilla::destroyScreen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gsGorilla::destroyScreen",1,"gsGorilla *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gsGorilla::destroyScreen",2,"gsGorillaScreen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gsGorilla,0))){
    SWIG_fail_ptr("gsGorilla_destroyScreen",1,SWIGTYPE_p_gsGorilla);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gsGorillaScreen,0))){
    SWIG_fail_ptr("gsGorilla_destroyScreen",2,SWIGTYPE_p_gsGorillaScreen);
  }
  
  (arg1)->destroyScreen(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gsGorilla(void *obj) {
gsGorilla *arg1 = (gsGorilla *) obj;
delete arg1;
}
static int _proxy__wrap_new_gsGorilla(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_gsGorilla);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_gsGorilla_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_gsGorilla_methods[]= {
    { "loadAtlas", _wrap_gsGorilla_loadAtlas},
    { "createScreen", _wrap_gsGorilla_createScreen},
    { "createScreen3D", _wrap_gsGorilla_createScreen3D},
    { "destroyScreen", _wrap_gsGorilla_destroyScreen},
    {0,0}
};
static swig_lua_method swig_gsGorilla_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_gsGorilla_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_gsGorilla_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_gsGorilla_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_gsGorilla_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_gsGorilla_Sf_SwigStatic = {
    "gsGorilla",
    swig_gsGorilla_Sf_SwigStatic_methods,
    swig_gsGorilla_Sf_SwigStatic_attributes,
    swig_gsGorilla_Sf_SwigStatic_constants,
    swig_gsGorilla_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_gsGorilla_bases[] = {0};
static const char *swig_gsGorilla_base_names[] = {0};
static swig_lua_class _wrap_class_gsGorilla = { "gsGorilla", "gsGorilla", &SWIGTYPE_p_gsGorilla,_proxy__wrap_new_gsGorilla, swig_delete_gsGorilla, swig_gsGorilla_methods, swig_gsGorilla_attributes, &swig_gsGorilla_Sf_SwigStatic, swig_gsGorilla_meta, swig_gsGorilla_bases, swig_gsGorilla_base_names };

static swig_lua_attribute swig_SwigModule_attributes[] = {
    { "socketCallback", _wrap_socketCallback_get, _wrap_socketCallback_set },
    {0,0,0}
};
static swig_lua_const_info swig_SwigModule_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("GK_MAX_TEXTURE", 18)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_MIXTURE", GK_BT_MIXTURE)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_MULTIPLY", GK_BT_MULTIPLY)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_ADDITIVE", GK_BT_ADDITIVE)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_SUBTRACT", GK_BT_SUBTRACT)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_SCREEN", GK_BT_SCREEN)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_DARKEN", GK_BT_DARKEN)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_LIGHTEN", GK_BT_LIGHTEN)},
    {SWIG_LUA_CONSTTAB_INT("GK_BT_COLOR", GK_BT_COLOR)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_SPLAT", gkTextureProperties::TM_SPLAT)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_INVERT", gkTextureProperties::TM_INVERT)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_ALPHA", gkTextureProperties::TM_ALPHA)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_SPECULAR", gkTextureProperties::TM_SPECULAR)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_EMMISIVE", gkTextureProperties::TM_EMMISIVE)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_AMBIENT", gkTextureProperties::TM_AMBIENT)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_REFRACTION", gkTextureProperties::TM_REFRACTION)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_MIRROR", gkTextureProperties::TM_MIRROR)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TM_NORMAL", gkTextureProperties::TM_NORMAL)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TX_NEGATIVE", gkTextureProperties::TX_NEGATIVE)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TX_STENCIL", gkTextureProperties::TX_STENCIL)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TX_RGBTOINTEN", gkTextureProperties::TX_RGBTOINTEN)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_TX_OBJ_SPACE", gkTextureProperties::TX_OBJ_SPACE)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_IMT_IMAGE", gkTextureProperties::IMT_IMAGE)},
    {SWIG_LUA_CONSTTAB_INT("gkTextureProperties_IMT_CUBEMAP", gkTextureProperties::IMT_CUBEMAP)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_RECEIVESHADOWS", gkMaterialProperties::MA_RECEIVESHADOWS)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_LIGHTINGENABLED", gkMaterialProperties::MA_LIGHTINGENABLED)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_WIREFRAME", gkMaterialProperties::MA_WIREFRAME)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_DEPTHWRITE", gkMaterialProperties::MA_DEPTHWRITE)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_INVISIBLE", gkMaterialProperties::MA_INVISIBLE)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_TWOSIDE", gkMaterialProperties::MA_TWOSIDE)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_ALPHABLEND", gkMaterialProperties::MA_ALPHABLEND)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_ADDITIVEBLEND", gkMaterialProperties::MA_ADDITIVEBLEND)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_HASFACETEX", gkMaterialProperties::MA_HASFACETEX)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_HASRAMPBLEND", gkMaterialProperties::MA_HASRAMPBLEND)},
    {SWIG_LUA_CONSTTAB_INT("gkMaterialProperties_MA_ALPHACLIP", gkMaterialProperties::MA_ALPHACLIP)},
    {SWIG_LUA_CONSTTAB_INT("gkCameraProperties_CA_PERSPECTIVE", gkCameraProperties::CA_PERSPECTIVE)},
    {SWIG_LUA_CONSTTAB_INT("gkCameraProperties_CA_ORTHOGRAPHIC", gkCameraProperties::CA_ORTHOGRAPHIC)},
    {SWIG_LUA_CONSTTAB_INT("gkCurveProperties_CU_Bezier", gkCurveProperties::CU_Bezier)},
    {SWIG_LUA_CONSTTAB_INT("gkCurveProperties_CU_Spline", gkCurveProperties::CU_Spline)},
    {SWIG_LUA_CONSTTAB_INT("gkCurveProperties_CU_Points", gkCurveProperties::CU_Points)},
    {SWIG_LUA_CONSTTAB_INT("gkLightProperties_LI_POINT", gkLightProperties::LI_POINT)},
    {SWIG_LUA_CONSTTAB_INT("gkLightProperties_LI_SPOT", gkLightProperties::LI_SPOT)},
    {SWIG_LUA_CONSTTAB_INT("gkLightProperties_LI_DIR", gkLightProperties::LI_DIR)},
    {SWIG_LUA_CONSTTAB_INT("GK_NO_COLLISION", GK_NO_COLLISION)},
    {SWIG_LUA_CONSTTAB_INT("GK_STATIC", GK_STATIC)},
    {SWIG_LUA_CONSTTAB_INT("GK_DYNAMIC", GK_DYNAMIC)},
    {SWIG_LUA_CONSTTAB_INT("GK_RIGID", GK_RIGID)},
    {SWIG_LUA_CONSTTAB_INT("GK_SOFT", GK_SOFT)},
    {SWIG_LUA_CONSTTAB_INT("GK_SENSOR", GK_SENSOR)},
    {SWIG_LUA_CONSTTAB_INT("GK_NAVMESH", GK_NAVMESH)},
    {SWIG_LUA_CONSTTAB_INT("GK_CHARACTER", GK_CHARACTER)},
    {SWIG_LUA_CONSTTAB_INT("GK_NO_SLEEP", GK_NO_SLEEP)},
    {SWIG_LUA_CONSTTAB_INT("GK_CONTACT", GK_CONTACT)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_LINV_X", GK_LOCK_LINV_X)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_LINV_Y", GK_LOCK_LINV_Y)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_LINV_Z", GK_LOCK_LINV_Z)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_ANGV_X", GK_LOCK_ANGV_X)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_ANGV_Y", GK_LOCK_ANGV_Y)},
    {SWIG_LUA_CONSTTAB_INT("GK_LOCK_ANGV_Z", GK_LOCK_ANGV_Z)},
    {SWIG_LUA_CONSTTAB_INT("GK_COMPOUND", GK_COMPOUND)},
    {SWIG_LUA_CONSTTAB_INT("GK_COMPOUND_CHILD", GK_COMPOUND_CHILD)},
    {SWIG_LUA_CONSTTAB_INT("SH_BOX", SH_BOX)},
    {SWIG_LUA_CONSTTAB_INT("SH_CONE", SH_CONE)},
    {SWIG_LUA_CONSTTAB_INT("SH_CYLINDER", SH_CYLINDER)},
    {SWIG_LUA_CONSTTAB_INT("SH_SPHERE", SH_SPHERE)},
    {SWIG_LUA_CONSTTAB_INT("SH_CONVEX_TRIMESH", SH_CONVEX_TRIMESH)},
    {SWIG_LUA_CONSTTAB_INT("SH_GIMPACT_MESH", SH_GIMPACT_MESH)},
    {SWIG_LUA_CONSTTAB_INT("SH_BVH_MESH", SH_BVH_MESH)},
    {SWIG_LUA_CONSTTAB_INT("SH_CAPSULE", SH_CAPSULE)},
    {SWIG_LUA_CONSTTAB_INT("GK_BALL_CONSTRAINT", GK_BALL_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_HINGE_CONSTRAINT", GK_HINGE_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_CONETWIST_CONSTRAINT", GK_CONETWIST_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_VEHICLE_CONSTRAINT", GK_VEHICLE_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_D6_CONSTRAINT", GK_D6_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_SLIDER_CONSTRAINT", GK_SLIDER_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_CONTACT_CONSTRAINT", GK_CONTACT_CONSTRAINT)},
    {SWIG_LUA_CONSTTAB_INT("GK_OB_NULL", GK_OB_NULL)},
    {SWIG_LUA_CONSTTAB_INT("GK_CAMERA", GK_CAMERA)},
    {SWIG_LUA_CONSTTAB_INT("GK_LIGHT", GK_LIGHT)},
    {SWIG_LUA_CONSTTAB_INT("GK_ENTITY", GK_ENTITY)},
    {SWIG_LUA_CONSTTAB_INT("GK_OBJECT", GK_OBJECT)},
    {SWIG_LUA_CONSTTAB_INT("GK_SKELETON", GK_SKELETON)},
    {SWIG_LUA_CONSTTAB_INT("GK_PARTICLES", GK_PARTICLES)},
    {SWIG_LUA_CONSTTAB_INT("GK_CURVE", GK_CURVE)},
    {SWIG_LUA_CONSTTAB_INT("GK_GHOST", GK_GHOST)},
    {SWIG_LUA_CONSTTAB_INT("GK_ACTOR", GK_ACTOR)},
    {SWIG_LUA_CONSTTAB_INT("GK_INVISIBLE", GK_INVISIBLE)},
    {SWIG_LUA_CONSTTAB_INT("GK_OCCLUDER", GK_OCCLUDER)},
    {SWIG_LUA_CONSTTAB_INT("GK_HAS_LOGIC", GK_HAS_LOGIC)},
    {SWIG_LUA_CONSTTAB_INT("GK_IMMOVABLE", GK_IMMOVABLE)},
    {SWIG_LUA_CONSTTAB_INT("GK_STATIC_GEOM", GK_STATIC_GEOM)},
    {SWIG_LUA_CONSTTAB_INT("gkFogParams_FM_NONE", gkFogParams::FM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("gkFogParams_FM_LIN", gkFogParams::FM_LIN)},
    {SWIG_LUA_CONSTTAB_INT("gkFogParams_FM_EXP", gkFogParams::FM_EXP)},
    {SWIG_LUA_CONSTTAB_INT("gkFogParams_FM_QUAD", gkFogParams::FM_QUAD)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_NONE", gkSoundSceneProperties::DM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_INVERSE", gkSoundSceneProperties::DM_INVERSE)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_LINEAR", gkSoundSceneProperties::DM_LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_EXPONENT", gkSoundSceneProperties::DM_EXPONENT)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_INVERSE_CLAMP", gkSoundSceneProperties::DM_INVERSE_CLAMP)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_LINEAR_CLAMP", gkSoundSceneProperties::DM_LINEAR_CLAMP)},
    {SWIG_LUA_CONSTTAB_INT("gkSoundSceneProperties_DM_EXPONENT_CLAMP", gkSoundSceneProperties::DM_EXPONENT_CLAMP)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneMaterial_FLAT", gkSceneMaterial::FLAT)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneMaterial_LINEAR", gkSceneMaterial::LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneMaterial_RADIAL", gkSceneMaterial::RADIAL)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneMaterial_REFLECTED", gkSceneMaterial::REFLECTED)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneProperties_MA_GENERIC", gkSceneProperties::MA_GENERIC)},
    {SWIG_LUA_CONSTTAB_INT("gkSceneProperties_MA_OCTREE", gkSceneProperties::MA_OCTREE)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_PHY_NONE", gkParticleSettingsProperties::PHY_NONE)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_PHY_NEWTON", gkParticleSettingsProperties::PHY_NEWTON)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_PHY_KEYED", gkParticleSettingsProperties::PHY_KEYED)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_PHY_BOIDS", gkParticleSettingsProperties::PHY_BOIDS)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_PHY_FLUID", gkParticleSettingsProperties::PHY_FLUID)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_EF_VERTS", gkParticleSettingsProperties::EF_VERTS)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_EF_FACES", gkParticleSettingsProperties::EF_FACES)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_EF_VOLUME", gkParticleSettingsProperties::EF_VOLUME)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_EF_PARTICLES", gkParticleSettingsProperties::EF_PARTICLES)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_NONE", gkParticleSettingsProperties::R_NONE)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_HALO", gkParticleSettingsProperties::R_HALO)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_LINE", gkParticleSettingsProperties::R_LINE)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_PATH", gkParticleSettingsProperties::R_PATH)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_OBJECT", gkParticleSettingsProperties::R_OBJECT)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_GROUP", gkParticleSettingsProperties::R_GROUP)},
    {SWIG_LUA_CONSTTAB_INT("gkParticleSettingsProperties_R_BILLBOARD", gkParticleSettingsProperties::R_BILLBOARD)},
    {SWIG_LUA_CONSTTAB_INT("Gradient_NorthSouth", Gorilla::Gradient_NorthSouth)},
    {SWIG_LUA_CONSTTAB_INT("Gradient_WestEast", Gorilla::Gradient_WestEast)},
    {SWIG_LUA_CONSTTAB_INT("Gradient_Diagonal", Gorilla::Gradient_Diagonal)},
    {SWIG_LUA_CONSTTAB_INT("TWT_LINEAR", TWT_LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("TWT_SINE", TWT_SINE)},
    {SWIG_LUA_CONSTTAB_INT("TWT_QUINT", TWT_QUINT)},
    {SWIG_LUA_CONSTTAB_INT("TWT_QUART", TWT_QUART)},
    {SWIG_LUA_CONSTTAB_INT("TWT_QUAD", TWT_QUAD)},
    {SWIG_LUA_CONSTTAB_INT("TWT_EXPO", TWT_EXPO)},
    {SWIG_LUA_CONSTTAB_INT("TWT_ELASTIC", TWT_ELASTIC)},
    {SWIG_LUA_CONSTTAB_INT("TWT_CUBIC", TWT_CUBIC)},
    {SWIG_LUA_CONSTTAB_INT("TWT_CIRC", TWT_CIRC)},
    {SWIG_LUA_CONSTTAB_INT("TWT_BOUNCE", TWT_BOUNCE)},
    {SWIG_LUA_CONSTTAB_INT("TWT_BACK", TWT_BACK)},
    {SWIG_LUA_CONSTTAB_INT("TWE_EASE_IN", TWE_EASE_IN)},
    {SWIG_LUA_CONSTTAB_INT("TWE_EASE_OUT", TWE_EASE_OUT)},
    {SWIG_LUA_CONSTTAB_INT("TWE_EASE_IN_OUT", TWE_EASE_IN_OUT)},
    {SWIG_LUA_CONSTTAB_INT("OGRE_RS_GL", GS_RS_GL)},
    {SWIG_LUA_CONSTTAB_INT("OGRE_RS_GLES", GS_RS_GLES)},
    {SWIG_LUA_CONSTTAB_INT("OGRE_RS_D3D9", GS_RS_D3D9)},
    {SWIG_LUA_CONSTTAB_INT("OGRE_RS_D3D10", GS_RS_D3D10)},
    {SWIG_LUA_CONSTTAB_INT("OGRE_RS_D3D11", GS_RS_D3D11)},
    {SWIG_LUA_CONSTTAB_INT("ST_VERTEX", ST_VERTEX)},
    {SWIG_LUA_CONSTTAB_INT("ST_FRAGMENT", ST_FRAGMENT)},
    {SWIG_LUA_CONSTTAB_INT("PROP_NULL", PROP_NULL)},
    {SWIG_LUA_CONSTTAB_INT("PROP_BOOL", PROP_BOOL)},
    {SWIG_LUA_CONSTTAB_INT("PROP_NUMBER", PROP_NUMBER)},
    {SWIG_LUA_CONSTTAB_INT("PROP_STRING", PROP_STRING)},
    {SWIG_LUA_CONSTTAB_INT("TS_LOCAL", TS_LOCAL)},
    {SWIG_LUA_CONSTTAB_INT("TS_PARENT", TS_PARENT)},
    {SWIG_LUA_CONSTTAB_INT("TS_WORLD", TS_WORLD)},
    {SWIG_LUA_CONSTTAB_INT("OBT_UNKNOWN", OBT_UNKNOWN)},
    {SWIG_LUA_CONSTTAB_INT("OBT_CAMERA", OBT_CAMERA)},
    {SWIG_LUA_CONSTTAB_INT("OBT_LIGHT", OBT_LIGHT)},
    {SWIG_LUA_CONSTTAB_INT("OBT_ENTITY", OBT_ENTITY)},
    {SWIG_LUA_CONSTTAB_INT("OBT_EMPTY", OBT_EMPTY)},
    {SWIG_LUA_CONSTTAB_INT("OBT_SKELETON", OBT_SKELETON)},
    {SWIG_LUA_CONSTTAB_INT("OBT_CURVE", OBT_CURVE)},
    {SWIG_LUA_CONSTTAB_INT("LI_POINT", LI_POINT)},
    {SWIG_LUA_CONSTTAB_INT("LI_SPOT", LI_SPOT)},
    {SWIG_LUA_CONSTTAB_INT("LI_DIR", LI_DIR)},
    {SWIG_LUA_CONSTTAB_INT("EVT_TICK", EVT_TICK)},
    {SWIG_LUA_CONSTTAB_INT("LEFT", LEFT)},
    {SWIG_LUA_CONSTTAB_INT("RIGHT", RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("MIDDLE", MIDDLE)},
    {SWIG_LUA_CONSTTAB_INT("MT_None", MT_None)},
    {SWIG_LUA_CONSTTAB_INT("MT_Pressed", MT_Pressed)},
    {SWIG_LUA_CONSTTAB_INT("MT_Released", MT_Released)},
    {SWIG_LUA_CONSTTAB_INT("MT_Moved", MT_Moved)},
    {SWIG_LUA_CONSTTAB_INT("MT_Cancelled", MT_Cancelled)},
    {SWIG_LUA_CONSTTAB_INT("COP_ADD", COP_ADD)},
    {SWIG_LUA_CONSTTAB_INT("COP_DEL", COP_DEL)},
    {SWIG_LUA_CONSTTAB_INT("COP_REPLACE", COP_REPLACE)},
    {SWIG_LUA_CONSTTAB_INT("COP_RESET", COP_RESET)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_NONE", UPDATE_NONE)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_PHYSICS", UPDATE_PHYSICS)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_LOGIC_BRICKS", UPDATE_LOGIC_BRICKS)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_NODE_TREES", UPDATE_NODE_TREES)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_ANIMATIONS", UPDATE_ANIMATIONS)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_SOUNDS", UPDATE_SOUNDS)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_DBVT", UPDATE_DBVT)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_DEBUG", UPDATE_DEBUG)},
    {SWIG_LUA_CONSTTAB_INT("UPDATE_ALL", UPDATE_ALL)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESSION_BEST", COMPRESSION_BEST)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESSION_FAST", COMPRESSION_FAST)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESSION_NO", COMPRESSION_NO)},
    {SWIG_LUA_CONSTTAB_INT("KC_NONE", KC_NONE)},
    {SWIG_LUA_CONSTTAB_INT("KC_AKEY", KC_AKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_BKEY", KC_BKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_CKEY", KC_CKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_DKEY", KC_DKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_EKEY", KC_EKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_FKEY", KC_FKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_GKEY", KC_GKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_HKEY", KC_HKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_IKEY", KC_IKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_JKEY", KC_JKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_KKEY", KC_KKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LKEY", KC_LKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_MKEY", KC_MKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_NKEY", KC_NKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_OKEY", KC_OKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PKEY", KC_PKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_QKEY", KC_QKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RKEY", KC_RKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SKEY", KC_SKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_TKEY", KC_TKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_UKEY", KC_UKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_VKEY", KC_VKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_WKEY", KC_WKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_XKEY", KC_XKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_YKEY", KC_YKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ZKEY", KC_ZKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ZEROKEY", KC_ZEROKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ONEKEY", KC_ONEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_TWOKEY", KC_TWOKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_THREEKEY", KC_THREEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_FOURKEY", KC_FOURKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_FIVEKEY", KC_FIVEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SIXKEY", KC_SIXKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SEVENKEY", KC_SEVENKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_EIGHTKEY", KC_EIGHTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_NINEKEY", KC_NINEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_CAPSLOCKKEY", KC_CAPSLOCKKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LEFTCTRLKEY", KC_LEFTCTRLKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LEFTALTKEY", KC_LEFTALTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RIGHTALTKEY", KC_RIGHTALTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RIGHTCTRLKEY", KC_RIGHTCTRLKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RIGHTSHIFTKEY", KC_RIGHTSHIFTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LEFTSHIFTKEY", KC_LEFTSHIFTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ESCKEY", KC_ESCKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_TABKEY", KC_TABKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RETKEY", KC_RETKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SPACEKEY", KC_SPACEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LINEFEEDKEY", KC_LINEFEEDKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_BACKSPACEKEY", KC_BACKSPACEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_DELKEY", KC_DELKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SEMICOLONKEY", KC_SEMICOLONKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PERIODKEY", KC_PERIODKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_COMMAKEY", KC_COMMAKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_QUOTEKEY", KC_QUOTEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ACCENTGRAVEKEY", KC_ACCENTGRAVEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_MINUSKEY", KC_MINUSKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_SLASHKEY", KC_SLASHKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_BACKSLASHKEY", KC_BACKSLASHKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_EQUALKEY", KC_EQUALKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LEFTBRACKETKEY", KC_LEFTBRACKETKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RIGHTBRACKETKEY", KC_RIGHTBRACKETKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_LEFTARROWKEY", KC_LEFTARROWKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_DOWNARROWKEY", KC_DOWNARROWKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_RIGHTARROWKEY", KC_RIGHTARROWKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_UPARROWKEY", KC_UPARROWKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD0", KC_PAD0)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD1", KC_PAD1)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD2", KC_PAD2)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD3", KC_PAD3)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD4", KC_PAD4)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD5", KC_PAD5)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD6", KC_PAD6)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD7", KC_PAD7)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD8", KC_PAD8)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAD9", KC_PAD9)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADEQUALS", KC_PADEQUALS)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADPERIOD", KC_PADPERIOD)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADSLASHKEY", KC_PADSLASHKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADASTERKEY", KC_PADASTERKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADMINUS", KC_PADMINUS)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADENTER", KC_PADENTER)},
    {SWIG_LUA_CONSTTAB_INT("KC_PADPLUSKEY", KC_PADPLUSKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F1KEY", KC_F1KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F2KEY", KC_F2KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F3KEY", KC_F3KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F4KEY", KC_F4KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F5KEY", KC_F5KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F6KEY", KC_F6KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F7KEY", KC_F7KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F8KEY", KC_F8KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F9KEY", KC_F9KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F10KEY", KC_F10KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F11KEY", KC_F11KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_F12KEY", KC_F12KEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAUSEKEY", KC_PAUSEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_INSERTKEY", KC_INSERTKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_HOMEKEY", KC_HOMEKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAGEUPKEY", KC_PAGEUPKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_PAGEDOWNKEY", KC_PAGEDOWNKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_ENDKEY", KC_ENDKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_UNKNOWNKEY", KC_UNKNOWNKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_COMMANDKEY", KC_COMMANDKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_GRLESSKEY", KC_GRLESSKEY)},
    {SWIG_LUA_CONSTTAB_INT("KC_MAX", KC_MAX)},
    {SWIG_LUA_CONSTTAB_INT("gsAnimationPlayer_onStart", gsAnimationPlayer::onStart)},
    {SWIG_LUA_CONSTTAB_INT("gsAnimationPlayer_onEnd", gsAnimationPlayer::onEnd)},
    {SWIG_LUA_CONSTTAB_INT("gsAnimationPlayer_onLoopEnd", gsAnimationPlayer::onLoopEnd)},
    {SWIG_LUA_CONSTTAB_INT("gsAnimationPlayer_onTrigger", gsAnimationPlayer::onTrigger)},
    {SWIG_LUA_CONSTTAB_INT("gsAnimationPlayer_onDestruction", gsAnimationPlayer::onDestruction)},
    {SWIG_LUA_CONSTTAB_INT("BM_NONE", GS_BM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("BM_OFF", GS_BM_OFF)},
    {SWIG_LUA_CONSTTAB_INT("BM_ON", GS_BM_ON)},
    {SWIG_LUA_CONSTTAB_INT("PM_NONE", PM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("PM_OFF", PM_OFF)},
    {SWIG_LUA_CONSTTAB_INT("PM_ON", PM_ON)},
    {SWIG_LUA_CONSTTAB_INT("MST_LEFT", MST_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("MST_RIGHT", MST_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("MST_MIDDLE", MST_MIDDLE)},
    {SWIG_LUA_CONSTTAB_INT("MST_MOTION", MST_MOTION)},
    {SWIG_LUA_CONSTTAB_INT("MST_WHEEL_UP", MST_WHEEL_UP)},
    {SWIG_LUA_CONSTTAB_INT("MST_WHEEL_DOWN", MST_WHEEL_DOWN)},
    {SWIG_LUA_CONSTTAB_INT("MST_OVER", MST_OVER)},
    {SWIG_LUA_CONSTTAB_INT("MST_OVER_ANY", MST_OVER_ANY)},
    {SWIG_LUA_CONSTTAB_INT("LM_EVT_OVERIDE", LM_EVT_OVERIDE)},
    {SWIG_LUA_CONSTTAB_INT("LM_EVT_AND", LM_EVT_AND)},
    {SWIG_LUA_CONSTTAB_INT("PST_EQUAL", PST_EQUAL)},
    {SWIG_LUA_CONSTTAB_INT("PST_NEQUAL", PST_NEQUAL)},
    {SWIG_LUA_CONSTTAB_INT("PST_INTERVAL", PST_INTERVAL)},
    {SWIG_LUA_CONSTTAB_INT("PST_CHANGED", PST_CHANGED)},
    {SWIG_LUA_CONSTTAB_INT("RSA_XPOS", RSA_XPOS)},
    {SWIG_LUA_CONSTTAB_INT("RSA_YPOS", RSA_YPOS)},
    {SWIG_LUA_CONSTTAB_INT("RSA_ZPOS", RSA_ZPOS)},
    {SWIG_LUA_CONSTTAB_INT("RSA_XNEG", RSA_XNEG)},
    {SWIG_LUA_CONSTTAB_INT("RSA_YNEG", RSA_YNEG)},
    {SWIG_LUA_CONSTTAB_INT("RSA_ZNEG", RSA_ZNEG)},
    {SWIG_LUA_CONSTTAB_INT("LOP_NONE", LOP_NONE)},
    {SWIG_LUA_CONSTTAB_INT("LOP_AND", LOP_AND)},
    {SWIG_LUA_CONSTTAB_INT("LOP_OR", LOP_OR)},
    {SWIG_LUA_CONSTTAB_INT("LOP_XOR", LOP_XOR)},
    {SWIG_LUA_CONSTTAB_INT("LOP_NAND", LOP_NAND)},
    {SWIG_LUA_CONSTTAB_INT("LOP_NOR", LOP_NOR)},
    {SWIG_LUA_CONSTTAB_INT("LOP_XNOR", LOP_XNOR)},
    {SWIG_LUA_CONSTTAB_INT("AAT_PLAY", AAT_PLAY)},
    {SWIG_LUA_CONSTTAB_INT("AAT_PONG", AAT_PONG)},
    {SWIG_LUA_CONSTTAB_INT("AAT_FLIPPER", AAT_FLIPPER)},
    {SWIG_LUA_CONSTTAB_INT("AAT_LOOP_STOP", AAT_LOOP_STOP)},
    {SWIG_LUA_CONSTTAB_INT("AAT_LOOP_END", AAT_LOOP_END)},
    {SWIG_LUA_CONSTTAB_INT("AAT_PROPERTY", AAT_PROPERTY)},
    {SWIG_LUA_CONSTTAB_INT("GAT_QUIT", GAT_QUIT)},
    {SWIG_LUA_CONSTTAB_INT("GAT_RESTART", GAT_RESTART)},
    {SWIG_LUA_CONSTTAB_INT("GAT_START_NEW", GAT_START_NEW)},
    {SWIG_LUA_CONSTTAB_INT("GAT_SAVE", GAT_SAVE)},
    {SWIG_LUA_CONSTTAB_INT("GAT_LOAD", GAT_LOAD)},
    {SWIG_LUA_CONSTTAB_INT("EOT_ADDOBJ", EOT_ADDOBJ)},
    {SWIG_LUA_CONSTTAB_INT("EOT_ENDOBJ", EOT_ENDOBJ)},
    {SWIG_LUA_CONSTTAB_INT("EOT_REPLACEMESH", EOT_REPLACEMESH)},
    {SWIG_LUA_CONSTTAB_INT("EOT_TRACKTO_2D", EOT_TRACKTO_2D)},
    {SWIG_LUA_CONSTTAB_INT("EOT_TRACKTO_3D", EOT_TRACKTO_3D)},
    {SWIG_LUA_CONSTTAB_INT("EOT_DYNAMICS", EOT_DYNAMICS)},
    {SWIG_LUA_CONSTTAB_INT("EOD_RESTORE", EOD_RESTORE)},
    {SWIG_LUA_CONSTTAB_INT("EOD_SUSPEND", EOD_SUSPEND)},
    {SWIG_LUA_CONSTTAB_INT("EOD_ENABLE_BODY", EOD_ENABLE_BODY)},
    {SWIG_LUA_CONSTTAB_INT("EOD_DISABLE_BODY", EOD_DISABLE_BODY)},
    {SWIG_LUA_CONSTTAB_INT("EOD_SETMASS", EOD_SETMASS)},
    {SWIG_LUA_CONSTTAB_INT("MBT_TEXT", MBT_TEXT)},
    {SWIG_LUA_CONSTTAB_INT("MBT_PROP", MBT_PROP)},
    {SWIG_LUA_CONSTTAB_INT("PA_SET", PA_SET)},
    {SWIG_LUA_CONSTTAB_INT("PA_CLEAR", PA_CLEAR)},
    {SWIG_LUA_CONSTTAB_INT("PA_ASSIGN", PA_ASSIGN)},
    {SWIG_LUA_CONSTTAB_INT("PA_ADD", PA_ADD)},
    {SWIG_LUA_CONSTTAB_INT("PA_COPY", PA_COPY)},
    {SWIG_LUA_CONSTTAB_INT("PA_TOGGLE", PA_TOGGLE)},
    {SWIG_LUA_CONSTTAB_INT("RA_BOOL_CONSTANT", RA_BOOL_CONSTANT)},
    {SWIG_LUA_CONSTTAB_INT("RA_BOOL_UNIFORM", RA_BOOL_UNIFORM)},
    {SWIG_LUA_CONSTTAB_INT("RA_BOOL_BERNOUILLI", RA_BOOL_BERNOUILLI)},
    {SWIG_LUA_CONSTTAB_INT("RA_INT_CONSTANT", RA_INT_CONSTANT)},
    {SWIG_LUA_CONSTTAB_INT("RA_INT_UNIFORM", RA_INT_UNIFORM)},
    {SWIG_LUA_CONSTTAB_INT("RA_INT_POISSON", RA_INT_POISSON)},
    {SWIG_LUA_CONSTTAB_INT("RA_FLOAT_CONSTANT", RA_FLOAT_CONSTANT)},
    {SWIG_LUA_CONSTTAB_INT("RA_FLOAT_UNIFORM", RA_FLOAT_UNIFORM)},
    {SWIG_LUA_CONSTTAB_INT("RA_FLOAT_NORMAL", RA_FLOAT_NORMAL)},
    {SWIG_LUA_CONSTTAB_INT("RA_FLOAT_NEGEXP", RA_FLOAT_NEGEXP)},
    {SWIG_LUA_CONSTTAB_INT("SC_RESTART", SC_RESTART)},
    {SWIG_LUA_CONSTTAB_INT("SC_SET_SCENE", SC_SET_SCENE)},
    {SWIG_LUA_CONSTTAB_INT("SC_SET_CAMERA", SC_SET_CAMERA)},
    {SWIG_LUA_CONSTTAB_INT("SC_ADD_BACK", SC_ADD_BACK)},
    {SWIG_LUA_CONSTTAB_INT("SC_ADD_FRONT", SC_ADD_FRONT)},
    {SWIG_LUA_CONSTTAB_INT("SC_REMOVE", SC_REMOVE)},
    {SWIG_LUA_CONSTTAB_INT("SC_SUSPEND", SC_SUSPEND)},
    {SWIG_LUA_CONSTTAB_INT("SC_RESUME", SC_RESUME)},
    {SWIG_LUA_CONSTTAB_INT("SA_PLAY_STOP", SA_PLAY_STOP)},
    {SWIG_LUA_CONSTTAB_INT("SA_PLAY_END", SA_PLAY_END)},
    {SWIG_LUA_CONSTTAB_INT("SA_LOOP_STOP", SA_LOOP_STOP)},
    {SWIG_LUA_CONSTTAB_INT("SA_LOOP_END", SA_LOOP_END)},
    {SWIG_LUA_CONSTTAB_INT("SOP_ADD", SOP_ADD)},
    {SWIG_LUA_CONSTTAB_INT("SOP_SUB", SOP_SUB)},
    {SWIG_LUA_CONSTTAB_INT("SOP_CPY", SOP_CPY)},
    {SWIG_LUA_CONSTTAB_INT("SOP_INV", SOP_INV)},
    {SWIG_LUA_CONSTTAB_INT("VA_INVIS_FLAG", VA_INVIS_FLAG)},
    {SWIG_LUA_CONSTTAB_INT("VA_OCCLUDER", VA_OCCLUDER)},
    {SWIG_LUA_CONSTTAB_INT("VA_CHILDREN", VA_CHILDREN)},
    {SWIG_LUA_CONSTTAB_INT("ENONE", ENONE)},
    {SWIG_LUA_CONSTTAB_INT("EButton", EButton)},
    {SWIG_LUA_CONSTTAB_INT("ECaption", ECaption)},
    {SWIG_LUA_CONSTTAB_INT("ECheckbox", ECheckbox)},
    {SWIG_LUA_CONSTTAB_INT("ECombobox", ECombobox)},
    {SWIG_LUA_CONSTTAB_INT("EListbox", EListbox)},
    {SWIG_LUA_CONSTTAB_INT("EScrollbar", EScrollbar)},
    {SWIG_LUA_CONSTTAB_INT("ETextzone", ETextzone)},
    {SWIG_LUA_CONSTTAB_INT("EProgressBar", EProgressBar)},
    {SWIG_LUA_CONSTTAB_INT("ERectangle", ERectangle)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SwigModule_methods[]= {
    { "lerp", _wrap_lerp},
    { "getTriNormal", _wrap_getTriNormal},
    { "str2vec3", _wrap_str2vec3},
    { "str2vec4", _wrap_str2vec4},
    { "str2mat4", _wrap_str2mat4},
    { "Vec3Negate", _wrap_Vec3Negate},
    { "Vec3AddVec3", _wrap_Vec3AddVec3},
    { "Vec3SubVec3", _wrap_Vec3SubVec3},
    { "Vec3MulVec3", _wrap_Vec3MulVec3},
    { "Vec3DivVec3", _wrap_Vec3DivVec3},
    { "Vec3Mulf", _wrap_Vec3Mulf},
    { "Vec3Divf", _wrap_Vec3Divf},
    { "QuatNegate", _wrap_QuatNegate},
    { "QuatAddQuat", _wrap_QuatAddQuat},
    { "QuatSubQuat", _wrap_QuatSubQuat},
    { "QuatMulQuat", _wrap_QuatMulQuat},
    { "QuatMulf", _wrap_QuatMulf},
    { "QuatMulVec3", _wrap_QuatMulVec3},
    { "Vec3RotationTo", _wrap_Vec3RotationTo},
    { "getScreenshotAsString",native_getScreenshotAsString},
    { "getNumJoysticks", _wrap_getNumJoysticks},
    { "getHUD", _wrap_getHUD},
    { "getActiveScene", _wrap_getActiveScene},
    { "getScene", _wrap_getScene},
    { "addScene", _wrap_addScene},
    { "createGroupInstance", _wrap_createGroupInstance},
    { "updateStaticBatch", _wrap_updateStaticBatch},
    { "groupExists", _wrap_groupExists},
    { "getGroupCount", _wrap_getGroupCount},
    { "getGroupNameAt", _wrap_getGroupNameAt},
    { "destroyResourceGroup", _wrap_destroyResourceGroup},
    { "addResourceLocation", _wrap_addResourceLocation},
    { "loadResource", _wrap_loadResource},
    { "loadBlend", _wrap_loadBlend},
    { "unloadBlendFile", _wrap_unloadBlendFile},
    { "unloadAllBlendFiles", _wrap_unloadAllBlendFiles},
    { "downloadFile", _wrap_downloadFile},
    { "downloadToString", _wrap_downloadToString},
    { "nbDownload", _wrap_nbDownload},
    { "nbPoll", _wrap_nbPoll},
    { "nbSetCallback", _wrap_nbSetCallback},
    { "nbIsRunning", _wrap_nbIsRunning},
    { "sendMessage", _wrap_sendMessage},
    { "sendEventMessage", _wrap_sendEventMessage},
    { "DebugPrint", _wrap_DebugPrint},
    { "infoClear", _wrap_infoClear},
    { "infoLock", _wrap_infoLock},
    { "infoShow", _wrap_infoShow},
    { "getScriptFolder", _wrap_getScriptFolder},
    { "SetCompositorChain", _wrap_SetCompositorChain},
    { "import", _wrap_import},
    { "fileExists", _wrap_fileExists},
    { "fileLoad", _wrap_fileLoad},
    { "getPlatform", _wrap_getPlatform},
    { "isMobile", _wrap_isMobile},
    { "isSoundAvailable", _wrap_isSoundAvailable},
    { "isMaterialInitialized", _wrap_isMaterialInitialized},
    { "initMaterial", _wrap_initMaterial},
    { "getWindowTitle", _wrap_getWindowTitle},
    { "setMaterialParam", _wrap_setMaterialParam},
    { "log", _wrap_log},
    { "logDisable", _wrap_logDisable},
    { "logEnable", _wrap_logEnable},
    { "md5", _wrap_md5},
    { "blowfishEncrypt", _wrap_blowfishEncrypt},
    { "blowfishDecrypt", _wrap_blowfishDecrypt},
    { "isNetworkAvailable", _wrap_isNetworkAvailable},
    { "asyncIsNetworkAvailable", _wrap_asyncIsNetworkAvailable},
    { "ribbon", _wrap_ribbon},
    { "scancodeToInt", _wrap_scancodeToInt},
    { "getTime", _wrap_getTime},
    { "getSystemTime", _wrap_getSystemTime},
    { "getScreenSize", _wrap_getScreenSize},
    { "setScreenSize", _wrap_setScreenSize},
    { "getFPS", _wrap_getFPS},
    { "getDataDirectory", _wrap_getDataDirectory},
    { "getWorkingFolder", _wrap_getWorkingFolder},
    { "compressString", _wrap_compressString},
    { "compressCString", _wrap_compressCString},
    { "uncompressString", _wrap_uncompressString},
    { "executeScript", _wrap_executeScript},
    { "setSinglestepMode", _wrap_setSinglestepMode},
    { "inSinglestepMode", _wrap_inSinglestepMode},
    { "requestSinglestep", _wrap_requestSinglestep},
    { "getCurrentGUIElement", _wrap_getCurrentGUIElement},
    { "getDraggedElement", _wrap_getDraggedElement},
    { "getCurrentTargetElement", _wrap_getCurrentTargetElement},
    { "getCurrentRCSSEvent", _wrap_getCurrentRCSSEvent},
    { "getCurrentRCSSElement", _wrap_getCurrentRCSSElement},
    { "getCurrentRCSSProperty", _wrap_getCurrentRCSSProperty},
    { "getStringEventParameter", _wrap_getStringEventParameter},
    { "getIntEventParameter", _wrap_getIntEventParameter},
    { "getCurrentController", _wrap_getCurrentController},
    { "initCallbacks", _wrap_initCallbacks},
    { "onSocketOpen", _wrap_onSocketOpen},
    { "onSocketMessage", _wrap_onSocketMessage},
    { "onSocketError", _wrap_onSocketError},
    { "setSocketCallback", _wrap_setSocketCallback},
    { "startNetServer", _wrap_startNetServer},
    { "stopNetServer", _wrap_stopNetServer},
    { "isServerRunning", _wrap_isServerRunning},
    { "startNetClient", _wrap_startNetClient},
    { "stopNetClient", _wrap_stopNetClient},
    { "isClientRunning", _wrap_isClientRunning},
    { "getLogicTree", _wrap_getLogicTree},
    { "getLogicTreeAmount", _wrap_getLogicTreeAmount},
    { "getLogicTreeAt", _wrap_getLogicTreeAt},
    { "getCurrentLogicTree", _wrap_getCurrentLogicTree},
    { "getCurrentLogicNode", _wrap_getCurrentLogicNode},
    { "enableLogicTreeDebug", _wrap_enableLogicTreeDebug},
    { "getLogicTreeDebugOutput", _wrap_getLogicTreeDebugOutput},
    { "getLogicTreeDebugOutputCompressed", _wrap_getLogicTreeDebugOutputCompressed},
    { "isLogicTreeDebugging", _wrap_isLogicTreeDebugging},
    { "setGlobalVolume", _wrap_setGlobalVolume},
    { "getGlobalVolume", _wrap_getGlobalVolume},
    {0,0}
};
static swig_lua_class* swig_SwigModule_classes[]= {
&_wrap_class_string,
&_wrap_class_gkTextureProperties,
&_wrap_class_gkMaterialProperties,
&_wrap_class_gkCameraProperties,
&_wrap_class_gkEntityProperties,
&_wrap_class_gkCurveProperties,
&_wrap_class_gkLightProperties,
&_wrap_class_gkPhysicsConstraintProperties,
&_wrap_class_gkPhysicsProperties,
&_wrap_class_gkGameObjectProperties,
&_wrap_class_gkFogParams,
&_wrap_class_gkSoundSceneProperties,
&_wrap_class_gkSceneMaterial,
&_wrap_class_gkSceneProperties,
&_wrap_class_gkParticleSettingsProperties,
&_wrap_class_gkParticleSystemProperties,
&_wrap_class_gkSoundProperties,
&_wrap_class_gsVector2,
&_wrap_class_Vector3,
&_wrap_class_Vector4,
&_wrap_class_Quaternion,
&_wrap_class_Matrix4,
&_wrap_class_Ray,
&_wrap_class_gkVector2,
&_wrap_class_gkVector3,
&_wrap_class_gkVertex,
&_wrap_class_gkColor,
&_wrap_class_ColourValue,
&_wrap_class_gkTriangle,
&_wrap_class_ObjectList,
&_wrap_class_ObjectIterator,
&_wrap_class_ProcessList,
&_wrap_class_ProcessIterator,
&_wrap_class_Property,
&_wrap_class_UserDefs,
&_wrap_class_gsMultiTouchState,
&_wrap_class_Touch,
&_wrap_class_Mouse,
&_wrap_class_Joystick,
&_wrap_class_Keyboard,
&_wrap_class_Engine,
&_wrap_class_Object,
&_wrap_class_HUD,
&_wrap_class_HUDElement,
&_wrap_class_gsStaticBatch,
&_wrap_class_Scene,
&_wrap_class_gsGameObjectInstance,
&_wrap_class_gsContactInfo,
&_wrap_class_GameObject,
&_wrap_class_gsMessageListenerCallback,
&_wrap_class_MessageManager,
&_wrap_class_Curve,
&_wrap_class_Light,
&_wrap_class_Camera,
&_wrap_class_Entity,
&_wrap_class_Skeleton,
&_wrap_class_Particles,
&_wrap_class_Debugger,
&_wrap_class_gsRecastDebugger,
&_wrap_class_gsSubMesh,
&_wrap_class_gsMesh,
&_wrap_class_gsTween,
&_wrap_class_gsProcedural,
&_wrap_class_gsLuaStream,
&_wrap_class_gsGuiDocumentRocket,
&_wrap_class_gsGuiElementQuery,
&_wrap_class_gsGuiElementEventListener,
&_wrap_class_gsGuiElement,
&_wrap_class_gsGUI,
&_wrap_class_gsGuiDataSource,
&_wrap_class_gsGuiDataFormatter,
&_wrap_class_WhenEvent,
&_wrap_class_FSM,
&_wrap_class_NavPath,
&_wrap_class_SteerGroup,
&_wrap_class_SteerRayObstacle,
&_wrap_class_SteerSweptObstacle,
&_wrap_class_SteerObstacleGroup,
&_wrap_class_gsSteerPathFollowing,
&_wrap_class_MyVehicle,
&_wrap_class_SteerObject,
&_wrap_class_gsAnimationPlayer,
&_wrap_class_LogicList,
&_wrap_class_LogicIterator,
&_wrap_class_Sensors,
&_wrap_class_SensorIterator,
&_wrap_class_Controllers,
&_wrap_class_ControllerIterator,
&_wrap_class_Actuators,
&_wrap_class_ActuatorIterator,
&_wrap_class_LogicManager,
&_wrap_class_LogicObject,
&_wrap_class_Brick,
&_wrap_class_Sensor,
&_wrap_class_ActuatorSensor,
&_wrap_class_AlwaysSensor,
&_wrap_class_CollisionSensor,
&_wrap_class_gsTouchSensor,
&_wrap_class_DelaySensor,
&_wrap_class_KeyboardSensor,
&_wrap_class_MessageSensor,
&_wrap_class_MouseSensor,
&_wrap_class_NearSensor,
&_wrap_class_PropertySensor,
&_wrap_class_RaySensor,
&_wrap_class_RadarSensor,
&_wrap_class_RandomSensor,
&_wrap_class_Controller,
&_wrap_class_LogicOpController,
&_wrap_class_ExpressionController,
&_wrap_class_ScriptController,
&_wrap_class_Actuator,
&_wrap_class_ActionActuator,
&_wrap_class_EditObjectActuator,
&_wrap_class_GameActuator,
&_wrap_class_MessageActuator,
&_wrap_class_MotionActuator,
&_wrap_class_ParentActuator,
&_wrap_class_PropertyActuator,
&_wrap_class_RandomActuator,
&_wrap_class_SceneActuator,
&_wrap_class_SoundActuator,
&_wrap_class_StateActuator,
&_wrap_class_VisibilityActuator,
&_wrap_class_gsNetwork,
&_wrap_class_gsLogicTree,
&_wrap_class_gsILogicSocket,
&_wrap_class_gsVariable,
&_wrap_class_gsLogicNode,
&_wrap_class_gsPickRayNodeAbstract,
&_wrap_class_gsTestNodeAbstract,
&_wrap_class_gsMessageSendAbstract,
&_wrap_class_gsMessageGetAbstract,
&_wrap_class_gsObjectManipulatorAbstract,
&_wrap_class_gsCharacterNodeAbstract,
&_wrap_class_gsSequenceAbstract,
&_wrap_class_gsSeqFinishedAbstract,
&_wrap_class_gsSeqTimeAbstract,
&_wrap_class_gsMotionNodeAbstract,
&_wrap_class_gsMouseNodeAbstract,
&_wrap_class_gsBoolNodeAbstract,
&_wrap_class_gsMathNodeAbstract,
&_wrap_class_gsTimerNodeAbstract,
&_wrap_class_gsObjectNodeAbstract,
&_wrap_class_gsObjectDataAbstract,
&_wrap_class_gsAccelerometerAbstract,
&_wrap_class_gsVectorDecompAbstract,
&_wrap_class_gsNodeTreeNodeAbstract,
&_wrap_class_gsStateMachineAbstract,
&_wrap_class_gsStateAbstract,
&_wrap_class_gsStateTransitionAbstract,
&_wrap_class_gsStateMachineRefAbstract,
&_wrap_class_gsStateRefAbstract,
&_wrap_class_gsStateManipulatorAbstract,
&_wrap_class_gsPropertyAbstract,
&_wrap_class_gsPropertyGetAbstract,
&_wrap_class_gsNoOpAbstract,
&_wrap_class_gsTemplaterNodeAbstract,
&_wrap_class_gsScreenActionAbstract,
&_wrap_class_gsElementAbstract,
&_wrap_class_gsAnimationDefinitionAbstract,
&_wrap_class_gsAnimationPlayerAbstract,
&_wrap_class_gsAnimationTriggerAbstract,
&_wrap_class_gsCollisionNodeAbstract,
&_wrap_class_gsFileNodeAbstract,
&_wrap_class_gsLuaNodeAbstract,
&_wrap_class_gsAdditionNodeAbstract,
&_wrap_class_gsPrintNodeAbstract,
&_wrap_class_gsKeyNodeAbstract,
&_wrap_class_gsMouseButtonAbstract,
&_wrap_class_gsDeltaNodeAbstract,
&_wrap_class_gsTypeColorAbstract,
&_wrap_class_gsTypeIntAbstract,
&_wrap_class_gsTypeFloatAbstract,
&_wrap_class_gsTypeBoolAbstract,
&_wrap_class_gsPBSMaterialAbstract,
&_wrap_class_gsPBSSlotAbstract,
&_wrap_class_gsPBSTex_AlbedoAbstract,
&_wrap_class_gsPBSTex_EnvAbstract,
&_wrap_class_gsPBSTex_NormalAbstract,
&_wrap_class_gsPBSTex_F0Abstract,
&_wrap_class_gsEngineNodeAbstract,
&_wrap_class_gsIfNodeAbstract,
&_wrap_class_gsSoundNodeAbstract,
&_wrap_class_gsJoystickNodeAbstract,
&_wrap_class_gsJoystickButtonAbstract,
&_wrap_class_gsVehicleNodeAbstract,
&_wrap_class_gsVehicleGearboxAbstract,
&_wrap_class_gsVehicleGearAbstract,
&_wrap_class_gsVehicleWheelAbstract,
&_wrap_class_gsCameraNodeAbstract,
&_wrap_class_DynamicsWorld,
&_wrap_class_gsVehicle,
&_wrap_class_RayTest,
&_wrap_class_SweptTest,
&_wrap_class_Character,
&_wrap_class_SoundManager,
&_wrap_class_Source,
&_wrap_class_LuaScript,
&_wrap_class_LuaManager,
&_wrap_class_Process,
&_wrap_class_ProcessManager,
&_wrap_class_PanelColors,
&_wrap_class_gsGUI3DScriptCallback,
&_wrap_class_tsPanel,
&_wrap_class_gsGUI3DElement,
&_wrap_class_gsRectangleDesigned,
&_wrap_class_gsGUI3DButton,
&_wrap_class_gsGUI3DCaption,
&_wrap_class_gsGUI3DCheckbox,
&_wrap_class_gsGUI3DTextField,
&_wrap_class_gsGUI3DRectangle,
&_wrap_class_gsGUI3DProgressbar,
&_wrap_class_gsGUI3DScrollbar,
&_wrap_class_gsGUI3DCombobox,
&_wrap_class_gsGUI3DListbox,
&_wrap_class_gsGUI3D,
&_wrap_class_gsSprite,
&_wrap_class_gsGorillaText,
&_wrap_class_gsGorillaLineList,
&_wrap_class_gkGorillaRectangle,
&_wrap_class_gsGorillaRectangle,
&_wrap_class_gsTextureAtlas,
&_wrap_class_gsGorillaScreenFunctions,
&_wrap_class_gsGorillaScreen,
&_wrap_class_gsGorillaScreen3D,
&_wrap_class_gsGorilla,
    0
};
static swig_lua_namespace* swig_SwigModule_namespaces[] = {
    0
};

static swig_lua_namespace swig_SwigModule = {
    "OgreKit",
    swig_SwigModule_methods,
    swig_SwigModule_attributes,
    swig_SwigModule_constants,
    swig_SwigModule_classes,
    swig_SwigModule_namespaces
};
#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_gsGUI3DButtonTo_p_gsRectangleDesigned(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsRectangleDesigned *)  ((gsGUI3DButton *) x));
}
static void *_p_gsParticlesTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsParticles *) x));
}
static void *_p_gsLightTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsLight *) x));
}
static void *_p_gsEntityTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsEntity *) x));
}
static void *_p_gsCurveTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsCurve *) x));
}
static void *_p_gsCameraTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsCamera *) x));
}
static void *_p_gsSkeletonTo_p_gsGameObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGameObject *)  ((gsSkeleton *) x));
}
static void *_p_gsParticlesTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsParticles *) x));
}
static void *_p_gsSceneTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *)  ((gsScene *) x));
}
static void *_p_gsLightTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsLight *) x));
}
static void *_p_gsGameObjectTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *)  ((gsGameObject *) x));
}
static void *_p_gsEntityTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsEntity *) x));
}
static void *_p_gsCurveTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsCurve *) x));
}
static void *_p_gsCameraTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsCamera *) x));
}
static void *_p_gsSkeletonTo_p_gsObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsObject *) (gsGameObject *) ((gsSkeleton *) x));
}
static void *_p_gsRandomSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsRandomSensor *) x));
}
static void *_p_gsRaySensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsRaySensor *) x));
}
static void *_p_gsPropertySensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsPropertySensor *) x));
}
static void *_p_gsMouseSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsMouseSensor *) x));
}
static void *_p_gsMessageSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsMessageSensor *) x));
}
static void *_p_gsDelaySensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsDelaySensor *) x));
}
static void *_p_gsAlwaysSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsAlwaysSensor *) x));
}
static void *_p_gsSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *)  ((gsSensor *) x));
}
static void *_p_gsRadarSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsRadarSensor *) x));
}
static void *_p_gsNearSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsNearSensor *) x));
}
static void *_p_gsKeyboardSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsKeyboardSensor *) x));
}
static void *_p_gsTouchSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsTouchSensor *) x));
}
static void *_p_gsCollisionSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsCollisionSensor *) x));
}
static void *_p_gsActuatorSensorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsSensor *) ((gsActuatorSensor *) x));
}
static void *_p_gsControllerTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *)  ((gsController *) x));
}
static void *_p_gsLogicOpControllerTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsController *) ((gsLogicOpController *) x));
}
static void *_p_gsExpressionControllerTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsController *) ((gsExpressionController *) x));
}
static void *_p_gsScriptControllerTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsController *) ((gsScriptController *) x));
}
static void *_p_gsActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *)  ((gsActuator *) x));
}
static void *_p_gsActionActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsActionActuator *) x));
}
static void *_p_gsEditObjectActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsEditObjectActuator *) x));
}
static void *_p_gsGameActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsGameActuator *) x));
}
static void *_p_gsMessageActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsMessageActuator *) x));
}
static void *_p_gsMotionActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsMotionActuator *) x));
}
static void *_p_gsParentActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsParentActuator *) x));
}
static void *_p_gsPropertyActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsPropertyActuator *) x));
}
static void *_p_gsRandomActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsRandomActuator *) x));
}
static void *_p_gsSceneActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsSceneActuator *) x));
}
static void *_p_gsSoundActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsSoundActuator *) x));
}
static void *_p_gsStateActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsStateActuator *) x));
}
static void *_p_gsVisibilityActuatorTo_p_gsBrick(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsBrick *) (gsActuator *) ((gsVisibilityActuator *) x));
}
static void *_p_gsGUI3DCaptionTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DCaption *) x));
}
static void *_p_gsGUI3DCheckboxTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DCheckbox *) x));
}
static void *_p_gsGUI3DComboboxTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DCombobox *) x));
}
static void *_p_gsGUI3DButtonTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DButton *) x));
}
static void *_p_gsGUI3DScrollbarTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DScrollbar *) x));
}
static void *_p_gsGUI3DRectangleTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DRectangle *) x));
}
static void *_p_gsGUI3DProgressbarTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DProgressbar *) x));
}
static void *_p_gsGUI3DListboxTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DListbox *) x));
}
static void *_p_gsGUI3DTextFieldTo_p_gsGUI3DElement(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGUI3DElement *)  ((gsGUI3DTextField *) x));
}
static void *_p_gsActionActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsActionActuator *) x));
}
static void *_p_gsEditObjectActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsEditObjectActuator *) x));
}
static void *_p_gsGameActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsGameActuator *) x));
}
static void *_p_gsMessageActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsMessageActuator *) x));
}
static void *_p_gsMotionActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsMotionActuator *) x));
}
static void *_p_gsParentActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsParentActuator *) x));
}
static void *_p_gsPropertyActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsPropertyActuator *) x));
}
static void *_p_gsRandomActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsRandomActuator *) x));
}
static void *_p_gsSceneActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsSceneActuator *) x));
}
static void *_p_gsSoundActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsSoundActuator *) x));
}
static void *_p_gsStateActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsStateActuator *) x));
}
static void *_p_gsVisibilityActuatorTo_p_gsActuator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsActuator *)  ((gsVisibilityActuator *) x));
}
static void *_p_gsLogicOpControllerTo_p_gsController(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsController *)  ((gsLogicOpController *) x));
}
static void *_p_gsExpressionControllerTo_p_gsController(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsController *)  ((gsExpressionController *) x));
}
static void *_p_gsScriptControllerTo_p_gsController(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsController *)  ((gsScriptController *) x));
}
static void *_p_gsGorillaScreen3DTo_p_gsGorillaScreenFunctions(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGorillaScreenFunctions *)  ((gsGorillaScreen3D *) x));
}
static void *_p_gsGorillaScreenTo_p_gsGorillaScreenFunctions(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsGorillaScreenFunctions *)  ((gsGorillaScreen *) x));
}
static void *_p_gsAnimationTriggerAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsAnimationTriggerAbstract *) x));
}
static void *_p_gsAnimationPlayerAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsAnimationPlayerAbstract *) x));
}
static void *_p_gsAnimationDefinitionAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsAnimationDefinitionAbstract *) x));
}
static void *_p_gsElementAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsElementAbstract *) x));
}
static void *_p_gsScreenActionAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsScreenActionAbstract *) x));
}
static void *_p_gsTemplaterNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTemplaterNodeAbstract *) x));
}
static void *_p_gsNoOpAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsNoOpAbstract *) x));
}
static void *_p_gsPropertyGetAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPropertyGetAbstract *) x));
}
static void *_p_gsPropertyAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPropertyAbstract *) x));
}
static void *_p_gsStateManipulatorAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateManipulatorAbstract *) x));
}
static void *_p_gsStateRefAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateRefAbstract *) x));
}
static void *_p_gsStateMachineRefAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateMachineRefAbstract *) x));
}
static void *_p_gsStateTransitionAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateTransitionAbstract *) x));
}
static void *_p_gsStateAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateAbstract *) x));
}
static void *_p_gsStateMachineAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsStateMachineAbstract *) x));
}
static void *_p_gsNodeTreeNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsNodeTreeNodeAbstract *) x));
}
static void *_p_gsVectorDecompAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsVectorDecompAbstract *) x));
}
static void *_p_gsAccelerometerAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsAccelerometerAbstract *) x));
}
static void *_p_gsObjectDataAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsObjectDataAbstract *) x));
}
static void *_p_gsObjectNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsObjectNodeAbstract *) x));
}
static void *_p_gsPickRayNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPickRayNodeAbstract *) x));
}
static void *_p_gsTestNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTestNodeAbstract *) x));
}
static void *_p_gsMessageSendAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMessageSendAbstract *) x));
}
static void *_p_gsMessageGetAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMessageGetAbstract *) x));
}
static void *_p_gsObjectManipulatorAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsObjectManipulatorAbstract *) x));
}
static void *_p_gsCharacterNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsCharacterNodeAbstract *) x));
}
static void *_p_gsSequenceAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsSequenceAbstract *) x));
}
static void *_p_gsSeqFinishedAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsSeqFinishedAbstract *) x));
}
static void *_p_gsSeqTimeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsSeqTimeAbstract *) x));
}
static void *_p_gsMotionNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMotionNodeAbstract *) x));
}
static void *_p_gsMouseNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMouseNodeAbstract *) x));
}
static void *_p_gsBoolNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsBoolNodeAbstract *) x));
}
static void *_p_gsMathNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMathNodeAbstract *) x));
}
static void *_p_gsTimerNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTimerNodeAbstract *) x));
}
static void *_p_gsCollisionNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsCollisionNodeAbstract *) x));
}
static void *_p_gsFileNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsFileNodeAbstract *) x));
}
static void *_p_gsLuaNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsLuaNodeAbstract *) x));
}
static void *_p_gsAdditionNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsAdditionNodeAbstract *) x));
}
static void *_p_gsPrintNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPrintNodeAbstract *) x));
}
static void *_p_gsKeyNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsKeyNodeAbstract *) x));
}
static void *_p_gsMouseButtonAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsMouseButtonAbstract *) x));
}
static void *_p_gsDeltaNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsDeltaNodeAbstract *) x));
}
static void *_p_gsTypeColorAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTypeColorAbstract *) x));
}
static void *_p_gsTypeIntAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTypeIntAbstract *) x));
}
static void *_p_gsTypeFloatAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTypeFloatAbstract *) x));
}
static void *_p_gsTypeBoolAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsTypeBoolAbstract *) x));
}
static void *_p_gsPBSMaterialAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSMaterialAbstract *) x));
}
static void *_p_gsPBSSlotAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSSlotAbstract *) x));
}
static void *_p_gsPBSTex_AlbedoAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSTex_AlbedoAbstract *) x));
}
static void *_p_gsPBSTex_EnvAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSTex_EnvAbstract *) x));
}
static void *_p_gsPBSTex_NormalAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSTex_NormalAbstract *) x));
}
static void *_p_gsPBSTex_F0AbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsPBSTex_F0Abstract *) x));
}
static void *_p_gsEngineNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsEngineNodeAbstract *) x));
}
static void *_p_gsIfNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsIfNodeAbstract *) x));
}
static void *_p_gsSoundNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsSoundNodeAbstract *) x));
}
static void *_p_gsJoystickNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsJoystickNodeAbstract *) x));
}
static void *_p_gsJoystickButtonAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsJoystickButtonAbstract *) x));
}
static void *_p_gsVehicleNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsVehicleNodeAbstract *) x));
}
static void *_p_gsVehicleGearboxAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsVehicleGearboxAbstract *) x));
}
static void *_p_gsVehicleGearAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsVehicleGearAbstract *) x));
}
static void *_p_gsVehicleWheelAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsVehicleWheelAbstract *) x));
}
static void *_p_gsCameraNodeAbstractTo_p_gsLogicNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsLogicNode *)  ((gsCameraNodeAbstract *) x));
}
static void *_p_gsActuatorSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsActuatorSensor *) x));
}
static void *_p_gsCollisionSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsCollisionSensor *) x));
}
static void *_p_gsTouchSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsTouchSensor *) x));
}
static void *_p_gsKeyboardSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsKeyboardSensor *) x));
}
static void *_p_gsNearSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsNearSensor *) x));
}
static void *_p_gsRadarSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsRadarSensor *) x));
}
static void *_p_gsAlwaysSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsAlwaysSensor *) x));
}
static void *_p_gsDelaySensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsDelaySensor *) x));
}
static void *_p_gsMessageSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsMessageSensor *) x));
}
static void *_p_gsMouseSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsMouseSensor *) x));
}
static void *_p_gsPropertySensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsPropertySensor *) x));
}
static void *_p_gsRaySensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsRaySensor *) x));
}
static void *_p_gsRandomSensorTo_p_gsSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((gsSensor *)  ((gsRandomSensor *) x));
}
static swig_type_info _swigt__p_Array = {"_p_Array", "Array *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BezTriples = {"_p_BezTriples", "BezTriples *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BrickList = {"_p_BrickList", "BrickList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CollisionMask = {"_p_CollisionMask", "CollisionMask *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CurvePoints = {"_p_CurvePoints", "CurvePoints *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__Layer = {"_p_Gorilla__Layer", "Gorilla::Layer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__LineList = {"_p_Gorilla__LineList", "Gorilla::LineList *|gkGorillaLineList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__MarkupText = {"_p_Gorilla__MarkupText", "Gorilla::MarkupText *|gkGorillaText *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__Rectangle = {"_p_Gorilla__Rectangle", "Gorilla::Rectangle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__Screen = {"_p_Gorilla__Screen", "Gorilla::Screen *|gkGorillaScreen *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__ScreenRenderable = {"_p_Gorilla__ScreenRenderable", "Gorilla::ScreenRenderable *|gkGorillaScreen3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__Sprite = {"_p_Gorilla__Sprite", "Gorilla::Sprite *|gkSprite *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gorilla__TextureAtlas = {"_p_Gorilla__TextureAtlas", "Gorilla::TextureAtlas *|gkTextureAtlas *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Button = {"_p_Gui3D__Button", "Gui3D::Button *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Caption = {"_p_Gui3D__Caption", "Gui3D::Caption *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Checkbox = {"_p_Gui3D__Checkbox", "Gui3D::Checkbox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Combobox = {"_p_Gui3D__Combobox", "Gui3D::Combobox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Listbox = {"_p_Gui3D__Listbox", "Gui3D::Listbox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__PanelColors = {"_p_Gui3D__PanelColors", "Gui3D::PanelColors *", 0, 0, (void*)&_wrap_class_PanelColors, 0};
static swig_type_info _swigt__p_Gui3D__PanelContainer = {"_p_Gui3D__PanelContainer", "Gui3D::PanelContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__PanelElement = {"_p_Gui3D__PanelElement", "Gui3D::PanelElement *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__ProgressBar = {"_p_Gui3D__ProgressBar", "Gui3D::ProgressBar *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__Rectangle = {"_p_Gui3D__Rectangle", "Gui3D::Rectangle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__ScrollBar = {"_p_Gui3D__ScrollBar", "Gui3D::ScrollBar *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Gui3D__TextZone = {"_p_Gui3D__TextZone", "Gui3D::TextZone *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Iterator = {"_p_Iterator", "Iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MyVehicle = {"_p_MyVehicle", "MyVehicle *", 0, 0, (void*)&_wrap_class_MyVehicle, 0};
static swig_type_info _swigt__p_OIS__MultiTouchState = {"_p_OIS__MultiTouchState", "OIS::MultiTouchState *|gkMultiTouchState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__ColourValue = {"_p_Ogre__ColourValue", "Ogre::ColourValue *", 0, 0, (void*)&_wrap_class_ColourValue, 0};
static swig_type_info _swigt__p_Ogre__Entity = {"_p_Ogre__Entity", "Ogre::Entity *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__PbsMaterial = {"_p_Ogre__PbsMaterial", "Ogre::PbsMaterial *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Real = {"_p_Ogre__Real", "Ogre::Real *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenSteer__AVGroup = {"_p_OpenSteer__AVGroup", "OpenSteer::AVGroup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenSteer__AbstractVehicle = {"_p_OpenSteer__AbstractVehicle", "OpenSteer::AbstractVehicle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenSteer__ObstacleGroup = {"_p_OpenSteer__ObstacleGroup", "OpenSteer::ObstacleGroup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenSteer__Vec3 = {"_p_OpenSteer__Vec3", "OpenSteer::Vec3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rocket__Core__Element = {"_p_Rocket__Core__Element", "Rocket::Core::Element *|gkGuiElement *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rocket__Core__Event = {"_p_Rocket__Core__Event", "Rocket::Core::Event *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rocket__Core__String = {"_p_Rocket__Core__String", "Rocket::Core::String *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rocket__Core__StringList = {"_p_Rocket__Core__StringList", "Rocket::Core::StringList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UTsize = {"_p_UTsize", "UTsize *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_btManifoldPoint = {"_p_btManifoldPoint", "btManifoldPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAccelerometerAbstract = {"_p_gkAccelerometerAbstract", "gkAccelerometerAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAdditionNodeAbstract = {"_p_gkAdditionNodeAbstract", "gkAdditionNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAnimationDefinitionAbstract = {"_p_gkAnimationDefinitionAbstract", "gkAnimationDefinitionAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAnimationPlayer = {"_p_gkAnimationPlayer", "gkAnimationPlayer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAnimationPlayerAbstract = {"_p_gkAnimationPlayerAbstract", "gkAnimationPlayerAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkAnimationTriggerAbstract = {"_p_gkAnimationTriggerAbstract", "gkAnimationTriggerAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkBoolNodeAbstract = {"_p_gkBoolNodeAbstract", "gkBoolNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkCameraNodeAbstract = {"_p_gkCameraNodeAbstract", "gkCameraNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkCameraProperties = {"_p_gkCameraProperties", "gkCameraProperties *", 0, 0, (void*)&_wrap_class_gkCameraProperties, 0};
static swig_type_info _swigt__p_gkCharacter = {"_p_gkCharacter", "gkCharacter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkCharacterNodeAbstract = {"_p_gkCharacterNodeAbstract", "gkCharacterNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkCollisionNodeAbstract = {"_p_gkCollisionNodeAbstract", "gkCollisionNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkColor = {"_p_gkColor", "gkColor *", 0, 0, (void*)&_wrap_class_gkColor, 0};
static swig_type_info _swigt__p_gkCurveProperties = {"_p_gkCurveProperties", "gkCurveProperties *", 0, 0, (void*)&_wrap_class_gkCurveProperties, 0};
static swig_type_info _swigt__p_gkDebugger = {"_p_gkDebugger", "gkDebugger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkDeltaNodeAbstract = {"_p_gkDeltaNodeAbstract", "gkDeltaNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkDynamicsWorld = {"_p_gkDynamicsWorld", "gkDynamicsWorld *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkElementAbstract = {"_p_gkElementAbstract", "gkElementAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkEngineNodeAbstract = {"_p_gkEngineNodeAbstract", "gkEngineNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkEntityProperties = {"_p_gkEntityProperties", "gkEntityProperties *", 0, 0, (void*)&_wrap_class_gkEntityProperties, 0};
static swig_type_info _swigt__p_gkFileNodeAbstract = {"_p_gkFileNodeAbstract", "gkFileNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkFogParams = {"_p_gkFogParams", "gkFogParams *", 0, 0, (void*)&_wrap_class_gkFogParams, 0};
static swig_type_info _swigt__p_gkGameObject = {"_p_gkGameObject", "gkGameObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkGameObjectInstance = {"_p_gkGameObjectInstance", "gkGameObjectInstance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkGameObjectProperties = {"_p_gkGameObjectProperties", "gkGameObjectProperties *", 0, 0, (void*)&_wrap_class_gkGameObjectProperties, 0};
static swig_type_info _swigt__p_gkGorillaRectangle = {"_p_gkGorillaRectangle", "gkGorillaRectangle *", 0, 0, (void*)&_wrap_class_gkGorillaRectangle, 0};
static swig_type_info _swigt__p_gkILogicSocket = {"_p_gkILogicSocket", "gkILogicSocket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkIfNodeAbstract = {"_p_gkIfNodeAbstract", "gkIfNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkJoystickButtonAbstract = {"_p_gkJoystickButtonAbstract", "gkJoystickButtonAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkJoystickNodeAbstract = {"_p_gkJoystickNodeAbstract", "gkJoystickNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkKeyNodeAbstract = {"_p_gkKeyNodeAbstract", "gkKeyNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLightProperties = {"_p_gkLightProperties", "gkLightProperties *", 0, 0, (void*)&_wrap_class_gkLightProperties, 0};
static swig_type_info _swigt__p_gkLogicManager = {"_p_gkLogicManager", "gkLogicManager *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLogicNode = {"_p_gkLogicNode", "gkLogicNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLogicTree = {"_p_gkLogicTree", "gkLogicTree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLuaCurState = {"_p_gkLuaCurState", "gsSelf *|gsFunction *|gkLuaCurState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLuaEvent = {"_p_gkLuaEvent", "gkLuaEvent *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkLuaNodeAbstract = {"_p_gkLuaNodeAbstract", "gkLuaNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMaterialProperties = {"_p_gkMaterialProperties", "gkMaterialProperties *", 0, 0, (void*)&_wrap_class_gkMaterialProperties, 0};
static swig_type_info _swigt__p_gkMathNodeAbstract = {"_p_gkMathNodeAbstract", "gkMathNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMesh = {"_p_gkMesh", "gkMesh *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMessageGetAbstract = {"_p_gkMessageGetAbstract", "gkMessageGetAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMessageManager__Message = {"_p_gkMessageManager__Message", "gkMessageManager::Message *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMessageSendAbstract = {"_p_gkMessageSendAbstract", "gkMessageSendAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMotionNodeAbstract = {"_p_gkMotionNodeAbstract", "gkMotionNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMouseButtonAbstract = {"_p_gkMouseButtonAbstract", "gkMouseButtonAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkMouseNodeAbstract = {"_p_gkMouseNodeAbstract", "gkMouseNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkNavPath = {"_p_gkNavPath", "gkNavPath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkNoOpAbstract = {"_p_gkNoOpAbstract", "gkNoOpAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkNodeTreeNodeAbstract = {"_p_gkNodeTreeNodeAbstract", "gkNodeTreeNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkObjectDataAbstract = {"_p_gkObjectDataAbstract", "gkObjectDataAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkObjectManipulatorAbstract = {"_p_gkObjectManipulatorAbstract", "gkObjectManipulatorAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkObjectNodeAbstract = {"_p_gkObjectNodeAbstract", "gkObjectNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSMaterialAbstract = {"_p_gkPBSMaterialAbstract", "gkPBSMaterialAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSSlotAbstract = {"_p_gkPBSSlotAbstract", "gkPBSSlotAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSTex_AlbedoAbstract = {"_p_gkPBSTex_AlbedoAbstract", "gkPBSTex_AlbedoAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSTex_EnvAbstract = {"_p_gkPBSTex_EnvAbstract", "gkPBSTex_EnvAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSTex_F0Abstract = {"_p_gkPBSTex_F0Abstract", "gkPBSTex_F0Abstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPBSTex_NormalAbstract = {"_p_gkPBSTex_NormalAbstract", "gkPBSTex_NormalAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkParticleSettingsProperties = {"_p_gkParticleSettingsProperties", "gkParticleSettingsProperties *", 0, 0, (void*)&_wrap_class_gkParticleSettingsProperties, 0};
static swig_type_info _swigt__p_gkParticleSystemProperties = {"_p_gkParticleSystemProperties", "gkParticleSystemProperties *", 0, 0, (void*)&_wrap_class_gkParticleSystemProperties, 0};
static swig_type_info _swigt__p_gkPhysicsConstraintProperties = {"_p_gkPhysicsConstraintProperties", "gkPhysicsConstraintProperties *", 0, 0, (void*)&_wrap_class_gkPhysicsConstraintProperties, 0};
static swig_type_info _swigt__p_gkPhysicsProperties = {"_p_gkPhysicsProperties", "gkPhysicsProperties *", 0, 0, (void*)&_wrap_class_gkPhysicsProperties, 0};
static swig_type_info _swigt__p_gkPickRayNodeAbstract = {"_p_gkPickRayNodeAbstract", "gkPickRayNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPrintNodeAbstract = {"_p_gkPrintNodeAbstract", "gkPrintNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkProcessManager = {"_p_gkProcessManager", "gkProcessManager *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPropertyAbstract = {"_p_gkPropertyAbstract", "gkPropertyAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkPropertyGetAbstract = {"_p_gkPropertyGetAbstract", "gkPropertyGetAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkQuaternion = {"_p_gkQuaternion", "gkQuaternion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkRecastDebugger = {"_p_gkRecastDebugger", "gkRecastDebugger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkScanCode = {"_p_gkScanCode", "gkScanCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkScene = {"_p_gkScene", "gkScene *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSceneMaterial = {"_p_gkSceneMaterial", "gkSceneMaterial *", 0, 0, (void*)&_wrap_class_gkSceneMaterial, 0};
static swig_type_info _swigt__p_gkSceneProperties = {"_p_gkSceneProperties", "gkSceneProperties *", 0, 0, (void*)&_wrap_class_gkSceneProperties, 0};
static swig_type_info _swigt__p_gkSceneRayObstacle = {"_p_gkSceneRayObstacle", "gkSceneRayObstacle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSceneSweptObstacle = {"_p_gkSceneSweptObstacle", "gkSceneSweptObstacle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkScreenActionAbstract = {"_p_gkScreenActionAbstract", "gkScreenActionAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSeqFinishedAbstract = {"_p_gkSeqFinishedAbstract", "gkSeqFinishedAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSeqTimeAbstract = {"_p_gkSeqTimeAbstract", "gkSeqTimeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSequenceAbstract = {"_p_gkSequenceAbstract", "gkSequenceAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSoundNodeAbstract = {"_p_gkSoundNodeAbstract", "gkSoundNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSoundProperties = {"_p_gkSoundProperties", "gkSoundProperties *", 0, 0, (void*)&_wrap_class_gkSoundProperties, 0};
static swig_type_info _swigt__p_gkSoundSceneProperties = {"_p_gkSoundSceneProperties", "gkSoundSceneProperties *", 0, 0, (void*)&_wrap_class_gkSoundSceneProperties, 0};
static swig_type_info _swigt__p_gkSource = {"_p_gkSource", "gkSource *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateAbstract = {"_p_gkStateAbstract", "gkStateAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateMachineAbstract = {"_p_gkStateMachineAbstract", "gkStateMachineAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateMachineRefAbstract = {"_p_gkStateMachineRefAbstract", "gkStateMachineRefAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateManipulatorAbstract = {"_p_gkStateManipulatorAbstract", "gkStateManipulatorAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateRefAbstract = {"_p_gkStateRefAbstract", "gkStateRefAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkStateTransitionAbstract = {"_p_gkStateTransitionAbstract", "gkStateTransitionAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkSubMesh = {"_p_gkSubMesh", "gkSubMesh *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTemplaterNodeAbstract = {"_p_gkTemplaterNodeAbstract", "gkTemplaterNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTestNodeAbstract = {"_p_gkTestNodeAbstract", "gkTestNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTextureProperties = {"_p_gkTextureProperties", "gkTextureProperties *", 0, 0, (void*)&_wrap_class_gkTextureProperties, 0};
static swig_type_info _swigt__p_gkTimerNodeAbstract = {"_p_gkTimerNodeAbstract", "gkTimerNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTransformState = {"_p_gkTransformState", "gkTransformState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTriangle = {"_p_gkTriangle", "gkTriangle *", 0, 0, (void*)&_wrap_class_gkTriangle, 0};
static swig_type_info _swigt__p_gkTypeBoolAbstract = {"_p_gkTypeBoolAbstract", "gkTypeBoolAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTypeColorAbstract = {"_p_gkTypeColorAbstract", "gkTypeColorAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTypeFloatAbstract = {"_p_gkTypeFloatAbstract", "gkTypeFloatAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkTypeIntAbstract = {"_p_gkTypeIntAbstract", "gkTypeIntAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVariable = {"_p_gkVariable", "gkVariable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVector2 = {"_p_gkVector2", "gkVector2 *", 0, 0, (void*)&_wrap_class_gkVector2, 0};
static swig_type_info _swigt__p_gkVector3 = {"_p_gkVector3", "gkVector3 *", 0, 0, (void*)&_wrap_class_gkVector3, 0};
static swig_type_info _swigt__p_gkVectorDecompAbstract = {"_p_gkVectorDecompAbstract", "gkVectorDecompAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVehicle = {"_p_gkVehicle", "gkVehicle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVehicleGearAbstract = {"_p_gkVehicleGearAbstract", "gkVehicleGearAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVehicleGearboxAbstract = {"_p_gkVehicleGearboxAbstract", "gkVehicleGearboxAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVehicleNodeAbstract = {"_p_gkVehicleNodeAbstract", "gkVehicleNodeAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVehicleWheelAbstract = {"_p_gkVehicleWheelAbstract", "gkVehicleWheelAbstract *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gkVertex = {"_p_gkVertex", "gkVertex *", 0, 0, (void*)&_wrap_class_gkVertex, 0};
static swig_type_info _swigt__p_gsAccelerometerAbstract = {"_p_gsAccelerometerAbstract", "gsAccelerometerAbstract *", 0, 0, (void*)&_wrap_class_gsAccelerometerAbstract, 0};
static swig_type_info _swigt__p_gsActionActuator = {"_p_gsActionActuator", "gsActionActuator *", 0, 0, (void*)&_wrap_class_ActionActuator, 0};
static swig_type_info _swigt__p_gsActuator = {"_p_gsActuator", "gsActuator *", 0, 0, (void*)&_wrap_class_Actuator, 0};
static swig_type_info _swigt__p_gsActuatorSensor = {"_p_gsActuatorSensor", "gsActuatorSensor *", 0, 0, (void*)&_wrap_class_ActuatorSensor, 0};
static swig_type_info _swigt__p_gsAdditionNodeAbstract = {"_p_gsAdditionNodeAbstract", "gsAdditionNodeAbstract *", 0, 0, (void*)&_wrap_class_gsAdditionNodeAbstract, 0};
static swig_type_info _swigt__p_gsAlwaysSensor = {"_p_gsAlwaysSensor", "gsAlwaysSensor *", 0, 0, (void*)&_wrap_class_AlwaysSensor, 0};
static swig_type_info _swigt__p_gsAnimationDefinitionAbstract = {"_p_gsAnimationDefinitionAbstract", "gsAnimationDefinitionAbstract *", 0, 0, (void*)&_wrap_class_gsAnimationDefinitionAbstract, 0};
static swig_type_info _swigt__p_gsAnimationPlayer = {"_p_gsAnimationPlayer", "gsAnimationPlayer *", 0, 0, (void*)&_wrap_class_gsAnimationPlayer, 0};
static swig_type_info _swigt__p_gsAnimationPlayerAbstract = {"_p_gsAnimationPlayerAbstract", "gsAnimationPlayerAbstract *", 0, 0, (void*)&_wrap_class_gsAnimationPlayerAbstract, 0};
static swig_type_info _swigt__p_gsAnimationTriggerAbstract = {"_p_gsAnimationTriggerAbstract", "gsAnimationTriggerAbstract *", 0, 0, (void*)&_wrap_class_gsAnimationTriggerAbstract, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkGameObject_t = {"_p_gsArrayIteratorT_gkGameObject_t", "gsArrayIterator< gkGameObject > *", 0, 0, (void*)&_wrap_class_ObjectIterator, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkLogicActuator_t = {"_p_gsArrayIteratorT_gkLogicActuator_t", "gsArrayIterator< gkLogicActuator > *", 0, 0, (void*)&_wrap_class_ActuatorIterator, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkLogicController_t = {"_p_gsArrayIteratorT_gkLogicController_t", "gsArrayIterator< gkLogicController > *", 0, 0, (void*)&_wrap_class_ControllerIterator, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkLogicLink_t = {"_p_gsArrayIteratorT_gkLogicLink_t", "gsArrayIterator< gkLogicLink > *", 0, 0, (void*)&_wrap_class_LogicIterator, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkLogicSensor_t = {"_p_gsArrayIteratorT_gkLogicSensor_t", "gsArrayIterator< gkLogicSensor > *", 0, 0, (void*)&_wrap_class_SensorIterator, 0};
static swig_type_info _swigt__p_gsArrayIteratorT_gkProcess_t = {"_p_gsArrayIteratorT_gkProcess_t", "gsArrayIterator< gkProcess > *", 0, 0, (void*)&_wrap_class_ProcessIterator, 0};
static swig_type_info _swigt__p_gsArrayT_gsActuator_gkLogicActuator_t = {"_p_gsArrayT_gsActuator_gkLogicActuator_t", "gsArray< gsActuator,gkLogicActuator > *", 0, 0, (void*)&_wrap_class_Actuators, 0};
static swig_type_info _swigt__p_gsArrayT_gsController_gkLogicController_t = {"_p_gsArrayT_gsController_gkLogicController_t", "gsArray< gsController,gkLogicController > *", 0, 0, (void*)&_wrap_class_Controllers, 0};
static swig_type_info _swigt__p_gsArrayT_gsGameObject_gkGameObject_t = {"_p_gsArrayT_gsGameObject_gkGameObject_t", "gsArray< gsGameObject,gkGameObject > *", 0, 0, (void*)&_wrap_class_ObjectList, 0};
static swig_type_info _swigt__p_gsArrayT_gsLogicObject_gkLogicLink_t = {"_p_gsArrayT_gsLogicObject_gkLogicLink_t", "gsArray< gsLogicObject,gkLogicLink > *", 0, 0, (void*)&_wrap_class_LogicList, 0};
static swig_type_info _swigt__p_gsArrayT_gsProcess_gkProcess_t = {"_p_gsArrayT_gsProcess_gkProcess_t", "gsArray< gsProcess,gkProcess > *", 0, 0, (void*)&_wrap_class_ProcessList, 0};
static swig_type_info _swigt__p_gsArrayT_gsSensor_gkLogicSensor_t = {"_p_gsArrayT_gsSensor_gkLogicSensor_t", "gsArray< gsSensor,gkLogicSensor > *", 0, 0, (void*)&_wrap_class_Sensors, 0};
static swig_type_info _swigt__p_gsBoolNodeAbstract = {"_p_gsBoolNodeAbstract", "gsBoolNodeAbstract *", 0, 0, (void*)&_wrap_class_gsBoolNodeAbstract, 0};
static swig_type_info _swigt__p_gsBrick = {"_p_gsBrick", "gsBrick *", 0, 0, (void*)&_wrap_class_Brick, 0};
static swig_type_info _swigt__p_gsCamera = {"_p_gsCamera", "gsCamera *", 0, 0, (void*)&_wrap_class_Camera, 0};
static swig_type_info _swigt__p_gsCameraNodeAbstract = {"_p_gsCameraNodeAbstract", "gsCameraNodeAbstract *", 0, 0, (void*)&_wrap_class_gsCameraNodeAbstract, 0};
static swig_type_info _swigt__p_gsCharacter = {"_p_gsCharacter", "gsCharacter *", 0, 0, (void*)&_wrap_class_Character, 0};
static swig_type_info _swigt__p_gsCharacterNodeAbstract = {"_p_gsCharacterNodeAbstract", "gsCharacterNodeAbstract *", 0, 0, (void*)&_wrap_class_gsCharacterNodeAbstract, 0};
static swig_type_info _swigt__p_gsCollisionNodeAbstract = {"_p_gsCollisionNodeAbstract", "gsCollisionNodeAbstract *", 0, 0, (void*)&_wrap_class_gsCollisionNodeAbstract, 0};
static swig_type_info _swigt__p_gsCollisionSensor = {"_p_gsCollisionSensor", "gsCollisionSensor *", 0, 0, (void*)&_wrap_class_CollisionSensor, 0};
static swig_type_info _swigt__p_gsContactInfo = {"_p_gsContactInfo", "gsContactInfo *", 0, 0, (void*)&_wrap_class_gsContactInfo, 0};
static swig_type_info _swigt__p_gsController = {"_p_gsController", "gsController *", 0, 0, (void*)&_wrap_class_Controller, 0};
static swig_type_info _swigt__p_gsCurve = {"_p_gsCurve", "gsCurve *", 0, 0, (void*)&_wrap_class_Curve, 0};
static swig_type_info _swigt__p_gsDebugger = {"_p_gsDebugger", "gsDebugger *", 0, 0, (void*)&_wrap_class_Debugger, 0};
static swig_type_info _swigt__p_gsDelaySensor = {"_p_gsDelaySensor", "gsDelaySensor *", 0, 0, (void*)&_wrap_class_DelaySensor, 0};
static swig_type_info _swigt__p_gsDeltaNodeAbstract = {"_p_gsDeltaNodeAbstract", "gsDeltaNodeAbstract *", 0, 0, (void*)&_wrap_class_gsDeltaNodeAbstract, 0};
static swig_type_info _swigt__p_gsDynamicsWorld = {"_p_gsDynamicsWorld", "gsDynamicsWorld *", 0, 0, (void*)&_wrap_class_DynamicsWorld, 0};
static swig_type_info _swigt__p_gsEditObjectActuator = {"_p_gsEditObjectActuator", "gsEditObjectActuator *", 0, 0, (void*)&_wrap_class_EditObjectActuator, 0};
static swig_type_info _swigt__p_gsElementAbstract = {"_p_gsElementAbstract", "gsElementAbstract *", 0, 0, (void*)&_wrap_class_gsElementAbstract, 0};
static swig_type_info _swigt__p_gsEngine = {"_p_gsEngine", "gsEngine *", 0, 0, (void*)&_wrap_class_Engine, 0};
static swig_type_info _swigt__p_gsEngineNodeAbstract = {"_p_gsEngineNodeAbstract", "gsEngineNodeAbstract *", 0, 0, (void*)&_wrap_class_gsEngineNodeAbstract, 0};
static swig_type_info _swigt__p_gsEntity = {"_p_gsEntity", "gsEntity *", 0, 0, (void*)&_wrap_class_Entity, 0};
static swig_type_info _swigt__p_gsExpressionController = {"_p_gsExpressionController", "gsExpressionController *", 0, 0, (void*)&_wrap_class_ExpressionController, 0};
static swig_type_info _swigt__p_gsFSM = {"_p_gsFSM", "gsFSM *", 0, 0, (void*)&_wrap_class_FSM, 0};
static swig_type_info _swigt__p_gsFileNodeAbstract = {"_p_gsFileNodeAbstract", "gsFileNodeAbstract *", 0, 0, (void*)&_wrap_class_gsFileNodeAbstract, 0};
static swig_type_info _swigt__p_gsGUI = {"_p_gsGUI", "gsGUI *", 0, 0, (void*)&_wrap_class_gsGUI, 0};
static swig_type_info _swigt__p_gsGUI3D = {"_p_gsGUI3D", "gsGUI3D *", 0, 0, (void*)&_wrap_class_gsGUI3D, 0};
static swig_type_info _swigt__p_gsGUI3DButton = {"_p_gsGUI3DButton", "gsGUI3DButton *", 0, 0, (void*)&_wrap_class_gsGUI3DButton, 0};
static swig_type_info _swigt__p_gsGUI3DCaption = {"_p_gsGUI3DCaption", "gsGUI3DCaption *", 0, 0, (void*)&_wrap_class_gsGUI3DCaption, 0};
static swig_type_info _swigt__p_gsGUI3DCheckbox = {"_p_gsGUI3DCheckbox", "gsGUI3DCheckbox *", 0, 0, (void*)&_wrap_class_gsGUI3DCheckbox, 0};
static swig_type_info _swigt__p_gsGUI3DCombobox = {"_p_gsGUI3DCombobox", "gsGUI3DCombobox *", 0, 0, (void*)&_wrap_class_gsGUI3DCombobox, 0};
static swig_type_info _swigt__p_gsGUI3DElement = {"_p_gsGUI3DElement", "gsGUI3DElement *", 0, 0, (void*)&_wrap_class_gsGUI3DElement, 0};
static swig_type_info _swigt__p_gsGUI3DListbox = {"_p_gsGUI3DListbox", "gsGUI3DListbox *", 0, 0, (void*)&_wrap_class_gsGUI3DListbox, 0};
static swig_type_info _swigt__p_gsGUI3DProgressbar = {"_p_gsGUI3DProgressbar", "gsGUI3DProgressbar *", 0, 0, (void*)&_wrap_class_gsGUI3DProgressbar, 0};
static swig_type_info _swigt__p_gsGUI3DRectangle = {"_p_gsGUI3DRectangle", "gsGUI3DRectangle *", 0, 0, (void*)&_wrap_class_gsGUI3DRectangle, 0};
static swig_type_info _swigt__p_gsGUI3DScriptCallback = {"_p_gsGUI3DScriptCallback", "gsGUI3DScriptCallback *", 0, 0, (void*)&_wrap_class_gsGUI3DScriptCallback, 0};
static swig_type_info _swigt__p_gsGUI3DScrollbar = {"_p_gsGUI3DScrollbar", "gsGUI3DScrollbar *", 0, 0, (void*)&_wrap_class_gsGUI3DScrollbar, 0};
static swig_type_info _swigt__p_gsGUI3DTextField = {"_p_gsGUI3DTextField", "gsGUI3DTextField *", 0, 0, (void*)&_wrap_class_gsGUI3DTextField, 0};
static swig_type_info _swigt__p_gsGameActuator = {"_p_gsGameActuator", "gsGameActuator *", 0, 0, (void*)&_wrap_class_GameActuator, 0};
static swig_type_info _swigt__p_gsGameObject = {"_p_gsGameObject", "gsGameObject *", 0, 0, (void*)&_wrap_class_GameObject, 0};
static swig_type_info _swigt__p_gsGameObjectInstance = {"_p_gsGameObjectInstance", "gsGameObjectInstance *", 0, 0, (void*)&_wrap_class_gsGameObjectInstance, 0};
static swig_type_info _swigt__p_gsGorilla = {"_p_gsGorilla", "gsGorilla *", 0, 0, (void*)&_wrap_class_gsGorilla, 0};
static swig_type_info _swigt__p_gsGorillaLineList = {"_p_gsGorillaLineList", "gsGorillaLineList *", 0, 0, (void*)&_wrap_class_gsGorillaLineList, 0};
static swig_type_info _swigt__p_gsGorillaRectangle = {"_p_gsGorillaRectangle", "gsGorillaRectangle *", 0, 0, (void*)&_wrap_class_gsGorillaRectangle, 0};
static swig_type_info _swigt__p_gsGorillaScreen = {"_p_gsGorillaScreen", "gsGorillaScreen *", 0, 0, (void*)&_wrap_class_gsGorillaScreen, 0};
static swig_type_info _swigt__p_gsGorillaScreen3D = {"_p_gsGorillaScreen3D", "gsGorillaScreen3D *", 0, 0, (void*)&_wrap_class_gsGorillaScreen3D, 0};
static swig_type_info _swigt__p_gsGorillaScreenFunctions = {"_p_gsGorillaScreenFunctions", "gsGorillaScreenFunctions *", 0, 0, (void*)&_wrap_class_gsGorillaScreenFunctions, 0};
static swig_type_info _swigt__p_gsGorillaText = {"_p_gsGorillaText", "gsGorillaText *", 0, 0, (void*)&_wrap_class_gsGorillaText, 0};
static swig_type_info _swigt__p_gsGuiDataFormatter = {"_p_gsGuiDataFormatter", "gsGuiDataFormatter *", 0, 0, (void*)&_wrap_class_gsGuiDataFormatter, 0};
static swig_type_info _swigt__p_gsGuiDataSource = {"_p_gsGuiDataSource", "gsGuiDataSource *", 0, 0, (void*)&_wrap_class_gsGuiDataSource, 0};
static swig_type_info _swigt__p_gsGuiDocumentRocket = {"_p_gsGuiDocumentRocket", "gsGuiDocumentRocket *", 0, 0, (void*)&_wrap_class_gsGuiDocumentRocket, 0};
static swig_type_info _swigt__p_gsGuiElement = {"_p_gsGuiElement", "gsGuiElement *", 0, 0, (void*)&_wrap_class_gsGuiElement, 0};
static swig_type_info _swigt__p_gsGuiElementEventListener = {"_p_gsGuiElementEventListener", "gsGuiElementEventListener *", 0, 0, (void*)&_wrap_class_gsGuiElementEventListener, 0};
static swig_type_info _swigt__p_gsGuiElementQuery = {"_p_gsGuiElementQuery", "gsGuiElementQuery *", 0, 0, (void*)&_wrap_class_gsGuiElementQuery, 0};
static swig_type_info _swigt__p_gsHUD = {"_p_gsHUD", "gsHUD *", 0, 0, (void*)&_wrap_class_HUD, 0};
static swig_type_info _swigt__p_gsHUDElement = {"_p_gsHUDElement", "gsHUDElement *", 0, 0, (void*)&_wrap_class_HUDElement, 0};
static swig_type_info _swigt__p_gsILogicSocket = {"_p_gsILogicSocket", "gsILogicSocket *", 0, 0, (void*)&_wrap_class_gsILogicSocket, 0};
static swig_type_info _swigt__p_gsIfNodeAbstract = {"_p_gsIfNodeAbstract", "gsIfNodeAbstract *", 0, 0, (void*)&_wrap_class_gsIfNodeAbstract, 0};
static swig_type_info _swigt__p_gsJoystick = {"_p_gsJoystick", "gsJoystick *", 0, 0, (void*)&_wrap_class_Joystick, 0};
static swig_type_info _swigt__p_gsJoystickButtonAbstract = {"_p_gsJoystickButtonAbstract", "gsJoystickButtonAbstract *", 0, 0, (void*)&_wrap_class_gsJoystickButtonAbstract, 0};
static swig_type_info _swigt__p_gsJoystickNodeAbstract = {"_p_gsJoystickNodeAbstract", "gsJoystickNodeAbstract *", 0, 0, (void*)&_wrap_class_gsJoystickNodeAbstract, 0};
static swig_type_info _swigt__p_gsKeyNodeAbstract = {"_p_gsKeyNodeAbstract", "gsKeyNodeAbstract *", 0, 0, (void*)&_wrap_class_gsKeyNodeAbstract, 0};
static swig_type_info _swigt__p_gsKeyboard = {"_p_gsKeyboard", "gsKeyboard *", 0, 0, (void*)&_wrap_class_Keyboard, 0};
static swig_type_info _swigt__p_gsKeyboardSensor = {"_p_gsKeyboardSensor", "gsKeyboardSensor *", 0, 0, (void*)&_wrap_class_KeyboardSensor, 0};
static swig_type_info _swigt__p_gsLight = {"_p_gsLight", "gsLight *", 0, 0, (void*)&_wrap_class_Light, 0};
static swig_type_info _swigt__p_gsLogicManager = {"_p_gsLogicManager", "gsLogicManager *", 0, 0, (void*)&_wrap_class_LogicManager, 0};
static swig_type_info _swigt__p_gsLogicNode = {"_p_gsLogicNode", "gsLogicNode *", 0, 0, (void*)&_wrap_class_gsLogicNode, 0};
static swig_type_info _swigt__p_gsLogicObject = {"_p_gsLogicObject", "gsLogicObject *", 0, 0, (void*)&_wrap_class_LogicObject, 0};
static swig_type_info _swigt__p_gsLogicOpController = {"_p_gsLogicOpController", "gsLogicOpController *", 0, 0, (void*)&_wrap_class_LogicOpController, 0};
static swig_type_info _swigt__p_gsLogicTree = {"_p_gsLogicTree", "gsLogicTree *", 0, 0, (void*)&_wrap_class_gsLogicTree, 0};
static swig_type_info _swigt__p_gsLuaManager = {"_p_gsLuaManager", "gsLuaManager *", 0, 0, (void*)&_wrap_class_LuaManager, 0};
static swig_type_info _swigt__p_gsLuaNodeAbstract = {"_p_gsLuaNodeAbstract", "gsLuaNodeAbstract *", 0, 0, (void*)&_wrap_class_gsLuaNodeAbstract, 0};
static swig_type_info _swigt__p_gsLuaScript = {"_p_gsLuaScript", "gsLuaScript *", 0, 0, (void*)&_wrap_class_LuaScript, 0};
static swig_type_info _swigt__p_gsLuaStream = {"_p_gsLuaStream", "gsLuaStream *", 0, 0, (void*)&_wrap_class_gsLuaStream, 0};
static swig_type_info _swigt__p_gsMathNodeAbstract = {"_p_gsMathNodeAbstract", "gsMathNodeAbstract *", 0, 0, (void*)&_wrap_class_gsMathNodeAbstract, 0};
static swig_type_info _swigt__p_gsMatrix4 = {"_p_gsMatrix4", "gsMatrix4 *", 0, 0, (void*)&_wrap_class_Matrix4, 0};
static swig_type_info _swigt__p_gsMesh = {"_p_gsMesh", "gsMesh *", 0, 0, (void*)&_wrap_class_gsMesh, 0};
static swig_type_info _swigt__p_gsMessageActuator = {"_p_gsMessageActuator", "gsMessageActuator *", 0, 0, (void*)&_wrap_class_MessageActuator, 0};
static swig_type_info _swigt__p_gsMessageGetAbstract = {"_p_gsMessageGetAbstract", "gsMessageGetAbstract *", 0, 0, (void*)&_wrap_class_gsMessageGetAbstract, 0};
static swig_type_info _swigt__p_gsMessageListenerCallback = {"_p_gsMessageListenerCallback", "gsMessageListenerCallback *", 0, 0, (void*)&_wrap_class_gsMessageListenerCallback, 0};
static swig_type_info _swigt__p_gsMessageManager = {"_p_gsMessageManager", "gsMessageManager *", 0, 0, (void*)&_wrap_class_MessageManager, 0};
static swig_type_info _swigt__p_gsMessageSendAbstract = {"_p_gsMessageSendAbstract", "gsMessageSendAbstract *", 0, 0, (void*)&_wrap_class_gsMessageSendAbstract, 0};
static swig_type_info _swigt__p_gsMessageSensor = {"_p_gsMessageSensor", "gsMessageSensor *", 0, 0, (void*)&_wrap_class_MessageSensor, 0};
static swig_type_info _swigt__p_gsMotionActuator = {"_p_gsMotionActuator", "gsMotionActuator *", 0, 0, (void*)&_wrap_class_MotionActuator, 0};
static swig_type_info _swigt__p_gsMotionNodeAbstract = {"_p_gsMotionNodeAbstract", "gsMotionNodeAbstract *", 0, 0, (void*)&_wrap_class_gsMotionNodeAbstract, 0};
static swig_type_info _swigt__p_gsMouse = {"_p_gsMouse", "gsMouse *", 0, 0, (void*)&_wrap_class_Mouse, 0};
static swig_type_info _swigt__p_gsMouseButtonAbstract = {"_p_gsMouseButtonAbstract", "gsMouseButtonAbstract *", 0, 0, (void*)&_wrap_class_gsMouseButtonAbstract, 0};
static swig_type_info _swigt__p_gsMouseNodeAbstract = {"_p_gsMouseNodeAbstract", "gsMouseNodeAbstract *", 0, 0, (void*)&_wrap_class_gsMouseNodeAbstract, 0};
static swig_type_info _swigt__p_gsMouseSensor = {"_p_gsMouseSensor", "gsMouseSensor *", 0, 0, (void*)&_wrap_class_MouseSensor, 0};
static swig_type_info _swigt__p_gsMultiTouchState = {"_p_gsMultiTouchState", "gsMultiTouchState *", 0, 0, (void*)&_wrap_class_gsMultiTouchState, 0};
static swig_type_info _swigt__p_gsNavPath = {"_p_gsNavPath", "gsNavPath *", 0, 0, (void*)&_wrap_class_NavPath, 0};
static swig_type_info _swigt__p_gsNearSensor = {"_p_gsNearSensor", "gsNearSensor *", 0, 0, (void*)&_wrap_class_NearSensor, 0};
static swig_type_info _swigt__p_gsNetwork = {"_p_gsNetwork", "gsNetwork *", 0, 0, (void*)&_wrap_class_gsNetwork, 0};
static swig_type_info _swigt__p_gsNoOpAbstract = {"_p_gsNoOpAbstract", "gsNoOpAbstract *", 0, 0, (void*)&_wrap_class_gsNoOpAbstract, 0};
static swig_type_info _swigt__p_gsNodeTreeNodeAbstract = {"_p_gsNodeTreeNodeAbstract", "gsNodeTreeNodeAbstract *", 0, 0, (void*)&_wrap_class_gsNodeTreeNodeAbstract, 0};
static swig_type_info _swigt__p_gsObject = {"_p_gsObject", "gsObject *", 0, 0, (void*)&_wrap_class_Object, 0};
static swig_type_info _swigt__p_gsObjectDataAbstract = {"_p_gsObjectDataAbstract", "gsObjectDataAbstract *", 0, 0, (void*)&_wrap_class_gsObjectDataAbstract, 0};
static swig_type_info _swigt__p_gsObjectManipulatorAbstract = {"_p_gsObjectManipulatorAbstract", "gsObjectManipulatorAbstract *", 0, 0, (void*)&_wrap_class_gsObjectManipulatorAbstract, 0};
static swig_type_info _swigt__p_gsObjectNodeAbstract = {"_p_gsObjectNodeAbstract", "gsObjectNodeAbstract *", 0, 0, (void*)&_wrap_class_gsObjectNodeAbstract, 0};
static swig_type_info _swigt__p_gsPBSMaterialAbstract = {"_p_gsPBSMaterialAbstract", "gsPBSMaterialAbstract *", 0, 0, (void*)&_wrap_class_gsPBSMaterialAbstract, 0};
static swig_type_info _swigt__p_gsPBSSlotAbstract = {"_p_gsPBSSlotAbstract", "gsPBSSlotAbstract *", 0, 0, (void*)&_wrap_class_gsPBSSlotAbstract, 0};
static swig_type_info _swigt__p_gsPBSTex_AlbedoAbstract = {"_p_gsPBSTex_AlbedoAbstract", "gsPBSTex_AlbedoAbstract *", 0, 0, (void*)&_wrap_class_gsPBSTex_AlbedoAbstract, 0};
static swig_type_info _swigt__p_gsPBSTex_EnvAbstract = {"_p_gsPBSTex_EnvAbstract", "gsPBSTex_EnvAbstract *", 0, 0, (void*)&_wrap_class_gsPBSTex_EnvAbstract, 0};
static swig_type_info _swigt__p_gsPBSTex_F0Abstract = {"_p_gsPBSTex_F0Abstract", "gsPBSTex_F0Abstract *", 0, 0, (void*)&_wrap_class_gsPBSTex_F0Abstract, 0};
static swig_type_info _swigt__p_gsPBSTex_NormalAbstract = {"_p_gsPBSTex_NormalAbstract", "gsPBSTex_NormalAbstract *", 0, 0, (void*)&_wrap_class_gsPBSTex_NormalAbstract, 0};
static swig_type_info _swigt__p_gsParentActuator = {"_p_gsParentActuator", "gsParentActuator *", 0, 0, (void*)&_wrap_class_ParentActuator, 0};
static swig_type_info _swigt__p_gsParticles = {"_p_gsParticles", "gsParticles *", 0, 0, (void*)&_wrap_class_Particles, 0};
static swig_type_info _swigt__p_gsPickRayNodeAbstract = {"_p_gsPickRayNodeAbstract", "gsPickRayNodeAbstract *", 0, 0, (void*)&_wrap_class_gsPickRayNodeAbstract, 0};
static swig_type_info _swigt__p_gsPrintNodeAbstract = {"_p_gsPrintNodeAbstract", "gsPrintNodeAbstract *", 0, 0, (void*)&_wrap_class_gsPrintNodeAbstract, 0};
static swig_type_info _swigt__p_gsProcedural = {"_p_gsProcedural", "gsProcedural *", 0, 0, (void*)&_wrap_class_gsProcedural, 0};
static swig_type_info _swigt__p_gsProcess = {"_p_gsProcess", "gsProcess *", 0, 0, (void*)&_wrap_class_Process, 0};
static swig_type_info _swigt__p_gsProcessManager = {"_p_gsProcessManager", "gsProcessManager *", 0, 0, (void*)&_wrap_class_ProcessManager, 0};
static swig_type_info _swigt__p_gsProperty = {"_p_gsProperty", "gsProperty *", 0, 0, (void*)&_wrap_class_Property, 0};
static swig_type_info _swigt__p_gsPropertyAbstract = {"_p_gsPropertyAbstract", "gsPropertyAbstract *", 0, 0, (void*)&_wrap_class_gsPropertyAbstract, 0};
static swig_type_info _swigt__p_gsPropertyActuator = {"_p_gsPropertyActuator", "gsPropertyActuator *", 0, 0, (void*)&_wrap_class_PropertyActuator, 0};
static swig_type_info _swigt__p_gsPropertyGetAbstract = {"_p_gsPropertyGetAbstract", "gsPropertyGetAbstract *", 0, 0, (void*)&_wrap_class_gsPropertyGetAbstract, 0};
static swig_type_info _swigt__p_gsPropertySensor = {"_p_gsPropertySensor", "gsPropertySensor *", 0, 0, (void*)&_wrap_class_PropertySensor, 0};
static swig_type_info _swigt__p_gsQuaternion = {"_p_gsQuaternion", "gsQuaternion *", 0, 0, (void*)&_wrap_class_Quaternion, 0};
static swig_type_info _swigt__p_gsRadarSensor = {"_p_gsRadarSensor", "gsRadarSensor *", 0, 0, (void*)&_wrap_class_RadarSensor, 0};
static swig_type_info _swigt__p_gsRandomActuator = {"_p_gsRandomActuator", "gsRandomActuator *", 0, 0, (void*)&_wrap_class_RandomActuator, 0};
static swig_type_info _swigt__p_gsRandomSensor = {"_p_gsRandomSensor", "gsRandomSensor *", 0, 0, (void*)&_wrap_class_RandomSensor, 0};
static swig_type_info _swigt__p_gsRay = {"_p_gsRay", "gsRay *", 0, 0, (void*)&_wrap_class_Ray, 0};
static swig_type_info _swigt__p_gsRaySensor = {"_p_gsRaySensor", "gsRaySensor *", 0, 0, (void*)&_wrap_class_RaySensor, 0};
static swig_type_info _swigt__p_gsRayTest = {"_p_gsRayTest", "gsRayTest *", 0, 0, (void*)&_wrap_class_RayTest, 0};
static swig_type_info _swigt__p_gsRecastDebugger = {"_p_gsRecastDebugger", "gsRecastDebugger *", 0, 0, (void*)&_wrap_class_gsRecastDebugger, 0};
static swig_type_info _swigt__p_gsRectangleDesigned = {"_p_gsRectangleDesigned", "gsRectangleDesigned *", 0, 0, (void*)&_wrap_class_gsRectangleDesigned, 0};
static swig_type_info _swigt__p_gsScene = {"_p_gsScene", "gsScene *", 0, 0, (void*)&_wrap_class_Scene, 0};
static swig_type_info _swigt__p_gsSceneActuator = {"_p_gsSceneActuator", "gsSceneActuator *", 0, 0, (void*)&_wrap_class_SceneActuator, 0};
static swig_type_info _swigt__p_gsScreenActionAbstract = {"_p_gsScreenActionAbstract", "gsScreenActionAbstract *", 0, 0, (void*)&_wrap_class_gsScreenActionAbstract, 0};
static swig_type_info _swigt__p_gsScriptController = {"_p_gsScriptController", "gsScriptController *", 0, 0, (void*)&_wrap_class_ScriptController, 0};
static swig_type_info _swigt__p_gsSensor = {"_p_gsSensor", "gsSensor *", 0, 0, (void*)&_wrap_class_Sensor, 0};
static swig_type_info _swigt__p_gsSeqFinishedAbstract = {"_p_gsSeqFinishedAbstract", "gsSeqFinishedAbstract *", 0, 0, (void*)&_wrap_class_gsSeqFinishedAbstract, 0};
static swig_type_info _swigt__p_gsSeqTimeAbstract = {"_p_gsSeqTimeAbstract", "gsSeqTimeAbstract *", 0, 0, (void*)&_wrap_class_gsSeqTimeAbstract, 0};
static swig_type_info _swigt__p_gsSequenceAbstract = {"_p_gsSequenceAbstract", "gsSequenceAbstract *", 0, 0, (void*)&_wrap_class_gsSequenceAbstract, 0};
static swig_type_info _swigt__p_gsSkeleton = {"_p_gsSkeleton", "gsSkeleton *", 0, 0, (void*)&_wrap_class_Skeleton, 0};
static swig_type_info _swigt__p_gsSoundActuator = {"_p_gsSoundActuator", "gsSoundActuator *", 0, 0, (void*)&_wrap_class_SoundActuator, 0};
static swig_type_info _swigt__p_gsSoundManager = {"_p_gsSoundManager", "gsSoundManager *", 0, 0, (void*)&_wrap_class_SoundManager, 0};
static swig_type_info _swigt__p_gsSoundNodeAbstract = {"_p_gsSoundNodeAbstract", "gsSoundNodeAbstract *", 0, 0, (void*)&_wrap_class_gsSoundNodeAbstract, 0};
static swig_type_info _swigt__p_gsSource = {"_p_gsSource", "gsSource *", 0, 0, (void*)&_wrap_class_Source, 0};
static swig_type_info _swigt__p_gsSprite = {"_p_gsSprite", "gsSprite *", 0, 0, (void*)&_wrap_class_gsSprite, 0};
static swig_type_info _swigt__p_gsStateAbstract = {"_p_gsStateAbstract", "gsStateAbstract *", 0, 0, (void*)&_wrap_class_gsStateAbstract, 0};
static swig_type_info _swigt__p_gsStateActuator = {"_p_gsStateActuator", "gsStateActuator *", 0, 0, (void*)&_wrap_class_StateActuator, 0};
static swig_type_info _swigt__p_gsStateMachineAbstract = {"_p_gsStateMachineAbstract", "gsStateMachineAbstract *", 0, 0, (void*)&_wrap_class_gsStateMachineAbstract, 0};
static swig_type_info _swigt__p_gsStateMachineRefAbstract = {"_p_gsStateMachineRefAbstract", "gsStateMachineRefAbstract *", 0, 0, (void*)&_wrap_class_gsStateMachineRefAbstract, 0};
static swig_type_info _swigt__p_gsStateManipulatorAbstract = {"_p_gsStateManipulatorAbstract", "gsStateManipulatorAbstract *", 0, 0, (void*)&_wrap_class_gsStateManipulatorAbstract, 0};
static swig_type_info _swigt__p_gsStateRefAbstract = {"_p_gsStateRefAbstract", "gsStateRefAbstract *", 0, 0, (void*)&_wrap_class_gsStateRefAbstract, 0};
static swig_type_info _swigt__p_gsStateTransitionAbstract = {"_p_gsStateTransitionAbstract", "gsStateTransitionAbstract *", 0, 0, (void*)&_wrap_class_gsStateTransitionAbstract, 0};
static swig_type_info _swigt__p_gsStaticBatch = {"_p_gsStaticBatch", "gsStaticBatch *", 0, 0, (void*)&_wrap_class_gsStaticBatch, 0};
static swig_type_info _swigt__p_gsSteerGroup = {"_p_gsSteerGroup", "gsSteerGroup *", 0, 0, (void*)&_wrap_class_SteerGroup, 0};
static swig_type_info _swigt__p_gsSteerObject = {"_p_gsSteerObject", "gsSteerObject *", 0, 0, (void*)&_wrap_class_SteerObject, 0};
static swig_type_info _swigt__p_gsSteerObstacleGroup = {"_p_gsSteerObstacleGroup", "gsSteerObstacleGroup *", 0, 0, (void*)&_wrap_class_SteerObstacleGroup, 0};
static swig_type_info _swigt__p_gsSteerPathFollowing = {"_p_gsSteerPathFollowing", "gsSteerPathFollowing *", 0, 0, (void*)&_wrap_class_gsSteerPathFollowing, 0};
static swig_type_info _swigt__p_gsSteerRayObstacle = {"_p_gsSteerRayObstacle", "gsSteerRayObstacle *", 0, 0, (void*)&_wrap_class_SteerRayObstacle, 0};
static swig_type_info _swigt__p_gsSteerSweptObstacle = {"_p_gsSteerSweptObstacle", "gsSteerSweptObstacle *", 0, 0, (void*)&_wrap_class_SteerSweptObstacle, 0};
static swig_type_info _swigt__p_gsSubMesh = {"_p_gsSubMesh", "gsSubMesh *", 0, 0, (void*)&_wrap_class_gsSubMesh, 0};
static swig_type_info _swigt__p_gsSweptTest = {"_p_gsSweptTest", "gsSweptTest *", 0, 0, (void*)&_wrap_class_SweptTest, 0};
static swig_type_info _swigt__p_gsTemplaterNodeAbstract = {"_p_gsTemplaterNodeAbstract", "gsTemplaterNodeAbstract *", 0, 0, (void*)&_wrap_class_gsTemplaterNodeAbstract, 0};
static swig_type_info _swigt__p_gsTestNodeAbstract = {"_p_gsTestNodeAbstract", "gsTestNodeAbstract *", 0, 0, (void*)&_wrap_class_gsTestNodeAbstract, 0};
static swig_type_info _swigt__p_gsTextureAtlas = {"_p_gsTextureAtlas", "gsTextureAtlas *", 0, 0, (void*)&_wrap_class_gsTextureAtlas, 0};
static swig_type_info _swigt__p_gsTimerNodeAbstract = {"_p_gsTimerNodeAbstract", "gsTimerNodeAbstract *", 0, 0, (void*)&_wrap_class_gsTimerNodeAbstract, 0};
static swig_type_info _swigt__p_gsTouch = {"_p_gsTouch", "gsTouch *", 0, 0, (void*)&_wrap_class_Touch, 0};
static swig_type_info _swigt__p_gsTouchSensor = {"_p_gsTouchSensor", "gsTouchSensor *", 0, 0, (void*)&_wrap_class_gsTouchSensor, 0};
static swig_type_info _swigt__p_gsTween = {"_p_gsTween", "gsTween *", 0, 0, (void*)&_wrap_class_gsTween, 0};
static swig_type_info _swigt__p_gsTypeBoolAbstract = {"_p_gsTypeBoolAbstract", "gsTypeBoolAbstract *", 0, 0, (void*)&_wrap_class_gsTypeBoolAbstract, 0};
static swig_type_info _swigt__p_gsTypeColorAbstract = {"_p_gsTypeColorAbstract", "gsTypeColorAbstract *", 0, 0, (void*)&_wrap_class_gsTypeColorAbstract, 0};
static swig_type_info _swigt__p_gsTypeFloatAbstract = {"_p_gsTypeFloatAbstract", "gsTypeFloatAbstract *", 0, 0, (void*)&_wrap_class_gsTypeFloatAbstract, 0};
static swig_type_info _swigt__p_gsTypeIntAbstract = {"_p_gsTypeIntAbstract", "gsTypeIntAbstract *", 0, 0, (void*)&_wrap_class_gsTypeIntAbstract, 0};
static swig_type_info _swigt__p_gsUserDefs = {"_p_gsUserDefs", "gsUserDefs *", 0, 0, (void*)&_wrap_class_UserDefs, 0};
static swig_type_info _swigt__p_gsVariable = {"_p_gsVariable", "gsVariable *", 0, 0, (void*)&_wrap_class_gsVariable, 0};
static swig_type_info _swigt__p_gsVector2 = {"_p_gsVector2", "gsVector2 *", 0, 0, (void*)&_wrap_class_gsVector2, 0};
static swig_type_info _swigt__p_gsVector3 = {"_p_gsVector3", "gsVector3 *", 0, 0, (void*)&_wrap_class_Vector3, 0};
static swig_type_info _swigt__p_gsVector4 = {"_p_gsVector4", "gsVector4 *", 0, 0, (void*)&_wrap_class_Vector4, 0};
static swig_type_info _swigt__p_gsVectorDecompAbstract = {"_p_gsVectorDecompAbstract", "gsVectorDecompAbstract *", 0, 0, (void*)&_wrap_class_gsVectorDecompAbstract, 0};
static swig_type_info _swigt__p_gsVehicle = {"_p_gsVehicle", "gsVehicle *", 0, 0, (void*)&_wrap_class_gsVehicle, 0};
static swig_type_info _swigt__p_gsVehicleGearAbstract = {"_p_gsVehicleGearAbstract", "gsVehicleGearAbstract *", 0, 0, (void*)&_wrap_class_gsVehicleGearAbstract, 0};
static swig_type_info _swigt__p_gsVehicleGearboxAbstract = {"_p_gsVehicleGearboxAbstract", "gsVehicleGearboxAbstract *", 0, 0, (void*)&_wrap_class_gsVehicleGearboxAbstract, 0};
static swig_type_info _swigt__p_gsVehicleNodeAbstract = {"_p_gsVehicleNodeAbstract", "gsVehicleNodeAbstract *", 0, 0, (void*)&_wrap_class_gsVehicleNodeAbstract, 0};
static swig_type_info _swigt__p_gsVehicleWheelAbstract = {"_p_gsVehicleWheelAbstract", "gsVehicleWheelAbstract *", 0, 0, (void*)&_wrap_class_gsVehicleWheelAbstract, 0};
static swig_type_info _swigt__p_gsVisibilityActuator = {"_p_gsVisibilityActuator", "gsVisibilityActuator *", 0, 0, (void*)&_wrap_class_VisibilityActuator, 0};
static swig_type_info _swigt__p_gsWhenEvent = {"_p_gsWhenEvent", "gsWhenEvent *", 0, 0, (void*)&_wrap_class_WhenEvent, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)&_wrap_class_string, 0};
static swig_type_info _swigt__p_tsPanel = {"_p_tsPanel", "tsPanel *", 0, 0, (void*)&_wrap_class_tsPanel, 0};
static swig_type_info _swigt__p_tsScriptCallbackList = {"_p_tsScriptCallbackList", "tsScriptCallbackList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkGameObject_p_t = {"_p_utArrayT_gkGameObject_p_t", "gsArray< gsGameObject,gkGameObject >::Array *|utArray< gkGameObject * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkLogicActuator_p_t = {"_p_utArrayT_gkLogicActuator_p_t", "gsArray< gsActuator,gkLogicActuator >::Array *|utArray< gkLogicActuator * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkLogicController_p_t = {"_p_utArrayT_gkLogicController_p_t", "gsArray< gsController,gkLogicController >::Array *|utArray< gkLogicController * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkLogicLink_p_t = {"_p_utArrayT_gkLogicLink_p_t", "gsArray< gsLogicObject,gkLogicLink >::Array *|utArray< gkLogicLink * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkLogicSensor_p_t = {"_p_utArrayT_gkLogicSensor_p_t", "gsArray< gsSensor,gkLogicSensor >::Array *|utArray< gkLogicSensor * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkPhysicsConstraintProperties_t = {"_p_utArrayT_gkPhysicsConstraintProperties_t", "utArray< gkPhysicsConstraintProperties > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkProcess_p_t = {"_p_utArrayT_gkProcess_p_t", "gsArray< gsProcess,gkProcess >::Array *|utArray< gkProcess * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkString_t = {"_p_utArrayT_gkString_t", "utArray< gkString > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_gkVector3_t = {"_p_utArrayT_gkVector3_t", "gkCurveProperties::CurvePoints *|utArray< gkVector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utArrayT_utArrayT_gkVector3_t_t = {"_p_utArrayT_utArrayT_gkVector3_t_t", "utArray< utArray< gkVector3 > > *|gkCurveProperties::BezTriples *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_utMemoryStream = {"_p_utMemoryStream", "utMemoryStream *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Array,
  &_swigt__p_BezTriples,
  &_swigt__p_BrickList,
  &_swigt__p_CollisionMask,
  &_swigt__p_CurvePoints,
  &_swigt__p_Gorilla__Layer,
  &_swigt__p_Gorilla__LineList,
  &_swigt__p_Gorilla__MarkupText,
  &_swigt__p_Gorilla__Rectangle,
  &_swigt__p_Gorilla__Screen,
  &_swigt__p_Gorilla__ScreenRenderable,
  &_swigt__p_Gorilla__Sprite,
  &_swigt__p_Gorilla__TextureAtlas,
  &_swigt__p_Gui3D__Button,
  &_swigt__p_Gui3D__Caption,
  &_swigt__p_Gui3D__Checkbox,
  &_swigt__p_Gui3D__Combobox,
  &_swigt__p_Gui3D__Listbox,
  &_swigt__p_Gui3D__PanelColors,
  &_swigt__p_Gui3D__PanelContainer,
  &_swigt__p_Gui3D__PanelElement,
  &_swigt__p_Gui3D__ProgressBar,
  &_swigt__p_Gui3D__Rectangle,
  &_swigt__p_Gui3D__ScrollBar,
  &_swigt__p_Gui3D__TextZone,
  &_swigt__p_Iterator,
  &_swigt__p_MyVehicle,
  &_swigt__p_OIS__MultiTouchState,
  &_swigt__p_Ogre__ColourValue,
  &_swigt__p_Ogre__Entity,
  &_swigt__p_Ogre__PbsMaterial,
  &_swigt__p_Ogre__Real,
  &_swigt__p_OpenSteer__AVGroup,
  &_swigt__p_OpenSteer__AbstractVehicle,
  &_swigt__p_OpenSteer__ObstacleGroup,
  &_swigt__p_OpenSteer__Vec3,
  &_swigt__p_Rocket__Core__Element,
  &_swigt__p_Rocket__Core__Event,
  &_swigt__p_Rocket__Core__String,
  &_swigt__p_Rocket__Core__StringList,
  &_swigt__p_UTsize,
  &_swigt__p_btManifoldPoint,
  &_swigt__p_float,
  &_swigt__p_gkAccelerometerAbstract,
  &_swigt__p_gkAdditionNodeAbstract,
  &_swigt__p_gkAnimationDefinitionAbstract,
  &_swigt__p_gkAnimationPlayer,
  &_swigt__p_gkAnimationPlayerAbstract,
  &_swigt__p_gkAnimationTriggerAbstract,
  &_swigt__p_gkBoolNodeAbstract,
  &_swigt__p_gkCameraNodeAbstract,
  &_swigt__p_gkCameraProperties,
  &_swigt__p_gkCharacter,
  &_swigt__p_gkCharacterNodeAbstract,
  &_swigt__p_gkCollisionNodeAbstract,
  &_swigt__p_gkColor,
  &_swigt__p_gkCurveProperties,
  &_swigt__p_gkDebugger,
  &_swigt__p_gkDeltaNodeAbstract,
  &_swigt__p_gkDynamicsWorld,
  &_swigt__p_gkElementAbstract,
  &_swigt__p_gkEngineNodeAbstract,
  &_swigt__p_gkEntityProperties,
  &_swigt__p_gkFileNodeAbstract,
  &_swigt__p_gkFogParams,
  &_swigt__p_gkGameObject,
  &_swigt__p_gkGameObjectInstance,
  &_swigt__p_gkGameObjectProperties,
  &_swigt__p_gkGorillaRectangle,
  &_swigt__p_gkILogicSocket,
  &_swigt__p_gkIfNodeAbstract,
  &_swigt__p_gkJoystickButtonAbstract,
  &_swigt__p_gkJoystickNodeAbstract,
  &_swigt__p_gkKeyNodeAbstract,
  &_swigt__p_gkLightProperties,
  &_swigt__p_gkLogicManager,
  &_swigt__p_gkLogicNode,
  &_swigt__p_gkLogicTree,
  &_swigt__p_gkLuaCurState,
  &_swigt__p_gkLuaEvent,
  &_swigt__p_gkLuaNodeAbstract,
  &_swigt__p_gkMaterialProperties,
  &_swigt__p_gkMathNodeAbstract,
  &_swigt__p_gkMesh,
  &_swigt__p_gkMessageGetAbstract,
  &_swigt__p_gkMessageManager__Message,
  &_swigt__p_gkMessageSendAbstract,
  &_swigt__p_gkMotionNodeAbstract,
  &_swigt__p_gkMouseButtonAbstract,
  &_swigt__p_gkMouseNodeAbstract,
  &_swigt__p_gkNavPath,
  &_swigt__p_gkNoOpAbstract,
  &_swigt__p_gkNodeTreeNodeAbstract,
  &_swigt__p_gkObjectDataAbstract,
  &_swigt__p_gkObjectManipulatorAbstract,
  &_swigt__p_gkObjectNodeAbstract,
  &_swigt__p_gkPBSMaterialAbstract,
  &_swigt__p_gkPBSSlotAbstract,
  &_swigt__p_gkPBSTex_AlbedoAbstract,
  &_swigt__p_gkPBSTex_EnvAbstract,
  &_swigt__p_gkPBSTex_F0Abstract,
  &_swigt__p_gkPBSTex_NormalAbstract,
  &_swigt__p_gkParticleSettingsProperties,
  &_swigt__p_gkParticleSystemProperties,
  &_swigt__p_gkPhysicsConstraintProperties,
  &_swigt__p_gkPhysicsProperties,
  &_swigt__p_gkPickRayNodeAbstract,
  &_swigt__p_gkPrintNodeAbstract,
  &_swigt__p_gkProcessManager,
  &_swigt__p_gkPropertyAbstract,
  &_swigt__p_gkPropertyGetAbstract,
  &_swigt__p_gkQuaternion,
  &_swigt__p_gkRecastDebugger,
  &_swigt__p_gkScanCode,
  &_swigt__p_gkScene,
  &_swigt__p_gkSceneMaterial,
  &_swigt__p_gkSceneProperties,
  &_swigt__p_gkSceneRayObstacle,
  &_swigt__p_gkSceneSweptObstacle,
  &_swigt__p_gkScreenActionAbstract,
  &_swigt__p_gkSeqFinishedAbstract,
  &_swigt__p_gkSeqTimeAbstract,
  &_swigt__p_gkSequenceAbstract,
  &_swigt__p_gkSoundNodeAbstract,
  &_swigt__p_gkSoundProperties,
  &_swigt__p_gkSoundSceneProperties,
  &_swigt__p_gkSource,
  &_swigt__p_gkStateAbstract,
  &_swigt__p_gkStateMachineAbstract,
  &_swigt__p_gkStateMachineRefAbstract,
  &_swigt__p_gkStateManipulatorAbstract,
  &_swigt__p_gkStateRefAbstract,
  &_swigt__p_gkStateTransitionAbstract,
  &_swigt__p_gkSubMesh,
  &_swigt__p_gkTemplaterNodeAbstract,
  &_swigt__p_gkTestNodeAbstract,
  &_swigt__p_gkTextureProperties,
  &_swigt__p_gkTimerNodeAbstract,
  &_swigt__p_gkTransformState,
  &_swigt__p_gkTriangle,
  &_swigt__p_gkTypeBoolAbstract,
  &_swigt__p_gkTypeColorAbstract,
  &_swigt__p_gkTypeFloatAbstract,
  &_swigt__p_gkTypeIntAbstract,
  &_swigt__p_gkVariable,
  &_swigt__p_gkVector2,
  &_swigt__p_gkVector3,
  &_swigt__p_gkVectorDecompAbstract,
  &_swigt__p_gkVehicle,
  &_swigt__p_gkVehicleGearAbstract,
  &_swigt__p_gkVehicleGearboxAbstract,
  &_swigt__p_gkVehicleNodeAbstract,
  &_swigt__p_gkVehicleWheelAbstract,
  &_swigt__p_gkVertex,
  &_swigt__p_gsAccelerometerAbstract,
  &_swigt__p_gsActionActuator,
  &_swigt__p_gsActuator,
  &_swigt__p_gsActuatorSensor,
  &_swigt__p_gsAdditionNodeAbstract,
  &_swigt__p_gsAlwaysSensor,
  &_swigt__p_gsAnimationDefinitionAbstract,
  &_swigt__p_gsAnimationPlayer,
  &_swigt__p_gsAnimationPlayerAbstract,
  &_swigt__p_gsAnimationTriggerAbstract,
  &_swigt__p_gsArrayIteratorT_gkGameObject_t,
  &_swigt__p_gsArrayIteratorT_gkLogicActuator_t,
  &_swigt__p_gsArrayIteratorT_gkLogicController_t,
  &_swigt__p_gsArrayIteratorT_gkLogicLink_t,
  &_swigt__p_gsArrayIteratorT_gkLogicSensor_t,
  &_swigt__p_gsArrayIteratorT_gkProcess_t,
  &_swigt__p_gsArrayT_gsActuator_gkLogicActuator_t,
  &_swigt__p_gsArrayT_gsController_gkLogicController_t,
  &_swigt__p_gsArrayT_gsGameObject_gkGameObject_t,
  &_swigt__p_gsArrayT_gsLogicObject_gkLogicLink_t,
  &_swigt__p_gsArrayT_gsProcess_gkProcess_t,
  &_swigt__p_gsArrayT_gsSensor_gkLogicSensor_t,
  &_swigt__p_gsBoolNodeAbstract,
  &_swigt__p_gsBrick,
  &_swigt__p_gsCamera,
  &_swigt__p_gsCameraNodeAbstract,
  &_swigt__p_gsCharacter,
  &_swigt__p_gsCharacterNodeAbstract,
  &_swigt__p_gsCollisionNodeAbstract,
  &_swigt__p_gsCollisionSensor,
  &_swigt__p_gsContactInfo,
  &_swigt__p_gsController,
  &_swigt__p_gsCurve,
  &_swigt__p_gsDebugger,
  &_swigt__p_gsDelaySensor,
  &_swigt__p_gsDeltaNodeAbstract,
  &_swigt__p_gsDynamicsWorld,
  &_swigt__p_gsEditObjectActuator,
  &_swigt__p_gsElementAbstract,
  &_swigt__p_gsEngine,
  &_swigt__p_gsEngineNodeAbstract,
  &_swigt__p_gsEntity,
  &_swigt__p_gsExpressionController,
  &_swigt__p_gsFSM,
  &_swigt__p_gsFileNodeAbstract,
  &_swigt__p_gsGUI,
  &_swigt__p_gsGUI3D,
  &_swigt__p_gsGUI3DButton,
  &_swigt__p_gsGUI3DCaption,
  &_swigt__p_gsGUI3DCheckbox,
  &_swigt__p_gsGUI3DCombobox,
  &_swigt__p_gsGUI3DElement,
  &_swigt__p_gsGUI3DListbox,
  &_swigt__p_gsGUI3DProgressbar,
  &_swigt__p_gsGUI3DRectangle,
  &_swigt__p_gsGUI3DScriptCallback,
  &_swigt__p_gsGUI3DScrollbar,
  &_swigt__p_gsGUI3DTextField,
  &_swigt__p_gsGameActuator,
  &_swigt__p_gsGameObject,
  &_swigt__p_gsGameObjectInstance,
  &_swigt__p_gsGorilla,
  &_swigt__p_gsGorillaLineList,
  &_swigt__p_gsGorillaRectangle,
  &_swigt__p_gsGorillaScreen,
  &_swigt__p_gsGorillaScreen3D,
  &_swigt__p_gsGorillaScreenFunctions,
  &_swigt__p_gsGorillaText,
  &_swigt__p_gsGuiDataFormatter,
  &_swigt__p_gsGuiDataSource,
  &_swigt__p_gsGuiDocumentRocket,
  &_swigt__p_gsGuiElement,
  &_swigt__p_gsGuiElementEventListener,
  &_swigt__p_gsGuiElementQuery,
  &_swigt__p_gsHUD,
  &_swigt__p_gsHUDElement,
  &_swigt__p_gsILogicSocket,
  &_swigt__p_gsIfNodeAbstract,
  &_swigt__p_gsJoystick,
  &_swigt__p_gsJoystickButtonAbstract,
  &_swigt__p_gsJoystickNodeAbstract,
  &_swigt__p_gsKeyNodeAbstract,
  &_swigt__p_gsKeyboard,
  &_swigt__p_gsKeyboardSensor,
  &_swigt__p_gsLight,
  &_swigt__p_gsLogicManager,
  &_swigt__p_gsLogicNode,
  &_swigt__p_gsLogicObject,
  &_swigt__p_gsLogicOpController,
  &_swigt__p_gsLogicTree,
  &_swigt__p_gsLuaManager,
  &_swigt__p_gsLuaNodeAbstract,
  &_swigt__p_gsLuaScript,
  &_swigt__p_gsLuaStream,
  &_swigt__p_gsMathNodeAbstract,
  &_swigt__p_gsMatrix4,
  &_swigt__p_gsMesh,
  &_swigt__p_gsMessageActuator,
  &_swigt__p_gsMessageGetAbstract,
  &_swigt__p_gsMessageListenerCallback,
  &_swigt__p_gsMessageManager,
  &_swigt__p_gsMessageSendAbstract,
  &_swigt__p_gsMessageSensor,
  &_swigt__p_gsMotionActuator,
  &_swigt__p_gsMotionNodeAbstract,
  &_swigt__p_gsMouse,
  &_swigt__p_gsMouseButtonAbstract,
  &_swigt__p_gsMouseNodeAbstract,
  &_swigt__p_gsMouseSensor,
  &_swigt__p_gsMultiTouchState,
  &_swigt__p_gsNavPath,
  &_swigt__p_gsNearSensor,
  &_swigt__p_gsNetwork,
  &_swigt__p_gsNoOpAbstract,
  &_swigt__p_gsNodeTreeNodeAbstract,
  &_swigt__p_gsObject,
  &_swigt__p_gsObjectDataAbstract,
  &_swigt__p_gsObjectManipulatorAbstract,
  &_swigt__p_gsObjectNodeAbstract,
  &_swigt__p_gsPBSMaterialAbstract,
  &_swigt__p_gsPBSSlotAbstract,
  &_swigt__p_gsPBSTex_AlbedoAbstract,
  &_swigt__p_gsPBSTex_EnvAbstract,
  &_swigt__p_gsPBSTex_F0Abstract,
  &_swigt__p_gsPBSTex_NormalAbstract,
  &_swigt__p_gsParentActuator,
  &_swigt__p_gsParticles,
  &_swigt__p_gsPickRayNodeAbstract,
  &_swigt__p_gsPrintNodeAbstract,
  &_swigt__p_gsProcedural,
  &_swigt__p_gsProcess,
  &_swigt__p_gsProcessManager,
  &_swigt__p_gsProperty,
  &_swigt__p_gsPropertyAbstract,
  &_swigt__p_gsPropertyActuator,
  &_swigt__p_gsPropertyGetAbstract,
  &_swigt__p_gsPropertySensor,
  &_swigt__p_gsQuaternion,
  &_swigt__p_gsRadarSensor,
  &_swigt__p_gsRandomActuator,
  &_swigt__p_gsRandomSensor,
  &_swigt__p_gsRay,
  &_swigt__p_gsRaySensor,
  &_swigt__p_gsRayTest,
  &_swigt__p_gsRecastDebugger,
  &_swigt__p_gsRectangleDesigned,
  &_swigt__p_gsScene,
  &_swigt__p_gsSceneActuator,
  &_swigt__p_gsScreenActionAbstract,
  &_swigt__p_gsScriptController,
  &_swigt__p_gsSensor,
  &_swigt__p_gsSeqFinishedAbstract,
  &_swigt__p_gsSeqTimeAbstract,
  &_swigt__p_gsSequenceAbstract,
  &_swigt__p_gsSkeleton,
  &_swigt__p_gsSoundActuator,
  &_swigt__p_gsSoundManager,
  &_swigt__p_gsSoundNodeAbstract,
  &_swigt__p_gsSource,
  &_swigt__p_gsSprite,
  &_swigt__p_gsStateAbstract,
  &_swigt__p_gsStateActuator,
  &_swigt__p_gsStateMachineAbstract,
  &_swigt__p_gsStateMachineRefAbstract,
  &_swigt__p_gsStateManipulatorAbstract,
  &_swigt__p_gsStateRefAbstract,
  &_swigt__p_gsStateTransitionAbstract,
  &_swigt__p_gsStaticBatch,
  &_swigt__p_gsSteerGroup,
  &_swigt__p_gsSteerObject,
  &_swigt__p_gsSteerObstacleGroup,
  &_swigt__p_gsSteerPathFollowing,
  &_swigt__p_gsSteerRayObstacle,
  &_swigt__p_gsSteerSweptObstacle,
  &_swigt__p_gsSubMesh,
  &_swigt__p_gsSweptTest,
  &_swigt__p_gsTemplaterNodeAbstract,
  &_swigt__p_gsTestNodeAbstract,
  &_swigt__p_gsTextureAtlas,
  &_swigt__p_gsTimerNodeAbstract,
  &_swigt__p_gsTouch,
  &_swigt__p_gsTouchSensor,
  &_swigt__p_gsTween,
  &_swigt__p_gsTypeBoolAbstract,
  &_swigt__p_gsTypeColorAbstract,
  &_swigt__p_gsTypeFloatAbstract,
  &_swigt__p_gsTypeIntAbstract,
  &_swigt__p_gsUserDefs,
  &_swigt__p_gsVariable,
  &_swigt__p_gsVector2,
  &_swigt__p_gsVector3,
  &_swigt__p_gsVector4,
  &_swigt__p_gsVectorDecompAbstract,
  &_swigt__p_gsVehicle,
  &_swigt__p_gsVehicleGearAbstract,
  &_swigt__p_gsVehicleGearboxAbstract,
  &_swigt__p_gsVehicleNodeAbstract,
  &_swigt__p_gsVehicleWheelAbstract,
  &_swigt__p_gsVisibilityActuator,
  &_swigt__p_gsWhenEvent,
  &_swigt__p_int,
  &_swigt__p_std__string,
  &_swigt__p_tsPanel,
  &_swigt__p_tsScriptCallbackList,
  &_swigt__p_utArrayT_gkGameObject_p_t,
  &_swigt__p_utArrayT_gkLogicActuator_p_t,
  &_swigt__p_utArrayT_gkLogicController_p_t,
  &_swigt__p_utArrayT_gkLogicLink_p_t,
  &_swigt__p_utArrayT_gkLogicSensor_p_t,
  &_swigt__p_utArrayT_gkPhysicsConstraintProperties_t,
  &_swigt__p_utArrayT_gkProcess_p_t,
  &_swigt__p_utArrayT_gkString_t,
  &_swigt__p_utArrayT_gkVector3_t,
  &_swigt__p_utArrayT_utArrayT_gkVector3_t_t,
  &_swigt__p_utMemoryStream,
};

static swig_cast_info _swigc__p_Array[] = {  {&_swigt__p_Array, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BezTriples[] = {  {&_swigt__p_BezTriples, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BrickList[] = {  {&_swigt__p_BrickList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CollisionMask[] = {  {&_swigt__p_CollisionMask, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CurvePoints[] = {  {&_swigt__p_CurvePoints, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__Layer[] = {  {&_swigt__p_Gorilla__Layer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__LineList[] = {  {&_swigt__p_Gorilla__LineList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__MarkupText[] = {  {&_swigt__p_Gorilla__MarkupText, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__Rectangle[] = {  {&_swigt__p_Gorilla__Rectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__Screen[] = {  {&_swigt__p_Gorilla__Screen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__ScreenRenderable[] = {  {&_swigt__p_Gorilla__ScreenRenderable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__Sprite[] = {  {&_swigt__p_Gorilla__Sprite, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gorilla__TextureAtlas[] = {  {&_swigt__p_Gorilla__TextureAtlas, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Button[] = {  {&_swigt__p_Gui3D__Button, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Caption[] = {  {&_swigt__p_Gui3D__Caption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Checkbox[] = {  {&_swigt__p_Gui3D__Checkbox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Combobox[] = {  {&_swigt__p_Gui3D__Combobox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Listbox[] = {  {&_swigt__p_Gui3D__Listbox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__PanelColors[] = {  {&_swigt__p_Gui3D__PanelColors, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__PanelContainer[] = {  {&_swigt__p_Gui3D__PanelContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__PanelElement[] = {  {&_swigt__p_Gui3D__PanelElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__ProgressBar[] = {  {&_swigt__p_Gui3D__ProgressBar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__Rectangle[] = {  {&_swigt__p_Gui3D__Rectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__ScrollBar[] = {  {&_swigt__p_Gui3D__ScrollBar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Gui3D__TextZone[] = {  {&_swigt__p_Gui3D__TextZone, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Iterator[] = {  {&_swigt__p_Iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MyVehicle[] = {  {&_swigt__p_MyVehicle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OIS__MultiTouchState[] = {  {&_swigt__p_OIS__MultiTouchState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__ColourValue[] = {  {&_swigt__p_Ogre__ColourValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Entity[] = {  {&_swigt__p_Ogre__Entity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__PbsMaterial[] = {  {&_swigt__p_Ogre__PbsMaterial, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Real[] = {  {&_swigt__p_Ogre__Real, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenSteer__AVGroup[] = {  {&_swigt__p_OpenSteer__AVGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenSteer__AbstractVehicle[] = {  {&_swigt__p_OpenSteer__AbstractVehicle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenSteer__ObstacleGroup[] = {  {&_swigt__p_OpenSteer__ObstacleGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenSteer__Vec3[] = {  {&_swigt__p_OpenSteer__Vec3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rocket__Core__Element[] = {  {&_swigt__p_Rocket__Core__Element, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rocket__Core__Event[] = {  {&_swigt__p_Rocket__Core__Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rocket__Core__String[] = {  {&_swigt__p_Rocket__Core__String, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rocket__Core__StringList[] = {  {&_swigt__p_Rocket__Core__StringList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UTsize[] = {  {&_swigt__p_UTsize, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_btManifoldPoint[] = {  {&_swigt__p_btManifoldPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAccelerometerAbstract[] = {  {&_swigt__p_gkAccelerometerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAdditionNodeAbstract[] = {  {&_swigt__p_gkAdditionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAnimationDefinitionAbstract[] = {  {&_swigt__p_gkAnimationDefinitionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAnimationPlayer[] = {  {&_swigt__p_gkAnimationPlayer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAnimationPlayerAbstract[] = {  {&_swigt__p_gkAnimationPlayerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkAnimationTriggerAbstract[] = {  {&_swigt__p_gkAnimationTriggerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkBoolNodeAbstract[] = {  {&_swigt__p_gkBoolNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCameraNodeAbstract[] = {  {&_swigt__p_gkCameraNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCameraProperties[] = {  {&_swigt__p_gkCameraProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCharacter[] = {  {&_swigt__p_gkCharacter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCharacterNodeAbstract[] = {  {&_swigt__p_gkCharacterNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCollisionNodeAbstract[] = {  {&_swigt__p_gkCollisionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkColor[] = {  {&_swigt__p_gkColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkCurveProperties[] = {  {&_swigt__p_gkCurveProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkDebugger[] = {  {&_swigt__p_gkDebugger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkDeltaNodeAbstract[] = {  {&_swigt__p_gkDeltaNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkDynamicsWorld[] = {  {&_swigt__p_gkDynamicsWorld, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkElementAbstract[] = {  {&_swigt__p_gkElementAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkEngineNodeAbstract[] = {  {&_swigt__p_gkEngineNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkEntityProperties[] = {  {&_swigt__p_gkEntityProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkFileNodeAbstract[] = {  {&_swigt__p_gkFileNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkFogParams[] = {  {&_swigt__p_gkFogParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkGameObject[] = {  {&_swigt__p_gkGameObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkGameObjectInstance[] = {  {&_swigt__p_gkGameObjectInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkGameObjectProperties[] = {  {&_swigt__p_gkGameObjectProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkGorillaRectangle[] = {  {&_swigt__p_gkGorillaRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkILogicSocket[] = {  {&_swigt__p_gkILogicSocket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkIfNodeAbstract[] = {  {&_swigt__p_gkIfNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkJoystickButtonAbstract[] = {  {&_swigt__p_gkJoystickButtonAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkJoystickNodeAbstract[] = {  {&_swigt__p_gkJoystickNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkKeyNodeAbstract[] = {  {&_swigt__p_gkKeyNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLightProperties[] = {  {&_swigt__p_gkLightProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLogicManager[] = {  {&_swigt__p_gkLogicManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLogicNode[] = {  {&_swigt__p_gkLogicNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLogicTree[] = {  {&_swigt__p_gkLogicTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLuaCurState[] = {  {&_swigt__p_gkLuaCurState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLuaEvent[] = {  {&_swigt__p_gkLuaEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkLuaNodeAbstract[] = {  {&_swigt__p_gkLuaNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMaterialProperties[] = {  {&_swigt__p_gkMaterialProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMathNodeAbstract[] = {  {&_swigt__p_gkMathNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMesh[] = {  {&_swigt__p_gkMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMessageGetAbstract[] = {  {&_swigt__p_gkMessageGetAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMessageManager__Message[] = {  {&_swigt__p_gkMessageManager__Message, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMessageSendAbstract[] = {  {&_swigt__p_gkMessageSendAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMotionNodeAbstract[] = {  {&_swigt__p_gkMotionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMouseButtonAbstract[] = {  {&_swigt__p_gkMouseButtonAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkMouseNodeAbstract[] = {  {&_swigt__p_gkMouseNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkNavPath[] = {  {&_swigt__p_gkNavPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkNoOpAbstract[] = {  {&_swigt__p_gkNoOpAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkNodeTreeNodeAbstract[] = {  {&_swigt__p_gkNodeTreeNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkObjectDataAbstract[] = {  {&_swigt__p_gkObjectDataAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkObjectManipulatorAbstract[] = {  {&_swigt__p_gkObjectManipulatorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkObjectNodeAbstract[] = {  {&_swigt__p_gkObjectNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSMaterialAbstract[] = {  {&_swigt__p_gkPBSMaterialAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSSlotAbstract[] = {  {&_swigt__p_gkPBSSlotAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSTex_AlbedoAbstract[] = {  {&_swigt__p_gkPBSTex_AlbedoAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSTex_EnvAbstract[] = {  {&_swigt__p_gkPBSTex_EnvAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSTex_F0Abstract[] = {  {&_swigt__p_gkPBSTex_F0Abstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPBSTex_NormalAbstract[] = {  {&_swigt__p_gkPBSTex_NormalAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkParticleSettingsProperties[] = {  {&_swigt__p_gkParticleSettingsProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkParticleSystemProperties[] = {  {&_swigt__p_gkParticleSystemProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPhysicsConstraintProperties[] = {  {&_swigt__p_gkPhysicsConstraintProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPhysicsProperties[] = {  {&_swigt__p_gkPhysicsProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPickRayNodeAbstract[] = {  {&_swigt__p_gkPickRayNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPrintNodeAbstract[] = {  {&_swigt__p_gkPrintNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkProcessManager[] = {  {&_swigt__p_gkProcessManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPropertyAbstract[] = {  {&_swigt__p_gkPropertyAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkPropertyGetAbstract[] = {  {&_swigt__p_gkPropertyGetAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkQuaternion[] = {  {&_swigt__p_gkQuaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkRecastDebugger[] = {  {&_swigt__p_gkRecastDebugger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkScanCode[] = {  {&_swigt__p_gkScanCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkScene[] = {  {&_swigt__p_gkScene, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSceneMaterial[] = {  {&_swigt__p_gkSceneMaterial, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSceneProperties[] = {  {&_swigt__p_gkSceneProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSceneRayObstacle[] = {  {&_swigt__p_gkSceneRayObstacle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSceneSweptObstacle[] = {  {&_swigt__p_gkSceneSweptObstacle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkScreenActionAbstract[] = {  {&_swigt__p_gkScreenActionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSeqFinishedAbstract[] = {  {&_swigt__p_gkSeqFinishedAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSeqTimeAbstract[] = {  {&_swigt__p_gkSeqTimeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSequenceAbstract[] = {  {&_swigt__p_gkSequenceAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSoundNodeAbstract[] = {  {&_swigt__p_gkSoundNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSoundProperties[] = {  {&_swigt__p_gkSoundProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSoundSceneProperties[] = {  {&_swigt__p_gkSoundSceneProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSource[] = {  {&_swigt__p_gkSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateAbstract[] = {  {&_swigt__p_gkStateAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateMachineAbstract[] = {  {&_swigt__p_gkStateMachineAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateMachineRefAbstract[] = {  {&_swigt__p_gkStateMachineRefAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateManipulatorAbstract[] = {  {&_swigt__p_gkStateManipulatorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateRefAbstract[] = {  {&_swigt__p_gkStateRefAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkStateTransitionAbstract[] = {  {&_swigt__p_gkStateTransitionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkSubMesh[] = {  {&_swigt__p_gkSubMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTemplaterNodeAbstract[] = {  {&_swigt__p_gkTemplaterNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTestNodeAbstract[] = {  {&_swigt__p_gkTestNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTextureProperties[] = {  {&_swigt__p_gkTextureProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTimerNodeAbstract[] = {  {&_swigt__p_gkTimerNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTransformState[] = {  {&_swigt__p_gkTransformState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTriangle[] = {  {&_swigt__p_gkTriangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTypeBoolAbstract[] = {  {&_swigt__p_gkTypeBoolAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTypeColorAbstract[] = {  {&_swigt__p_gkTypeColorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTypeFloatAbstract[] = {  {&_swigt__p_gkTypeFloatAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkTypeIntAbstract[] = {  {&_swigt__p_gkTypeIntAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVariable[] = {  {&_swigt__p_gkVariable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVector2[] = {  {&_swigt__p_gkVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVector3[] = {  {&_swigt__p_gkVector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVectorDecompAbstract[] = {  {&_swigt__p_gkVectorDecompAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVehicle[] = {  {&_swigt__p_gkVehicle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVehicleGearAbstract[] = {  {&_swigt__p_gkVehicleGearAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVehicleGearboxAbstract[] = {  {&_swigt__p_gkVehicleGearboxAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVehicleNodeAbstract[] = {  {&_swigt__p_gkVehicleNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVehicleWheelAbstract[] = {  {&_swigt__p_gkVehicleWheelAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gkVertex[] = {  {&_swigt__p_gkVertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAccelerometerAbstract[] = {  {&_swigt__p_gsAccelerometerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsActionActuator[] = {  {&_swigt__p_gsActionActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsActuator[] = {  {&_swigt__p_gsActuator, 0, 0, 0},  {&_swigt__p_gsActionActuator, _p_gsActionActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsEditObjectActuator, _p_gsEditObjectActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsGameActuator, _p_gsGameActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsMessageActuator, _p_gsMessageActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsMotionActuator, _p_gsMotionActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsParentActuator, _p_gsParentActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsPropertyActuator, _p_gsPropertyActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsRandomActuator, _p_gsRandomActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsSceneActuator, _p_gsSceneActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsSoundActuator, _p_gsSoundActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsStateActuator, _p_gsStateActuatorTo_p_gsActuator, 0, 0},  {&_swigt__p_gsVisibilityActuator, _p_gsVisibilityActuatorTo_p_gsActuator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsActuatorSensor[] = {  {&_swigt__p_gsActuatorSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAdditionNodeAbstract[] = {  {&_swigt__p_gsAdditionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAlwaysSensor[] = {  {&_swigt__p_gsAlwaysSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAnimationDefinitionAbstract[] = {  {&_swigt__p_gsAnimationDefinitionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAnimationPlayer[] = {  {&_swigt__p_gsAnimationPlayer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAnimationPlayerAbstract[] = {  {&_swigt__p_gsAnimationPlayerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsAnimationTriggerAbstract[] = {  {&_swigt__p_gsAnimationTriggerAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkGameObject_t[] = {  {&_swigt__p_gsArrayIteratorT_gkGameObject_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkLogicActuator_t[] = {  {&_swigt__p_gsArrayIteratorT_gkLogicActuator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkLogicController_t[] = {  {&_swigt__p_gsArrayIteratorT_gkLogicController_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkLogicLink_t[] = {  {&_swigt__p_gsArrayIteratorT_gkLogicLink_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkLogicSensor_t[] = {  {&_swigt__p_gsArrayIteratorT_gkLogicSensor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayIteratorT_gkProcess_t[] = {  {&_swigt__p_gsArrayIteratorT_gkProcess_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsActuator_gkLogicActuator_t[] = {  {&_swigt__p_gsArrayT_gsActuator_gkLogicActuator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsController_gkLogicController_t[] = {  {&_swigt__p_gsArrayT_gsController_gkLogicController_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsGameObject_gkGameObject_t[] = {  {&_swigt__p_gsArrayT_gsGameObject_gkGameObject_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsLogicObject_gkLogicLink_t[] = {  {&_swigt__p_gsArrayT_gsLogicObject_gkLogicLink_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsProcess_gkProcess_t[] = {  {&_swigt__p_gsArrayT_gsProcess_gkProcess_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsArrayT_gsSensor_gkLogicSensor_t[] = {  {&_swigt__p_gsArrayT_gsSensor_gkLogicSensor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsBoolNodeAbstract[] = {  {&_swigt__p_gsBoolNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsBrick[] = {  {&_swigt__p_gsAlwaysSensor, _p_gsAlwaysSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsDelaySensor, _p_gsDelaySensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsMessageSensor, _p_gsMessageSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsMouseSensor, _p_gsMouseSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsPropertySensor, _p_gsPropertySensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsRaySensor, _p_gsRaySensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsRandomSensor, _p_gsRandomSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsSensor, _p_gsSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsBrick, 0, 0, 0},  {&_swigt__p_gsCollisionSensor, _p_gsCollisionSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsTouchSensor, _p_gsTouchSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsKeyboardSensor, _p_gsKeyboardSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsNearSensor, _p_gsNearSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsRadarSensor, _p_gsRadarSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsActuatorSensor, _p_gsActuatorSensorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsController, _p_gsControllerTo_p_gsBrick, 0, 0},  {&_swigt__p_gsLogicOpController, _p_gsLogicOpControllerTo_p_gsBrick, 0, 0},  {&_swigt__p_gsExpressionController, _p_gsExpressionControllerTo_p_gsBrick, 0, 0},  {&_swigt__p_gsScriptController, _p_gsScriptControllerTo_p_gsBrick, 0, 0},  {&_swigt__p_gsActuator, _p_gsActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsActionActuator, _p_gsActionActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsEditObjectActuator, _p_gsEditObjectActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsGameActuator, _p_gsGameActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsMessageActuator, _p_gsMessageActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsMotionActuator, _p_gsMotionActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsParentActuator, _p_gsParentActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsPropertyActuator, _p_gsPropertyActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsRandomActuator, _p_gsRandomActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsSceneActuator, _p_gsSceneActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsSoundActuator, _p_gsSoundActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsStateActuator, _p_gsStateActuatorTo_p_gsBrick, 0, 0},  {&_swigt__p_gsVisibilityActuator, _p_gsVisibilityActuatorTo_p_gsBrick, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCamera[] = {  {&_swigt__p_gsCamera, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCameraNodeAbstract[] = {  {&_swigt__p_gsCameraNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCharacter[] = {  {&_swigt__p_gsCharacter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCharacterNodeAbstract[] = {  {&_swigt__p_gsCharacterNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCollisionNodeAbstract[] = {  {&_swigt__p_gsCollisionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCollisionSensor[] = {  {&_swigt__p_gsCollisionSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsContactInfo[] = {  {&_swigt__p_gsContactInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsController[] = {  {&_swigt__p_gsController, 0, 0, 0},  {&_swigt__p_gsLogicOpController, _p_gsLogicOpControllerTo_p_gsController, 0, 0},  {&_swigt__p_gsExpressionController, _p_gsExpressionControllerTo_p_gsController, 0, 0},  {&_swigt__p_gsScriptController, _p_gsScriptControllerTo_p_gsController, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsCurve[] = {  {&_swigt__p_gsCurve, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsDebugger[] = {  {&_swigt__p_gsDebugger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsDelaySensor[] = {  {&_swigt__p_gsDelaySensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsDeltaNodeAbstract[] = {  {&_swigt__p_gsDeltaNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsDynamicsWorld[] = {  {&_swigt__p_gsDynamicsWorld, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsEditObjectActuator[] = {  {&_swigt__p_gsEditObjectActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsElementAbstract[] = {  {&_swigt__p_gsElementAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsEngine[] = {  {&_swigt__p_gsEngine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsEngineNodeAbstract[] = {  {&_swigt__p_gsEngineNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsEntity[] = {  {&_swigt__p_gsEntity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsExpressionController[] = {  {&_swigt__p_gsExpressionController, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsFSM[] = {  {&_swigt__p_gsFSM, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsFileNodeAbstract[] = {  {&_swigt__p_gsFileNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI[] = {  {&_swigt__p_gsGUI, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3D[] = {  {&_swigt__p_gsGUI3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DButton[] = {  {&_swigt__p_gsGUI3DButton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DCaption[] = {  {&_swigt__p_gsGUI3DCaption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DCheckbox[] = {  {&_swigt__p_gsGUI3DCheckbox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DCombobox[] = {  {&_swigt__p_gsGUI3DCombobox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DElement[] = {  {&_swigt__p_gsGUI3DElement, 0, 0, 0},  {&_swigt__p_gsGUI3DCaption, _p_gsGUI3DCaptionTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DCheckbox, _p_gsGUI3DCheckboxTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DCombobox, _p_gsGUI3DComboboxTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DButton, _p_gsGUI3DButtonTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DScrollbar, _p_gsGUI3DScrollbarTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DRectangle, _p_gsGUI3DRectangleTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DProgressbar, _p_gsGUI3DProgressbarTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DListbox, _p_gsGUI3DListboxTo_p_gsGUI3DElement, 0, 0},  {&_swigt__p_gsGUI3DTextField, _p_gsGUI3DTextFieldTo_p_gsGUI3DElement, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DListbox[] = {  {&_swigt__p_gsGUI3DListbox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DProgressbar[] = {  {&_swigt__p_gsGUI3DProgressbar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DRectangle[] = {  {&_swigt__p_gsGUI3DRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DScriptCallback[] = {  {&_swigt__p_gsGUI3DScriptCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DScrollbar[] = {  {&_swigt__p_gsGUI3DScrollbar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGUI3DTextField[] = {  {&_swigt__p_gsGUI3DTextField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGameActuator[] = {  {&_swigt__p_gsGameActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGameObject[] = {  {&_swigt__p_gsParticles, _p_gsParticlesTo_p_gsGameObject, 0, 0},  {&_swigt__p_gsLight, _p_gsLightTo_p_gsGameObject, 0, 0},  {&_swigt__p_gsGameObject, 0, 0, 0},  {&_swigt__p_gsEntity, _p_gsEntityTo_p_gsGameObject, 0, 0},  {&_swigt__p_gsCurve, _p_gsCurveTo_p_gsGameObject, 0, 0},  {&_swigt__p_gsCamera, _p_gsCameraTo_p_gsGameObject, 0, 0},  {&_swigt__p_gsSkeleton, _p_gsSkeletonTo_p_gsGameObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGameObjectInstance[] = {  {&_swigt__p_gsGameObjectInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorilla[] = {  {&_swigt__p_gsGorilla, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaLineList[] = {  {&_swigt__p_gsGorillaLineList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaRectangle[] = {  {&_swigt__p_gsGorillaRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaScreen[] = {  {&_swigt__p_gsGorillaScreen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaScreen3D[] = {  {&_swigt__p_gsGorillaScreen3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaScreenFunctions[] = {  {&_swigt__p_gsGorillaScreenFunctions, 0, 0, 0},  {&_swigt__p_gsGorillaScreen3D, _p_gsGorillaScreen3DTo_p_gsGorillaScreenFunctions, 0, 0},  {&_swigt__p_gsGorillaScreen, _p_gsGorillaScreenTo_p_gsGorillaScreenFunctions, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGorillaText[] = {  {&_swigt__p_gsGorillaText, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiDataFormatter[] = {  {&_swigt__p_gsGuiDataFormatter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiDataSource[] = {  {&_swigt__p_gsGuiDataSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiDocumentRocket[] = {  {&_swigt__p_gsGuiDocumentRocket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiElement[] = {  {&_swigt__p_gsGuiElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiElementEventListener[] = {  {&_swigt__p_gsGuiElementEventListener, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsGuiElementQuery[] = {  {&_swigt__p_gsGuiElementQuery, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsHUD[] = {  {&_swigt__p_gsHUD, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsHUDElement[] = {  {&_swigt__p_gsHUDElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsILogicSocket[] = {  {&_swigt__p_gsILogicSocket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsIfNodeAbstract[] = {  {&_swigt__p_gsIfNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsJoystick[] = {  {&_swigt__p_gsJoystick, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsJoystickButtonAbstract[] = {  {&_swigt__p_gsJoystickButtonAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsJoystickNodeAbstract[] = {  {&_swigt__p_gsJoystickNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsKeyNodeAbstract[] = {  {&_swigt__p_gsKeyNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsKeyboard[] = {  {&_swigt__p_gsKeyboard, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsKeyboardSensor[] = {  {&_swigt__p_gsKeyboardSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLight[] = {  {&_swigt__p_gsLight, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLogicManager[] = {  {&_swigt__p_gsLogicManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLogicNode[] = {  {&_swigt__p_gsStateTransitionAbstract, _p_gsStateTransitionAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsStateMachineRefAbstract, _p_gsStateMachineRefAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsStateRefAbstract, _p_gsStateRefAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsStateManipulatorAbstract, _p_gsStateManipulatorAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPropertyAbstract, _p_gsPropertyAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPropertyGetAbstract, _p_gsPropertyGetAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsNoOpAbstract, _p_gsNoOpAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTemplaterNodeAbstract, _p_gsTemplaterNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsScreenActionAbstract, _p_gsScreenActionAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsElementAbstract, _p_gsElementAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsAnimationDefinitionAbstract, _p_gsAnimationDefinitionAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsAnimationPlayerAbstract, _p_gsAnimationPlayerAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsAnimationTriggerAbstract, _p_gsAnimationTriggerAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsStateAbstract, _p_gsStateAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsStateMachineAbstract, _p_gsStateMachineAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsNodeTreeNodeAbstract, _p_gsNodeTreeNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsVectorDecompAbstract, _p_gsVectorDecompAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsAccelerometerAbstract, _p_gsAccelerometerAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsObjectDataAbstract, _p_gsObjectDataAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsObjectNodeAbstract, _p_gsObjectNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMathNodeAbstract, _p_gsMathNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsBoolNodeAbstract, _p_gsBoolNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMouseNodeAbstract, _p_gsMouseNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMotionNodeAbstract, _p_gsMotionNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsSeqTimeAbstract, _p_gsSeqTimeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsSeqFinishedAbstract, _p_gsSeqFinishedAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsSequenceAbstract, _p_gsSequenceAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsCharacterNodeAbstract, _p_gsCharacterNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsObjectManipulatorAbstract, _p_gsObjectManipulatorAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMessageGetAbstract, _p_gsMessageGetAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMessageSendAbstract, _p_gsMessageSendAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTestNodeAbstract, _p_gsTestNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPickRayNodeAbstract, _p_gsPickRayNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTimerNodeAbstract, _p_gsTimerNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsCollisionNodeAbstract, _p_gsCollisionNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsFileNodeAbstract, _p_gsFileNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsLuaNodeAbstract, _p_gsLuaNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsAdditionNodeAbstract, _p_gsAdditionNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPrintNodeAbstract, _p_gsPrintNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsKeyNodeAbstract, _p_gsKeyNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsMouseButtonAbstract, _p_gsMouseButtonAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsDeltaNodeAbstract, _p_gsDeltaNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTypeColorAbstract, _p_gsTypeColorAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTypeIntAbstract, _p_gsTypeIntAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTypeFloatAbstract, _p_gsTypeFloatAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsTypeBoolAbstract, _p_gsTypeBoolAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSMaterialAbstract, _p_gsPBSMaterialAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSSlotAbstract, _p_gsPBSSlotAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSTex_AlbedoAbstract, _p_gsPBSTex_AlbedoAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSTex_EnvAbstract, _p_gsPBSTex_EnvAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSTex_NormalAbstract, _p_gsPBSTex_NormalAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsPBSTex_F0Abstract, _p_gsPBSTex_F0AbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsEngineNodeAbstract, _p_gsEngineNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsIfNodeAbstract, _p_gsIfNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsSoundNodeAbstract, _p_gsSoundNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsJoystickNodeAbstract, _p_gsJoystickNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsJoystickButtonAbstract, _p_gsJoystickButtonAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsVehicleNodeAbstract, _p_gsVehicleNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsVehicleGearboxAbstract, _p_gsVehicleGearboxAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsVehicleGearAbstract, _p_gsVehicleGearAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsVehicleWheelAbstract, _p_gsVehicleWheelAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsCameraNodeAbstract, _p_gsCameraNodeAbstractTo_p_gsLogicNode, 0, 0},  {&_swigt__p_gsLogicNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLogicObject[] = {  {&_swigt__p_gsLogicObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLogicOpController[] = {  {&_swigt__p_gsLogicOpController, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLogicTree[] = {  {&_swigt__p_gsLogicTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLuaManager[] = {  {&_swigt__p_gsLuaManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLuaNodeAbstract[] = {  {&_swigt__p_gsLuaNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLuaScript[] = {  {&_swigt__p_gsLuaScript, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsLuaStream[] = {  {&_swigt__p_gsLuaStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMathNodeAbstract[] = {  {&_swigt__p_gsMathNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMatrix4[] = {  {&_swigt__p_gsMatrix4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMesh[] = {  {&_swigt__p_gsMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageActuator[] = {  {&_swigt__p_gsMessageActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageGetAbstract[] = {  {&_swigt__p_gsMessageGetAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageListenerCallback[] = {  {&_swigt__p_gsMessageListenerCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageManager[] = {  {&_swigt__p_gsMessageManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageSendAbstract[] = {  {&_swigt__p_gsMessageSendAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMessageSensor[] = {  {&_swigt__p_gsMessageSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMotionActuator[] = {  {&_swigt__p_gsMotionActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMotionNodeAbstract[] = {  {&_swigt__p_gsMotionNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMouse[] = {  {&_swigt__p_gsMouse, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMouseButtonAbstract[] = {  {&_swigt__p_gsMouseButtonAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMouseNodeAbstract[] = {  {&_swigt__p_gsMouseNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMouseSensor[] = {  {&_swigt__p_gsMouseSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsMultiTouchState[] = {  {&_swigt__p_gsMultiTouchState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsNavPath[] = {  {&_swigt__p_gsNavPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsNearSensor[] = {  {&_swigt__p_gsNearSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsNetwork[] = {  {&_swigt__p_gsNetwork, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsNoOpAbstract[] = {  {&_swigt__p_gsNoOpAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsNodeTreeNodeAbstract[] = {  {&_swigt__p_gsNodeTreeNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsObject[] = {  {&_swigt__p_gsParticles, _p_gsParticlesTo_p_gsObject, 0, 0},  {&_swigt__p_gsScene, _p_gsSceneTo_p_gsObject, 0, 0},  {&_swigt__p_gsLight, _p_gsLightTo_p_gsObject, 0, 0},  {&_swigt__p_gsObject, 0, 0, 0},  {&_swigt__p_gsGameObject, _p_gsGameObjectTo_p_gsObject, 0, 0},  {&_swigt__p_gsEntity, _p_gsEntityTo_p_gsObject, 0, 0},  {&_swigt__p_gsCurve, _p_gsCurveTo_p_gsObject, 0, 0},  {&_swigt__p_gsCamera, _p_gsCameraTo_p_gsObject, 0, 0},  {&_swigt__p_gsSkeleton, _p_gsSkeletonTo_p_gsObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsObjectDataAbstract[] = {  {&_swigt__p_gsObjectDataAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsObjectManipulatorAbstract[] = {  {&_swigt__p_gsObjectManipulatorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsObjectNodeAbstract[] = {  {&_swigt__p_gsObjectNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSMaterialAbstract[] = {  {&_swigt__p_gsPBSMaterialAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSSlotAbstract[] = {  {&_swigt__p_gsPBSSlotAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSTex_AlbedoAbstract[] = {  {&_swigt__p_gsPBSTex_AlbedoAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSTex_EnvAbstract[] = {  {&_swigt__p_gsPBSTex_EnvAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSTex_F0Abstract[] = {  {&_swigt__p_gsPBSTex_F0Abstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPBSTex_NormalAbstract[] = {  {&_swigt__p_gsPBSTex_NormalAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsParentActuator[] = {  {&_swigt__p_gsParentActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsParticles[] = {  {&_swigt__p_gsParticles, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPickRayNodeAbstract[] = {  {&_swigt__p_gsPickRayNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPrintNodeAbstract[] = {  {&_swigt__p_gsPrintNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsProcedural[] = {  {&_swigt__p_gsProcedural, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsProcess[] = {  {&_swigt__p_gsProcess, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsProcessManager[] = {  {&_swigt__p_gsProcessManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsProperty[] = {  {&_swigt__p_gsProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPropertyAbstract[] = {  {&_swigt__p_gsPropertyAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPropertyActuator[] = {  {&_swigt__p_gsPropertyActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPropertyGetAbstract[] = {  {&_swigt__p_gsPropertyGetAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsPropertySensor[] = {  {&_swigt__p_gsPropertySensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsQuaternion[] = {  {&_swigt__p_gsQuaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRadarSensor[] = {  {&_swigt__p_gsRadarSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRandomActuator[] = {  {&_swigt__p_gsRandomActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRandomSensor[] = {  {&_swigt__p_gsRandomSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRay[] = {  {&_swigt__p_gsRay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRaySensor[] = {  {&_swigt__p_gsRaySensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRayTest[] = {  {&_swigt__p_gsRayTest, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRecastDebugger[] = {  {&_swigt__p_gsRecastDebugger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsRectangleDesigned[] = {  {&_swigt__p_gsGUI3DButton, _p_gsGUI3DButtonTo_p_gsRectangleDesigned, 0, 0},  {&_swigt__p_gsRectangleDesigned, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsScene[] = {  {&_swigt__p_gsScene, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSceneActuator[] = {  {&_swigt__p_gsSceneActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsScreenActionAbstract[] = {  {&_swigt__p_gsScreenActionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsScriptController[] = {  {&_swigt__p_gsScriptController, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSensor[] = {  {&_swigt__p_gsAlwaysSensor, _p_gsAlwaysSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsDelaySensor, _p_gsDelaySensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsMessageSensor, _p_gsMessageSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsMouseSensor, _p_gsMouseSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsPropertySensor, _p_gsPropertySensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsRaySensor, _p_gsRaySensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsRandomSensor, _p_gsRandomSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsSensor, 0, 0, 0},  {&_swigt__p_gsActuatorSensor, _p_gsActuatorSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsCollisionSensor, _p_gsCollisionSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsTouchSensor, _p_gsTouchSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsKeyboardSensor, _p_gsKeyboardSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsNearSensor, _p_gsNearSensorTo_p_gsSensor, 0, 0},  {&_swigt__p_gsRadarSensor, _p_gsRadarSensorTo_p_gsSensor, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSeqFinishedAbstract[] = {  {&_swigt__p_gsSeqFinishedAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSeqTimeAbstract[] = {  {&_swigt__p_gsSeqTimeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSequenceAbstract[] = {  {&_swigt__p_gsSequenceAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSkeleton[] = {  {&_swigt__p_gsSkeleton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSoundActuator[] = {  {&_swigt__p_gsSoundActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSoundManager[] = {  {&_swigt__p_gsSoundManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSoundNodeAbstract[] = {  {&_swigt__p_gsSoundNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSource[] = {  {&_swigt__p_gsSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSprite[] = {  {&_swigt__p_gsSprite, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateAbstract[] = {  {&_swigt__p_gsStateAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateActuator[] = {  {&_swigt__p_gsStateActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateMachineAbstract[] = {  {&_swigt__p_gsStateMachineAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateMachineRefAbstract[] = {  {&_swigt__p_gsStateMachineRefAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateManipulatorAbstract[] = {  {&_swigt__p_gsStateManipulatorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateRefAbstract[] = {  {&_swigt__p_gsStateRefAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStateTransitionAbstract[] = {  {&_swigt__p_gsStateTransitionAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsStaticBatch[] = {  {&_swigt__p_gsStaticBatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerGroup[] = {  {&_swigt__p_gsSteerGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerObject[] = {  {&_swigt__p_gsSteerObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerObstacleGroup[] = {  {&_swigt__p_gsSteerObstacleGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerPathFollowing[] = {  {&_swigt__p_gsSteerPathFollowing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerRayObstacle[] = {  {&_swigt__p_gsSteerRayObstacle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSteerSweptObstacle[] = {  {&_swigt__p_gsSteerSweptObstacle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSubMesh[] = {  {&_swigt__p_gsSubMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsSweptTest[] = {  {&_swigt__p_gsSweptTest, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTemplaterNodeAbstract[] = {  {&_swigt__p_gsTemplaterNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTestNodeAbstract[] = {  {&_swigt__p_gsTestNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTextureAtlas[] = {  {&_swigt__p_gsTextureAtlas, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTimerNodeAbstract[] = {  {&_swigt__p_gsTimerNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTouch[] = {  {&_swigt__p_gsTouch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTouchSensor[] = {  {&_swigt__p_gsTouchSensor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTween[] = {  {&_swigt__p_gsTween, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTypeBoolAbstract[] = {  {&_swigt__p_gsTypeBoolAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTypeColorAbstract[] = {  {&_swigt__p_gsTypeColorAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTypeFloatAbstract[] = {  {&_swigt__p_gsTypeFloatAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsTypeIntAbstract[] = {  {&_swigt__p_gsTypeIntAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsUserDefs[] = {  {&_swigt__p_gsUserDefs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVariable[] = {  {&_swigt__p_gsVariable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVector2[] = {  {&_swigt__p_gsVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVector3[] = {  {&_swigt__p_gsVector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVector4[] = {  {&_swigt__p_gsVector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVectorDecompAbstract[] = {  {&_swigt__p_gsVectorDecompAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVehicle[] = {  {&_swigt__p_gsVehicle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVehicleGearAbstract[] = {  {&_swigt__p_gsVehicleGearAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVehicleGearboxAbstract[] = {  {&_swigt__p_gsVehicleGearboxAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVehicleNodeAbstract[] = {  {&_swigt__p_gsVehicleNodeAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVehicleWheelAbstract[] = {  {&_swigt__p_gsVehicleWheelAbstract, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsVisibilityActuator[] = {  {&_swigt__p_gsVisibilityActuator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsWhenEvent[] = {  {&_swigt__p_gsWhenEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tsPanel[] = {  {&_swigt__p_tsPanel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tsScriptCallbackList[] = {  {&_swigt__p_tsScriptCallbackList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkGameObject_p_t[] = {  {&_swigt__p_utArrayT_gkGameObject_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkLogicActuator_p_t[] = {  {&_swigt__p_utArrayT_gkLogicActuator_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkLogicController_p_t[] = {  {&_swigt__p_utArrayT_gkLogicController_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkLogicLink_p_t[] = {  {&_swigt__p_utArrayT_gkLogicLink_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkLogicSensor_p_t[] = {  {&_swigt__p_utArrayT_gkLogicSensor_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkPhysicsConstraintProperties_t[] = {  {&_swigt__p_utArrayT_gkPhysicsConstraintProperties_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkProcess_p_t[] = {  {&_swigt__p_utArrayT_gkProcess_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkString_t[] = {  {&_swigt__p_utArrayT_gkString_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_gkVector3_t[] = {  {&_swigt__p_utArrayT_gkVector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utArrayT_utArrayT_gkVector3_t_t[] = {  {&_swigt__p_utArrayT_utArrayT_gkVector3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_utMemoryStream[] = {  {&_swigt__p_utMemoryStream, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Array,
  _swigc__p_BezTriples,
  _swigc__p_BrickList,
  _swigc__p_CollisionMask,
  _swigc__p_CurvePoints,
  _swigc__p_Gorilla__Layer,
  _swigc__p_Gorilla__LineList,
  _swigc__p_Gorilla__MarkupText,
  _swigc__p_Gorilla__Rectangle,
  _swigc__p_Gorilla__Screen,
  _swigc__p_Gorilla__ScreenRenderable,
  _swigc__p_Gorilla__Sprite,
  _swigc__p_Gorilla__TextureAtlas,
  _swigc__p_Gui3D__Button,
  _swigc__p_Gui3D__Caption,
  _swigc__p_Gui3D__Checkbox,
  _swigc__p_Gui3D__Combobox,
  _swigc__p_Gui3D__Listbox,
  _swigc__p_Gui3D__PanelColors,
  _swigc__p_Gui3D__PanelContainer,
  _swigc__p_Gui3D__PanelElement,
  _swigc__p_Gui3D__ProgressBar,
  _swigc__p_Gui3D__Rectangle,
  _swigc__p_Gui3D__ScrollBar,
  _swigc__p_Gui3D__TextZone,
  _swigc__p_Iterator,
  _swigc__p_MyVehicle,
  _swigc__p_OIS__MultiTouchState,
  _swigc__p_Ogre__ColourValue,
  _swigc__p_Ogre__Entity,
  _swigc__p_Ogre__PbsMaterial,
  _swigc__p_Ogre__Real,
  _swigc__p_OpenSteer__AVGroup,
  _swigc__p_OpenSteer__AbstractVehicle,
  _swigc__p_OpenSteer__ObstacleGroup,
  _swigc__p_OpenSteer__Vec3,
  _swigc__p_Rocket__Core__Element,
  _swigc__p_Rocket__Core__Event,
  _swigc__p_Rocket__Core__String,
  _swigc__p_Rocket__Core__StringList,
  _swigc__p_UTsize,
  _swigc__p_btManifoldPoint,
  _swigc__p_float,
  _swigc__p_gkAccelerometerAbstract,
  _swigc__p_gkAdditionNodeAbstract,
  _swigc__p_gkAnimationDefinitionAbstract,
  _swigc__p_gkAnimationPlayer,
  _swigc__p_gkAnimationPlayerAbstract,
  _swigc__p_gkAnimationTriggerAbstract,
  _swigc__p_gkBoolNodeAbstract,
  _swigc__p_gkCameraNodeAbstract,
  _swigc__p_gkCameraProperties,
  _swigc__p_gkCharacter,
  _swigc__p_gkCharacterNodeAbstract,
  _swigc__p_gkCollisionNodeAbstract,
  _swigc__p_gkColor,
  _swigc__p_gkCurveProperties,
  _swigc__p_gkDebugger,
  _swigc__p_gkDeltaNodeAbstract,
  _swigc__p_gkDynamicsWorld,
  _swigc__p_gkElementAbstract,
  _swigc__p_gkEngineNodeAbstract,
  _swigc__p_gkEntityProperties,
  _swigc__p_gkFileNodeAbstract,
  _swigc__p_gkFogParams,
  _swigc__p_gkGameObject,
  _swigc__p_gkGameObjectInstance,
  _swigc__p_gkGameObjectProperties,
  _swigc__p_gkGorillaRectangle,
  _swigc__p_gkILogicSocket,
  _swigc__p_gkIfNodeAbstract,
  _swigc__p_gkJoystickButtonAbstract,
  _swigc__p_gkJoystickNodeAbstract,
  _swigc__p_gkKeyNodeAbstract,
  _swigc__p_gkLightProperties,
  _swigc__p_gkLogicManager,
  _swigc__p_gkLogicNode,
  _swigc__p_gkLogicTree,
  _swigc__p_gkLuaCurState,
  _swigc__p_gkLuaEvent,
  _swigc__p_gkLuaNodeAbstract,
  _swigc__p_gkMaterialProperties,
  _swigc__p_gkMathNodeAbstract,
  _swigc__p_gkMesh,
  _swigc__p_gkMessageGetAbstract,
  _swigc__p_gkMessageManager__Message,
  _swigc__p_gkMessageSendAbstract,
  _swigc__p_gkMotionNodeAbstract,
  _swigc__p_gkMouseButtonAbstract,
  _swigc__p_gkMouseNodeAbstract,
  _swigc__p_gkNavPath,
  _swigc__p_gkNoOpAbstract,
  _swigc__p_gkNodeTreeNodeAbstract,
  _swigc__p_gkObjectDataAbstract,
  _swigc__p_gkObjectManipulatorAbstract,
  _swigc__p_gkObjectNodeAbstract,
  _swigc__p_gkPBSMaterialAbstract,
  _swigc__p_gkPBSSlotAbstract,
  _swigc__p_gkPBSTex_AlbedoAbstract,
  _swigc__p_gkPBSTex_EnvAbstract,
  _swigc__p_gkPBSTex_F0Abstract,
  _swigc__p_gkPBSTex_NormalAbstract,
  _swigc__p_gkParticleSettingsProperties,
  _swigc__p_gkParticleSystemProperties,
  _swigc__p_gkPhysicsConstraintProperties,
  _swigc__p_gkPhysicsProperties,
  _swigc__p_gkPickRayNodeAbstract,
  _swigc__p_gkPrintNodeAbstract,
  _swigc__p_gkProcessManager,
  _swigc__p_gkPropertyAbstract,
  _swigc__p_gkPropertyGetAbstract,
  _swigc__p_gkQuaternion,
  _swigc__p_gkRecastDebugger,
  _swigc__p_gkScanCode,
  _swigc__p_gkScene,
  _swigc__p_gkSceneMaterial,
  _swigc__p_gkSceneProperties,
  _swigc__p_gkSceneRayObstacle,
  _swigc__p_gkSceneSweptObstacle,
  _swigc__p_gkScreenActionAbstract,
  _swigc__p_gkSeqFinishedAbstract,
  _swigc__p_gkSeqTimeAbstract,
  _swigc__p_gkSequenceAbstract,
  _swigc__p_gkSoundNodeAbstract,
  _swigc__p_gkSoundProperties,
  _swigc__p_gkSoundSceneProperties,
  _swigc__p_gkSource,
  _swigc__p_gkStateAbstract,
  _swigc__p_gkStateMachineAbstract,
  _swigc__p_gkStateMachineRefAbstract,
  _swigc__p_gkStateManipulatorAbstract,
  _swigc__p_gkStateRefAbstract,
  _swigc__p_gkStateTransitionAbstract,
  _swigc__p_gkSubMesh,
  _swigc__p_gkTemplaterNodeAbstract,
  _swigc__p_gkTestNodeAbstract,
  _swigc__p_gkTextureProperties,
  _swigc__p_gkTimerNodeAbstract,
  _swigc__p_gkTransformState,
  _swigc__p_gkTriangle,
  _swigc__p_gkTypeBoolAbstract,
  _swigc__p_gkTypeColorAbstract,
  _swigc__p_gkTypeFloatAbstract,
  _swigc__p_gkTypeIntAbstract,
  _swigc__p_gkVariable,
  _swigc__p_gkVector2,
  _swigc__p_gkVector3,
  _swigc__p_gkVectorDecompAbstract,
  _swigc__p_gkVehicle,
  _swigc__p_gkVehicleGearAbstract,
  _swigc__p_gkVehicleGearboxAbstract,
  _swigc__p_gkVehicleNodeAbstract,
  _swigc__p_gkVehicleWheelAbstract,
  _swigc__p_gkVertex,
  _swigc__p_gsAccelerometerAbstract,
  _swigc__p_gsActionActuator,
  _swigc__p_gsActuator,
  _swigc__p_gsActuatorSensor,
  _swigc__p_gsAdditionNodeAbstract,
  _swigc__p_gsAlwaysSensor,
  _swigc__p_gsAnimationDefinitionAbstract,
  _swigc__p_gsAnimationPlayer,
  _swigc__p_gsAnimationPlayerAbstract,
  _swigc__p_gsAnimationTriggerAbstract,
  _swigc__p_gsArrayIteratorT_gkGameObject_t,
  _swigc__p_gsArrayIteratorT_gkLogicActuator_t,
  _swigc__p_gsArrayIteratorT_gkLogicController_t,
  _swigc__p_gsArrayIteratorT_gkLogicLink_t,
  _swigc__p_gsArrayIteratorT_gkLogicSensor_t,
  _swigc__p_gsArrayIteratorT_gkProcess_t,
  _swigc__p_gsArrayT_gsActuator_gkLogicActuator_t,
  _swigc__p_gsArrayT_gsController_gkLogicController_t,
  _swigc__p_gsArrayT_gsGameObject_gkGameObject_t,
  _swigc__p_gsArrayT_gsLogicObject_gkLogicLink_t,
  _swigc__p_gsArrayT_gsProcess_gkProcess_t,
  _swigc__p_gsArrayT_gsSensor_gkLogicSensor_t,
  _swigc__p_gsBoolNodeAbstract,
  _swigc__p_gsBrick,
  _swigc__p_gsCamera,
  _swigc__p_gsCameraNodeAbstract,
  _swigc__p_gsCharacter,
  _swigc__p_gsCharacterNodeAbstract,
  _swigc__p_gsCollisionNodeAbstract,
  _swigc__p_gsCollisionSensor,
  _swigc__p_gsContactInfo,
  _swigc__p_gsController,
  _swigc__p_gsCurve,
  _swigc__p_gsDebugger,
  _swigc__p_gsDelaySensor,
  _swigc__p_gsDeltaNodeAbstract,
  _swigc__p_gsDynamicsWorld,
  _swigc__p_gsEditObjectActuator,
  _swigc__p_gsElementAbstract,
  _swigc__p_gsEngine,
  _swigc__p_gsEngineNodeAbstract,
  _swigc__p_gsEntity,
  _swigc__p_gsExpressionController,
  _swigc__p_gsFSM,
  _swigc__p_gsFileNodeAbstract,
  _swigc__p_gsGUI,
  _swigc__p_gsGUI3D,
  _swigc__p_gsGUI3DButton,
  _swigc__p_gsGUI3DCaption,
  _swigc__p_gsGUI3DCheckbox,
  _swigc__p_gsGUI3DCombobox,
  _swigc__p_gsGUI3DElement,
  _swigc__p_gsGUI3DListbox,
  _swigc__p_gsGUI3DProgressbar,
  _swigc__p_gsGUI3DRectangle,
  _swigc__p_gsGUI3DScriptCallback,
  _swigc__p_gsGUI3DScrollbar,
  _swigc__p_gsGUI3DTextField,
  _swigc__p_gsGameActuator,
  _swigc__p_gsGameObject,
  _swigc__p_gsGameObjectInstance,
  _swigc__p_gsGorilla,
  _swigc__p_gsGorillaLineList,
  _swigc__p_gsGorillaRectangle,
  _swigc__p_gsGorillaScreen,
  _swigc__p_gsGorillaScreen3D,
  _swigc__p_gsGorillaScreenFunctions,
  _swigc__p_gsGorillaText,
  _swigc__p_gsGuiDataFormatter,
  _swigc__p_gsGuiDataSource,
  _swigc__p_gsGuiDocumentRocket,
  _swigc__p_gsGuiElement,
  _swigc__p_gsGuiElementEventListener,
  _swigc__p_gsGuiElementQuery,
  _swigc__p_gsHUD,
  _swigc__p_gsHUDElement,
  _swigc__p_gsILogicSocket,
  _swigc__p_gsIfNodeAbstract,
  _swigc__p_gsJoystick,
  _swigc__p_gsJoystickButtonAbstract,
  _swigc__p_gsJoystickNodeAbstract,
  _swigc__p_gsKeyNodeAbstract,
  _swigc__p_gsKeyboard,
  _swigc__p_gsKeyboardSensor,
  _swigc__p_gsLight,
  _swigc__p_gsLogicManager,
  _swigc__p_gsLogicNode,
  _swigc__p_gsLogicObject,
  _swigc__p_gsLogicOpController,
  _swigc__p_gsLogicTree,
  _swigc__p_gsLuaManager,
  _swigc__p_gsLuaNodeAbstract,
  _swigc__p_gsLuaScript,
  _swigc__p_gsLuaStream,
  _swigc__p_gsMathNodeAbstract,
  _swigc__p_gsMatrix4,
  _swigc__p_gsMesh,
  _swigc__p_gsMessageActuator,
  _swigc__p_gsMessageGetAbstract,
  _swigc__p_gsMessageListenerCallback,
  _swigc__p_gsMessageManager,
  _swigc__p_gsMessageSendAbstract,
  _swigc__p_gsMessageSensor,
  _swigc__p_gsMotionActuator,
  _swigc__p_gsMotionNodeAbstract,
  _swigc__p_gsMouse,
  _swigc__p_gsMouseButtonAbstract,
  _swigc__p_gsMouseNodeAbstract,
  _swigc__p_gsMouseSensor,
  _swigc__p_gsMultiTouchState,
  _swigc__p_gsNavPath,
  _swigc__p_gsNearSensor,
  _swigc__p_gsNetwork,
  _swigc__p_gsNoOpAbstract,
  _swigc__p_gsNodeTreeNodeAbstract,
  _swigc__p_gsObject,
  _swigc__p_gsObjectDataAbstract,
  _swigc__p_gsObjectManipulatorAbstract,
  _swigc__p_gsObjectNodeAbstract,
  _swigc__p_gsPBSMaterialAbstract,
  _swigc__p_gsPBSSlotAbstract,
  _swigc__p_gsPBSTex_AlbedoAbstract,
  _swigc__p_gsPBSTex_EnvAbstract,
  _swigc__p_gsPBSTex_F0Abstract,
  _swigc__p_gsPBSTex_NormalAbstract,
  _swigc__p_gsParentActuator,
  _swigc__p_gsParticles,
  _swigc__p_gsPickRayNodeAbstract,
  _swigc__p_gsPrintNodeAbstract,
  _swigc__p_gsProcedural,
  _swigc__p_gsProcess,
  _swigc__p_gsProcessManager,
  _swigc__p_gsProperty,
  _swigc__p_gsPropertyAbstract,
  _swigc__p_gsPropertyActuator,
  _swigc__p_gsPropertyGetAbstract,
  _swigc__p_gsPropertySensor,
  _swigc__p_gsQuaternion,
  _swigc__p_gsRadarSensor,
  _swigc__p_gsRandomActuator,
  _swigc__p_gsRandomSensor,
  _swigc__p_gsRay,
  _swigc__p_gsRaySensor,
  _swigc__p_gsRayTest,
  _swigc__p_gsRecastDebugger,
  _swigc__p_gsRectangleDesigned,
  _swigc__p_gsScene,
  _swigc__p_gsSceneActuator,
  _swigc__p_gsScreenActionAbstract,
  _swigc__p_gsScriptController,
  _swigc__p_gsSensor,
  _swigc__p_gsSeqFinishedAbstract,
  _swigc__p_gsSeqTimeAbstract,
  _swigc__p_gsSequenceAbstract,
  _swigc__p_gsSkeleton,
  _swigc__p_gsSoundActuator,
  _swigc__p_gsSoundManager,
  _swigc__p_gsSoundNodeAbstract,
  _swigc__p_gsSource,
  _swigc__p_gsSprite,
  _swigc__p_gsStateAbstract,
  _swigc__p_gsStateActuator,
  _swigc__p_gsStateMachineAbstract,
  _swigc__p_gsStateMachineRefAbstract,
  _swigc__p_gsStateManipulatorAbstract,
  _swigc__p_gsStateRefAbstract,
  _swigc__p_gsStateTransitionAbstract,
  _swigc__p_gsStaticBatch,
  _swigc__p_gsSteerGroup,
  _swigc__p_gsSteerObject,
  _swigc__p_gsSteerObstacleGroup,
  _swigc__p_gsSteerPathFollowing,
  _swigc__p_gsSteerRayObstacle,
  _swigc__p_gsSteerSweptObstacle,
  _swigc__p_gsSubMesh,
  _swigc__p_gsSweptTest,
  _swigc__p_gsTemplaterNodeAbstract,
  _swigc__p_gsTestNodeAbstract,
  _swigc__p_gsTextureAtlas,
  _swigc__p_gsTimerNodeAbstract,
  _swigc__p_gsTouch,
  _swigc__p_gsTouchSensor,
  _swigc__p_gsTween,
  _swigc__p_gsTypeBoolAbstract,
  _swigc__p_gsTypeColorAbstract,
  _swigc__p_gsTypeFloatAbstract,
  _swigc__p_gsTypeIntAbstract,
  _swigc__p_gsUserDefs,
  _swigc__p_gsVariable,
  _swigc__p_gsVector2,
  _swigc__p_gsVector3,
  _swigc__p_gsVector4,
  _swigc__p_gsVectorDecompAbstract,
  _swigc__p_gsVehicle,
  _swigc__p_gsVehicleGearAbstract,
  _swigc__p_gsVehicleGearboxAbstract,
  _swigc__p_gsVehicleNodeAbstract,
  _swigc__p_gsVehicleWheelAbstract,
  _swigc__p_gsVisibilityActuator,
  _swigc__p_gsWhenEvent,
  _swigc__p_int,
  _swigc__p_std__string,
  _swigc__p_tsPanel,
  _swigc__p_tsScriptCallbackList,
  _swigc__p_utArrayT_gkGameObject_p_t,
  _swigc__p_utArrayT_gkLogicActuator_p_t,
  _swigc__p_utArrayT_gkLogicController_p_t,
  _swigc__p_utArrayT_gkLogicLink_p_t,
  _swigc__p_utArrayT_gkLogicSensor_p_t,
  _swigc__p_utArrayT_gkPhysicsConstraintProperties_t,
  _swigc__p_utArrayT_gkProcess_p_t,
  _swigc__p_utArrayT_gkString_t,
  _swigc__p_utArrayT_gkVector3_t,
  _swigc__p_utArrayT_utArrayT_gkVector3_t_t,
  _swigc__p_utMemoryStream,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
void SWIG_init_user(lua_State* L );
    
#ifdef __cplusplus
extern "C" {
#endif
/* this is the initialization function
  added at the very end of the code
  the function is always called SWIG_init, but an earlier #define will rename it
*/
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
LUALIB_API int SWIG_init(lua_State* L)
#else
SWIGEXPORT int SWIG_init(lua_State* L) /* default Lua action */
#endif
{
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC) /* valid for both Lua and eLua */
  int i;
  int globalRegister = 0;
  /* start with global table */
  lua_pushglobaltable (L);
  /* SWIG's internal initialisation */
  SWIG_InitializeModule((void*)L);
  SWIG_PropagateClientData();
#endif

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)) || defined(SWIG_LUA_ELUA_EMULATE)
  /* add a global fn */
  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_class_equal);
#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* set up base class pointers (the hierarchy) */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
#ifdef SWIG_LUA_MODULE_GLOBAL
  globalRegister = 1;
#endif


#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  SWIG_Lua_namespace_register(L,&swig_SwigModule, globalRegister);
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_elua_class_register_instance(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
#endif

#if defined(SWIG_LUA_ELUA_EMULATE)
  lua_newtable(L);
  SWIG_Lua_elua_emulate_register(L,swig_SwigModule.ns_methods);
  SWIG_Lua_elua_emulate_register_clear(L);
  if(globalRegister) {
    lua_pushstring(L,swig_SwigModule.name);
    lua_pushvalue(L,-2);
    lua_rawset(L,-4);
  }
#endif

#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* invoke user-specific initialization */
  SWIG_init_user(L);
  /* end module */
  /* Note: We do not clean up the stack here (Lua will do this for us). At this
     point, we have the globals table and out module table on the stack. Returning
     one value makes the module table the result of the require command. */
  return 1;
#else
  return 0;
#endif
}

#ifdef __cplusplus
}
#endif


const char* SWIG_LUACODE=
  "";

void SWIG_init_user(lua_State* L)
{
  /* exec Lua code if applicable */
  SWIG_Lua_dostring(L,SWIG_LUACODE);
}

