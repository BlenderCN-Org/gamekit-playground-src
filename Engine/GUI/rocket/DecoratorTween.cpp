/*
-------------------------------------------------------------------------------
    This file is part of ogrekit.
    http://gamekit.googlecode.com/

    Copyright (c) 2006-2013 Thomas Trocha (dertom)

-------------------------------------------------------------------------------
  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
-------------------------------------------------------------------------------
*/

#include "DecoratorTween.h"
#include "gkLogger.h"
#include <Rocket/Core.h>
#include <Core/ElementStyle.h>
#include "Core/ElementDefinition.h"
#include <Rocket/Core/String.h>
#include "gkString.h"
#include "gkValue.h"
#include "gkGUIManager.h"
#include "gkTweenManager.h"
#include "gsGUI.h"


using namespace Rocket::Core;

DecoratorTween::~DecoratorTween()
{
	//gkLogger::write("destructor DECORATOR:"+gkString(m_propertyName.CString()),true);
}

bool DecoratorTween::initalize(int transition,int equation,float time,float wait,Rocket::Core::String propertyName,const Property* dstProp,const gkString& unit,
								int repeat,bool withReverse,bool infinite,Rocket::Core::String eventFunction,Rocket::Core::String eventInline)
{
	//gkLogger::write("NEW DECORATOR:"+gkString(propertyName.CString()),true);

	m_transition = transition;
	m_equation = equation;
	m_time = time;
	m_wait = wait;
	m_propertyName = propertyName;
	m_eventFunction = eventFunction;
	m_eventInline = eventInline;

	if (!dstProp)
		return false;

	if (dstProp->unit==Property::COLOUR){
		Colourb color = dstProp->Get<Colourb>();
		m_dstValue = color.red;
		m_dstValue2 = color.green;
		m_dstValue3 = color.blue;
		m_dstValue4 = color.alpha;
	} else
	{
		m_dstValue = dstProp->Get<float>();
	}

	m_unit = unit;
	m_repeatTimes = repeat;
	m_withReverse = withReverse;
	m_infinite = infinite;

	//gkLogger::write("CREATED TWEENER!!!!",true);

	if (propertyName.Empty())
		return false;
	else
		return true;


}
// Called on a decorator to generate any required per-element data for a newly decorated element.
DecoratorDataHandle DecoratorTween::GenerateElementData(Element* element)
{




////	if (!element->decoratorActive(this))
////		return NULL;
//	// is there a tween for this element running?
//	DecoratorTween::TweenLogic* tLogic = DecoratorTween::getTweenLogic(element,gkString(m_propertyName.CString()));
//
//	if (tLogic) {
//		// overwrite only if from different definition
//		if (tLogic->m_decoTween != this || tLogic->m_cancel){
//			DecoratorTween::TweenLogic* newLogic = new DecoratorTween::TweenLogic(element,dstProperty,m_propertyName,this);
//			// this will cancel the old one as well...at least it should
//			DecoratorTween::setTweenLogic(element,gkString(m_propertyName.CString()),newLogic);
//		}
//	} else {
//		DecoratorTween::TweenLogic* newLogic = new DecoratorTween::TweenLogic(element,dstProperty,m_propertyName,this);
//		// this will cancel the old one as well...at least it should
//		DecoratorTween::setTweenLogic(element,gkString(m_propertyName.CString()),newLogic);
//	}

	return NULL;
}

// Called to release element data generated by this decorator.
void DecoratorTween::ReleaseElementData(DecoratorDataHandle element_data)
{
	//gkLogger::write("ReleaseElementData Tween!",true);
}

// Called to render the decorator on an element.
void DecoratorTween::RenderElement(Element* element, DecoratorDataHandle ROCKET_UNUSED(element_data))
{
	DecoratorTween::TweenLogic* tLogic = getTweenLogic(element,m_propertyName.CString());
	// check if there is a tween that should be started




	if ( !tLogic || (tLogic && tLogic->m_decoTween!=this)){
		const Property* dstProperty = element->GetProperty(m_propertyName);


	//
		if (!dstProperty) {
			gkLogger::write("Unknown property:"+gkString(m_propertyName.CString()),true);
			return;
		}

		if (!isCurrentValueNotDest(dstProperty)) {
			return;
		}

		DecoratorTween::TweenLogic* newLogic = new DecoratorTween::TweenLogic(element,dstProperty,m_propertyName,this,gkString(m_eventFunction.CString()),gkString(m_eventInline.CString()));
				// this will cancel the old one as well...at least it should
		DecoratorTween::setTweenLogic(element,gkString(m_propertyName.CString()),newLogic);
		newLogic->start();

	}

}

#define convert(x) gkToString(x)


bool DecoratorTween::TweenLogic::onTweenStep()
{

	if (m_isColor)
	{
		gkString col("rgba("+convert((int)m_tweenValue)+","+convert((int)m_tweenValue2)+","+convert((int)m_tweenValue3)+","+convert((int)m_tweenValue4)+");");
		m_element->SetProperty(m_propertyName,gkString("rgba("+convert((int)m_tweenValue)+","+convert((int)m_tweenValue2)+","+convert((int)m_tweenValue3)+","+convert((int)m_tweenValue4)+");").c_str());

	}
	else
		m_element->SetProperty(m_propertyName,(convert(m_tweenValue)+m_unit).c_str());
	
//	gkLogger::write(gkString(m_element->GetId().CString())+": tweenStep:"+convert(m_tweenValue),true);

	const ElementDefinition* currentDef = m_element->GetStyle()->GetDefinition();
	
	return !m_cancel;
}

void DecoratorTween::TweenLogic::onTweenComplete()
{
//	m_element->Update();
//	m_element->UpdateLayout();
	int tweens = gkGUIManager::getSingleton().getTweenManager()->getTweener().total_tweens;
//	gkLogger::write("Still active:"+gkToString(tweens)+" Tween finished! "+gkToString(m_tweenValue)+" --> "+gkString(m_element->GetProperty(m_propertyName)->ToString().CString()),true);

	if (DecoratorTween::getTweenLogic(m_element,gkString(m_propertyName.CString()))==this) {
		DecoratorTween::removeTweenLogic(m_element,gkString(m_propertyName.CString()));
		// finally to be sure set the value to the destination-values
		if (m_isColor)
		{
			//gkString col("rgba("+convert((int)m_tweenValue)+","+convert((int)m_tweenValue2)+","+convert((int)m_tweenValue3)+","+convert((int)m_tweenValue4)+");");
			m_element->SetProperty(m_propertyName,
					gkString(
							"rgba(" + convert((int)m_decoTween->m_dstValue)
									+ ","
									+ convert((int)m_decoTween->m_dstValue2)
									+ ","
									+ convert((int)m_decoTween->m_dstValue3)
									+ ","
									+ convert((int)m_decoTween->m_dstValue4)
									+ ");").c_str());

		}
		else
			m_element->SetProperty(m_propertyName,(convert(m_decoTween->m_dstValue)+m_unit).c_str());

		callEventScripts("tween_end");


	}
	delete this;
}

void DecoratorTween::TweenLogic::callEventScripts(const gkString& eventName)
{
	// do we have an inline-script attached to event-inline-property?
	if (m_inlineScript)
	{


		gkGUI::CURRENT_RCSSEVENT_NAME=eventName;
		gkGUI::CURRENT_RCSSEVENT_ELEMENT=m_element;
		gkGUI::CURRENT_RCSSEVENT_PROPERTY=m_propertyName.CString();
		m_inlineScript->execute();
		gkGUI::CURRENT_RCSSEVENT_NAME="";
		gkGUI::CURRENT_RCSSEVENT_ELEMENT=0;
		gkGUI::CURRENT_RCSSEVENT_PROPERTY="";
	}

	// did we register an event for being called after finishing the tween ( event-callback:...)
	if (!m_eventFunction.empty())
	{
		gkLuaEvent* evt = gkLuaManager::getSingleton().getFunction(m_eventFunction);

		if (evt)
		{
			evt->beginCall();
			// event-type
			evt->addArgument(eventName);
			// the element
			// TODO: get the element out of the table that maps gs<->gk-elements
			// property
			evt->addArgument("gsGuiElement *",new gsGuiElement(m_element),1);
			evt->addArgument((char*)m_propertyName.CString());
			bool result = evt->call();
		}
		else
		{
			gkLogger::logScreenConsole("ERROR(TweenEvent): Couldn't find function with name '"+m_eventFunction+"' in gkLuaManager functionMap");
		}
	}
}

void DecoratorTween::TweenLogic::start()
{
	m_running = true;

	gkTweenManager* tweenM = gkGUIManager::getSingleton().getTweenManager();

	// the style this decorator is attached to
	if (m_property->unit == Property::COLOUR)
	{
		Colourb color = m_property->Get<Colourb>();
		m_tweenValue = color.red;
		m_tweenValue2 = color.green;
		m_tweenValue3 = color.blue;
		m_tweenValue4 = color.alpha;
		m_isColor = true;
	}
	else
	{
		m_tweenValue = m_property->Get<float>();
	}
//
	// only start the tween if the currentValue is different to the tweenValue
	// TODO: add e
	if ( (!m_isColor && m_tweenValue!=m_decoTween->m_dstValue)
	   ||(m_isColor && (m_tweenValue!=m_decoTween->m_dstValue
			   || m_tweenValue2!=m_decoTween->m_dstValue2
			   || m_tweenValue3!=m_decoTween->m_dstValue3
			   || m_tweenValue4!=m_decoTween->m_dstValue4 ))
	   )
	{
		tween::TweenerParam param = tween::TweenerParam(m_decoTween->m_time*1000,m_decoTween->m_transition,m_decoTween->m_equation,m_decoTween->m_wait*1000);
		param.addProperty(&m_tweenValue, m_decoTween->m_dstValue);
		if (m_isColor) {
			param.addProperty(&m_tweenValue2, m_decoTween->m_dstValue2);
			param.addProperty(&m_tweenValue3, m_decoTween->m_dstValue3);
			param.addProperty(&m_tweenValue4, m_decoTween->m_dstValue4);
		}
		param.setRepeatWithReverse(m_decoTween->m_repeatTimes,m_decoTween->m_withReverse);
		param.callback = this;
		param.setInfinite(m_decoTween->m_infinite);
		tweenM->addTween(param);

		callEventScripts("tween_start");
		//gkLogger::write("started Tween! "+gkToString(m_decoTween->m_wait),true);

	}
	else {
		onTweenComplete();
	}


}



DecoratorTween::TweenLogicMap DecoratorTween::m_tweenMap;
void DecoratorTween::setTweenLogic(Element* elem, const gkString& property, TweenLogic* newLogic)
{
	// check if the element has a propertymap
	UTsize pos = m_tweenMap.find(elem);
	PropertyLogicMap* propMap = 0;
	if (pos == UT_NPOS)
	{
		propMap = new PropertyLogicMap;
		m_tweenMap.insert(utPointerHashKey(elem),propMap);
	}
	else
	{
		propMap = static_cast<PropertyLogicMap*>(m_tweenMap.at(pos));
	}

	TweenLogic* currentLogic = 0;
	pos = propMap->find(utCharHashKey(property.c_str()));
	if (pos!=UT_NPOS) {
		currentLogic = propMap->at(pos);
	}

	if (currentLogic) {
		if ((currentLogic)->m_decoTween!=newLogic->m_decoTween  )
		{
			(currentLogic)->m_cancel=true;
			propMap->remove(utCharHashKey(property.c_str()));
		}
		else // already have a tween (maybe there will be a usecase someday to overwrite or modfy the tween!?
			return;
	}
	(propMap)->insert(utCharHashKey(property.c_str()),newLogic);
}

DecoratorTween::TweenLogic* DecoratorTween::getTweenLogic(Element* elem, const gkString& property)
{
	// check if the element has a propertymap
	UTsize pos = m_tweenMap.find(elem);
	PropertyLogicMap* propMap = 0;
	if (pos == UT_NPOS)
	{
		return 0;
	}
	else
	{
		propMap = static_cast<PropertyLogicMap*>(m_tweenMap.at(pos));
	}

	TweenLogic* currentLogic = 0;
	pos = propMap->find(utCharHashKey(property.c_str()));
	if (pos!=UT_NPOS) {
		currentLogic = propMap->at(pos);
	}

	if (currentLogic)
		return currentLogic;
	else
		return 0;
}

bool DecoratorTween::hasTweenLogic(Element* elem, const gkString& property)
{
	return getTweenLogic(elem,property)!=0;
}

void DecoratorTween::removeTweenLogic(Element* elem, const gkString& property)
{
	// check if the element has a propertymap
	UTsize pos = m_tweenMap.find(elem);
	PropertyLogicMap* propMap = 0;
	if (pos == UT_NPOS)
	{
		// There can't be an element if the hashtable isn'T there!
		return;
	}
	else
	{
		propMap = static_cast<PropertyLogicMap*>(m_tweenMap.at(pos));
	}

	TweenLogic* currentLogic = 0;
	pos = propMap->find(utCharHashKey(property.c_str()));
	if (pos!=UT_NPOS) {
		currentLogic = propMap->at(pos);
	}

	if (currentLogic)
	{
		(currentLogic)->m_cancel=true;
	}

	(propMap)->remove(utCharHashKey(property.c_str()));
}
