/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGLUA
#define SWIG_LUA_MODULE_GLOBAL


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>
#include <lauxlib.h>
#include <stdlib.h>  /* for malloc */
#include <assert.h>  /* for a few sanity tests */

/* -----------------------------------------------------------------------------
 * global swig types
 * ----------------------------------------------------------------------------- */
/* Constant table */
#define SWIG_LUA_INT     1
#define SWIG_LUA_FLOAT   2
#define SWIG_LUA_STRING  3
#define SWIG_LUA_POINTER 4
#define SWIG_LUA_BINARY  5
#define SWIG_LUA_CHAR    6

/* Structure for variable linking table */
typedef struct {
  const char *name;
  lua_CFunction get;
  lua_CFunction set;
} swig_lua_var_info;

/* Constant information structure */
typedef struct {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_lua_const_info;

typedef struct {
  const char     *name;
  lua_CFunction   method;
} swig_lua_method;

typedef struct {
  const char     *name;
  lua_CFunction   getmethod;
  lua_CFunction   setmethod;
} swig_lua_attribute;

typedef struct swig_lua_class {
  const char    *name;
  swig_type_info   **type;
  lua_CFunction  constructor;
  void    (*destructor)(void *);
  swig_lua_method   *methods;
  swig_lua_attribute     *attributes;
  struct swig_lua_class **bases;
  const char **base_names;
} swig_lua_class;

/* this is the struct for wrappering all pointers in SwigLua
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  void        *ptr;
} swig_lua_userdata;

/* this is the struct for wrapping arbitary packed binary data
(currently it is only used for member function pointers)
the data ordering is similar to swig_lua_userdata, but it is currently not possible
to tell the two structures apart within SWIG, other than by looking at the type
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  char data[1];       /* arbitary amount of data */    
} swig_lua_rawdata;

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else

/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(func_name,argnum,type) \
  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
  goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
#define SWIG_check_num_args(func_name,a,b) \
  if (lua_gettop(L)<a || lua_gettop(L)>b) \
  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
  goto fail;}


#define SWIG_Lua_get_table(L,n) \
  (lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
  (lua_pushstring(L, n), \
      lua_pushcfunction(L, f), \
      lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
//#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
#endif

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State* L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
    ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);  /* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* this function is called when trying to set an immutable.
default value is to print an error.
This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
SWIGINTERN int SWIG_Lua_set_immutable(lua_State* L)
{
/*  there should be 1 param passed in: the new value */
#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
  lua_pop(L,1);  /* remove it */
  lua_pushstring(L,"This variable is immutable");
  lua_error(L);
#endif
    return 0;   /* should not return anything */
}

/* the module.get method used for getting linked data */
SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  printf("SWIG_Lua_module_get %p(%s) '%s'\n",
   lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
   lua_tostring(L,2));
*/
  /* get the metatable */
  assert(lua_istable(L,1));  /* just in case */
  lua_getmetatable(L,1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get");  /* get the .get table */
  lua_remove(L,3);  /* remove metatable */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .get table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,3);  /* remove .get */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_call(L,0,1);
      return 1;
    }
    lua_pop(L,1);  /* remove the top */
  }
  lua_pop(L,1);  /* remove the .get */
  lua_pushnil(L);  /* return a nil */
    return 1;
}

/* the module.set method used for setting linked data */
SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
*/
  /* get the metatable */
  assert(lua_istable(L,1));  /* just in case */
  lua_getmetatable(L,1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".set");  /* get the .set table */
  lua_remove(L,4);  /* remove metatable */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,4);  /* remove .set */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,1,0);
      return 0;
    }
  }
  lua_settop(L,3);  /* reset back to start */
  /* we now have the table, key & new value, so just set directly */
  lua_rawset(L,1);  /* add direct */
  return 0;
}

/* registering a module in lua. Pushes the module table on the stack. */
SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushstring(L,name);
  lua_newtable(L);   /* the table */
  /* add meta table */
  lua_newtable(L);    /* the meta table */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
  lua_pushstring(L,".get");
  lua_newtable(L);    /* the .get table */
  lua_rawset(L,-3);  /* add .get into metatable */
  lua_pushstring(L,".set");
  lua_newtable(L);    /* the .set table */
  lua_rawset(L,-3);  /* add .set into metatable */
  lua_setmetatable(L,-2);  /* sets meta table in module */
#ifdef SWIG_LUA_MODULE_GLOBAL
  /* If requested, install the module directly into the global namespace. */
  lua_rawset(L,-3);        /* add module into parent */
  SWIG_Lua_get_table(L,name);   /* get the table back out */
#else
  /* Do not install the module table as global name. The stack top has
     the module table with the name below. We pop the top and replace
     the name with it. */
  lua_replace(L,-2);
#endif
}

/* ending the register */
SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
{
  lua_pop(L,1);       /* tidy stack (remove module) */
}

/* adding a linked variable to the module */
SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_getmetatable(L,-1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* should be a table: */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)  /* if there is a set fn */
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* should be a table: */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
  lua_pop(L,1);       /* tidy stack (remove meta) */
}

/* adding a function module */
SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
{
  SWIG_Lua_add_function(L,name,fn);
}

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

/* the class.get method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  /* look for the key in the .get table */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* NEW: looks for the __getitem() fn
  this is a user provided get fn */
  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  return 0;  /* sorry not known */
}

/* the class.set method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
      lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
      lua_tostring(L,2),
      lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/

  assert(lua_isuserdata(L,1));  /* just in case */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,1);  /* userdata */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,2,0);
      return 0;
    }
    lua_pop(L,1);  /* remove the value */
  }
  lua_pop(L,1);  /* remove the value .set table */
  /* NEW: looks for the __setitem() fn
  this is a user provided set fn */
  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_pushvalue(L,3);  /* the value */
    lua_call(L,3,0);  /* 3 values in ,0 out */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata* usr;
  swig_lua_class* clss;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  /* if must be destroyed & has a destructor */
  if (usr->own) /* if must be destroyed */
  {
    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
    if (clss && clss->destructor)  /* there is a destroy fn */
    {
      clss->destructor(usr->ptr);  /* bye bye */
    }
  }
  return 0;
}

/* gets the swig class registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
{
  /* add this all into the swig registry: */
  lua_pushstring(L,"SWIG");
  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
  if (!lua_istable(L,-1))  /* not there */
  {  /* must be first time, so add it */
    lua_pop(L,1);  /* remove the result */
    lua_pushstring(L,"SWIG");
    lua_newtable(L);
    lua_rawset(L,LUA_REGISTRYINDEX);
    /* then get it */
    lua_pushstring(L,"SWIG");
    lua_rawget(L,LUA_REGISTRYINDEX);
  }
}

/* helper fn to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
{
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,cname);  /* get the name */
  lua_rawget(L,-2);    /* get it */
  lua_remove(L,-2);    /* tidy up (remove registry) */
}

/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* just in case */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
}

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
{
  int i;
  /* call all the base classes first: we can then override these later: */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_add_class_details(L,clss->bases[i]);
  }
  /* add fns */
  for(i=0;clss->attributes[i].name;i++){
    SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
  }
  /* add methods to the metatable */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->methods[i].name;i++){
    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
  }
  lua_pop(L,1);       /* tidy stack (remove table) */
  /*   add operator overloads
    these look ANY method which start with "__" and assume they
    are operator overloads & add them to the metatable
    (this might mess up is someone defines a method __gc (the destructor)*/
  for(i=0;clss->methods[i].name;i++){
    if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
      SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
    }
  }
}

/* set up the base classes pointers.
Each class structure has a list of pointers to the base class structures.
This function fills them.
It cannot be done at compile time, as this will not work with hireachies
spread over more than one swig file. 
Therefore it must be done at runtime, querying the SWIG type system.
*/
SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
{
  int i=0;
  swig_module_info* module=SWIG_GetModule(L);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* not found yet */
    {
      /* lookup and cache the base class */
      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
    }
  }	
}

/* performs the entire class registration process */
SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
{
  /*  add its constructor to module with the name of the class
  so you can do MyClass(...) as well as new_MyClass(...)
  BUT only if a constructor is defined
  (this overcomes the problem of pure virtual classes without constructors)*/
  if (clss->constructor)
    SWIG_Lua_add_function(L,clss->name,clss->constructor);

  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->name);  /* get the name */
  lua_newtable(L);    /* create the metatable */
  /* add string of class name called ".type" */
  lua_pushstring(L,".type");
  lua_pushstring(L,clss->name);
  lua_rawset(L,-3);
  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
  /* add it */
  lua_rawset(L,-3);  /* metatable into registry */
  lua_pop(L,1);      /* tidy stack (remove registry) */

  SWIG_Lua_get_class_metatable(L,clss->name);
  SWIG_Lua_add_class_details(L,clss);  /* recursive adding of details (atts & ops) */
  lua_pop(L,1);      /* tidy stack (remove class metatable) */
}

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
{
  if (type->clientdata)  /* there is clientdata: so add the metatable */
  {
    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
    if (lua_istable(L,-1))
    {
      lua_setmetatable(L,-2);
    }
    else
    {
      lua_pop(L,1);
    }
  }
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
{
  swig_lua_userdata* usr;
  if (!ptr){
    lua_pushnil(L);
    return;
  }
  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
  usr->ptr=ptr;  /* set the ptr */
  usr->type=type;
  usr->own=own;
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
{
  swig_lua_userdata* usr;
  swig_cast_info *cast;
  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
  if (usr)
  {
    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
    {
        usr->own=0;
    }
    if (!type)            /* special cast void*, no casting fn */
    {
      *ptr=usr->ptr;
      return SWIG_OK; /* ok */
    }
    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
    if (cast)
    {
      int newmemory = 0;
      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
      return SWIG_OK;  /* ok */
    }
  }
  return SWIG_ERROR;  /* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
       int argnum,const char* func_name){
  void* result;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
    lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
      func_name,(type && type->str)?type->str:"void*",argnum);
    lua_error(L);
  }
  return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  assert(ptr); /* not acceptable to pass in a NULL value */
  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
  raw->type=type;
  raw->own=0;
  memcpy(raw->data,ptr,size); /* copy the data */
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
  if (!raw) return SWIG_ERROR;  /* error */
  if (type==0 || type==raw->type) /* void* or identical type */
  {
    memcpy(ptr,raw->data,size); /* copy it */
    return SWIG_OK; /* ok */
  }
  return SWIG_ERROR;  /* error */
}

/* a function to get the typestring of a piece of data */
SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
{
  swig_lua_userdata* usr;
  if (lua_isuserdata(L,tp))
  {
    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
    if (usr && usr->type && usr->type->str)
      return usr->type->str;
    return "userdata (unknown type)";
  }
  return lua_typename(L,lua_type(L,tp));
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
{
  lua_pushstring(L,SWIG_Lua_typename(L,1));
  return 1;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
{
  int result;
  swig_lua_userdata *usr1,*usr2;
  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
    return 0;  /* nil reply */
  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
  result=(usr1->ptr==usr2->ptr);
   lua_pushboolean(L,result);
  return 1;
}

/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
      lua_pushstring(L,constants[i].name);
      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
      lua_rawset(L,-3);
      break;
    default:
      break;
    }
  }
}

/* -----------------------------------------------------------------------------
 * executing lua code from within the wrapper
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
#endif
/* Executes a C string in Lua a really simple way of calling lua from C
Unfortunately lua keeps changing its API's, so we need a conditional compile
In lua 5.0.X its lua_dostring()
In lua 5.1.X its luaL_dostring()
*/
SWIGINTERN int 
SWIG_Lua_dostring(lua_State *L, const char* str) {
  int ok,top;
  if (str==0 || str[0]==0) return 0; /* nothing to do */
  top=lua_gettop(L); /* save stack */
#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
#else
  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
#endif
  if (ok!=0) {
    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
  }
  lua_settop(L,top); /* restore the stack */
  return ok;
}    

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13




/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ControlPoint swig_types[0]
#define SWIGTYPE_p_MultiShape swig_types[1]
#define SWIGTYPE_p_Ogre__Angle swig_types[2]
#define SWIGTYPE_p_Ogre__AxisAlignedBox swig_types[3]
#define SWIGTYPE_p_Ogre__Box swig_types[4]
#define SWIGTYPE_p_Ogre__ColourValue swig_types[5]
#define SWIGTYPE_p_Ogre__Degree swig_types[6]
#define SWIGTYPE_p_Ogre__HashedVectorT_Ogre__Light_p_t swig_types[7]
#define SWIGTYPE_p_Ogre__Image swig_types[8]
#define SWIGTYPE_p_Ogre__ManualObject swig_types[9]
#define SWIGTYPE_p_Ogre__Math swig_types[10]
#define SWIGTYPE_p_Ogre__Math__RandomValueProvider swig_types[11]
#define SWIGTYPE_p_Ogre__Matrix3 swig_types[12]
#define SWIGTYPE_p_Ogre__Matrix4 swig_types[13]
#define SWIGTYPE_p_Ogre__MeshPtr swig_types[14]
#define SWIGTYPE_p_Ogre__NameGenerator swig_types[15]
#define SWIGTYPE_p_Ogre__Plane swig_types[16]
#define SWIGTYPE_p_Ogre__Quaternion swig_types[17]
#define SWIGTYPE_p_Ogre__Radian swig_types[18]
#define SWIGTYPE_p_Ogre__Ray swig_types[19]
#define SWIGTYPE_p_Ogre__RenderWindowDescription swig_types[20]
#define SWIGTYPE_p_Ogre__SimpleSpline swig_types[21]
#define SWIGTYPE_p_Ogre__Sphere swig_types[22]
#define SWIGTYPE_p_Ogre__TRectT_float_t swig_types[23]
#define SWIGTYPE_p_Ogre__TRectT_long_t swig_types[24]
#define SWIGTYPE_p_Ogre__TexturePtr swig_types[25]
#define SWIGTYPE_p_Ogre__Vector2 swig_types[26]
#define SWIGTYPE_p_Ogre__Vector3 swig_types[27]
#define SWIGTYPE_p_Ogre__Vector4 swig_types[28]
#define SWIGTYPE_p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type swig_types[29]
#define SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type swig_types[30]
#define SWIGTYPE_p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type swig_types[31]
#define SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type swig_types[32]
#define SWIGTYPE_p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type swig_types[33]
#define SWIGTYPE_p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type swig_types[34]
#define SWIGTYPE_p_Path swig_types[35]
#define SWIGTYPE_p_Procedural__Abnormals swig_types[36]
#define SWIGTYPE_p_Procedural__Alpha swig_types[37]
#define SWIGTYPE_p_Procedural__AlphaMask swig_types[38]
#define SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t swig_types[39]
#define SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t swig_types[40]
#define SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t swig_types[41]
#define SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t swig_types[42]
#define SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t swig_types[43]
#define SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t swig_types[44]
#define SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t swig_types[45]
#define SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t swig_types[46]
#define SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t swig_types[47]
#define SWIGTYPE_p_Procedural__BezierCurve2 swig_types[48]
#define SWIGTYPE_p_Procedural__BezierCurve3 swig_types[49]
#define SWIGTYPE_p_Procedural__Blit swig_types[50]
#define SWIGTYPE_p_Procedural__Blur swig_types[51]
#define SWIGTYPE_p_Procedural__Boolean swig_types[52]
#define SWIGTYPE_p_Procedural__BoxGenerator swig_types[53]
#define SWIGTYPE_p_Procedural__BoxUVModifier swig_types[54]
#define SWIGTYPE_p_Procedural__CalculateNormalsModifier swig_types[55]
#define SWIGTYPE_p_Procedural__CapsuleGenerator swig_types[56]
#define SWIGTYPE_p_Procedural__CatmullRomSpline2 swig_types[57]
#define SWIGTYPE_p_Procedural__CatmullRomSpline3 swig_types[58]
#define SWIGTYPE_p_Procedural__Cell swig_types[59]
#define SWIGTYPE_p_Procedural__Channel swig_types[60]
#define SWIGTYPE_p_Procedural__Circle swig_types[61]
#define SWIGTYPE_p_Procedural__CircleShape swig_types[62]
#define SWIGTYPE_p_Procedural__CircleTexture swig_types[63]
#define SWIGTYPE_p_Procedural__Cloud swig_types[64]
#define SWIGTYPE_p_Procedural__Colours swig_types[65]
#define SWIGTYPE_p_Procedural__Combine swig_types[66]
#define SWIGTYPE_p_Procedural__ConeGenerator swig_types[67]
#define SWIGTYPE_p_Procedural__Convolution swig_types[68]
#define SWIGTYPE_p_Procedural__Crack swig_types[69]
#define SWIGTYPE_p_Procedural__CubicHermiteSpline2 swig_types[70]
#define SWIGTYPE_p_Procedural__CubicHermiteSpline3 swig_types[71]
#define SWIGTYPE_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t swig_types[72]
#define SWIGTYPE_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t swig_types[73]
#define SWIGTYPE_p_Procedural__Cycloid swig_types[74]
#define SWIGTYPE_p_Procedural__CylinderGenerator swig_types[75]
#define SWIGTYPE_p_Procedural__CylinderUVModifier swig_types[76]
#define SWIGTYPE_p_Procedural__Dilate swig_types[77]
#define SWIGTYPE_p_Procedural__Distort swig_types[78]
#define SWIGTYPE_p_Procedural__EdgeDetection swig_types[79]
#define SWIGTYPE_p_Procedural__EllipseShape swig_types[80]
#define SWIGTYPE_p_Procedural__EllipseTexture swig_types[81]
#define SWIGTYPE_p_Procedural__Extruder swig_types[82]
#define SWIGTYPE_p_Procedural__Flip swig_types[83]
#define SWIGTYPE_p_Procedural__Glow swig_types[84]
#define SWIGTYPE_p_Procedural__Gradient swig_types[85]
#define SWIGTYPE_p_Procedural__HelixPath swig_types[86]
#define SWIGTYPE_p_Procedural__HemisphereUVModifier swig_types[87]
#define SWIGTYPE_p_Procedural__IcoSphereGenerator swig_types[88]
#define SWIGTYPE_p_Procedural__Image swig_types[89]
#define SWIGTYPE_p_Procedural__IntVector2 swig_types[90]
#define SWIGTYPE_p_Procedural__Invert swig_types[91]
#define SWIGTYPE_p_Procedural__Jitter swig_types[92]
#define SWIGTYPE_p_Procedural__KochanekBartelsSpline2 swig_types[93]
#define SWIGTYPE_p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t swig_types[94]
#define SWIGTYPE_p_Procedural__Labyrinth swig_types[95]
#define SWIGTYPE_p_Procedural__Lathe swig_types[96]
#define SWIGTYPE_p_Procedural__Lerp swig_types[97]
#define SWIGTYPE_p_Procedural__Light swig_types[98]
#define SWIGTYPE_p_Procedural__Line swig_types[99]
#define SWIGTYPE_p_Procedural__Line2D swig_types[100]
#define SWIGTYPE_p_Procedural__LinePath swig_types[101]
#define SWIGTYPE_p_Procedural__Lookup swig_types[102]
#define SWIGTYPE_p_Procedural__Marble swig_types[103]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t swig_types[104]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t swig_types[105]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t swig_types[106]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t swig_types[107]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t swig_types[108]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t swig_types[109]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t swig_types[110]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t swig_types[111]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t swig_types[112]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t swig_types[113]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t swig_types[114]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t swig_types[115]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t swig_types[116]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t swig_types[117]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t swig_types[118]
#define SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t swig_types[119]
#define SWIGTYPE_p_Procedural__MultiShape swig_types[120]
#define SWIGTYPE_p_Procedural__Noise swig_types[121]
#define SWIGTYPE_p_Procedural__NoiseBase swig_types[122]
#define SWIGTYPE_p_Procedural__Normals swig_types[123]
#define SWIGTYPE_p_Procedural__OilPaint swig_types[124]
#define SWIGTYPE_p_Procedural__Path swig_types[125]
#define SWIGTYPE_p_Procedural__PerlinNoise swig_types[126]
#define SWIGTYPE_p_Procedural__Plane swig_types[127]
#define SWIGTYPE_p_Procedural__PlaneGenerator swig_types[128]
#define SWIGTYPE_p_Procedural__PlaneUVModifier swig_types[129]
#define SWIGTYPE_p_Procedural__RandomPixels swig_types[130]
#define SWIGTYPE_p_Procedural__RectangleShape swig_types[131]
#define SWIGTYPE_p_Procedural__RectangleTexture swig_types[132]
#define SWIGTYPE_p_Procedural__RotationZoom swig_types[133]
#define SWIGTYPE_p_Procedural__RoundedBoxGenerator swig_types[134]
#define SWIGTYPE_p_Procedural__RoundedCornerSpline2 swig_types[135]
#define SWIGTYPE_p_Procedural__RoundedCornerSpline3 swig_types[136]
#define SWIGTYPE_p_Procedural__Segment swig_types[137]
#define SWIGTYPE_p_Procedural__Segment2D swig_types[138]
#define SWIGTYPE_p_Procedural__Segment3D swig_types[139]
#define SWIGTYPE_p_Procedural__Shape swig_types[140]
#define SWIGTYPE_p_Procedural__Sharpen swig_types[141]
#define SWIGTYPE_p_Procedural__ShowNormalsGenerator swig_types[142]
#define SWIGTYPE_p_Procedural__Solid swig_types[143]
#define SWIGTYPE_p_Procedural__SphereGenerator swig_types[144]
#define SWIGTYPE_p_Procedural__SphereUVModifier swig_types[145]
#define SWIGTYPE_p_Procedural__SpherifyModifier swig_types[146]
#define SWIGTYPE_p_Procedural__SpringGenerator swig_types[147]
#define SWIGTYPE_p_Procedural__SvgLoader swig_types[148]
#define SWIGTYPE_p_Procedural__Textile swig_types[149]
#define SWIGTYPE_p_Procedural__TextureBuffer swig_types[150]
#define SWIGTYPE_p_Procedural__TextureProcessing swig_types[151]
#define SWIGTYPE_p_Procedural__Threshold swig_types[152]
#define SWIGTYPE_p_Procedural__TorusGenerator swig_types[153]
#define SWIGTYPE_p_Procedural__TorusKnotGenerator swig_types[154]
#define SWIGTYPE_p_Procedural__Track swig_types[155]
#define SWIGTYPE_p_Procedural__Triangle2D swig_types[156]
#define SWIGTYPE_p_Procedural__Triangle3D swig_types[157]
#define SWIGTYPE_p_Procedural__TriangleBuffer swig_types[158]
#define SWIGTYPE_p_Procedural__TriangleBuffer__Vertex swig_types[159]
#define SWIGTYPE_p_Procedural__TriangleShape swig_types[160]
#define SWIGTYPE_p_Procedural__Triangulator swig_types[161]
#define SWIGTYPE_p_Procedural__TubeGenerator swig_types[162]
#define SWIGTYPE_p_Procedural__UnweldVerticesModifier swig_types[163]
#define SWIGTYPE_p_Procedural__Vector2Comparator swig_types[164]
#define SWIGTYPE_p_Procedural__Vector3Comparator swig_types[165]
#define SWIGTYPE_p_Procedural__Vortex swig_types[166]
#define SWIGTYPE_p_Procedural__WeldVerticesModifier swig_types[167]
#define SWIGTYPE_p_Procedural__WhiteNoise swig_types[168]
#define SWIGTYPE_p_Procedural__Wood swig_types[169]
#define SWIGTYPE_p_Shape swig_types[170]
#define SWIGTYPE_p_Side swig_types[171]
#define SWIGTYPE_p_Track swig_types[172]
#define SWIGTYPE_p_Track__AddressingMode swig_types[173]
#define SWIGTYPE_p_float swig_types[174]
#define SWIGTYPE_p_int swig_types[175]
#define SWIGTYPE_p_long_long swig_types[176]
#define SWIGTYPE_p_p_char swig_types[177]
#define SWIGTYPE_p_short swig_types[178]
#define SWIGTYPE_p_signed_char swig_types[179]
#define SWIGTYPE_p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[180]
#define SWIGTYPE_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator swig_types[181]
#define SWIGTYPE_p_std__pairT_bool_float_t swig_types[182]
#define SWIGTYPE_p_std__string swig_types[183]
#define SWIGTYPE_p_std__vectorT_Ogre__Vector2_t swig_types[184]
#define SWIGTYPE_p_std__vectorT_Ogre__Vector2_t__size_type swig_types[185]
#define SWIGTYPE_p_std__vectorT_Ogre__Vector3_t swig_types[186]
#define SWIGTYPE_p_std__vectorT_Procedural__Path_t swig_types[187]
#define SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t swig_types[188]
#define SWIGTYPE_p_std__vectorT_Procedural__Vertex_t swig_types[189]
#define SWIGTYPE_p_std__vectorT_Segment2D_t swig_types[190]
#define SWIGTYPE_p_std__vectorT_Segment3D_t swig_types[191]
#define SWIGTYPE_p_std__vectorT_int_t swig_types[192]
#define SWIGTYPE_p_unsigned_char swig_types[193]
#define SWIGTYPE_p_unsigned_int swig_types[194]
#define SWIGTYPE_p_unsigned_long swig_types[195]
#define SWIGTYPE_p_unsigned_long_long swig_types[196]
#define SWIGTYPE_p_unsigned_short swig_types[197]
static swig_type_info *swig_types[199];
static swig_module_info swig_module = {swig_types, 198, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_name      "Procedural"
#define SWIG_init      luaopen_Procedural
#define SWIG_init_user luaopen_Procedural_user

#define SWIG_LUACODE   luaopen_Procedural_luacode


namespace swig {
typedef struct{} LANGUAGE_OBJ;
}


#include <stdexcept>


#define SWIG_exception(a,b)\
{ lua_pushfstring(L,"%s:%s",#a,b);SWIG_fail; }


#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>


	#include <string>


SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
  int ret = lua_isstring(L, idx);
  if (!ret)
   ret = lua_isnil(L, idx);
  return ret;
}


#include <vector>

 
 #include "Ogre.h" 
 #include <hash_map>
 
 
 #include "Procedural.h"
 //#include "ScriptInterpreter.h"
 using namespace Procedural;
 
SWIGINTERN Procedural::Segment2D std_vector_Sl_Procedural_Segment2D_Sg____getitem__(std::vector< Procedural::Segment2D > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_Procedural_Segment2D_Sg____setitem__(std::vector< Procedural::Segment2D > *self,unsigned int idx,Procedural::Segment2D val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_new_string__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  std::string *result = 0 ;
  
  SWIG_check_num_args("std::string::string",0,0)
  result = (std::string *)new std::string();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_string__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_num_args("std::string::string",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("std::string::string",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (std::string *)new std::string((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_string(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_string__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = SWIG_lua_isnilstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_string__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_string'\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::string::string()\n"
    "    std::string::string(char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_string_size(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::string::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::size",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_size",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_length(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::string::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::length",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_length",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_empty(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  bool result;
  
  SWIG_check_num_args("std::string::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::empty",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_empty",1,SWIGTYPE_p_std__string);
  }
  
  result = (bool)((std::string const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_c_str(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("std::string::c_str",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::c_str",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_c_str",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->c_str();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_data(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("std::string::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::data",1,"std::string const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_data",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->data();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_string_assign(lua_State* L) {
  int SWIG_arg = 0;
  std::string *arg1 = (std::string *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("std::string::assign",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::assign",1,"std::string *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("std::string::assign",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_assign",1,SWIGTYPE_p_std__string);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->assign((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_string(void *obj) {
std::string *arg1 = (std::string *) obj;
delete arg1;
}
static swig_lua_method swig_std_string_methods[] = {
    {"size", _wrap_string_size}, 
    {"length", _wrap_string_length}, 
    {"empty", _wrap_string_empty}, 
    {"c_str", _wrap_string_c_str}, 
    {"data", _wrap_string_data}, 
    {"assign", _wrap_string_assign}, 
    {0,0}
};
static swig_lua_attribute swig_std_string_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_string_bases[] = {0};
static const char *swig_std_string_base_names[] = {0};
static swig_lua_class _wrap_class_std_string = { "string", &SWIGTYPE_p_std__string,_wrap_new_string, swig_delete_string, swig_std_string_methods, swig_std_string_attributes, swig_std_string_bases, swig_std_string_base_names };

static int _wrap_Vector2_x_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector2::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::x",1,"Ogre::Vector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::x",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_x_set",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_x_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::x",1,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_x_get",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_y_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector2::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::y",1,"Ogre::Vector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::y",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_y_set",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::y",1,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_y_get",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",0,0)
  result = (Ogre::Vector2 *)new Ogre::Vector2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector2::Vector2",1,"Ogre::Real const");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::Vector2",2,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = (Ogre::Vector2 *)new Ogre::Vector2(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector2::Vector2",1,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  result = (Ogre::Vector2 *)new Ogre::Vector2(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::Vector2",1,"Ogre::Real const [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector2",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector2 *)new Ogre::Vector2((Ogre::Real const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  int *arg1 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::Vector2",1,"int const [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("new_Vector2",1,SWIGTYPE_p_int);
  }
  
  result = (Ogre::Vector2 *)new Ogre::Vector2((int const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 = (Ogre::Real *) (Ogre::Real *)0 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::Vector2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::Vector2",1,"Ogre::Real *const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector2",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector2 *)new Ogre::Vector2(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector2__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector2__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_int, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector2__SWIG_4(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector2__SWIG_5(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Vector2__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Vector2__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Vector2'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector2::Vector2()\n"
    "    Ogre::Vector2::Vector2(Ogre::Real const,Ogre::Real const)\n"
    "    Ogre::Vector2::Vector2(Ogre::Real const)\n"
    "    Ogre::Vector2::Vector2(Ogre::Real const [2])\n"
    "    Ogre::Vector2::Vector2(int const [2])\n"
    "    Ogre::Vector2::Vector2(Ogre::Real *const)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector2_swap(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::swap",1,"Ogre::Vector2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::swap",2,"Ogre::Vector2 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_swap",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_swap",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  (arg1)->swap(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_ptr__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::ptr",1,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_ptr",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real *)(arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_ptr__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::ptr",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_ptr",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real *)((Ogre::Vector2 const *)arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_ptr(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector2_ptr__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector2_ptr__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector2_ptr'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector2::ptr()\n"
    "    Ogre::Vector2::ptr() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector2___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector2::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator ==",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator ==",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___eq",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___eq",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Ogre::Vector2 const *)arg1)->operator ==((Ogre::Vector2 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___add__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator +",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator +",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___add",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___add",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->operator +((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___sub(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator -",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator -",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___sub",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___sub",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->operator -((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator *",1,"Ogre::Vector2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::operator *",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___mul",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector2 const *)arg1)->operator *(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator *",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator *",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___mul",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___mul",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->operator *((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector2___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector2___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector2___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector2::operator *(Ogre::Real const) const\n"
    "    Ogre::Vector2::operator *(Ogre::Vector2 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector2___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator /",1,"Ogre::Vector2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::operator /",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___div",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector2 const *)arg1)->operator /(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator /",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator /",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___div",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___div",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->operator /((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector2___div__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector2___div__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector2___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector2::operator /(Ogre::Real const) const\n"
    "    Ogre::Vector2::operator /(Ogre::Vector2 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector2___add__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::operator +",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator +",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___add",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Vector2 *) &((Ogre::Vector2 const *)arg1)->operator +();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___add(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector2___add__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector2___add__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector2___add'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector2::operator +(Ogre::Vector2 const &) const\n"
    "    Ogre::Vector2::operator +() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector2___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator -",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___unm",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->operator -();
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_length(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::length",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_length",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_squaredLength(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::squaredLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::squaredLength",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_squaredLength",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->squaredLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_distance(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::distance",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::distance",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_distance",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_distance",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->distance((Ogre::Vector2 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_squaredDistance(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::squaredDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::squaredDistance",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::squaredDistance",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_squaredDistance",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_squaredDistance",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->squaredDistance((Ogre::Vector2 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_dotProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::dotProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::dotProduct",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::dotProduct",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_dotProduct",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_dotProduct",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->dotProduct((Ogre::Vector2 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_normalise(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::normalise",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::normalise",1,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_normalise",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)(arg1)->normalise();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_midPoint(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::midPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::midPoint",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::midPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_midPoint",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_midPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->midPoint((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2___lt(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector2::operator <",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::operator <",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::operator <",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___lt",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2___lt",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Ogre::Vector2 const *)arg1)->operator <((Ogre::Vector2 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_makeFloor(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::makeFloor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::makeFloor",1,"Ogre::Vector2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::makeFloor",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_makeFloor",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_makeFloor",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  (arg1)->makeFloor((Ogre::Vector2 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_makeCeil(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::makeCeil",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::makeCeil",1,"Ogre::Vector2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::makeCeil",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_makeCeil",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_makeCeil",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  (arg1)->makeCeil((Ogre::Vector2 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_perpendicular(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::perpendicular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::perpendicular",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_perpendicular",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->perpendicular();
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_crossProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector2::crossProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::crossProduct",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::crossProduct",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_crossProduct",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_crossProduct",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Ogre::Real)((Ogre::Vector2 const *)arg1)->crossProduct((Ogre::Vector2 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_randomDeviant(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::randomDeviant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::randomDeviant",1,"Ogre::Vector2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector2::randomDeviant",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_randomDeviant",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Vector2 const *)arg1)->randomDeviant(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_isZeroLength(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector2::isZeroLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::isZeroLength",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_isZeroLength",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Ogre::Vector2 const *)arg1)->isZeroLength();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_normalisedCopy(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::normalisedCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::normalisedCopy",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_normalisedCopy",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->normalisedCopy();
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_reflect(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Ogre::Vector2::reflect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::reflect",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::reflect",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_reflect",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_reflect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->reflect((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_isNaN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector2::isNaN",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::isNaN",1,"Ogre::Vector2 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_isNaN",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Ogre::Vector2 const *)arg1)->isNaN();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_angleBetween(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Vector2::angleBetween",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::angleBetween",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::angleBetween",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_angleBetween",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_angleBetween",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->angleBetween((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_angleTo(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = (Ogre::Vector2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Vector2::angleTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector2::angleTo",1,"Ogre::Vector2 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector2::angleTo",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_angleTo",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2_angleTo",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = ((Ogre::Vector2 const *)arg1)->angleTo((Ogre::Vector2 const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_ZERO_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::ZERO",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::ZERO;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_UNIT_X_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::UNIT_X",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::UNIT_X;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_UNIT_Y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::UNIT_Y",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::UNIT_Y;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_NEGATIVE_UNIT_X_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::NEGATIVE_UNIT_X",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::NEGATIVE_UNIT_X;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_NEGATIVE_UNIT_Y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::NEGATIVE_UNIT_Y",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::NEGATIVE_UNIT_Y;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_UNIT_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector2::UNIT_SCALE",0,0)
  result = (Ogre::Vector2 *)&Ogre::Vector2::UNIT_SCALE;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector2(void *obj) {
Ogre::Vector2 *arg1 = (Ogre::Vector2 *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Vector2_methods[] = {
    {"swap", _wrap_Vector2_swap}, 
    {"ptr", _wrap_Vector2_ptr}, 
    {"__eq", _wrap_Vector2___eq}, 
    {"__sub", _wrap_Vector2___sub}, 
    {"__mul", _wrap_Vector2___mul}, 
    {"__div", _wrap_Vector2___div}, 
    {"__add", _wrap_Vector2___add}, 
    {"__unm", _wrap_Vector2___unm}, 
    {"length", _wrap_Vector2_length}, 
    {"squaredLength", _wrap_Vector2_squaredLength}, 
    {"distance", _wrap_Vector2_distance}, 
    {"squaredDistance", _wrap_Vector2_squaredDistance}, 
    {"dotProduct", _wrap_Vector2_dotProduct}, 
    {"normalise", _wrap_Vector2_normalise}, 
    {"midPoint", _wrap_Vector2_midPoint}, 
    {"__lt", _wrap_Vector2___lt}, 
    {"makeFloor", _wrap_Vector2_makeFloor}, 
    {"makeCeil", _wrap_Vector2_makeCeil}, 
    {"perpendicular", _wrap_Vector2_perpendicular}, 
    {"crossProduct", _wrap_Vector2_crossProduct}, 
    {"randomDeviant", _wrap_Vector2_randomDeviant}, 
    {"isZeroLength", _wrap_Vector2_isZeroLength}, 
    {"normalisedCopy", _wrap_Vector2_normalisedCopy}, 
    {"reflect", _wrap_Vector2_reflect}, 
    {"isNaN", _wrap_Vector2_isNaN}, 
    {"angleBetween", _wrap_Vector2_angleBetween}, 
    {"angleTo", _wrap_Vector2_angleTo}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Vector2_attributes[] = {
    { "x", _wrap_Vector2_x_get, _wrap_Vector2_x_set},
    { "y", _wrap_Vector2_y_get, _wrap_Vector2_y_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Vector2_bases[] = {0};
static const char *swig_Ogre_Vector2_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Vector2 = { "Vector2", &SWIGTYPE_p_Ogre__Vector2,_wrap_new_Vector2, swig_delete_Vector2, swig_Ogre_Vector2_methods, swig_Ogre_Vector2_attributes, swig_Ogre_Vector2_bases, swig_Ogre_Vector2_base_names };

static int _wrap_Vector3_x_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector3::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::x",1,"Ogre::Vector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::x",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_x_set",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_x_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::x",1,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_x_get",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector3::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::y",1,"Ogre::Vector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::y",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_y_set",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::y",1,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_y_get",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector3::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::z",1,"Ogre::Vector3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::z",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_z_set",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::z",1,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_z_get",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",0,0)
  result = (Ogre::Vector3 *)new Ogre::Vector3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector3::Vector3",1,"Ogre::Real const");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::Vector3",2,"Ogre::Real const");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Vector3::Vector3",3,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  arg3 = (Ogre::Real const)lua_tonumber(L, 3);
  result = (Ogre::Vector3 *)new Ogre::Vector3(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::Vector3",1,"Ogre::Real const [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector3",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector3 *)new Ogre::Vector3((Ogre::Real const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  int *arg1 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::Vector3",1,"int const [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("new_Vector3",1,SWIGTYPE_p_int);
  }
  
  result = (Ogre::Vector3 *)new Ogre::Vector3((int const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 = (Ogre::Real *) (Ogre::Real *)0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::Vector3",1,"Ogre::Real *const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector3",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector3 *)new Ogre::Vector3(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::Vector3",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector3::Vector3",1,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  result = (Ogre::Vector3 *)new Ogre::Vector3(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector3__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_int, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_4(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_5(L);
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_Vector3__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Vector3'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::Vector3()\n"
    "    Ogre::Vector3::Vector3(Ogre::Real const,Ogre::Real const,Ogre::Real const)\n"
    "    Ogre::Vector3::Vector3(Ogre::Real const [3])\n"
    "    Ogre::Vector3::Vector3(int const [3])\n"
    "    Ogre::Vector3::Vector3(Ogre::Real *const)\n"
    "    Ogre::Vector3::Vector3(Ogre::Real const)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_swap(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::swap",1,"Ogre::Vector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::swap",2,"Ogre::Vector3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_swap",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_swap",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->swap(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_ptr__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::ptr",1,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_ptr",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real *)(arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_ptr__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::ptr",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_ptr",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real *)((Ogre::Vector3 const *)arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_ptr(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector3_ptr__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector3_ptr__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3_ptr'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::ptr()\n"
    "    Ogre::Vector3::ptr() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator ==",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator ==",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___eq",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___eq",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->operator ==((Ogre::Vector3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___add__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator +",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator +",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___add",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___add",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->operator +((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___sub(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator -",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator -",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___sub",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___sub",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->operator -((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator *",1,"Ogre::Vector3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::operator *",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector3 const *)arg1)->operator *(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator *",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator *",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->operator *((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::operator *(Ogre::Real const) const\n"
    "    Ogre::Vector3::operator *(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator /",1,"Ogre::Vector3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector3::operator /",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___div",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector3 const *)arg1)->operator /(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator /",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator /",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___div",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___div",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->operator /((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___div__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3___div__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::operator /(Ogre::Real const) const\n"
    "    Ogre::Vector3::operator /(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___add__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::operator +",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator +",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___add",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Vector3 *) &((Ogre::Vector3 const *)arg1)->operator +();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___add(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector3___add__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___add__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3___add'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::operator +(Ogre::Vector3 const &) const\n"
    "    Ogre::Vector3::operator +() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator -",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___unm",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->operator -();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_length(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::length",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_length",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_squaredLength(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::squaredLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::squaredLength",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_squaredLength",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->squaredLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_distance(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::distance",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::distance",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_distance",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_distance",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->distance((Ogre::Vector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_squaredDistance(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::squaredDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::squaredDistance",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::squaredDistance",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_squaredDistance",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_squaredDistance",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->squaredDistance((Ogre::Vector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_dotProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::dotProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::dotProduct",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::dotProduct",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_dotProduct",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_dotProduct",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->dotProduct((Ogre::Vector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_absDotProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::absDotProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::absDotProduct",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::absDotProduct",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_absDotProduct",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_absDotProduct",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)((Ogre::Vector3 const *)arg1)->absDotProduct((Ogre::Vector3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_normalise(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector3::normalise",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::normalise",1,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_normalise",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Real)(arg1)->normalise();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_crossProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::crossProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::crossProduct",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::crossProduct",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_crossProduct",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_crossProduct",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->crossProduct((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_midPoint(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::midPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::midPoint",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::midPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_midPoint",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_midPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->midPoint((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___lt(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::operator <",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::operator <",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::operator <",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___lt",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3___lt",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->operator <((Ogre::Vector3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_makeFloor(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::makeFloor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::makeFloor",1,"Ogre::Vector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::makeFloor",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_makeFloor",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_makeFloor",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->makeFloor((Ogre::Vector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_makeCeil(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::makeCeil",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::makeCeil",1,"Ogre::Vector3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::makeCeil",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_makeCeil",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_makeCeil",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->makeCeil((Ogre::Vector3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_perpendicular(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::perpendicular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::perpendicular",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_perpendicular",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->perpendicular();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_randomDeviant__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::randomDeviant",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::randomDeviant",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::randomDeviant",2,"Ogre::Radian const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Vector3::randomDeviant",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_randomDeviant",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Vector3_randomDeviant",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_randomDeviant",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->randomDeviant((Ogre::Radian const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_randomDeviant__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::randomDeviant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::randomDeviant",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::randomDeviant",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_randomDeviant",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Vector3_randomDeviant",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->randomDeviant((Ogre::Radian const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_randomDeviant(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_randomDeviant__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Vector3_randomDeviant__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3_randomDeviant'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::randomDeviant(Ogre::Radian const &,Ogre::Vector3 const &) const\n"
    "    Ogre::Vector3::randomDeviant(Ogre::Radian const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_angleBetween(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Vector3::angleBetween",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::angleBetween",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::angleBetween",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_angleBetween",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_angleBetween",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->angleBetween((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_getRotationTo__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Vector3::getRotationTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::getRotationTo",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::getRotationTo",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Vector3::getRotationTo",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->getRotationTo((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_getRotationTo__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Vector3::getRotationTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::getRotationTo",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::getRotationTo",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_getRotationTo",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->getRotationTo((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_getRotationTo(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_getRotationTo__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Vector3_getRotationTo__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3_getRotationTo'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::getRotationTo(Ogre::Vector3 const &,Ogre::Vector3 const &) const\n"
    "    Ogre::Vector3::getRotationTo(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_isZeroLength(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::isZeroLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::isZeroLength",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_isZeroLength",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->isZeroLength();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_normalisedCopy(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::normalisedCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::normalisedCopy",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_normalisedCopy",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->normalisedCopy();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_reflect(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::reflect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::reflect",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::reflect",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_reflect",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_reflect",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->reflect((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_positionEquals__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real arg3 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::positionEquals",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::positionEquals",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::positionEquals",2,"Ogre::Vector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Vector3::positionEquals",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionEquals",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionEquals",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (bool)((Ogre::Vector3 const *)arg1)->positionEquals((Ogre::Vector3 const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_positionEquals__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::positionEquals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::positionEquals",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::positionEquals",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionEquals",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionEquals",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->positionEquals((Ogre::Vector3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_positionEquals(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_positionEquals__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Vector3_positionEquals__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3_positionEquals'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::positionEquals(Ogre::Vector3 const &,Ogre::Real) const\n"
    "    Ogre::Vector3::positionEquals(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_positionCloses__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Real arg3 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::positionCloses",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::positionCloses",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::positionCloses",2,"Ogre::Vector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Vector3::positionCloses",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionCloses",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionCloses",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (bool)((Ogre::Vector3 const *)arg1)->positionCloses((Ogre::Vector3 const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_positionCloses__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::positionCloses",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::positionCloses",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::positionCloses",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionCloses",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_positionCloses",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->positionCloses((Ogre::Vector3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_positionCloses(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_positionCloses__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Vector3_positionCloses__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector3_positionCloses'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector3::positionCloses(Ogre::Vector3 const &,Ogre::Real) const\n"
    "    Ogre::Vector3::positionCloses(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector3_directionEquals(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Radian *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::directionEquals",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::directionEquals",1,"Ogre::Vector3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector3::directionEquals",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Vector3::directionEquals",3,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_directionEquals",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_directionEquals",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Vector3_directionEquals",3,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->directionEquals((Ogre::Vector3 const &)*arg2,(Ogre::Radian const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_isNaN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector3::isNaN",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::isNaN",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_isNaN",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Ogre::Vector3 const *)arg1)->isNaN();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_primaryAxis(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Vector3::primaryAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector3::primaryAxis",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3_primaryAxis",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Vector3 const *)arg1)->primaryAxis();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_ZERO_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::ZERO",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::ZERO;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_UNIT_X_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::UNIT_X",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::UNIT_X;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_UNIT_Y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::UNIT_Y",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::UNIT_Y;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_UNIT_Z_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::UNIT_Z",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::UNIT_Z;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_NEGATIVE_UNIT_X_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::NEGATIVE_UNIT_X",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::NEGATIVE_UNIT_X;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_NEGATIVE_UNIT_Y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::NEGATIVE_UNIT_Y",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::NEGATIVE_UNIT_Y;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_NEGATIVE_UNIT_Z_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::NEGATIVE_UNIT_Z",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::NEGATIVE_UNIT_Z;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_UNIT_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector3::UNIT_SCALE",0,0)
  result = (Ogre::Vector3 *)&Ogre::Vector3::UNIT_SCALE;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector3(void *obj) {
Ogre::Vector3 *arg1 = (Ogre::Vector3 *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Vector3_methods[] = {
    {"swap", _wrap_Vector3_swap}, 
    {"ptr", _wrap_Vector3_ptr}, 
    {"__eq", _wrap_Vector3___eq}, 
    {"__sub", _wrap_Vector3___sub}, 
    {"__mul", _wrap_Vector3___mul}, 
    {"__div", _wrap_Vector3___div}, 
    {"__add", _wrap_Vector3___add}, 
    {"__unm", _wrap_Vector3___unm}, 
    {"length", _wrap_Vector3_length}, 
    {"squaredLength", _wrap_Vector3_squaredLength}, 
    {"distance", _wrap_Vector3_distance}, 
    {"squaredDistance", _wrap_Vector3_squaredDistance}, 
    {"dotProduct", _wrap_Vector3_dotProduct}, 
    {"absDotProduct", _wrap_Vector3_absDotProduct}, 
    {"normalise", _wrap_Vector3_normalise}, 
    {"crossProduct", _wrap_Vector3_crossProduct}, 
    {"midPoint", _wrap_Vector3_midPoint}, 
    {"__lt", _wrap_Vector3___lt}, 
    {"makeFloor", _wrap_Vector3_makeFloor}, 
    {"makeCeil", _wrap_Vector3_makeCeil}, 
    {"perpendicular", _wrap_Vector3_perpendicular}, 
    {"randomDeviant", _wrap_Vector3_randomDeviant}, 
    {"angleBetween", _wrap_Vector3_angleBetween}, 
    {"getRotationTo", _wrap_Vector3_getRotationTo}, 
    {"isZeroLength", _wrap_Vector3_isZeroLength}, 
    {"normalisedCopy", _wrap_Vector3_normalisedCopy}, 
    {"reflect", _wrap_Vector3_reflect}, 
    {"positionEquals", _wrap_Vector3_positionEquals}, 
    {"positionCloses", _wrap_Vector3_positionCloses}, 
    {"directionEquals", _wrap_Vector3_directionEquals}, 
    {"isNaN", _wrap_Vector3_isNaN}, 
    {"primaryAxis", _wrap_Vector3_primaryAxis}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Vector3_attributes[] = {
    { "x", _wrap_Vector3_x_get, _wrap_Vector3_x_set},
    { "y", _wrap_Vector3_y_get, _wrap_Vector3_y_set},
    { "z", _wrap_Vector3_z_get, _wrap_Vector3_z_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Vector3_bases[] = {0};
static const char *swig_Ogre_Vector3_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Vector3 = { "Vector3", &SWIGTYPE_p_Ogre__Vector3,_wrap_new_Vector3, swig_delete_Vector3, swig_Ogre_Vector3_methods, swig_Ogre_Vector3_attributes, swig_Ogre_Vector3_bases, swig_Ogre_Vector3_base_names };

static int _wrap_Vector4_x_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector4::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::x",1,"Ogre::Vector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::x",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_x_set",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_x_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector4::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::x",1,"Ogre::Vector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_x_get",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector4::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::y",1,"Ogre::Vector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::y",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_y_set",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector4::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::y",1,"Ogre::Vector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_y_get",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector4::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::z",1,"Ogre::Vector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::z",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_z_set",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector4::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::z",1,"Ogre::Vector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_z_get",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Vector4::w",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::w",1,"Ogre::Vector4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::w",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_w_set",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector4::w",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::w",1,"Ogre::Vector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_w_get",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real) ((arg1)->w);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",0,0)
  result = (Ogre::Vector4 *)new Ogre::Vector4();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"Ogre::Real const");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::Vector4",2,"Ogre::Real const");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Vector4::Vector4",3,"Ogre::Real const");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Vector4::Vector4",4,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  arg3 = (Ogre::Real const)lua_tonumber(L, 3);
  arg4 = (Ogre::Real const)lua_tonumber(L, 4);
  result = (Ogre::Vector4 *)new Ogre::Vector4(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"Ogre::Real const [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector4",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector4 *)new Ogre::Vector4((Ogre::Real const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  int *arg1 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"int const [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("new_Vector4",1,SWIGTYPE_p_int);
  }
  
  result = (Ogre::Vector4 *)new Ogre::Vector4((int const (*))arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 = (Ogre::Real *) (Ogre::Real *)0 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"Ogre::Real *const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Vector4",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Vector4 *)new Ogre::Vector4(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"Ogre::Real const");
  arg1 = (Ogre::Real const)lua_tonumber(L, 1);
  result = (Ogre::Vector4 *)new Ogre::Vector4(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::Vector4",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Vector4::Vector4",1,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Vector4",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Vector4 *)new Ogre::Vector4((Ogre::Vector3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector4__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_int, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_4(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_6(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_5(L);
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Vector4__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Vector4'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector4::Vector4()\n"
    "    Ogre::Vector4::Vector4(Ogre::Real const,Ogre::Real const,Ogre::Real const,Ogre::Real const)\n"
    "    Ogre::Vector4::Vector4(Ogre::Real const [4])\n"
    "    Ogre::Vector4::Vector4(int const [4])\n"
    "    Ogre::Vector4::Vector4(Ogre::Real *const)\n"
    "    Ogre::Vector4::Vector4(Ogre::Real const)\n"
    "    Ogre::Vector4::Vector4(Ogre::Vector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4_swap(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::swap",1,"Ogre::Vector4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::swap",2,"Ogre::Vector4 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_swap",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_swap",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  (arg1)->swap(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_ptr__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::ptr",1,"Ogre::Vector4 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_ptr",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real *)(arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_ptr__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::ptr",1,"Ogre::Vector4 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_ptr",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real *)((Ogre::Vector4 const *)arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_ptr(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector4_ptr__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector4_ptr__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector4_ptr'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector4::ptr()\n"
    "    Ogre::Vector4::ptr() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector4::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator ==",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::operator ==",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___eq",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___eq",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (bool)((Ogre::Vector4 const *)arg1)->operator ==((Ogre::Vector4 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___add__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator +",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::operator +",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___add",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___add",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = ((Ogre::Vector4 const *)arg1)->operator +((Ogre::Vector4 const &)*arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___sub(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator -",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::operator -",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___sub",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___sub",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = ((Ogre::Vector4 const *)arg1)->operator -((Ogre::Vector4 const &)*arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator *",1,"Ogre::Vector4 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::operator *",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___mul",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector4 const *)arg1)->operator *(arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator *",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::operator *",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___mul",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___mul",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = ((Ogre::Vector4 const *)arg1)->operator *((Ogre::Vector4 const &)*arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector4___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector4___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector4___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector4::operator *(Ogre::Real const) const\n"
    "    Ogre::Vector4::operator *(Ogre::Vector4 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator /",1,"Ogre::Vector4 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Vector4::operator /",2,"Ogre::Real const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___div",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  arg2 = (Ogre::Real const)lua_tonumber(L, 2);
  result = ((Ogre::Vector4 const *)arg1)->operator /(arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator /",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::operator /",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___div",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___div",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = ((Ogre::Vector4 const *)arg1)->operator /((Ogre::Vector4 const &)*arg2);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector4___div__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector4___div__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector4___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector4::operator /(Ogre::Real const) const\n"
    "    Ogre::Vector4::operator /(Ogre::Vector4 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___add__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::operator +",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator +",1,"Ogre::Vector4 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___add",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Vector4 *) &((Ogre::Vector4 const *)arg1)->operator +();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4___add(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Vector4___add__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector4___add__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vector4___add'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Vector4::operator +(Ogre::Vector4 const &) const\n"
    "    Ogre::Vector4::operator +() const\n");
  lua_error(L);return 0;
}


static int _wrap_Vector4___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Vector4::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::operator -",1,"Ogre::Vector4 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4___unm",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = ((Ogre::Vector4 const *)arg1)->operator -();
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_dotProduct(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  Ogre::Vector4 *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Vector4::dotProduct",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::dotProduct",1,"Ogre::Vector4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Vector4::dotProduct",2,"Ogre::Vector4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_dotProduct",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_dotProduct",2,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (Ogre::Real)((Ogre::Vector4 const *)arg1)->dotProduct((Ogre::Vector4 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_isNaN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *arg1 = (Ogre::Vector4 *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Vector4::isNaN",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Vector4::isNaN",1,"Ogre::Vector4 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector4,0))){
    SWIG_fail_ptr("Vector4_isNaN",1,SWIGTYPE_p_Ogre__Vector4);
  }
  
  result = (bool)((Ogre::Vector4 const *)arg1)->isNaN();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_ZERO_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector4 *result = 0 ;
  
  SWIG_check_num_args("Ogre::Vector4::ZERO",0,0)
  result = (Ogre::Vector4 *)&Ogre::Vector4::ZERO;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector4,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector4(void *obj) {
Ogre::Vector4 *arg1 = (Ogre::Vector4 *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Vector4_methods[] = {
    {"swap", _wrap_Vector4_swap}, 
    {"ptr", _wrap_Vector4_ptr}, 
    {"__eq", _wrap_Vector4___eq}, 
    {"__sub", _wrap_Vector4___sub}, 
    {"__mul", _wrap_Vector4___mul}, 
    {"__div", _wrap_Vector4___div}, 
    {"__add", _wrap_Vector4___add}, 
    {"__unm", _wrap_Vector4___unm}, 
    {"dotProduct", _wrap_Vector4_dotProduct}, 
    {"isNaN", _wrap_Vector4_isNaN}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Vector4_attributes[] = {
    { "x", _wrap_Vector4_x_get, _wrap_Vector4_x_set},
    { "y", _wrap_Vector4_y_get, _wrap_Vector4_y_set},
    { "z", _wrap_Vector4_z_get, _wrap_Vector4_z_set},
    { "w", _wrap_Vector4_w_get, _wrap_Vector4_w_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Vector4_bases[] = {0};
static const char *swig_Ogre_Vector4_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Vector4 = { "Vector4", &SWIGTYPE_p_Ogre__Vector4,_wrap_new_Vector4, swig_delete_Vector4, swig_Ogre_Vector4_methods, swig_Ogre_Vector4_attributes, swig_Ogre_Vector4_bases, swig_Ogre_Vector4_base_names };

static int _wrap_new_Quaternion__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",0,0)
  result = (Ogre::Quaternion *)new Ogre::Quaternion();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",4,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Ogre::Quaternion *)new Ogre::Quaternion(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Matrix3 *arg1 = 0 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Matrix3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Matrix3,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_Ogre__Matrix3);
  }
  
  result = (Ogre::Quaternion *)new Ogre::Quaternion((Ogre::Matrix3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Radian const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Quaternion",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Quaternion *)new Ogre::Quaternion((Ogre::Radian const &)*arg1,(Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Quaternion",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Quaternion",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Quaternion *)new Ogre::Quaternion((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = (Ogre::Vector3 *) 0 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Ogre::Quaternion *)new Ogre::Quaternion((Ogre::Vector3 const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real *arg1 = (Ogre::Real *) 0 ;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Quaternion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Quaternion",1,"Ogre::Real *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_float);
  }
  
  result = (Ogre::Quaternion *)new Ogre::Quaternion(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Quaternion__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Matrix3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Quaternion__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Quaternion__SWIG_5(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Quaternion__SWIG_6(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Quaternion__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_new_Quaternion__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Quaternion__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Quaternion'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::Quaternion()\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Matrix3 const &)\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Radian const &,Ogre::Vector3 const &)\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Vector3 const *)\n"
    "    Ogre::Quaternion::Quaternion(Ogre::Real *)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_swap(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::swap",1,"Ogre::Quaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::swap",2,"Ogre::Quaternion &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_swap",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_swap",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  (arg1)->swap(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ptr__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ptr",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ptr",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real *)(arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ptr__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ptr",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ptr",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real *)((Ogre::Quaternion const *)arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ptr(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_ptr__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_ptr__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_ptr'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::ptr()\n"
    "    Ogre::Quaternion::ptr() const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_FromRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Matrix3 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::FromRotationMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::FromRotationMatrix",1,"Ogre::Quaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::FromRotationMatrix",2,"Ogre::Matrix3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_FromRotationMatrix",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Matrix3,0))){
    SWIG_fail_ptr("Quaternion_FromRotationMatrix",2,SWIGTYPE_p_Ogre__Matrix3);
  }
  
  (arg1)->FromRotationMatrix((Ogre::Matrix3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Matrix3 *arg2 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ToRotationMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ToRotationMatrix",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::ToRotationMatrix",2,"Ogre::Matrix3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ToRotationMatrix",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Matrix3,0))){
    SWIG_fail_ptr("Quaternion_ToRotationMatrix",2,SWIGTYPE_p_Ogre__Matrix3);
  }
  
  ((Ogre::Quaternion const *)arg1)->ToRotationMatrix(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_FromAngleAxis(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::FromAngleAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::FromAngleAxis",1,"Ogre::Quaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::FromAngleAxis",2,"Ogre::Radian const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::FromAngleAxis",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_FromAngleAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Quaternion_FromAngleAxis",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_FromAngleAxis",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->FromAngleAxis((Ogre::Radian const &)*arg2,(Ogre::Vector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToAngleAxis__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ToAngleAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",2,"Ogre::Radian &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",3,"Ogre::Vector3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  ((Ogre::Quaternion const *)arg1)->ToAngleAxis(*arg2,*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToAngleAxis__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ToAngleAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",2,"Ogre::Degree &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::ToAngleAxis",3,"Ogre::Vector3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAngleAxis",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  ((Ogre::Quaternion const *)arg1)->ToAngleAxis(*arg2,*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToAngleAxis(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Quaternion_ToAngleAxis__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Quaternion_ToAngleAxis__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_ToAngleAxis'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::ToAngleAxis(Ogre::Radian &,Ogre::Vector3 &) const\n"
    "    Ogre::Quaternion::ToAngleAxis(Ogre::Degree &,Ogre::Vector3 &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_FromAxes__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::FromAxes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",1,"Ogre::Quaternion *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",2,"Ogre::Vector3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->FromAxes((Ogre::Vector3 const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_FromAxes__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::FromAxes",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",1,"Ogre::Quaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Quaternion::FromAxes",4,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_FromAxes",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->FromAxes((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_FromAxes(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion_FromAxes__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Quaternion_FromAxes__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_FromAxes'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::FromAxes(Ogre::Vector3 const *)\n"
    "    Ogre::Quaternion::FromAxes(Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_ToAxes__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ToAxes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",1,"Ogre::Quaternion const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",2,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  ((Ogre::Quaternion const *)arg1)->ToAxes(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToAxes__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ToAxes",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",2,"Ogre::Vector3 &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",3,"Ogre::Vector3 &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Quaternion::ToAxes",4,"Ogre::Vector3 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion_ToAxes",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  ((Ogre::Quaternion const *)arg1)->ToAxes(*arg2,*arg3,*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ToAxes(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion_ToAxes__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Quaternion_ToAxes__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_ToAxes'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::ToAxes(Ogre::Vector3 *) const\n"
    "    Ogre::Quaternion::ToAxes(Ogre::Vector3 &,Ogre::Vector3 &,Ogre::Vector3 &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_xAxis(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Quaternion::xAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::xAxis",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_xAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->xAxis();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_yAxis(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Quaternion::yAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::yAxis",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_yAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->yAxis();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_zAxis(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Quaternion::zAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::zAxis",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_zAxis",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->zAxis();
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___add(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator +",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator +",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___add",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___add",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->operator +((Ogre::Quaternion const &)*arg2);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___sub(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator -",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator -",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->operator -((Ogre::Quaternion const &)*arg2);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator *",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator *",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->operator *((Ogre::Quaternion const &)*arg2);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator *",1,"Ogre::Quaternion const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator *",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Quaternion const *)arg1)->operator *(arg2);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator -",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___unm",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->operator -();
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator ==",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator ==",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___eq",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___eq",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (bool)((Ogre::Quaternion const *)arg1)->operator ==((Ogre::Quaternion const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Dot(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::Dot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Dot",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Dot",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Dot",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Dot",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real)((Ogre::Quaternion const *)arg1)->Dot((Ogre::Quaternion const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Norm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::Norm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Norm",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Norm",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real)((Ogre::Quaternion const *)arg1)->Norm();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_normalise(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::normalise",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::normalise",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_normalise",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real)(arg1)->normalise();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Inverse(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Inverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Inverse",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Inverse",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->Inverse();
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_UnitInverse(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::UnitInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::UnitInverse",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_UnitInverse",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->UnitInverse();
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Exp(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Exp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Exp",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Exp",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->Exp();
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Log(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Log",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::Log",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Log",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->Log();
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Quaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::operator *",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::operator *",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->operator *((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Quaternion___mul__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::operator *(Ogre::Quaternion const &) const\n"
    "    Ogre::Quaternion::operator *(Ogre::Real) const\n"
    "    Ogre::Quaternion::operator *(Ogre::Vector3 const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_getRoll__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  bool arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getRoll",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getRoll",1,"Ogre::Quaternion const *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Quaternion::getRoll",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getRoll",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = ((Ogre::Quaternion const *)arg1)->getRoll(arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getRoll__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getRoll",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getRoll",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getRoll",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->getRoll();
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getRoll(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_getRoll__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Quaternion_getRoll__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_getRoll'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::getRoll(bool) const\n"
    "    Ogre::Quaternion::getRoll() const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_getPitch__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  bool arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getPitch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getPitch",1,"Ogre::Quaternion const *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Quaternion::getPitch",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getPitch",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = ((Ogre::Quaternion const *)arg1)->getPitch(arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getPitch__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getPitch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getPitch",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getPitch",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->getPitch();
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getPitch(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_getPitch__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Quaternion_getPitch__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_getPitch'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::getPitch(bool) const\n"
    "    Ogre::Quaternion::getPitch() const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_getYaw__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  bool arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getYaw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getYaw",1,"Ogre::Quaternion const *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Quaternion::getYaw",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getYaw",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = ((Ogre::Quaternion const *)arg1)->getYaw(arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getYaw__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Quaternion::getYaw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::getYaw",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_getYaw",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = ((Ogre::Quaternion const *)arg1)->getYaw();
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_getYaw(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_getYaw__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Quaternion_getYaw__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_getYaw'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::getYaw(bool) const\n"
    "    Ogre::Quaternion::getYaw() const\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_equals(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Radian *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Quaternion::equals",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::equals",1,"Ogre::Quaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::equals",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::equals",3,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_equals",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_equals",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Quaternion_equals",3,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (bool)((Ogre::Quaternion const *)arg1)->equals((Ogre::Quaternion const &)*arg2,(Ogre::Radian const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Slerp__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  bool arg4 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Slerp",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::Slerp",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Slerp",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Slerp",3,"Ogre::Quaternion const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Ogre::Quaternion::Slerp",4,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Slerp",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Slerp",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = Ogre::Quaternion::Slerp(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,arg4);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Slerp__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Slerp",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::Slerp",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Slerp",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Slerp",3,"Ogre::Quaternion const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Slerp",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Slerp",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = Ogre::Quaternion::Slerp(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Slerp(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Quaternion_Slerp__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Quaternion_Slerp__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_Slerp'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::Slerp(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &,bool)\n"
    "    Ogre::Quaternion::Slerp(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_SlerpExtraSpins(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  int arg4 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::SlerpExtraSpins",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::SlerpExtraSpins",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::SlerpExtraSpins",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::SlerpExtraSpins",3,"Ogre::Quaternion const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Quaternion::SlerpExtraSpins",4,"int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_SlerpExtraSpins",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_SlerpExtraSpins",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = Ogre::Quaternion::SlerpExtraSpins(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,arg4);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Intermediate(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  Ogre::Quaternion *arg4 = 0 ;
  Ogre::Quaternion *arg5 = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::Intermediate",5,5)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Quaternion::Intermediate",1,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Intermediate",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Intermediate",3,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Quaternion::Intermediate",4,"Ogre::Quaternion &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Quaternion::Intermediate",5,"Ogre::Quaternion &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Intermediate",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Intermediate",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Intermediate",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Intermediate",4,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Intermediate",5,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  Ogre::Quaternion::Intermediate((Ogre::Quaternion const &)*arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,*arg4,*arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Squad__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  Ogre::Quaternion *arg4 = 0 ;
  Ogre::Quaternion *arg5 = 0 ;
  bool arg6 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Squad",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::Squad",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Squad",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Squad",3,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Quaternion::Squad",4,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Quaternion::Squad",5,"Ogre::Quaternion const &");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("Ogre::Quaternion::Squad",6,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",4,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",5,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg6 = (lua_toboolean(L, 6)!=0);
  result = Ogre::Quaternion::Squad(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,(Ogre::Quaternion const &)*arg4,(Ogre::Quaternion const &)*arg5,arg6);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Squad__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  Ogre::Quaternion *arg4 = 0 ;
  Ogre::Quaternion *arg5 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::Squad",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::Squad",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::Squad",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::Squad",3,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Quaternion::Squad",4,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Quaternion::Squad",5,"Ogre::Quaternion const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",4,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_Squad",5,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = Ogre::Quaternion::Squad(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,(Ogre::Quaternion const &)*arg4,(Ogre::Quaternion const &)*arg5);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_Squad(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_Quaternion_Squad__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                return _wrap_Quaternion_Squad__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_Squad'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::Squad(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &,Ogre::Quaternion const &,Ogre::Quaternion const &,bool)\n"
    "    Ogre::Quaternion::Squad(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &,Ogre::Quaternion const &,Ogre::Quaternion const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_nlerp__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  bool arg4 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::nlerp",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::nlerp",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::nlerp",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::nlerp",3,"Ogre::Quaternion const &");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Ogre::Quaternion::nlerp",4,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_nlerp",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_nlerp",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = Ogre::Quaternion::nlerp(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3,arg4);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_nlerp__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Quaternion *arg3 = 0 ;
  Ogre::Quaternion result;
  
  SWIG_check_num_args("Ogre::Quaternion::nlerp",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Quaternion::nlerp",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Quaternion::nlerp",2,"Ogre::Quaternion const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Quaternion::nlerp",3,"Ogre::Quaternion const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_nlerp",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_nlerp",3,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = Ogre::Quaternion::nlerp(arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Quaternion const &)*arg3);
  {
    Ogre::Quaternion * resultptr = new Ogre::Quaternion((const Ogre::Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_nlerp(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Quaternion_nlerp__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Quaternion_nlerp__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Quaternion_nlerp'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Quaternion::nlerp(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &,bool)\n"
    "    Ogre::Quaternion::nlerp(Ogre::Real,Ogre::Quaternion const &,Ogre::Quaternion const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_msEpsilon_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::msEpsilon",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Quaternion::msEpsilon;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_ZERO_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::ZERO",0,0)
  result = (Ogre::Quaternion *)&Ogre::Quaternion::ZERO;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_IDENTITY_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *result = 0 ;
  
  SWIG_check_num_args("Ogre::Quaternion::IDENTITY",0,0)
  result = (Ogre::Quaternion *)&Ogre::Quaternion::IDENTITY;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Quaternion,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_w_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Quaternion::w",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::w",1,"Ogre::Quaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::w",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_w_set",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_w_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::w",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::w",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_w_get",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real) ((arg1)->w);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Quaternion::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::x",1,"Ogre::Quaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::x",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_x_set",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::x",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_x_get",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Quaternion::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::y",1,"Ogre::Quaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::y",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_y_set",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::y",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_y_get",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Ogre::Quaternion::z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::z",1,"Ogre::Quaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Quaternion::z",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_z_set",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Quaternion::z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::z",1,"Ogre::Quaternion *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_z_get",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Ogre::Real) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_isNaN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Quaternion *arg1 = (Ogre::Quaternion *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Quaternion::isNaN",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Quaternion::isNaN",1,"Ogre::Quaternion const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Quaternion_isNaN",1,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (bool)((Ogre::Quaternion const *)arg1)->isNaN();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Quaternion(void *obj) {
Ogre::Quaternion *arg1 = (Ogre::Quaternion *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Quaternion_methods[] = {
    {"swap", _wrap_Quaternion_swap}, 
    {"ptr", _wrap_Quaternion_ptr}, 
    {"FromRotationMatrix", _wrap_Quaternion_FromRotationMatrix}, 
    {"ToRotationMatrix", _wrap_Quaternion_ToRotationMatrix}, 
    {"FromAngleAxis", _wrap_Quaternion_FromAngleAxis}, 
    {"ToAngleAxis", _wrap_Quaternion_ToAngleAxis}, 
    {"FromAxes", _wrap_Quaternion_FromAxes}, 
    {"ToAxes", _wrap_Quaternion_ToAxes}, 
    {"xAxis", _wrap_Quaternion_xAxis}, 
    {"yAxis", _wrap_Quaternion_yAxis}, 
    {"zAxis", _wrap_Quaternion_zAxis}, 
    {"__add", _wrap_Quaternion___add}, 
    {"__sub", _wrap_Quaternion___sub}, 
    {"__unm", _wrap_Quaternion___unm}, 
    {"__eq", _wrap_Quaternion___eq}, 
    {"Dot", _wrap_Quaternion_Dot}, 
    {"Norm", _wrap_Quaternion_Norm}, 
    {"normalise", _wrap_Quaternion_normalise}, 
    {"Inverse", _wrap_Quaternion_Inverse}, 
    {"UnitInverse", _wrap_Quaternion_UnitInverse}, 
    {"Exp", _wrap_Quaternion_Exp}, 
    {"Log", _wrap_Quaternion_Log}, 
    {"__mul", _wrap_Quaternion___mul}, 
    {"getRoll", _wrap_Quaternion_getRoll}, 
    {"getPitch", _wrap_Quaternion_getPitch}, 
    {"getYaw", _wrap_Quaternion_getYaw}, 
    {"equals", _wrap_Quaternion_equals}, 
    {"isNaN", _wrap_Quaternion_isNaN}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Quaternion_attributes[] = {
    { "w", _wrap_Quaternion_w_get, _wrap_Quaternion_w_set},
    { "x", _wrap_Quaternion_x_get, _wrap_Quaternion_x_set},
    { "y", _wrap_Quaternion_y_get, _wrap_Quaternion_y_set},
    { "z", _wrap_Quaternion_z_get, _wrap_Quaternion_z_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Quaternion_bases[] = {0};
static const char *swig_Ogre_Quaternion_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Quaternion = { "Quaternion", &SWIGTYPE_p_Ogre__Quaternion,_wrap_new_Quaternion, swig_delete_Quaternion, swig_Ogre_Quaternion_methods, swig_Ogre_Quaternion_attributes, swig_Ogre_Quaternion_bases, swig_Ogre_Quaternion_base_names };

static int _wrap_new_Radian__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian *result = 0 ;
  
  SWIG_check_num_args("Ogre::Radian::Radian",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Radian::Radian",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Radian *)new Ogre::Radian(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Radian__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *result = 0 ;
  
  SWIG_check_num_args("Ogre::Radian::Radian",0,0)
  result = (Ogre::Radian *)new Ogre::Radian();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Radian__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = 0 ;
  Ogre::Radian *result = 0 ;
  
  SWIG_check_num_args("Ogre::Radian::Radian",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Radian::Radian",1,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("new_Radian",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (Ogre::Radian *)new Ogre::Radian((Ogre::Degree const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Radian(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Radian__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Radian__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Radian__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Radian'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Radian::Radian(Ogre::Real)\n"
    "    Ogre::Radian::Radian()\n"
    "    Ogre::Radian::Radian(Ogre::Degree const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Radian_valueDegrees(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Radian::valueDegrees",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::valueDegrees",1,"Ogre::Radian const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian_valueDegrees",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)((Ogre::Radian const *)arg1)->valueDegrees();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian_valueRadians(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Radian::valueRadians",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::valueRadians",1,"Ogre::Radian const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian_valueRadians",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)((Ogre::Radian const *)arg1)->valueRadians();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian_valueAngleUnits(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Radian::valueAngleUnits",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::valueAngleUnits",1,"Ogre::Radian const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian_valueAngleUnits",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)((Ogre::Radian const *)arg1)->valueAngleUnits();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___add__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *result = 0 ;
  
  SWIG_check_num_args("Ogre::Radian::operator +",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator +",1,"Ogre::Radian const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___add",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Radian *) &((Ogre::Radian const *)arg1)->operator +();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Radian,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___add__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator +",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator +",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___add",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___add",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator +((Ogre::Radian const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___add__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator +",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator +",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___add",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Radian___add",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator +((Ogre::Degree const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___add(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Radian___add__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Radian___add__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Radian___add__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Radian___add'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Radian::operator +() const\n"
    "    Ogre::Radian::operator +(Ogre::Radian const &) const\n"
    "    Ogre::Radian::operator +(Ogre::Degree const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Radian___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator -",1,"Ogre::Radian const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___unm",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator -();
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___sub__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator -",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator -",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___sub",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___sub",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator -((Ogre::Radian const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___sub__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator -",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator -",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___sub",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Radian___sub",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator -((Ogre::Degree const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___sub(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Radian___sub__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Radian___sub__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Radian___sub'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Radian::operator -(Ogre::Radian const &) const\n"
    "    Ogre::Radian::operator -(Ogre::Degree const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Radian___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator *",1,"Ogre::Radian const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Radian::operator *",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___mul",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Radian const *)arg1)->operator *(arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator *",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator *",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___mul",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___mul",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Radian const *)arg1)->operator *((Ogre::Radian const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Radian___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Radian___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Radian___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Radian::operator *(Ogre::Real) const\n"
    "    Ogre::Radian::operator *(Ogre::Radian const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Radian___div(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Radian::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator /",1,"Ogre::Radian const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Radian::operator /",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___div",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Radian const *)arg1)->operator /(arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___lt(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Radian::operator <",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator <",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator <",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___lt",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___lt",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (bool)((Ogre::Radian const *)arg1)->operator <((Ogre::Radian const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___le(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Radian::operator <=",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator <=",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator <=",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___le",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___le",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (bool)((Ogre::Radian const *)arg1)->operator <=((Ogre::Radian const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Radian___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = (Ogre::Radian *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Radian::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Radian::operator ==",1,"Ogre::Radian const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Radian::operator ==",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___eq",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Radian___eq",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (bool)((Ogre::Radian const *)arg1)->operator ==((Ogre::Radian const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Radian(void *obj) {
Ogre::Radian *arg1 = (Ogre::Radian *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Radian_methods[] = {
    {"valueDegrees", _wrap_Radian_valueDegrees}, 
    {"valueRadians", _wrap_Radian_valueRadians}, 
    {"valueAngleUnits", _wrap_Radian_valueAngleUnits}, 
    {"__add", _wrap_Radian___add}, 
    {"__unm", _wrap_Radian___unm}, 
    {"__sub", _wrap_Radian___sub}, 
    {"__mul", _wrap_Radian___mul}, 
    {"__div", _wrap_Radian___div}, 
    {"__lt", _wrap_Radian___lt}, 
    {"__le", _wrap_Radian___le}, 
    {"__eq", _wrap_Radian___eq}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Radian_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Radian_bases[] = {0};
static const char *swig_Ogre_Radian_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Radian = { "Radian", &SWIGTYPE_p_Ogre__Radian,_wrap_new_Radian, swig_delete_Radian, swig_Ogre_Radian_methods, swig_Ogre_Radian_attributes, swig_Ogre_Radian_bases, swig_Ogre_Radian_base_names };

static int _wrap_new_Degree__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Degree *result = 0 ;
  
  SWIG_check_num_args("Ogre::Degree::Degree",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Degree::Degree",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Degree *)new Ogre::Degree(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Degree__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *result = 0 ;
  
  SWIG_check_num_args("Ogre::Degree::Degree",0,0)
  result = (Ogre::Degree *)new Ogre::Degree();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Degree__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Degree *result = 0 ;
  
  SWIG_check_num_args("Ogre::Degree::Degree",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Degree::Degree",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("new_Degree",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Degree *)new Ogre::Degree((Ogre::Radian const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Degree(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Degree__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Degree__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Degree__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Degree'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Degree::Degree(Ogre::Real)\n"
    "    Ogre::Degree::Degree()\n"
    "    Ogre::Degree::Degree(Ogre::Radian const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Degree_valueDegrees(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Degree::valueDegrees",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::valueDegrees",1,"Ogre::Degree const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree_valueDegrees",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (Ogre::Real)((Ogre::Degree const *)arg1)->valueDegrees();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree_valueRadians(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Degree::valueRadians",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::valueRadians",1,"Ogre::Degree const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree_valueRadians",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (Ogre::Real)((Ogre::Degree const *)arg1)->valueRadians();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree_valueAngleUnits(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Degree::valueAngleUnits",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::valueAngleUnits",1,"Ogre::Degree const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree_valueAngleUnits",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (Ogre::Real)((Ogre::Degree const *)arg1)->valueAngleUnits();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___add__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *result = 0 ;
  
  SWIG_check_num_args("Ogre::Degree::operator +",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator +",1,"Ogre::Degree const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___add",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (Ogre::Degree *) &((Ogre::Degree const *)arg1)->operator +();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Degree,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___add__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator +",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator +",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___add",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___add",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator +((Ogre::Degree const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___add__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator +",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator +",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___add",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Degree___add",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator +((Ogre::Radian const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___add(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Degree___add__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Degree___add__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Degree___add__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Degree___add'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Degree::operator +() const\n"
    "    Ogre::Degree::operator +(Ogre::Degree const &) const\n"
    "    Ogre::Degree::operator +(Ogre::Radian const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Degree___unm(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator -",1,"Ogre::Degree const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___unm",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator -();
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___sub__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator -",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator -",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___sub",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___sub",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator -((Ogre::Degree const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___sub__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator -",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator -",2,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___sub",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Degree___sub",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator -((Ogre::Radian const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___sub(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Degree___sub__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Degree___sub__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Degree___sub'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Degree::operator -(Ogre::Degree const &) const\n"
    "    Ogre::Degree::operator -(Ogre::Radian const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Degree___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator *",1,"Ogre::Degree const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Degree::operator *",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___mul",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Degree const *)arg1)->operator *(arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator *",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator *",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___mul",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___mul",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = ((Ogre::Degree const *)arg1)->operator *((Ogre::Degree const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Degree___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Degree___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Degree___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Degree::operator *(Ogre::Real) const\n"
    "    Ogre::Degree::operator *(Ogre::Degree const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_Degree___div(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Degree::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator /",1,"Ogre::Degree const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Degree::operator /",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___div",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Ogre::Degree const *)arg1)->operator /(arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___lt(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Degree::operator <",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator <",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator <",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___lt",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___lt",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (bool)((Ogre::Degree const *)arg1)->operator <((Ogre::Degree const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___le(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Degree::operator <=",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator <=",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator <=",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___le",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___le",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (bool)((Ogre::Degree const *)arg1)->operator <=((Ogre::Degree const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Degree___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = (Ogre::Degree *) 0 ;
  Ogre::Degree *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Degree::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Degree::operator ==",1,"Ogre::Degree const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Degree::operator ==",2,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___eq",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Degree___eq",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = (bool)((Ogre::Degree const *)arg1)->operator ==((Ogre::Degree const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Degree(void *obj) {
Ogre::Degree *arg1 = (Ogre::Degree *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Degree_methods[] = {
    {"valueDegrees", _wrap_Degree_valueDegrees}, 
    {"valueRadians", _wrap_Degree_valueRadians}, 
    {"valueAngleUnits", _wrap_Degree_valueAngleUnits}, 
    {"__add", _wrap_Degree___add}, 
    {"__unm", _wrap_Degree___unm}, 
    {"__sub", _wrap_Degree___sub}, 
    {"__mul", _wrap_Degree___mul}, 
    {"__div", _wrap_Degree___div}, 
    {"__lt", _wrap_Degree___lt}, 
    {"__le", _wrap_Degree___le}, 
    {"__eq", _wrap_Degree___eq}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Degree_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Degree_bases[] = {0};
static const char *swig_Ogre_Degree_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Degree = { "Degree", &SWIGTYPE_p_Ogre__Degree,_wrap_new_Degree, swig_delete_Degree, swig_Ogre_Degree_methods, swig_Ogre_Degree_attributes, swig_Ogre_Degree_bases, swig_Ogre_Degree_base_names };

static int _wrap_new_Angle(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Angle *result = 0 ;
  
  SWIG_check_num_args("Ogre::Angle::Angle",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Angle::Angle",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Angle *)new Ogre::Angle(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Angle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Angle(void *obj) {
Ogre::Angle *arg1 = (Ogre::Angle *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Angle_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Ogre_Angle_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Angle_bases[] = {0};
static const char *swig_Ogre_Angle_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Angle = { "Angle", &SWIGTYPE_p_Ogre__Angle,_wrap_new_Angle, swig_delete_Angle, swig_Ogre_Angle_methods, swig_Ogre_Angle_attributes, swig_Ogre_Angle_bases, swig_Ogre_Angle_base_names };

static int _wrap_new_Math__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  unsigned int arg1 ;
  Ogre::Math *result = 0 ;
  
  SWIG_check_num_args("Ogre::Math::Math",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Math",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (Ogre::Math *)new Ogre::Math(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Math,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Math__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Math *result = 0 ;
  
  SWIG_check_num_args("Ogre::Math::Math",0,0)
  result = (Ogre::Math *)new Ogre::Math();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Math,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Math(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Math__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Math__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Math'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Math(unsigned int)\n"
    "    Ogre::Math::Math()\n");
  lua_error(L);return 0;
}


static int _wrap_Math_IAbs(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("Ogre::Math::IAbs",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::IAbs",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)Ogre::Math::IAbs(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_ICeil(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  int result;
  
  SWIG_check_num_args("Ogre::Math::ICeil",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ICeil",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (int)Ogre::Math::ICeil(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_IFloor(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  int result;
  
  SWIG_check_num_args("Ogre::Math::IFloor",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::IFloor",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (int)Ogre::Math::IFloor(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_ISign(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("Ogre::Math::ISign",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ISign",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)Ogre::Math::ISign(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Abs__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Abs",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Abs",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Abs(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Abs__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Math::Abs",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Abs",1,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Math_Abs",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = Ogre::Math::Abs((Ogre::Degree const &)*arg1);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Abs__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::Abs",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Abs",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Abs",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = Ogre::Math::Abs((Ogre::Radian const &)*arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Abs(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Abs__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Abs__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Abs__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Abs'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Abs(Ogre::Real)\n"
    "    Ogre::Math::Abs(Ogre::Degree const &)\n"
    "    Ogre::Math::Abs(Ogre::Radian const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_ACos(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::ACos",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ACos",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = Ogre::Math::ACos(arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_ASin(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::ASin",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ASin",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = Ogre::Math::ASin(arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_ATan(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::ATan",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ATan",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = Ogre::Math::ATan(arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_ATan2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::ATan2",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::ATan2",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::ATan2",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = Ogre::Math::ATan2(arg1,arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Ceil(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Ceil",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Ceil",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Ceil(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_isNaN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::isNaN",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::isNaN",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (bool)Ogre::Math::isNaN(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Cos__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Cos",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Cos",1,"Ogre::Radian const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Cos",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Cos",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Cos((Ogre::Radian const &)*arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Cos__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Cos",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Cos",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Cos",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)Ogre::Math::Cos((Ogre::Radian const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Cos__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Cos",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Cos",1,"Ogre::Real");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Cos",2,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Cos(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Cos__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Cos",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Cos",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Cos(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Cos(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Cos__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Cos__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Cos__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Cos__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Cos'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Cos(Ogre::Radian const &,bool)\n"
    "    Ogre::Math::Cos(Ogre::Radian const &)\n"
    "    Ogre::Math::Cos(Ogre::Real,bool)\n"
    "    Ogre::Math::Cos(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_Exp(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Exp",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Exp",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Exp(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Floor(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Floor",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Floor",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Floor(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Log(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Log",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Log",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Log(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_LOG2_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::LOG2",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::LOG2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Log2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Log2",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Log2",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Log2(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_LogN(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::LogN",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::LogN",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::LogN",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Ogre::Real)Ogre::Math::LogN(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Pow(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Pow",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Pow",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::Pow",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Ogre::Real)Ogre::Math::Pow(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sign__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sign",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Sign",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Sign(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sign__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::Sign",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sign",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Sign",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = Ogre::Math::Sign((Ogre::Radian const &)*arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sign__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Math::Sign",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sign",1,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Math_Sign",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = Ogre::Math::Sign((Ogre::Degree const &)*arg1);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sign(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Sign__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Sign__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Sign__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Sign'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Sign(Ogre::Real)\n"
    "    Ogre::Math::Sign(Ogre::Radian const &)\n"
    "    Ogre::Math::Sign(Ogre::Degree const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_saturate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float result;
  
  SWIG_check_num_args("Ogre::Math::saturate",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::saturate",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (float)Ogre::Math::saturate(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_saturate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  double arg1 ;
  double result;
  
  SWIG_check_num_args("Ogre::Math::saturate",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::saturate",1,"double");
  arg1 = (double)lua_tonumber(L, 1);
  result = (double)Ogre::Math::saturate(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_saturate(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_saturate__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_saturate__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_saturate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::saturate(float)\n"
    "    Ogre::Math::saturate(double)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_Sin__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sin",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sin",1,"Ogre::Radian const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Sin",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Sin",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Sin((Ogre::Radian const &)*arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sin__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sin",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sin",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Sin",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)Ogre::Math::Sin((Ogre::Radian const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sin__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sin",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Sin",1,"Ogre::Real");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Sin",2,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Sin(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sin__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sin",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Sin",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Sin(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sin(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Sin__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Sin__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Sin__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Sin__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Sin'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Sin(Ogre::Radian const &,bool)\n"
    "    Ogre::Math::Sin(Ogre::Radian const &)\n"
    "    Ogre::Math::Sin(Ogre::Real,bool)\n"
    "    Ogre::Math::Sin(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_Sqr(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sqr",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Sqr",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Sqr(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sqrt__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Sqrt",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Sqrt",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Sqrt(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sqrt__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::Math::Sqrt",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sqrt",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Sqrt",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = Ogre::Math::Sqrt((Ogre::Radian const &)*arg1);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sqrt__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Degree *arg1 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::Math::Sqrt",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Sqrt",1,"Ogre::Degree const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Math_Sqrt",1,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = Ogre::Math::Sqrt((Ogre::Degree const &)*arg1);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Sqrt(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Sqrt__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Sqrt__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Sqrt__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Sqrt'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Sqrt(Ogre::Real)\n"
    "    Ogre::Math::Sqrt(Ogre::Radian const &)\n"
    "    Ogre::Math::Sqrt(Ogre::Degree const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_InvSqrt(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::InvSqrt",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::InvSqrt",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::InvSqrt(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_UnitRandom(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::UnitRandom",0,0)
  result = (Ogre::Real)Ogre::Math::UnitRandom();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_RangeRandom(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::RangeRandom",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::RangeRandom",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::RangeRandom",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Ogre::Real)Ogre::Math::RangeRandom(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_SymmetricRandom(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::SymmetricRandom",0,0)
  result = (Ogre::Real)Ogre::Math::SymmetricRandom();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_SetRandomValueProvider(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Math::RandomValueProvider *arg1 = (Ogre::Math::RandomValueProvider *) 0 ;
  
  SWIG_check_num_args("Ogre::Math::SetRandomValueProvider",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Math::SetRandomValueProvider",1,"Ogre::Math::RandomValueProvider *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Math__RandomValueProvider,0))){
    SWIG_fail_ptr("Math_SetRandomValueProvider",1,SWIGTYPE_p_Ogre__Math__RandomValueProvider);
  }
  
  Ogre::Math::SetRandomValueProvider(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Tan__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Tan",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Tan",1,"Ogre::Radian const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Tan",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Tan",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Tan((Ogre::Radian const &)*arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Tan__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Radian *arg1 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Tan",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::Tan",1,"Ogre::Radian const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Math_Tan",1,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = (Ogre::Real)Ogre::Math::Tan((Ogre::Radian const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Tan__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  bool arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Tan",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Tan",1,"Ogre::Real");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::Math::Tan",2,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Ogre::Real)Ogre::Math::Tan(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Tan__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::Tan",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::Tan",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::Tan(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_Tan(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Math_Tan__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_Tan__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Tan__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_Tan__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_Tan'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::Tan(Ogre::Radian const &,bool)\n"
    "    Ogre::Math::Tan(Ogre::Radian const &)\n"
    "    Ogre::Math::Tan(Ogre::Real,bool)\n"
    "    Ogre::Math::Tan(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_DegreesToRadians(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::DegreesToRadians",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::DegreesToRadians",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::DegreesToRadians(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_RadiansToDegrees(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::RadiansToDegrees",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::RadiansToDegrees",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::RadiansToDegrees(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_setAngleUnit(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Math::AngleUnit arg1 ;
  
  SWIG_check_num_args("Ogre::Math::setAngleUnit",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::setAngleUnit",1,"Ogre::Math::AngleUnit");
  arg1 = (Ogre::Math::AngleUnit)(int)lua_tonumber(L, 1);
  Ogre::Math::setAngleUnit(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_getAngleUnit(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Math::AngleUnit result;
  
  SWIG_check_num_args("Ogre::Math::getAngleUnit",0,0)
  result = (Ogre::Math::AngleUnit)Ogre::Math::getAngleUnit();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_AngleUnitsToRadians(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::AngleUnitsToRadians",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::AngleUnitsToRadians",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::AngleUnitsToRadians(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_RadiansToAngleUnits(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::RadiansToAngleUnits",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::RadiansToAngleUnits",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::RadiansToAngleUnits(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_AngleUnitsToDegrees(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::AngleUnitsToDegrees",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::AngleUnitsToDegrees",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::AngleUnitsToDegrees(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_DegreesToAngleUnits(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::DegreesToAngleUnits",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::DegreesToAngleUnits",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::DegreesToAngleUnits(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_pointInTri2D(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  Ogre::Vector2 *arg4 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::pointInTri2D",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::pointInTri2D",1,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::pointInTri2D",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::pointInTri2D",3,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::pointInTri2D",4,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Math_pointInTri2D",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Math_pointInTri2D",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Math_pointInTri2D",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Math_pointInTri2D",4,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)Ogre::Math::pointInTri2D((Ogre::Vector2 const &)*arg1,(Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3,(Ogre::Vector2 const &)*arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_pointInTri3D(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  Ogre::Vector3 *arg5 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::pointInTri3D",5,5)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::pointInTri3D",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::pointInTri3D",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::pointInTri3D",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::pointInTri3D",4,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Math::pointInTri3D",5,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_pointInTri3D",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_pointInTri3D",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_pointInTri3D",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_pointInTri3D",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_pointInTri3D",5,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)Ogre::Math::pointInTri3D((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,(Ogre::Vector3 const &)*arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Plane *arg2 = 0 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Plane const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Plane,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Plane);
  }
  
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Plane const &)*arg2);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Sphere *arg2 = 0 ;
  bool arg3 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Sphere const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Sphere,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Sphere);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Sphere const &)*arg2,arg3);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Sphere *arg2 = 0 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Sphere const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Sphere,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Sphere);
  }
  
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Sphere const &)*arg2);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::AxisAlignedBox *arg2 = 0 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::AxisAlignedBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__AxisAlignedBox,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__AxisAlignedBox);
  }
  
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::AxisAlignedBox const &)*arg2);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::AxisAlignedBox *arg2 = 0 ;
  Ogre::Real *arg3 = (Ogre::Real *) 0 ;
  Ogre::Real *arg4 = (Ogre::Real *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::intersects",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::AxisAlignedBox const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Real *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Real *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__AxisAlignedBox,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__AxisAlignedBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_float);
  }
  
  result = (bool)Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::AxisAlignedBox const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  Ogre::Vector3 *arg5 = 0 ;
  bool arg6 ;
  bool arg7 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",7,7)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Math::intersects",5,"Ogre::Vector3 const &");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("Ogre::Math::intersects",6,"bool");
  if(!lua_isboolean(L,7)) SWIG_fail_arg("Ogre::Math::intersects",7,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",5,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg6 = (lua_toboolean(L, 6)!=0);
  arg7 = (lua_toboolean(L, 7)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,(Ogre::Vector3 const &)*arg5,arg6,arg7);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  Ogre::Vector3 *arg5 = 0 ;
  bool arg6 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",6,6)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Math::intersects",5,"Ogre::Vector3 const &");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("Ogre::Math::intersects",6,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",5,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg6 = (lua_toboolean(L, 6)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,(Ogre::Vector3 const &)*arg5,arg6);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_7(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  Ogre::Vector3 *arg5 = 0 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",5,5)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Ogre::Math::intersects",5,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",5,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,(Ogre::Vector3 const &)*arg5);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_8(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  bool arg5 ;
  bool arg6 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",6,6)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("Ogre::Math::intersects",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("Ogre::Math::intersects",6,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg5 = (lua_toboolean(L, 5)!=0);
  arg6 = (lua_toboolean(L, 6)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,arg5,arg6);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_9(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  bool arg5 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",5,5)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("Ogre::Math::intersects",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg5 = (lua_toboolean(L, 5)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4,arg5);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_10(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::Math::intersects",4,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_intersects",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_11(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Sphere *arg1 = 0 ;
  Ogre::AxisAlignedBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Sphere const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::AxisAlignedBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Sphere,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Sphere);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__AxisAlignedBox,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__AxisAlignedBox);
  }
  
  result = (bool)Ogre::Math::intersects((Ogre::Sphere const &)*arg1,(Ogre::AxisAlignedBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_12(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Plane *arg1 = 0 ;
  Ogre::AxisAlignedBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Plane const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::AxisAlignedBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Plane,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__AxisAlignedBox,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__AxisAlignedBox);
  }
  
  result = (bool)Ogre::Math::intersects((Ogre::Plane const &)*arg1,(Ogre::AxisAlignedBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_13(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::vector< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type *arg2 = 0 ;
  bool arg3 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::vector< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::vector< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &)*arg2,arg3);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_14(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Ray *arg1 = 0 ;
  Ogre::list< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type *arg2 = 0 ;
  bool arg3 ;
  std::pair< bool,Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::Math::intersects",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Ray const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::list< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Ogre::Math::intersects",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Ray,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Ray);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = Ogre::Math::intersects((Ogre::Ray const &)*arg1,(Ogre::list< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &)*arg2,arg3);
  {
    std::pair< bool,Ogre::Real > * resultptr = new std::pair< bool,Ogre::Real >((const std::pair< bool,Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__pairT_bool_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects__SWIG_15(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Sphere *arg1 = 0 ;
  Ogre::Plane *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::intersects",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::intersects",1,"Ogre::Sphere const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::intersects",2,"Ogre::Plane const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Sphere,0))){
    SWIG_fail_ptr("Math_intersects",1,SWIGTYPE_p_Ogre__Sphere);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Plane,0))){
    SWIG_fail_ptr("Math_intersects",2,SWIGTYPE_p_Ogre__Plane);
  }
  
  result = (bool)Ogre::Math::intersects((Ogre::Sphere const &)*arg1,(Ogre::Plane const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_intersects(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Plane, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Sphere, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__AxisAlignedBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_3(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Sphere, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__AxisAlignedBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_11(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Plane, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__AxisAlignedBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_12(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Sphere, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Plane, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_intersects__SWIG_15(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Math_intersects__SWIG_13(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Math_intersects__SWIG_14(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Sphere, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Math_intersects__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Math_intersects__SWIG_10(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__AxisAlignedBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_float, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_Math_intersects__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_Math_intersects__SWIG_7(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_Math_intersects__SWIG_9(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                return _wrap_Math_intersects__SWIG_6(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                return _wrap_Math_intersects__SWIG_8(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Ray, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isboolean(L,argv[6]);
                }
                if (_v) {
                  return _wrap_Math_intersects__SWIG_5(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_intersects'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Plane const &)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Sphere const &,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Sphere const &)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::AxisAlignedBox const &)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::AxisAlignedBox const &,Ogre::Real *,Ogre::Real *)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,bool,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,bool,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Ogre::Math::intersects(Ogre::Sphere const &,Ogre::AxisAlignedBox const &)\n"
    "    Ogre::Math::intersects(Ogre::Plane const &,Ogre::AxisAlignedBox const &)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::vector< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &,bool)\n"
    "    Ogre::Math::intersects(Ogre::Ray const &,Ogre::list< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type const &,bool)\n"
    "    Ogre::Math::intersects(Ogre::Sphere const &,Ogre::Plane const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_RealEqual__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::RealEqual",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::RealEqual",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::RealEqual",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Math::RealEqual",3,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (bool)Ogre::Math::RealEqual(arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_RealEqual__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Math::RealEqual",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::RealEqual",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::RealEqual",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (bool)Ogre::Math::RealEqual(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_RealEqual(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_RealEqual__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Math_RealEqual__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_RealEqual'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::RealEqual(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Ogre::Math::RealEqual(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_calculateTangentSpaceVector(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Ogre::Real arg6 ;
  Ogre::Real arg7 ;
  Ogre::Real arg8 ;
  Ogre::Real arg9 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Math::calculateTangentSpaceVector",9,9)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",3,"Ogre::Vector3 const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",6,"Ogre::Real");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",7,"Ogre::Real");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",8,"Ogre::Real");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("Ogre::Math::calculateTangentSpaceVector",9,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateTangentSpaceVector",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateTangentSpaceVector",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateTangentSpaceVector",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  arg6 = (Ogre::Real)lua_tonumber(L, 6);
  arg7 = (Ogre::Real)lua_tonumber(L, 7);
  arg8 = (Ogre::Real)lua_tonumber(L, 8);
  arg9 = (Ogre::Real)lua_tonumber(L, 9);
  result = Ogre::Math::calculateTangentSpaceVector((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_buildReflectionMatrix(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Plane *arg1 = 0 ;
  Ogre::Matrix4 result;
  
  SWIG_check_num_args("Ogre::Math::buildReflectionMatrix",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::buildReflectionMatrix",1,"Ogre::Plane const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Plane,0))){
    SWIG_fail_ptr("Math_buildReflectionMatrix",1,SWIGTYPE_p_Ogre__Plane);
  }
  
  result = Ogre::Math::buildReflectionMatrix((Ogre::Plane const &)*arg1);
  {
    Ogre::Matrix4 * resultptr = new Ogre::Matrix4((const Ogre::Matrix4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Matrix4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_calculateFaceNormal(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Math::calculateFaceNormal",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::calculateFaceNormal",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::calculateFaceNormal",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::calculateFaceNormal",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormal",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormal",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormal",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::calculateFaceNormal((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_calculateBasicFaceNormal(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Math::calculateBasicFaceNormal",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormal",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormal",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormal",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormal",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormal",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormal",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::calculateBasicFaceNormal((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_calculateFaceNormalWithoutNormalize(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector4 result;
  
  SWIG_check_num_args("Ogre::Math::calculateFaceNormalWithoutNormalize",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::calculateFaceNormalWithoutNormalize",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::calculateFaceNormalWithoutNormalize",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::calculateFaceNormalWithoutNormalize",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormalWithoutNormalize",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormalWithoutNormalize",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateFaceNormalWithoutNormalize",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::calculateFaceNormalWithoutNormalize((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Vector4 * resultptr = new Ogre::Vector4((const Ogre::Vector4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_calculateBasicFaceNormalWithoutNormalize(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Ogre::Math::calculateBasicFaceNormalWithoutNormalize",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormalWithoutNormalize",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormalWithoutNormalize",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::Math::calculateBasicFaceNormalWithoutNormalize",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormalWithoutNormalize",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormalWithoutNormalize",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_calculateBasicFaceNormalWithoutNormalize",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = Ogre::Math::calculateBasicFaceNormalWithoutNormalize((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_gaussianDistribution__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::gaussianDistribution",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",3,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Ogre::Real)Ogre::Math::gaussianDistribution(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_gaussianDistribution__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::gaussianDistribution",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Ogre::Real)Ogre::Math::gaussianDistribution(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_gaussianDistribution__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::gaussianDistribution",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Math::gaussianDistribution",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Ogre::Real)Ogre::Math::gaussianDistribution(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_gaussianDistribution(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_Math_gaussianDistribution__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Math_gaussianDistribution__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Math_gaussianDistribution__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_gaussianDistribution'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::gaussianDistribution(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Ogre::Math::gaussianDistribution(Ogre::Real,Ogre::Real)\n"
    "    Ogre::Math::gaussianDistribution(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_makeViewMatrix__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Matrix4 *arg3 = (Ogre::Matrix4 *) 0 ;
  Ogre::Matrix4 result;
  
  SWIG_check_num_args("Ogre::Math::makeViewMatrix",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::makeViewMatrix",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::makeViewMatrix",2,"Ogre::Quaternion const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Ogre::Math::makeViewMatrix",3,"Ogre::Matrix4 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_makeViewMatrix",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Math_makeViewMatrix",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Matrix4,0))){
    SWIG_fail_ptr("Math_makeViewMatrix",3,SWIGTYPE_p_Ogre__Matrix4);
  }
  
  result = Ogre::Math::makeViewMatrix((Ogre::Vector3 const &)*arg1,(Ogre::Quaternion const &)*arg2,(Ogre::Matrix4 const *)arg3);
  {
    Ogre::Matrix4 * resultptr = new Ogre::Matrix4((const Ogre::Matrix4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Matrix4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_makeViewMatrix__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Ogre::Matrix4 result;
  
  SWIG_check_num_args("Ogre::Math::makeViewMatrix",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::makeViewMatrix",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Math::makeViewMatrix",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Math_makeViewMatrix",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("Math_makeViewMatrix",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = Ogre::Math::makeViewMatrix((Ogre::Vector3 const &)*arg1,(Ogre::Quaternion const &)*arg2);
  {
    Ogre::Matrix4 * resultptr = new Ogre::Matrix4((const Ogre::Matrix4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Matrix4,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_makeViewMatrix(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Math_makeViewMatrix__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Matrix4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Math_makeViewMatrix__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Math_makeViewMatrix'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Math::makeViewMatrix(Ogre::Vector3 const &,Ogre::Quaternion const &,Ogre::Matrix4 const *)\n"
    "    Ogre::Math::makeViewMatrix(Ogre::Vector3 const &,Ogre::Quaternion const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Math_boundingRadiusFromAABB(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::AxisAlignedBox *arg1 = 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::boundingRadiusFromAABB",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::Math::boundingRadiusFromAABB",1,"Ogre::AxisAlignedBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__AxisAlignedBox,0))){
    SWIG_fail_ptr("Math_boundingRadiusFromAABB",1,SWIGTYPE_p_Ogre__AxisAlignedBox);
  }
  
  result = (Ogre::Real)Ogre::Math::boundingRadiusFromAABB((Ogre::AxisAlignedBox const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_POS_INFINITY_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::POS_INFINITY",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::POS_INFINITY;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_NEG_INFINITY_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::NEG_INFINITY",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::NEG_INFINITY;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_PI_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::PI",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::PI;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_TWO_PI_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::TWO_PI",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::TWO_PI;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_HALF_PI_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::HALF_PI",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::HALF_PI;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_fDeg2Rad_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::fDeg2Rad",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::fDeg2Rad;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Math_fRad2Deg_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real result;
  
  SWIG_check_num_args("Ogre::Math::fRad2Deg",0,0)
  result = (Ogre::Real)(Ogre::Real)Ogre::Math::fRad2Deg;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Math(void *obj) {
Ogre::Math *arg1 = (Ogre::Math *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Math_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Ogre_Math_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Math_bases[] = {0};
static const char *swig_Ogre_Math_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Math = { "Math", &SWIGTYPE_p_Ogre__Math,_wrap_new_Math, swig_delete_Math, swig_Ogre_Math_methods, swig_Ogre_Math_attributes, swig_Ogre_Math_bases, swig_Ogre_Math_base_names };

static int _wrap___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::operator *",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::operator *",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::operator *",2,"Ogre::Radian const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("__mul",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = Ogre::operator *(arg1,(Ogre::Radian const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Radian *arg2 = 0 ;
  Ogre::Radian result;
  
  SWIG_check_num_args("Ogre::operator /",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::operator /",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::operator /",2,"Ogre::Radian const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("__div",2,SWIGTYPE_p_Ogre__Radian);
  }
  
  result = Ogre::operator /(arg1,(Ogre::Radian const &)*arg2);
  {
    Ogre::Radian * resultptr = new Ogre::Radian((const Ogre::Radian &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Radian,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::operator *",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::operator *",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::operator *",2,"Ogre::Degree const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("__mul",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = Ogre::operator *(arg1,(Ogre::Degree const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap___mul__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function '__mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::operator *(Ogre::Real,Ogre::Radian const &)\n"
    "    Ogre::operator *(Ogre::Real,Ogre::Degree const &)\n");
  lua_error(L);return 0;
}


static int _wrap___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Degree *arg2 = 0 ;
  Ogre::Degree result;
  
  SWIG_check_num_args("Ogre::operator /",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::operator /",1,"Ogre::Real");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::operator /",2,"Ogre::Degree const &");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("__div",2,SWIGTYPE_p_Ogre__Degree);
  }
  
  result = Ogre::operator /(arg1,(Ogre::Degree const &)*arg2);
  {
    Ogre::Degree * resultptr = new Ogre::Degree((const Ogre::Degree &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Degree,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap___div__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap___div__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function '__div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::operator /(Ogre::Real,Ogre::Radian const &)\n"
    "    Ogre::operator /(Ogre::Real,Ogre::Degree const &)\n");
  lua_error(L);return 0;
}


static int _wrap_FastHash__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  Ogre::uint32 arg3 ;
  Ogre::uint32 result;
  
  SWIG_check_num_args("Ogre::FastHash",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("Ogre::FastHash",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::FastHash",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::FastHash",3,"Ogre::uint32");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (Ogre::uint32)lua_tonumber(L, 3);
  result = (Ogre::uint32)Ogre::FastHash((char const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FastHash__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  Ogre::uint32 result;
  
  SWIG_check_num_args("Ogre::FastHash",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("Ogre::FastHash",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::FastHash",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (Ogre::uint32)Ogre::FastHash((char const *)arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FastHash(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      _v = SWIG_lua_isnilstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_FastHash__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = SWIG_lua_isnilstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_FastHash__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'FastHash'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::FastHash(char const *,int,Ogre::uint32)\n"
    "    Ogre::FastHash(char const *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_Box_left_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::left",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::left",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_left_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->left = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_left_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::left",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_left_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->left);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_top_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::top",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::top",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_top_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->top = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_top_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::top",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_top_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->top);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_right_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::right",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::right",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_right_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->right = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_right_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::right",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_right_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->right);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_bottom_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::bottom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::bottom",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::bottom",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_bottom_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->bottom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_bottom_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::bottom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::bottom",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_bottom_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->bottom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_front_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::front",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::front",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::front",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_front_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->front = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_front_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::front",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_front_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->front);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_back_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Ogre::Box::back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::back",1,"Ogre::Box *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::back",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_back_set",1,SWIGTYPE_p_Ogre__Box);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->back = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_back_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::back",1,"Ogre::Box *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_back_get",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result =  ((arg1)->back);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Box__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *result = 0 ;
  
  SWIG_check_num_args("Ogre::Box::Box",0,0)
  result = (Ogre::Box *)new Ogre::Box();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Box,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Box__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  size_t arg1 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  Ogre::Box *result = 0 ;
  
  SWIG_check_num_args("Ogre::Box::Box",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Box::Box",1,"size_t");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::Box",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Box::Box",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Box::Box",4,"size_t");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (size_t)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (size_t)lua_tonumber(L, 4);
  result = (Ogre::Box *)new Ogre::Box(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Box,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Box__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  size_t arg1 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  size_t arg6 ;
  Ogre::Box *result = 0 ;
  
  SWIG_check_num_args("Ogre::Box::Box",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::Box::Box",1,"size_t");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::Box::Box",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::Box::Box",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::Box::Box",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Ogre::Box::Box",5,"size_t");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Ogre::Box::Box",6,"size_t");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (size_t)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (size_t)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (size_t)lua_tonumber(L, 6);
  result = (Ogre::Box *)new Ogre::Box(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Box,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Box(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Box__SWIG_0(L);
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Box__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_new_Box__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Box'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::Box::Box()\n"
    "    Ogre::Box::Box(size_t,size_t,size_t,size_t)\n"
    "    Ogre::Box::Box(size_t,size_t,size_t,size_t,size_t,size_t)\n");
  lua_error(L);return 0;
}


static int _wrap_Box_contains(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  Ogre::Box *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::Box::contains",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::contains",1,"Ogre::Box const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::Box::contains",2,"Ogre::Box const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_contains",1,SWIGTYPE_p_Ogre__Box);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_contains",2,SWIGTYPE_p_Ogre__Box);
  }
  
  result = (bool)((Ogre::Box const *)arg1)->contains((Ogre::Box const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_getWidth(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::getWidth",1,"Ogre::Box const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_getWidth",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result = ((Ogre::Box const *)arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_getHeight(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::getHeight",1,"Ogre::Box const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_getHeight",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result = ((Ogre::Box const *)arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Box_getDepth(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Box *arg1 = (Ogre::Box *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Ogre::Box::getDepth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::Box::getDepth",1,"Ogre::Box const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Box,0))){
    SWIG_fail_ptr("Box_getDepth",1,SWIGTYPE_p_Ogre__Box);
  }
  
  result = ((Ogre::Box const *)arg1)->getDepth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Box(void *obj) {
Ogre::Box *arg1 = (Ogre::Box *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_Box_methods[] = {
    {"contains", _wrap_Box_contains}, 
    {"getWidth", _wrap_Box_getWidth}, 
    {"getHeight", _wrap_Box_getHeight}, 
    {"getDepth", _wrap_Box_getDepth}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_Box_attributes[] = {
    { "left", _wrap_Box_left_get, _wrap_Box_left_set},
    { "top", _wrap_Box_top_get, _wrap_Box_top_set},
    { "right", _wrap_Box_right_get, _wrap_Box_right_set},
    { "bottom", _wrap_Box_bottom_get, _wrap_Box_bottom_set},
    { "front", _wrap_Box_front_get, _wrap_Box_front_set},
    { "back", _wrap_Box_back_get, _wrap_Box_back_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_Box_bases[] = {0};
static const char *swig_Ogre_Box_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_Box = { "Box", &SWIGTYPE_p_Ogre__Box,_wrap_new_Box, swig_delete_Box, swig_Ogre_Box_methods, swig_Ogre_Box_attributes, swig_Ogre_Box_bases, swig_Ogre_Box_base_names };

static int _wrap_findCommandLineOpts(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 = (char **) 0 ;
  Ogre::UnaryOptionList *arg3 = 0 ;
  Ogre::BinaryOptionList *arg4 = 0 ;
  int result;
  
  SWIG_check_num_args("Ogre::findCommandLineOpts",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::findCommandLineOpts",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Ogre::findCommandLineOpts",2,"char **");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Ogre::findCommandLineOpts",3,"Ogre::UnaryOptionList &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Ogre::findCommandLineOpts",4,"Ogre::BinaryOptionList &");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("findCommandLineOpts",2,SWIGTYPE_p_p_char);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type,0))){
    SWIG_fail_ptr("findCommandLineOpts",3,SWIGTYPE_p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type,0))){
    SWIG_fail_ptr("findCommandLineOpts",4,SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type);
  }
  
  result = (int)Ogre::findCommandLineOpts(arg1,arg2,*arg3,*arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_name_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  Ogre::String *arg2 = 0 ;
  std::string temp2 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::name",1,"Ogre::RenderWindowDescription *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Ogre::RenderWindowDescription::name",2,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_name_set",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->name = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_name_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  Ogre::String *result = 0 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::name",1,"Ogre::RenderWindowDescription *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_name_get",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  result = (Ogre::String *) & ((arg1)->name);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_width_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::width",1,"Ogre::RenderWindowDescription *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::RenderWindowDescription::width",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_width_set",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_width_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::width",1,"Ogre::RenderWindowDescription *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_width_get",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  result = (unsigned int) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_height_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::height",1,"Ogre::RenderWindowDescription *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::RenderWindowDescription::height",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_height_set",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_height_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::height",1,"Ogre::RenderWindowDescription *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_height_get",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  result = (unsigned int) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_useFullScreen_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::useFullScreen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::useFullScreen",1,"Ogre::RenderWindowDescription *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Ogre::RenderWindowDescription::useFullScreen",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_useFullScreen_set",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->useFullScreen = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_useFullScreen_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::useFullScreen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::useFullScreen",1,"Ogre::RenderWindowDescription *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_useFullScreen_get",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  result = (bool) ((arg1)->useFullScreen);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_miscParams_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  Ogre::NameValuePairList *arg2 = (Ogre::NameValuePairList *) 0 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::miscParams",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::miscParams",1,"Ogre::RenderWindowDescription *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Ogre::RenderWindowDescription::miscParams",2,"Ogre::NameValuePairList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_miscParams_set",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type,0))){
    SWIG_fail_ptr("RenderWindowDescription_miscParams_set",2,SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type);
  }
  
  if (arg1) (arg1)->miscParams = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenderWindowDescription_miscParams_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) 0 ;
  Ogre::NameValuePairList *result = 0 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::miscParams",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::RenderWindowDescription::miscParams",1,"Ogre::RenderWindowDescription *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__RenderWindowDescription,0))){
    SWIG_fail_ptr("RenderWindowDescription_miscParams_get",1,SWIGTYPE_p_Ogre__RenderWindowDescription);
  }
  
  result = (Ogre::NameValuePairList *)& ((arg1)->miscParams);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RenderWindowDescription(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::RenderWindowDescription *result = 0 ;
  
  SWIG_check_num_args("Ogre::RenderWindowDescription::RenderWindowDescription",0,0)
  result = (Ogre::RenderWindowDescription *)new Ogre::RenderWindowDescription();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__RenderWindowDescription,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RenderWindowDescription(void *obj) {
Ogre::RenderWindowDescription *arg1 = (Ogre::RenderWindowDescription *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_RenderWindowDescription_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Ogre_RenderWindowDescription_attributes[] = {
    { "name", _wrap_RenderWindowDescription_name_get, _wrap_RenderWindowDescription_name_set},
    { "width", _wrap_RenderWindowDescription_width_get, _wrap_RenderWindowDescription_width_set},
    { "height", _wrap_RenderWindowDescription_height_get, _wrap_RenderWindowDescription_height_set},
    { "useFullScreen", _wrap_RenderWindowDescription_useFullScreen_get, _wrap_RenderWindowDescription_useFullScreen_set},
    { "miscParams", _wrap_RenderWindowDescription_miscParams_get, _wrap_RenderWindowDescription_miscParams_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_RenderWindowDescription_bases[] = {0};
static const char *swig_Ogre_RenderWindowDescription_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_RenderWindowDescription = { "RenderWindowDescription", &SWIGTYPE_p_Ogre__RenderWindowDescription,_wrap_new_RenderWindowDescription, swig_delete_RenderWindowDescription, swig_Ogre_RenderWindowDescription_methods, swig_Ogre_RenderWindowDescription_attributes, swig_Ogre_RenderWindowDescription_bases, swig_Ogre_RenderWindowDescription_base_names };

static int _wrap_new_NameGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::NameGenerator *arg1 = 0 ;
  Ogre::NameGenerator *result = 0 ;
  
  SWIG_check_num_args("Ogre::NameGenerator::NameGenerator",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::NameGenerator::NameGenerator",1,"Ogre::NameGenerator const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__NameGenerator,0))){
    SWIG_fail_ptr("new_NameGenerator",1,SWIGTYPE_p_Ogre__NameGenerator);
  }
  
  result = (Ogre::NameGenerator *)new Ogre::NameGenerator((Ogre::NameGenerator const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__NameGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NameGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::String *arg1 = 0 ;
  std::string temp1 ;
  Ogre::NameGenerator *result = 0 ;
  
  SWIG_check_num_args("Ogre::NameGenerator::NameGenerator",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("Ogre::NameGenerator::NameGenerator",1,"Ogre::String const &");
  temp1.assign(lua_tostring(L,1),lua_strlen(L,1)); arg1=&temp1;
  result = (Ogre::NameGenerator *)new Ogre::NameGenerator((Ogre::String const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__NameGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NameGenerator(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__NameGenerator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_NameGenerator__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_NameGenerator__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_NameGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::NameGenerator::NameGenerator(Ogre::NameGenerator const &)\n"
    "    Ogre::NameGenerator::NameGenerator(Ogre::String const &)\n");
  lua_error(L);return 0;
}


static int _wrap_NameGenerator_generate(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::NameGenerator *arg1 = (Ogre::NameGenerator *) 0 ;
  Ogre::String result;
  
  SWIG_check_num_args("Ogre::NameGenerator::generate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::NameGenerator::generate",1,"Ogre::NameGenerator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__NameGenerator,0))){
    SWIG_fail_ptr("NameGenerator_generate",1,SWIGTYPE_p_Ogre__NameGenerator);
  }
  
  result = (arg1)->generate();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameGenerator_reset(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::NameGenerator *arg1 = (Ogre::NameGenerator *) 0 ;
  
  SWIG_check_num_args("Ogre::NameGenerator::reset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::NameGenerator::reset",1,"Ogre::NameGenerator *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__NameGenerator,0))){
    SWIG_fail_ptr("NameGenerator_reset",1,SWIGTYPE_p_Ogre__NameGenerator);
  }
  
  (arg1)->reset();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameGenerator_setNext(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::NameGenerator *arg1 = (Ogre::NameGenerator *) 0 ;
  unsigned long long arg2 ;
  
  SWIG_check_num_args("Ogre::NameGenerator::setNext",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::NameGenerator::setNext",1,"Ogre::NameGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::NameGenerator::setNext",2,"unsigned long long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__NameGenerator,0))){
    SWIG_fail_ptr("NameGenerator_setNext",1,SWIGTYPE_p_Ogre__NameGenerator);
  }
  
  arg2 = (unsigned long long)lua_tonumber(L, 2);
  (arg1)->setNext(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameGenerator_getNext(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::NameGenerator *arg1 = (Ogre::NameGenerator *) 0 ;
  unsigned long long result;
  
  SWIG_check_num_args("Ogre::NameGenerator::getNext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::NameGenerator::getNext",1,"Ogre::NameGenerator const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__NameGenerator,0))){
    SWIG_fail_ptr("NameGenerator_getNext",1,SWIGTYPE_p_Ogre__NameGenerator);
  }
  
  result = (unsigned long long)((Ogre::NameGenerator const *)arg1)->getNext();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NameGenerator(void *obj) {
Ogre::NameGenerator *arg1 = (Ogre::NameGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_NameGenerator_methods[] = {
    {"generate", _wrap_NameGenerator_generate}, 
    {"reset", _wrap_NameGenerator_reset}, 
    {"setNext", _wrap_NameGenerator_setNext}, 
    {"getNext", _wrap_NameGenerator_getNext}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_NameGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Ogre_NameGenerator_bases[] = {0};
static const char *swig_Ogre_NameGenerator_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_NameGenerator = { "NameGenerator", &SWIGTYPE_p_Ogre__NameGenerator,_wrap_new_NameGenerator, swig_delete_NameGenerator, swig_Ogre_NameGenerator_methods, swig_Ogre_NameGenerator_attributes, swig_Ogre_NameGenerator_bases, swig_Ogre_NameGenerator_base_names };

static int _wrap_Rect_left_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::left",1,"Ogre::TRect< long > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< long >::left",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_left_set",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->left = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_left_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::left",1,"Ogre::TRect< long > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_left_get",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long) ((arg1)->left);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_top_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::top",1,"Ogre::TRect< long > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< long >::top",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_top_set",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->top = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_top_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::top",1,"Ogre::TRect< long > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_top_get",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long) ((arg1)->top);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_right_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::right",1,"Ogre::TRect< long > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< long >::right",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_right_set",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->right = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_right_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::right",1,"Ogre::TRect< long > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_right_get",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long) ((arg1)->right);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_bottom_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::bottom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::bottom",1,"Ogre::TRect< long > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< long >::bottom",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_bottom_set",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->bottom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_bottom_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::bottom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::bottom",1,"Ogre::TRect< long > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_bottom_get",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long) ((arg1)->bottom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Rect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::TRect",0,0)
  result = (Ogre::TRect< long > *)new Ogre::TRect< long >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_long_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Rect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  long *arg1 = 0 ;
  long *arg2 = 0 ;
  long *arg3 = 0 ;
  long *arg4 = 0 ;
  long temp1 ;
  long temp2 ;
  long temp3 ;
  long temp4 ;
  Ogre::TRect< long > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::TRect",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::TRect< long >::TRect",1,"long const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< long >::TRect",2,"long const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::TRect< long >::TRect",3,"long const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::TRect< long >::TRect",4,"long const &");
  temp1=(long)lua_tonumber(L,1); arg1=&temp1;
  temp2=(long)lua_tonumber(L,2); arg2=&temp2;
  temp3=(long)lua_tonumber(L,3); arg3=&temp3;
  temp4=(long)lua_tonumber(L,4); arg4=&temp4;
  result = (Ogre::TRect< long > *)new Ogre::TRect< long >((long const &)*arg1,(long const &)*arg2,(long const &)*arg3,(long const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_long_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Rect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = 0 ;
  Ogre::TRect< long > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::TRect",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::TRect< long >::TRect",1,"Ogre::TRect< long > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("new_Rect",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (Ogre::TRect< long > *)new Ogre::TRect< long >((Ogre::TRect< long > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_long_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Rect(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Rect__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_long_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Rect__SWIG_2(L);
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Rect__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Rect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::TRect< long >::TRect()\n"
    "    Ogre::TRect< long >::TRect(long const &,long const &,long const &,long const &)\n"
    "    Ogre::TRect< long >::TRect(Ogre::TRect< long > const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Rect_width(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::width",1,"Ogre::TRect< long > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_width",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long)((Ogre::TRect< long > const *)arg1)->width();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_height(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  long result;
  
  SWIG_check_num_args("Ogre::TRect< long >::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::height",1,"Ogre::TRect< long > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_height",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (long)((Ogre::TRect< long > const *)arg1)->height();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_isNull(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::TRect< long >::isNull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::isNull",1,"Ogre::TRect< long > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_isNull",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (bool)((Ogre::TRect< long > const *)arg1)->isNull();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_setNull(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::setNull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::setNull",1,"Ogre::TRect< long > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_setNull",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  (arg1)->setNull();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_merge(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  Ogre::TRect< long > *arg2 = 0 ;
  Ogre::TRect< long > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< long >::merge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::merge",1,"Ogre::TRect< long > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::TRect< long >::merge",2,"Ogre::TRect< long > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_merge",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_merge",2,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = (Ogre::TRect< long > *) &(arg1)->merge((Ogre::TRect< long > const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_long_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rect_intersect(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) 0 ;
  Ogre::TRect< long > *arg2 = 0 ;
  Ogre::TRect< long > result;
  
  SWIG_check_num_args("Ogre::TRect< long >::intersect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< long >::intersect",1,"Ogre::TRect< long > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::TRect< long >::intersect",2,"Ogre::TRect< long > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_intersect",1,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Rect_intersect",2,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  
  result = ((Ogre::TRect< long > const *)arg1)->intersect((Ogre::TRect< long > const &)*arg2);
  {
    Ogre::TRect< long > * resultptr = new Ogre::TRect< long >((const Ogre::TRect< long > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__TRectT_long_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Rect(void *obj) {
Ogre::TRect< long > *arg1 = (Ogre::TRect< long > *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_TRect_Sl_long_Sg__methods[] = {
    {"width", _wrap_Rect_width}, 
    {"height", _wrap_Rect_height}, 
    {"isNull", _wrap_Rect_isNull}, 
    {"setNull", _wrap_Rect_setNull}, 
    {"merge", _wrap_Rect_merge}, 
    {"intersect", _wrap_Rect_intersect}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_TRect_Sl_long_Sg__attributes[] = {
    { "left", _wrap_Rect_left_get, _wrap_Rect_left_set},
    { "top", _wrap_Rect_top_get, _wrap_Rect_top_set},
    { "right", _wrap_Rect_right_get, _wrap_Rect_right_set},
    { "bottom", _wrap_Rect_bottom_get, _wrap_Rect_bottom_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_TRect_Sl_long_Sg__bases[] = {0};
static const char *swig_Ogre_TRect_Sl_long_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_TRect_Sl_long_Sg_ = { "Rect", &SWIGTYPE_p_Ogre__TRectT_long_t,_wrap_new_Rect, swig_delete_Rect, swig_Ogre_TRect_Sl_long_Sg__methods, swig_Ogre_TRect_Sl_long_Sg__attributes, swig_Ogre_TRect_Sl_long_Sg__bases, swig_Ogre_TRect_Sl_long_Sg__base_names };

static int _wrap_RealRect_left_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::left",1,"Ogre::TRect< Ogre::Real > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::left",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_left_set",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->left = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_left_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::left",1,"Ogre::TRect< Ogre::Real > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_left_get",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float) ((arg1)->left);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_top_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::top",1,"Ogre::TRect< Ogre::Real > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::top",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_top_set",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->top = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_top_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::top",1,"Ogre::TRect< Ogre::Real > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_top_get",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float) ((arg1)->top);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_right_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::right",1,"Ogre::TRect< Ogre::Real > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::right",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_right_set",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->right = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_right_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::right",1,"Ogre::TRect< Ogre::Real > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_right_get",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float) ((arg1)->right);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_bottom_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::bottom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::bottom",1,"Ogre::TRect< Ogre::Real > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::bottom",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_bottom_set",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->bottom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_bottom_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::bottom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::bottom",1,"Ogre::TRect< Ogre::Real > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_bottom_get",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float) ((arg1)->bottom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RealRect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::TRect",0,0)
  result = (Ogre::TRect< Ogre::Real > *)new Ogre::TRect< Ogre::Real >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_float_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RealRect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float *arg1 = 0 ;
  float *arg2 = 0 ;
  float *arg3 = 0 ;
  float *arg4 = 0 ;
  float temp1 ;
  float temp2 ;
  float temp3 ;
  float temp4 ;
  Ogre::TRect< Ogre::Real > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::TRect",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::TRect",1,"float const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::TRect",2,"float const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::TRect",3,"float const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::TRect",4,"float const &");
  temp1=(float)lua_tonumber(L,1); arg1=&temp1;
  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  temp3=(float)lua_tonumber(L,3); arg3=&temp3;
  temp4=(float)lua_tonumber(L,4); arg4=&temp4;
  result = (Ogre::TRect< Ogre::Real > *)new Ogre::TRect< Ogre::Real >((float const &)*arg1,(float const &)*arg2,(float const &)*arg3,(float const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_float_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RealRect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = 0 ;
  Ogre::TRect< Ogre::Real > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::TRect",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::TRect",1,"Ogre::TRect< Ogre::Real > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("new_RealRect",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Ogre::TRect< Ogre::Real > *)new Ogre::TRect< Ogre::Real >((Ogre::TRect< Ogre::Real > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_float_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RealRect(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_RealRect__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_RealRect__SWIG_2(L);
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_RealRect__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_RealRect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::TRect< Ogre::Real >::TRect()\n"
    "    Ogre::TRect< Ogre::Real >::TRect(float const &,float const &,float const &,float const &)\n"
    "    Ogre::TRect< Ogre::Real >::TRect(Ogre::TRect< Ogre::Real > const &)\n");
  lua_error(L);return 0;
}


static int _wrap_RealRect_width(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::width",1,"Ogre::TRect< Ogre::Real > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_width",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float)((Ogre::TRect< Ogre::Real > const *)arg1)->width();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_height(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::height",1,"Ogre::TRect< Ogre::Real > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_height",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (float)((Ogre::TRect< Ogre::Real > const *)arg1)->height();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_isNull(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::isNull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::isNull",1,"Ogre::TRect< Ogre::Real > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_isNull",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (bool)((Ogre::TRect< Ogre::Real > const *)arg1)->isNull();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_setNull(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::setNull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::setNull",1,"Ogre::TRect< Ogre::Real > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_setNull",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  (arg1)->setNull();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_merge(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  Ogre::TRect< Ogre::Real > *arg2 = 0 ;
  Ogre::TRect< Ogre::Real > *result = 0 ;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::merge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::merge",1,"Ogre::TRect< Ogre::Real > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::merge",2,"Ogre::TRect< Ogre::Real > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_merge",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_merge",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Ogre::TRect< Ogre::Real > *) &(arg1)->merge((Ogre::TRect< Ogre::Real > const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__TRectT_float_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRect_intersect(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) 0 ;
  Ogre::TRect< Ogre::Real > *arg2 = 0 ;
  Ogre::TRect< Ogre::Real > result;
  
  SWIG_check_num_args("Ogre::TRect< Ogre::Real >::intersect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::intersect",1,"Ogre::TRect< Ogre::Real > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::TRect< Ogre::Real >::intersect",2,"Ogre::TRect< Ogre::Real > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_intersect",1,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RealRect_intersect",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = ((Ogre::TRect< Ogre::Real > const *)arg1)->intersect((Ogre::TRect< Ogre::Real > const &)*arg2);
  {
    Ogre::TRect< Ogre::Real > * resultptr = new Ogre::TRect< Ogre::Real >((const Ogre::TRect< Ogre::Real > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__TRectT_float_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RealRect(void *obj) {
Ogre::TRect< Ogre::Real > *arg1 = (Ogre::TRect< Ogre::Real > *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_TRect_Sl_Ogre_Real_Sg__methods[] = {
    {"width", _wrap_RealRect_width}, 
    {"height", _wrap_RealRect_height}, 
    {"isNull", _wrap_RealRect_isNull}, 
    {"setNull", _wrap_RealRect_setNull}, 
    {"merge", _wrap_RealRect_merge}, 
    {"intersect", _wrap_RealRect_intersect}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_TRect_Sl_Ogre_Real_Sg__attributes[] = {
    { "left", _wrap_RealRect_left_get, _wrap_RealRect_left_set},
    { "top", _wrap_RealRect_top_get, _wrap_RealRect_top_set},
    { "right", _wrap_RealRect_right_get, _wrap_RealRect_right_set},
    { "bottom", _wrap_RealRect_bottom_get, _wrap_RealRect_bottom_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_TRect_Sl_Ogre_Real_Sg__bases[] = {0};
static const char *swig_Ogre_TRect_Sl_Ogre_Real_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_TRect_Sl_Ogre_Real_Sg_ = { "RealRect", &SWIGTYPE_p_Ogre__TRectT_float_t,_wrap_new_RealRect, swig_delete_RealRect, swig_Ogre_TRect_Sl_Ogre_Real_Sg__methods, swig_Ogre_TRect_Sl_Ogre_Real_Sg__attributes, swig_Ogre_TRect_Sl_Ogre_Real_Sg__bases, swig_Ogre_TRect_Sl_Ogre_Real_Sg__base_names };

static int _wrap_ColourValue_ZERO_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ZERO",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::ZERO;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_Black_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::Black",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::Black;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_White_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::White",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::White;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_Red_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::Red",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::Red;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_Green_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::Green",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::Green;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_Blue_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::Blue",0,0)
  result = (Ogre::ColourValue *)&Ogre::ColourValue::Blue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",4,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Ogre::ColourValue::ColourValue",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (Ogre::ColourValue *)new Ogre::ColourValue(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ColourValue",0,0)
  result = (Ogre::ColourValue *)new Ogre::ColourValue();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ColourValue(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ColourValue__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_ColourValue__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ColourValue__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_ColourValue__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_ColourValue__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_ColourValue'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::ColourValue::ColourValue(float,float,float,float)\n"
    "    Ogre::ColourValue::ColourValue(float,float,float)\n"
    "    Ogre::ColourValue::ColourValue(float,float)\n"
    "    Ogre::ColourValue::ColourValue(float)\n"
    "    Ogre::ColourValue::ColourValue()\n");
  lua_error(L);return 0;
}


static int _wrap_ColourValue___eq(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator ==",1,"Ogre::ColourValue const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator ==",2,"Ogre::ColourValue const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___eq",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___eq",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (bool)((Ogre::ColourValue const *)arg1)->operator ==((Ogre::ColourValue const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_r_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::r",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::r",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_r_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->r = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_r_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::r",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_r_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->r);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_g_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::g",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::g",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_g_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->g = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_g_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::g",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_g_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->g);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_b_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::b",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::b",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_b_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_b_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::b",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_b_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_a_set(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::a",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::a",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_a_set",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_a_get(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float result;
  
  SWIG_check_num_args("Ogre::ColourValue::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::a",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_a_get",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_getAsRGBA(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::RGBA result;
  
  SWIG_check_num_args("Ogre::ColourValue::getAsRGBA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::getAsRGBA",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_getAsRGBA",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (Ogre::RGBA)((Ogre::ColourValue const *)arg1)->getAsRGBA();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_getAsARGB(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ARGB result;
  
  SWIG_check_num_args("Ogre::ColourValue::getAsARGB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::getAsARGB",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_getAsARGB",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (Ogre::ARGB)((Ogre::ColourValue const *)arg1)->getAsARGB();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_getAsBGRA(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::BGRA result;
  
  SWIG_check_num_args("Ogre::ColourValue::getAsBGRA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::getAsBGRA",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_getAsBGRA",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (Ogre::BGRA)((Ogre::ColourValue const *)arg1)->getAsBGRA();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_getAsABGR(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ABGR result;
  
  SWIG_check_num_args("Ogre::ColourValue::getAsABGR",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::getAsABGR",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_getAsABGR",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (Ogre::ABGR)((Ogre::ColourValue const *)arg1)->getAsABGR();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_setAsRGBA(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::RGBA arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::setAsRGBA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::setAsRGBA",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::setAsRGBA",2,"Ogre::RGBA const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_setAsRGBA",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::RGBA const)lua_tonumber(L, 2);
  (arg1)->setAsRGBA(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_setAsARGB(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ARGB arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::setAsARGB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::setAsARGB",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::setAsARGB",2,"Ogre::ARGB const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_setAsARGB",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::ARGB const)lua_tonumber(L, 2);
  (arg1)->setAsARGB(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_setAsBGRA(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::BGRA arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::setAsBGRA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::setAsBGRA",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::setAsBGRA",2,"Ogre::BGRA const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_setAsBGRA",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::BGRA const)lua_tonumber(L, 2);
  (arg1)->setAsBGRA(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_setAsABGR(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ABGR arg2 ;
  
  SWIG_check_num_args("Ogre::ColourValue::setAsABGR",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::setAsABGR",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::setAsABGR",2,"Ogre::ABGR const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_setAsABGR",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::ABGR const)lua_tonumber(L, 2);
  (arg1)->setAsABGR(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_saturate(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::saturate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::saturate",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_saturate",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  (arg1)->saturate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_saturateCopy(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::saturateCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::saturateCopy",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_saturateCopy",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = ((Ogre::ColourValue const *)arg1)->saturateCopy();
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_ptr__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::ptr",1,"Ogre::ColourValue *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_ptr",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float *)(arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_ptr__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::ptr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::ptr",1,"Ogre::ColourValue const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_ptr",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = (float *)((Ogre::ColourValue const *)arg1)->ptr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_ptr(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_ColourValue_ptr__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_ColourValue_ptr__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'ColourValue_ptr'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::ColourValue::ptr()\n"
    "    Ogre::ColourValue::ptr() const\n");
  lua_error(L);return 0;
}


static int _wrap_ColourValue___add(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue *arg2 = 0 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator +",1,"Ogre::ColourValue const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator +",2,"Ogre::ColourValue const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___add",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___add",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = ((Ogre::ColourValue const *)arg1)->operator +((Ogre::ColourValue const &)*arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___sub(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue *arg2 = 0 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator -",1,"Ogre::ColourValue const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator -",2,"Ogre::ColourValue const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___sub",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___sub",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = ((Ogre::ColourValue const *)arg1)->operator -((Ogre::ColourValue const &)*arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator *",1,"Ogre::ColourValue const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator *",2,"float const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___mul",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float const)lua_tonumber(L, 2);
  result = ((Ogre::ColourValue const *)arg1)->operator *(arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue *arg2 = 0 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator *",1,"Ogre::ColourValue const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator *",2,"Ogre::ColourValue const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___mul",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___mul",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = ((Ogre::ColourValue const *)arg1)->operator *((Ogre::ColourValue const &)*arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_ColourValue___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_ColourValue___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'ColourValue___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::ColourValue::operator *(float const) const\n"
    "    Ogre::ColourValue::operator *(Ogre::ColourValue const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_ColourValue___div__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::ColourValue *arg2 = 0 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator /",1,"Ogre::ColourValue const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator /",2,"Ogre::ColourValue const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___div",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___div",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  result = ((Ogre::ColourValue const *)arg1)->operator /((Ogre::ColourValue const &)*arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___div__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  float arg2 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Ogre::ColourValue::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::operator /",1,"Ogre::ColourValue const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::operator /",2,"float const");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue___div",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (float const)lua_tonumber(L, 2);
  result = ((Ogre::ColourValue const *)arg1)->operator /(arg2);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue___div(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_ColourValue___div__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_ColourValue___div__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'ColourValue___div'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Ogre::ColourValue::operator /(Ogre::ColourValue const &) const\n"
    "    Ogre::ColourValue::operator /(float const) const\n");
  lua_error(L);return 0;
}


static int _wrap_ColourValue_setHSB(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  
  SWIG_check_num_args("Ogre::ColourValue::setHSB",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::setHSB",1,"Ogre::ColourValue *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Ogre::ColourValue::setHSB",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Ogre::ColourValue::setHSB",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Ogre::ColourValue::setHSB",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_setHSB",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  (arg1)->setHSB(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ColourValue_getHSB(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::ColourValue *arg1 = (Ogre::ColourValue *) 0 ;
  Ogre::Real *arg2 = (Ogre::Real *) 0 ;
  Ogre::Real *arg3 = (Ogre::Real *) 0 ;
  Ogre::Real *arg4 = (Ogre::Real *) 0 ;
  
  SWIG_check_num_args("Ogre::ColourValue::getHSB",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Ogre::ColourValue::getHSB",1,"Ogre::ColourValue const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Ogre::ColourValue::getHSB",2,"Ogre::Real *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Ogre::ColourValue::getHSB",3,"Ogre::Real *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("Ogre::ColourValue::getHSB",4,"Ogre::Real *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("ColourValue_getHSB",1,SWIGTYPE_p_Ogre__ColourValue);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ColourValue_getHSB",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ColourValue_getHSB",3,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ColourValue_getHSB",4,SWIGTYPE_p_float);
  }
  
  ((Ogre::ColourValue const *)arg1)->getHSB(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ColourValue(void *obj) {
Ogre::ColourValue *arg1 = (Ogre::ColourValue *) obj;
delete arg1;
}
static swig_lua_method swig_Ogre_ColourValue_methods[] = {
    {"__eq", _wrap_ColourValue___eq}, 
    {"getAsRGBA", _wrap_ColourValue_getAsRGBA}, 
    {"getAsARGB", _wrap_ColourValue_getAsARGB}, 
    {"getAsBGRA", _wrap_ColourValue_getAsBGRA}, 
    {"getAsABGR", _wrap_ColourValue_getAsABGR}, 
    {"setAsRGBA", _wrap_ColourValue_setAsRGBA}, 
    {"setAsARGB", _wrap_ColourValue_setAsARGB}, 
    {"setAsBGRA", _wrap_ColourValue_setAsBGRA}, 
    {"setAsABGR", _wrap_ColourValue_setAsABGR}, 
    {"saturate", _wrap_ColourValue_saturate}, 
    {"saturateCopy", _wrap_ColourValue_saturateCopy}, 
    {"ptr", _wrap_ColourValue_ptr}, 
    {"__add", _wrap_ColourValue___add}, 
    {"__sub", _wrap_ColourValue___sub}, 
    {"__mul", _wrap_ColourValue___mul}, 
    {"__div", _wrap_ColourValue___div}, 
    {"setHSB", _wrap_ColourValue_setHSB}, 
    {"getHSB", _wrap_ColourValue_getHSB}, 
    {0,0}
};
static swig_lua_attribute swig_Ogre_ColourValue_attributes[] = {
    { "r", _wrap_ColourValue_r_get, _wrap_ColourValue_r_set},
    { "g", _wrap_ColourValue_g_get, _wrap_ColourValue_g_set},
    { "b", _wrap_ColourValue_b_get, _wrap_ColourValue_b_set},
    { "a", _wrap_ColourValue_a_get, _wrap_ColourValue_a_set},
    {0,0,0}
};
static swig_lua_class *swig_Ogre_ColourValue_bases[] = {0};
static const char *swig_Ogre_ColourValue_base_names[] = {0};
static swig_lua_class _wrap_class_Ogre_ColourValue = { "ColourValue", &SWIGTYPE_p_Ogre__ColourValue,_wrap_new_ColourValue, swig_delete_ColourValue, swig_Ogre_ColourValue_methods, swig_Ogre_ColourValue_attributes, swig_Ogre_ColourValue_bases, swig_Ogre_ColourValue_base_names };

static int _wrap_new_TriangleBuffer__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::TriangleBuffer",0,0)
  result = (Procedural::TriangleBuffer *)new Procedural::TriangleBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_append(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::append",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::append",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::append",2,"Procedural::TriangleBuffer const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_append",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_append",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  (arg1)->append((Procedural::TriangleBuffer const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_getVertices__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::vector< Procedural::TriangleBuffer::Vertex > *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::getVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::getVertices",1,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_getVertices",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (std::vector< Procedural::TriangleBuffer::Vertex > *) &(arg1)->getVertices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Vertex_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_getVertices__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::vector< Procedural::TriangleBuffer::Vertex > *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::getVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::getVertices",1,"Procedural::TriangleBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_getVertices",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (std::vector< Procedural::TriangleBuffer::Vertex > *) &((Procedural::TriangleBuffer const *)arg1)->getVertices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Vertex_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_getVertices(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_TriangleBuffer_getVertices__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_TriangleBuffer_getVertices__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_getVertices'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::getVertices()\n"
    "    Procedural::TriangleBuffer::getVertices() const\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_getIndices__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::vector< int > *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::getIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::getIndices",1,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_getIndices",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (std::vector< int > *) &(arg1)->getIndices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_getIndices__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::vector< int > *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::getIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::getIndices",1,"Procedural::TriangleBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_getIndices",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (std::vector< int > *) &((Procedural::TriangleBuffer const *)arg1)->getIndices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_getIndices(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_TriangleBuffer_getIndices__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_TriangleBuffer_getIndices__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_getIndices'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::getIndices()\n"
    "    Procedural::TriangleBuffer::getIndices() const\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_rebaseOffset(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::rebaseOffset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::rebaseOffset",1,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_rebaseOffset",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  (arg1)->rebaseOffset();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_transformToMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::transformToMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::transformToMesh",1,"Procedural::TriangleBuffer const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::transformToMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::transformToMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_transformToMesh",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = ((Procedural::TriangleBuffer const *)arg1)->transformToMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_transformToMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::transformToMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::transformToMesh",1,"Procedural::TriangleBuffer const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::transformToMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_transformToMesh",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = ((Procedural::TriangleBuffer const *)arg1)->transformToMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_transformToMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_TriangleBuffer_transformToMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_TriangleBuffer_transformToMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_transformToMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::transformToMesh(std::string const &,Ogre::String const &) const\n"
    "    Procedural::TriangleBuffer::transformToMesh(std::string const &) const\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_vertex(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::TriangleBuffer::Vertex *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::vertex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::vertex",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::vertex",2,"Procedural::TriangleBuffer::Vertex const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_vertex",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer__Vertex,0))){
    SWIG_fail_ptr("TriangleBuffer_vertex",2,SWIGTYPE_p_Procedural__TriangleBuffer__Vertex);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->vertex((Procedural::TriangleBuffer::Vertex const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_position__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::position",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::position",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::position",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_position",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("TriangleBuffer_position",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->position((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_position__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::position",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::position",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::position",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::position",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TriangleBuffer::position",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_position",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TriangleBuffer *) &(arg1)->position(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_position(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriangleBuffer_position__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TriangleBuffer_position__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_position'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::position(Ogre::Vector3 const &)\n"
    "    Procedural::TriangleBuffer::position(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_normal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::normal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::normal",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::normal",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_normal",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("TriangleBuffer_normal",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->normal((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_textureCoord__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  float arg2 ;
  float arg3 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::textureCoord",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::textureCoord",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::textureCoord",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::textureCoord",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_textureCoord",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (Procedural::TriangleBuffer *) &(arg1)->textureCoord(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_textureCoord__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::textureCoord",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::textureCoord",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::textureCoord",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_textureCoord",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("TriangleBuffer_textureCoord",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->textureCoord((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_textureCoord(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriangleBuffer_textureCoord__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_TriangleBuffer_textureCoord__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_textureCoord'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::textureCoord(float,float)\n"
    "    Procedural::TriangleBuffer::textureCoord(Ogre::Vector2 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_index(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  int arg2 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::index",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::index",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_index",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Procedural::TriangleBuffer *) &(arg1)->index(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_triangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::triangle",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::triangle",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::triangle",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::triangle",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TriangleBuffer::triangle",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_triangle",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (Procedural::TriangleBuffer *) &(arg1)->triangle(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_applyTransform(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Matrix4 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::applyTransform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::applyTransform",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::applyTransform",2,"Ogre::Matrix4 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_applyTransform",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Matrix4,0))){
    SWIG_fail_ptr("TriangleBuffer_applyTransform",2,SWIGTYPE_p_Ogre__Matrix4);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->applyTransform((Ogre::Matrix4 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_translate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_translate",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("TriangleBuffer_translate",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->translate((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_translate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::translate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TriangleBuffer::translate",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_translate",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TriangleBuffer *) &(arg1)->translate(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_translate(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriangleBuffer_translate__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TriangleBuffer_translate__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_translate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::translate(Ogre::Vector3 const &)\n"
    "    Procedural::TriangleBuffer::translate(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_rotate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Quaternion arg2 ;
  Ogre::Quaternion *argp2 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::rotate",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::rotate",2,"Ogre::Quaternion");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_rotate",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("TriangleBuffer_rotate",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  arg2 = *argp2;
  
  result = (Procedural::TriangleBuffer *) &(arg1)->rotate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_scale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",1,"Procedural::TriangleBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_scale",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("TriangleBuffer_scale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->scale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_scale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::scale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TriangleBuffer::scale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_scale",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TriangleBuffer *) &(arg1)->scale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_scale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriangleBuffer_scale__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TriangleBuffer_scale__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriangleBuffer_scale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::scale(Ogre::Vector3 const &)\n"
    "    Procedural::TriangleBuffer::scale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TriangleBuffer_invertNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::invertNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::invertNormals",1,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_invertNormals",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::TriangleBuffer *) &(arg1)->invertNormals();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_estimateVertexCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::estimateVertexCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::estimateVertexCount",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::estimateVertexCount",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_estimateVertexCount",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  (arg1)->estimateVertexCount(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer_estimateIndexCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::estimateIndexCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::estimateIndexCount",1,"Procedural::TriangleBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::estimateIndexCount",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer_estimateIndexCount",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  (arg1)->estimateIndexCount(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleBuffer__dumpContentsToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::_dumpContentsToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::_dumpContentsToFile",1,"Procedural::TriangleBuffer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TriangleBuffer::_dumpContentsToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TriangleBuffer__dumpContentsToFile",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  (arg1)->_dumpContentsToFile((std::string const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriangleBuffer__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleBuffer *arg1 = 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleBuffer::TriangleBuffer",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::TriangleBuffer::TriangleBuffer",1,"Procedural::TriangleBuffer const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("new_TriangleBuffer",1,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::TriangleBuffer *)new Procedural::TriangleBuffer((Procedural::TriangleBuffer const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriangleBuffer(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_TriangleBuffer__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TriangleBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_TriangleBuffer__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_TriangleBuffer'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TriangleBuffer::TriangleBuffer()\n"
    "    Procedural::TriangleBuffer::TriangleBuffer(Procedural::TriangleBuffer const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_TriangleBuffer(void *obj) {
Procedural::TriangleBuffer *arg1 = (Procedural::TriangleBuffer *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TriangleBuffer_methods[] = {
    {"append", _wrap_TriangleBuffer_append}, 
    {"getVertices", _wrap_TriangleBuffer_getVertices}, 
    {"getIndices", _wrap_TriangleBuffer_getIndices}, 
    {"rebaseOffset", _wrap_TriangleBuffer_rebaseOffset}, 
    {"transformToMesh", _wrap_TriangleBuffer_transformToMesh}, 
    {"vertex", _wrap_TriangleBuffer_vertex}, 
    {"position", _wrap_TriangleBuffer_position}, 
    {"normal", _wrap_TriangleBuffer_normal}, 
    {"textureCoord", _wrap_TriangleBuffer_textureCoord}, 
    {"index", _wrap_TriangleBuffer_index}, 
    {"triangle", _wrap_TriangleBuffer_triangle}, 
    {"applyTransform", _wrap_TriangleBuffer_applyTransform}, 
    {"translate", _wrap_TriangleBuffer_translate}, 
    {"rotate", _wrap_TriangleBuffer_rotate}, 
    {"scale", _wrap_TriangleBuffer_scale}, 
    {"invertNormals", _wrap_TriangleBuffer_invertNormals}, 
    {"estimateVertexCount", _wrap_TriangleBuffer_estimateVertexCount}, 
    {"estimateIndexCount", _wrap_TriangleBuffer_estimateIndexCount}, 
    {"_dumpContentsToFile", _wrap_TriangleBuffer__dumpContentsToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TriangleBuffer_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TriangleBuffer_bases[] = {0};
static const char *swig_Procedural_TriangleBuffer_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_TriangleBuffer = { "TriangleBuffer", &SWIGTYPE_p_Procedural__TriangleBuffer,_wrap_new_TriangleBuffer, swig_delete_TriangleBuffer, swig_Procedural_TriangleBuffer_methods, swig_Procedural_TriangleBuffer_attributes, swig_Procedural_TriangleBuffer_bases, swig_Procedural_TriangleBuffer_base_names };

static int _wrap_new_bs1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::BaseSpline2",0,0)
  result = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *)new Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs1_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *) 0 ;
  Side arg2 ;
  Side *argp2 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setOutSide",1,"Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setOutSide",2,"Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,0))){
    SWIG_fail_ptr("bs1_setOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Side,0))){
    SWIG_fail_ptr("bs1_setOutSide",2,SWIGTYPE_p_Side);
  }
  arg2 = *argp2;
  
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs1_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *) 0 ;
  Side result;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::getOutSide",1,"Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,0))){
    SWIG_fail_ptr("bs1_getOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t);
  }
  
  result = ((Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > const *)arg1)->getOutSide();
  {
    Side * resultptr = new Side((const Side &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Side,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs1_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *) 0 ;
  unsigned int arg2 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setNumSeg",1,"Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,0))){
    SWIG_fail_ptr("bs1_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs1_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *) 0 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 >::close",1,"Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,0))){
    SWIG_fail_ptr("bs1_close",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t);
  }
  
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs1(void *obj) {
Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__methods[] = {
    {"setOutSide", _wrap_bs1_setOutSide}, 
    {"getOutSide", _wrap_bs1_getOutSide}, 
    {"setNumSeg", _wrap_bs1_setNumSeg}, 
    {"close", _wrap_bs1_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg_ = { "bs1", &SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,_wrap_new_bs1, swig_delete_bs1, swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__methods, swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__attributes, swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__bases, swig_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg__base_names };

static int _wrap_new_bs2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::BaseSpline2",0,0)
  result = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *)new Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs2_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *) 0 ;
  Side arg2 ;
  Side *argp2 ;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setOutSide",1,"Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setOutSide",2,"Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,0))){
    SWIG_fail_ptr("bs2_setOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Side,0))){
    SWIG_fail_ptr("bs2_setOutSide",2,SWIGTYPE_p_Side);
  }
  arg2 = *argp2;
  
  result = (Procedural::CatmullRomSpline2 *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs2_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *) 0 ;
  Side result;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::getOutSide",1,"Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,0))){
    SWIG_fail_ptr("bs2_getOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t);
  }
  
  result = ((Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > const *)arg1)->getOutSide();
  {
    Side * resultptr = new Side((const Side &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Side,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs2_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *) 0 ;
  unsigned int arg2 ;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setNumSeg",1,"Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,0))){
    SWIG_fail_ptr("bs2_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CatmullRomSpline2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs2_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *) 0 ;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::CatmullRomSpline2 >::close",1,"Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,0))){
    SWIG_fail_ptr("bs2_close",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t);
  }
  
  result = (Procedural::CatmullRomSpline2 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs2(void *obj) {
Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__methods[] = {
    {"setOutSide", _wrap_bs2_setOutSide}, 
    {"getOutSide", _wrap_bs2_getOutSide}, 
    {"setNumSeg", _wrap_bs2_setNumSeg}, 
    {"close", _wrap_bs2_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg_ = { "bs2", &SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,_wrap_new_bs2, swig_delete_bs2, swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__methods, swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__attributes, swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__bases, swig_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg__base_names };

static int _wrap_new_bs3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::BaseSpline2",0,0)
  result = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *)new Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs3_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *) 0 ;
  Side arg2 ;
  Side *argp2 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setOutSide",1,"Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setOutSide",2,"Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,0))){
    SWIG_fail_ptr("bs3_setOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Side,0))){
    SWIG_fail_ptr("bs3_setOutSide",2,SWIGTYPE_p_Side);
  }
  arg2 = *argp2;
  
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs3_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *) 0 ;
  Side result;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::getOutSide",1,"Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,0))){
    SWIG_fail_ptr("bs3_getOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t);
  }
  
  result = ((Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > const *)arg1)->getOutSide();
  {
    Side * resultptr = new Side((const Side &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Side,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs3_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *) 0 ;
  unsigned int arg2 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setNumSeg",1,"Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,0))){
    SWIG_fail_ptr("bs3_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs3_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *) 0 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 >::close",1,"Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,0))){
    SWIG_fail_ptr("bs3_close",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t);
  }
  
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs3(void *obj) {
Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__methods[] = {
    {"setOutSide", _wrap_bs3_setOutSide}, 
    {"getOutSide", _wrap_bs3_getOutSide}, 
    {"setNumSeg", _wrap_bs3_setNumSeg}, 
    {"close", _wrap_bs3_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg_ = { "bs3", &SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,_wrap_new_bs3, swig_delete_bs3, swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__methods, swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__attributes, swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__bases, swig_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg__base_names };

static int _wrap_new_bs4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::BaseSpline2",0,0)
  result = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *)new Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs4_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *) 0 ;
  Side arg2 ;
  Side *argp2 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setOutSide",1,"Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setOutSide",2,"Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,0))){
    SWIG_fail_ptr("bs4_setOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Side,0))){
    SWIG_fail_ptr("bs4_setOutSide",2,SWIGTYPE_p_Side);
  }
  arg2 = *argp2;
  
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs4_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *) 0 ;
  Side result;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::getOutSide",1,"Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,0))){
    SWIG_fail_ptr("bs4_getOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t);
  }
  
  result = ((Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > const *)arg1)->getOutSide();
  {
    Side * resultptr = new Side((const Side &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Side,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs4_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *) 0 ;
  unsigned int arg2 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setNumSeg",1,"Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,0))){
    SWIG_fail_ptr("bs4_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs4_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *) 0 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 >::close",1,"Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,0))){
    SWIG_fail_ptr("bs4_close",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t);
  }
  
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs4(void *obj) {
Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *arg1 = (Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__methods[] = {
    {"setOutSide", _wrap_bs4_setOutSide}, 
    {"getOutSide", _wrap_bs4_getOutSide}, 
    {"setNumSeg", _wrap_bs4_setNumSeg}, 
    {"close", _wrap_bs4_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg_ = { "bs4", &SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,_wrap_new_bs4, swig_delete_bs4, swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__methods, swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__attributes, swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__bases, swig_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg__base_names };

static int _wrap_new_bs5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::BezierCurve2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::BezierCurve2 >::BaseSpline2",0,0)
  result = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *)new Procedural::BaseSpline2< Procedural::BezierCurve2 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs5_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::BezierCurve2 > *arg1 = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *) 0 ;
  Side arg2 ;
  Side *argp2 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setOutSide",1,"Procedural::BaseSpline2< Procedural::BezierCurve2 > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setOutSide",2,"Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,0))){
    SWIG_fail_ptr("bs5_setOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Side,0))){
    SWIG_fail_ptr("bs5_setOutSide",2,SWIGTYPE_p_Side);
  }
  arg2 = *argp2;
  
  result = (Procedural::BezierCurve2 *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs5_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::BezierCurve2 > *arg1 = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *) 0 ;
  Side result;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::BezierCurve2 >::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::getOutSide",1,"Procedural::BaseSpline2< Procedural::BezierCurve2 > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,0))){
    SWIG_fail_ptr("bs5_getOutSide",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t);
  }
  
  result = ((Procedural::BaseSpline2< Procedural::BezierCurve2 > const *)arg1)->getOutSide();
  {
    Side * resultptr = new Side((const Side &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Side,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs5_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::BezierCurve2 > *arg1 = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *) 0 ;
  unsigned int arg2 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setNumSeg",1,"Procedural::BaseSpline2< Procedural::BezierCurve2 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,0))){
    SWIG_fail_ptr("bs5_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BezierCurve2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs5_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline2< Procedural::BezierCurve2 > *arg1 = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *) 0 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline2< Procedural::BezierCurve2 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline2< Procedural::BezierCurve2 >::close",1,"Procedural::BaseSpline2< Procedural::BezierCurve2 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,0))){
    SWIG_fail_ptr("bs5_close",1,SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t);
  }
  
  result = (Procedural::BezierCurve2 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs5(void *obj) {
Procedural::BaseSpline2< Procedural::BezierCurve2 > *arg1 = (Procedural::BaseSpline2< Procedural::BezierCurve2 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__methods[] = {
    {"setOutSide", _wrap_bs5_setOutSide}, 
    {"getOutSide", _wrap_bs5_getOutSide}, 
    {"setNumSeg", _wrap_bs5_setNumSeg}, 
    {"close", _wrap_bs5_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg_ = { "bs5", &SWIGTYPE_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,_wrap_new_bs5, swig_delete_bs5, swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__methods, swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__attributes, swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__bases, swig_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg__base_names };

static int _wrap_new_bs6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::BaseSpline3",0,0)
  result = (Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *)new Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs6_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *) 0 ;
  unsigned int arg2 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::setNumSeg",1,"Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,0))){
    SWIG_fail_ptr("bs6_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs6_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *) 0 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 >::close",1,"Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,0))){
    SWIG_fail_ptr("bs6_close",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t);
  }
  
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs6(void *obj) {
Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__methods[] = {
    {"setNumSeg", _wrap_bs6_setNumSeg}, 
    {"close", _wrap_bs6_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg_ = { "bs6", &SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,_wrap_new_bs6, swig_delete_bs6, swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__methods, swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__attributes, swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__bases, swig_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg__base_names };

static int _wrap_new_bs7(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::BaseSpline3",0,0)
  result = (Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *)new Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs7_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *) 0 ;
  unsigned int arg2 ;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::setNumSeg",1,"Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,0))){
    SWIG_fail_ptr("bs7_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CatmullRomSpline3 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs7_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *) 0 ;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::CatmullRomSpline3 >::close",1,"Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,0))){
    SWIG_fail_ptr("bs7_close",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t);
  }
  
  result = (Procedural::CatmullRomSpline3 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs7(void *obj) {
Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__methods[] = {
    {"setNumSeg", _wrap_bs7_setNumSeg}, 
    {"close", _wrap_bs7_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg_ = { "bs7", &SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,_wrap_new_bs7, swig_delete_bs7, swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__methods, swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__attributes, swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__bases, swig_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg__base_names };

static int _wrap_new_bs8(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::BaseSpline3",0,0)
  result = (Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *)new Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs8_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *) 0 ;
  unsigned int arg2 ;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::setNumSeg",1,"Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,0))){
    SWIG_fail_ptr("bs8_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::RoundedCornerSpline3 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs8_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *) 0 ;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 >::close",1,"Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,0))){
    SWIG_fail_ptr("bs8_close",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t);
  }
  
  result = (Procedural::RoundedCornerSpline3 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs8(void *obj) {
Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *arg1 = (Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__methods[] = {
    {"setNumSeg", _wrap_bs8_setNumSeg}, 
    {"close", _wrap_bs8_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg_ = { "bs8", &SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,_wrap_new_bs8, swig_delete_bs8, swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__methods, swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__attributes, swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__bases, swig_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg__base_names };

static int _wrap_new_bs9(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::BezierCurve3 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::BezierCurve3 >::BaseSpline3",0,0)
  result = (Procedural::BaseSpline3< Procedural::BezierCurve3 > *)new Procedural::BaseSpline3< Procedural::BezierCurve3 >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs9_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::BezierCurve3 > *arg1 = (Procedural::BaseSpline3< Procedural::BezierCurve3 > *) 0 ;
  unsigned int arg2 ;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::BezierCurve3 >::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::BezierCurve3 >::setNumSeg",1,"Procedural::BaseSpline3< Procedural::BezierCurve3 > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::BezierCurve3 >::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,0))){
    SWIG_fail_ptr("bs9_setNumSeg",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BezierCurve3 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_bs9_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BaseSpline3< Procedural::BezierCurve3 > *arg1 = (Procedural::BaseSpline3< Procedural::BezierCurve3 > *) 0 ;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BaseSpline3< Procedural::BezierCurve3 >::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BaseSpline3< Procedural::BezierCurve3 >::close",1,"Procedural::BaseSpline3< Procedural::BezierCurve3 > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,0))){
    SWIG_fail_ptr("bs9_close",1,SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t);
  }
  
  result = (Procedural::BezierCurve3 *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_bs9(void *obj) {
Procedural::BaseSpline3< Procedural::BezierCurve3 > *arg1 = (Procedural::BaseSpline3< Procedural::BezierCurve3 > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__methods[] = {
    {"setNumSeg", _wrap_bs9_setNumSeg}, 
    {"close", _wrap_bs9_close}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__bases[] = {0};
static const char *swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg_ = { "bs9", &SWIGTYPE_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,_wrap_new_bs9, swig_delete_bs9, swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__methods, swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__attributes, swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__bases, swig_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg__base_names };

static int _wrap_CubicHermiteSpline2_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  Ogre::Vector2 *arg4 = 0 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",3,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",4,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",4,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3,(Ogre::Vector2 const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",3,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::CubicHermiteSplineAutoTangentMode arg3 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Vector2 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",3,"Procedural::CubicHermiteSplineAutoTangentMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg3 = (Procedural::CubicHermiteSplineAutoTangentMode)(int)lua_tonumber(L, 3);
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::CubicHermiteSplineAutoTangentMode arg4 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",4,"Procedural::CubicHermiteSplineAutoTangentMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Procedural::CubicHermiteSplineAutoTangentMode)(int)lua_tonumber(L, 4);
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",1,"Procedural::CubicHermiteSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::CubicHermiteSpline2 *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_addPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CubicHermiteSpline2_addPoint__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_CubicHermiteSpline2_addPoint__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CubicHermiteSpline2_addPoint__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CubicHermiteSpline2_addPoint__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_CubicHermiteSpline2_addPoint__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_CubicHermiteSpline2_addPoint__SWIG_4(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CubicHermiteSpline2_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Vector2 const &,Ogre::Vector2 const &,Ogre::Vector2 const &)\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Vector2 const &,Ogre::Vector2 const &)\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Vector2 const &,Procedural::CubicHermiteSplineAutoTangentMode)\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Vector2 const &)\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Real,Ogre::Real,Procedural::CubicHermiteSplineAutoTangentMode)\n"
    "    Procedural::CubicHermiteSpline2::addPoint(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CubicHermiteSpline2_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  unsigned int arg2 ;
  Procedural::CubicHermiteSpline2::ControlPoint *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::safeGetPoint",1,"Procedural::CubicHermiteSpline2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_safeGetPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CubicHermiteSpline2::ControlPoint *) &((Procedural::CubicHermiteSpline2 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline2_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline2::realizeShape",1,"Procedural::CubicHermiteSpline2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline2,0))){
    SWIG_fail_ptr("CubicHermiteSpline2_realizeShape",1,SWIGTYPE_p_Procedural__CubicHermiteSpline2);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CubicHermiteSpline2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline2::CubicHermiteSpline2",0,0)
  result = (Procedural::CubicHermiteSpline2 *)new Procedural::CubicHermiteSpline2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CubicHermiteSpline2(void *obj) {
Procedural::CubicHermiteSpline2 *arg1 = (Procedural::CubicHermiteSpline2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CubicHermiteSpline2_methods[] = {
    {"addPoint", _wrap_CubicHermiteSpline2_addPoint}, 
    {"safeGetPoint", _wrap_CubicHermiteSpline2_safeGetPoint}, 
    {"realizeShape", _wrap_CubicHermiteSpline2_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CubicHermiteSpline2_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CubicHermiteSpline2_bases[] = {0,0};
static const char *swig_Procedural_CubicHermiteSpline2_base_names[] = {"Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *",0};
static swig_lua_class _wrap_class_Procedural_CubicHermiteSpline2 = { "CubicHermiteSpline2", &SWIGTYPE_p_Procedural__CubicHermiteSpline2,_wrap_new_CubicHermiteSpline2, swig_delete_CubicHermiteSpline2, swig_Procedural_CubicHermiteSpline2_methods, swig_Procedural_CubicHermiteSpline2_attributes, swig_Procedural_CubicHermiteSpline2_bases, swig_Procedural_CubicHermiteSpline2_base_names };

static int _wrap_CatmullRomSpline2_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline2 *arg1 = (Procedural::CatmullRomSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline2::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline2::addPoint",1,"Procedural::CatmullRomSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline2::addPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline2,0))){
    SWIG_fail_ptr("CatmullRomSpline2_addPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CatmullRomSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::CatmullRomSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline2_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline2 *arg1 = (Procedural::CatmullRomSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline2::addPoint",1,"Procedural::CatmullRomSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CatmullRomSpline2::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline2,0))){
    SWIG_fail_ptr("CatmullRomSpline2_addPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::CatmullRomSpline2 *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline2_addPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CatmullRomSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CatmullRomSpline2_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CatmullRomSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CatmullRomSpline2_addPoint__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CatmullRomSpline2_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CatmullRomSpline2::addPoint(Ogre::Vector2 const &)\n"
    "    Procedural::CatmullRomSpline2::addPoint(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CatmullRomSpline2_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline2 *arg1 = (Procedural::CatmullRomSpline2 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline2::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline2::safeGetPoint",1,"Procedural::CatmullRomSpline2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline2::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline2,0))){
    SWIG_fail_ptr("CatmullRomSpline2_safeGetPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector2 *) &((Procedural::CatmullRomSpline2 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline2_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline2 *arg1 = (Procedural::CatmullRomSpline2 *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline2::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline2::realizeShape",1,"Procedural::CatmullRomSpline2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline2,0))){
    SWIG_fail_ptr("CatmullRomSpline2_realizeShape",1,SWIGTYPE_p_Procedural__CatmullRomSpline2);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CatmullRomSpline2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline2::CatmullRomSpline2",0,0)
  result = (Procedural::CatmullRomSpline2 *)new Procedural::CatmullRomSpline2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CatmullRomSpline2(void *obj) {
Procedural::CatmullRomSpline2 *arg1 = (Procedural::CatmullRomSpline2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CatmullRomSpline2_methods[] = {
    {"addPoint", _wrap_CatmullRomSpline2_addPoint}, 
    {"safeGetPoint", _wrap_CatmullRomSpline2_safeGetPoint}, 
    {"realizeShape", _wrap_CatmullRomSpline2_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CatmullRomSpline2_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CatmullRomSpline2_bases[] = {0,0};
static const char *swig_Procedural_CatmullRomSpline2_base_names[] = {"Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *",0};
static swig_lua_class _wrap_class_Procedural_CatmullRomSpline2 = { "CatmullRomSpline2", &SWIGTYPE_p_Procedural__CatmullRomSpline2,_wrap_new_CatmullRomSpline2, swig_delete_CatmullRomSpline2, swig_Procedural_CatmullRomSpline2_methods, swig_Procedural_CatmullRomSpline2_attributes, swig_Procedural_CatmullRomSpline2_bases, swig_Procedural_CatmullRomSpline2_base_names };

static int _wrap_KochanekBartelsSpline2_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",1,"Procedural::KochanekBartelsSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_addPoint",1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KochanekBartelsSpline2_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp2 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",1,"Procedural::KochanekBartelsSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_addPoint",1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->addPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KochanekBartelsSpline2_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) 0 ;
  unsigned int arg2 ;
  Procedural::KochanekBartelsSpline2::ControlPoint *result = 0 ;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::safeGetPoint",1,"Procedural::KochanekBartelsSpline2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_safeGetPoint",1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::KochanekBartelsSpline2::ControlPoint *) &((Procedural::KochanekBartelsSpline2 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KochanekBartelsSpline2_addPoint__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Ogre::Vector2 *argp2 ;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::addPoint",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",1,"Procedural::KochanekBartelsSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",2,"Ogre::Vector2");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::addPoint",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_addPoint",1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::KochanekBartelsSpline2 *) &(arg1)->addPoint(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KochanekBartelsSpline2_addPoint(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__KochanekBartelsSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_KochanekBartelsSpline2_addPoint__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__KochanekBartelsSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_KochanekBartelsSpline2_addPoint__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__KochanekBartelsSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_KochanekBartelsSpline2_addPoint__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'KochanekBartelsSpline2_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::KochanekBartelsSpline2::addPoint(Ogre::Real,Ogre::Real)\n"
    "    Procedural::KochanekBartelsSpline2::addPoint(Ogre::Vector2)\n"
    "    Procedural::KochanekBartelsSpline2::addPoint(Ogre::Vector2,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_KochanekBartelsSpline2_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::KochanekBartelsSpline2::realizeShape",1,"Procedural::KochanekBartelsSpline2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,0))){
    SWIG_fail_ptr("KochanekBartelsSpline2_realizeShape",1,SWIGTYPE_p_Procedural__KochanekBartelsSpline2);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KochanekBartelsSpline2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::KochanekBartelsSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::KochanekBartelsSpline2::KochanekBartelsSpline2",0,0)
  result = (Procedural::KochanekBartelsSpline2 *)new Procedural::KochanekBartelsSpline2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__KochanekBartelsSpline2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_KochanekBartelsSpline2(void *obj) {
Procedural::KochanekBartelsSpline2 *arg1 = (Procedural::KochanekBartelsSpline2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_KochanekBartelsSpline2_methods[] = {
    {"safeGetPoint", _wrap_KochanekBartelsSpline2_safeGetPoint}, 
    {"addPoint", _wrap_KochanekBartelsSpline2_addPoint}, 
    {"realizeShape", _wrap_KochanekBartelsSpline2_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_KochanekBartelsSpline2_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_KochanekBartelsSpline2_bases[] = {0,0};
static const char *swig_Procedural_KochanekBartelsSpline2_base_names[] = {"Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *",0};
static swig_lua_class _wrap_class_Procedural_KochanekBartelsSpline2 = { "KochanekBartelsSpline2", &SWIGTYPE_p_Procedural__KochanekBartelsSpline2,_wrap_new_KochanekBartelsSpline2, swig_delete_KochanekBartelsSpline2, swig_Procedural_KochanekBartelsSpline2_methods, swig_Procedural_KochanekBartelsSpline2_attributes, swig_Procedural_KochanekBartelsSpline2_bases, swig_Procedural_KochanekBartelsSpline2_base_names };

static int _wrap_new_RectangleShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleShape::RectangleShape",0,0)
  result = (Procedural::RectangleShape *)new Procedural::RectangleShape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleShape_setWidth(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleShape *arg1 = (Procedural::RectangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleShape::setWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleShape::setWidth",1,"Procedural::RectangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleShape::setWidth",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleShape,0))){
    SWIG_fail_ptr("RectangleShape_setWidth",1,SWIGTYPE_p_Procedural__RectangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleShape *) &(arg1)->setWidth(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleShape_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleShape *arg1 = (Procedural::RectangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleShape::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleShape::setHeight",1,"Procedural::RectangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleShape::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleShape,0))){
    SWIG_fail_ptr("RectangleShape_setHeight",1,SWIGTYPE_p_Procedural__RectangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleShape *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleShape_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleShape *arg1 = (Procedural::RectangleShape *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::RectangleShape::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleShape::realizeShape",1,"Procedural::RectangleShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleShape,0))){
    SWIG_fail_ptr("RectangleShape_realizeShape",1,SWIGTYPE_p_Procedural__RectangleShape);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RectangleShape(void *obj) {
Procedural::RectangleShape *arg1 = (Procedural::RectangleShape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RectangleShape_methods[] = {
    {"setWidth", _wrap_RectangleShape_setWidth}, 
    {"setHeight", _wrap_RectangleShape_setHeight}, 
    {"realizeShape", _wrap_RectangleShape_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RectangleShape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RectangleShape_bases[] = {0};
static const char *swig_Procedural_RectangleShape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_RectangleShape = { "RectangleShape", &SWIGTYPE_p_Procedural__RectangleShape,_wrap_new_RectangleShape, swig_delete_RectangleShape, swig_Procedural_RectangleShape_methods, swig_Procedural_RectangleShape_attributes, swig_Procedural_RectangleShape_bases, swig_Procedural_RectangleShape_base_names };

static int _wrap_new_CircleShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleShape::CircleShape",0,0)
  result = (Procedural::CircleShape *)new Procedural::CircleShape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleShape_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleShape *arg1 = (Procedural::CircleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CircleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleShape::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleShape::setRadius",1,"Procedural::CircleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleShape::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleShape,0))){
    SWIG_fail_ptr("CircleShape_setRadius",1,SWIGTYPE_p_Procedural__CircleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CircleShape *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleShape_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleShape *arg1 = (Procedural::CircleShape *) 0 ;
  unsigned int arg2 ;
  Procedural::CircleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleShape::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleShape::setNumSeg",1,"Procedural::CircleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleShape::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleShape,0))){
    SWIG_fail_ptr("CircleShape_setNumSeg",1,SWIGTYPE_p_Procedural__CircleShape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CircleShape *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleShape_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleShape *arg1 = (Procedural::CircleShape *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::CircleShape::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleShape::realizeShape",1,"Procedural::CircleShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleShape,0))){
    SWIG_fail_ptr("CircleShape_realizeShape",1,SWIGTYPE_p_Procedural__CircleShape);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CircleShape(void *obj) {
Procedural::CircleShape *arg1 = (Procedural::CircleShape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CircleShape_methods[] = {
    {"setRadius", _wrap_CircleShape_setRadius}, 
    {"setNumSeg", _wrap_CircleShape_setNumSeg}, 
    {"realizeShape", _wrap_CircleShape_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CircleShape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CircleShape_bases[] = {0};
static const char *swig_Procedural_CircleShape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_CircleShape = { "CircleShape", &SWIGTYPE_p_Procedural__CircleShape,_wrap_new_CircleShape, swig_delete_CircleShape, swig_Procedural_CircleShape_methods, swig_Procedural_CircleShape_attributes, swig_Procedural_CircleShape_bases, swig_Procedural_CircleShape_base_names };

static int _wrap_new_EllipseShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseShape::EllipseShape",0,0)
  result = (Procedural::EllipseShape *)new Procedural::EllipseShape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseShape_setRadiusX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseShape *arg1 = (Procedural::EllipseShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseShape::setRadiusX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseShape::setRadiusX",1,"Procedural::EllipseShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseShape::setRadiusX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseShape,0))){
    SWIG_fail_ptr("EllipseShape_setRadiusX",1,SWIGTYPE_p_Procedural__EllipseShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseShape *) &(arg1)->setRadiusX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseShape_setRadiusY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseShape *arg1 = (Procedural::EllipseShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseShape::setRadiusY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseShape::setRadiusY",1,"Procedural::EllipseShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseShape::setRadiusY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseShape,0))){
    SWIG_fail_ptr("EllipseShape_setRadiusY",1,SWIGTYPE_p_Procedural__EllipseShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseShape *) &(arg1)->setRadiusY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseShape_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseShape *arg1 = (Procedural::EllipseShape *) 0 ;
  unsigned int arg2 ;
  Procedural::EllipseShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseShape::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseShape::setNumSeg",1,"Procedural::EllipseShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseShape::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseShape,0))){
    SWIG_fail_ptr("EllipseShape_setNumSeg",1,SWIGTYPE_p_Procedural__EllipseShape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::EllipseShape *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseShape_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseShape *arg1 = (Procedural::EllipseShape *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::EllipseShape::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseShape::realizeShape",1,"Procedural::EllipseShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseShape,0))){
    SWIG_fail_ptr("EllipseShape_realizeShape",1,SWIGTYPE_p_Procedural__EllipseShape);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_EllipseShape(void *obj) {
Procedural::EllipseShape *arg1 = (Procedural::EllipseShape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_EllipseShape_methods[] = {
    {"setRadiusX", _wrap_EllipseShape_setRadiusX}, 
    {"setRadiusY", _wrap_EllipseShape_setRadiusY}, 
    {"setNumSeg", _wrap_EllipseShape_setNumSeg}, 
    {"realizeShape", _wrap_EllipseShape_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_EllipseShape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_EllipseShape_bases[] = {0};
static const char *swig_Procedural_EllipseShape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_EllipseShape = { "EllipseShape", &SWIGTYPE_p_Procedural__EllipseShape,_wrap_new_EllipseShape, swig_delete_EllipseShape, swig_Procedural_EllipseShape_methods, swig_Procedural_EllipseShape_attributes, swig_Procedural_EllipseShape_bases, swig_Procedural_EllipseShape_base_names };

static int _wrap_new_TriangleShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleShape::TriangleShape",0,0)
  result = (Procedural::TriangleShape *)new Procedural::TriangleShape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleShape_setLength(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TriangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleShape::setLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleShape::setLength",1,"Procedural::TriangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleShape::setLength",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleShape,0))){
    SWIG_fail_ptr("TriangleShape_setLength",1,SWIGTYPE_p_Procedural__TriangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TriangleShape *) &(arg1)->setLength(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleShape_setLengthA(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TriangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleShape::setLengthA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleShape::setLengthA",1,"Procedural::TriangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleShape::setLengthA",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleShape,0))){
    SWIG_fail_ptr("TriangleShape_setLengthA",1,SWIGTYPE_p_Procedural__TriangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TriangleShape *) &(arg1)->setLengthA(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleShape_setLengthB(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TriangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleShape::setLengthB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleShape::setLengthB",1,"Procedural::TriangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleShape::setLengthB",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleShape,0))){
    SWIG_fail_ptr("TriangleShape_setLengthB",1,SWIGTYPE_p_Procedural__TriangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TriangleShape *) &(arg1)->setLengthB(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleShape_setLengthC(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TriangleShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::TriangleShape::setLengthC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleShape::setLengthC",1,"Procedural::TriangleShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TriangleShape::setLengthC",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleShape,0))){
    SWIG_fail_ptr("TriangleShape_setLengthC",1,SWIGTYPE_p_Procedural__TriangleShape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TriangleShape *) &(arg1)->setLengthC(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriangleShape_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::TriangleShape::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TriangleShape::realizeShape",1,"Procedural::TriangleShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TriangleShape,0))){
    SWIG_fail_ptr("TriangleShape_realizeShape",1,SWIGTYPE_p_Procedural__TriangleShape);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TriangleShape(void *obj) {
Procedural::TriangleShape *arg1 = (Procedural::TriangleShape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TriangleShape_methods[] = {
    {"setLength", _wrap_TriangleShape_setLength}, 
    {"setLengthA", _wrap_TriangleShape_setLengthA}, 
    {"setLengthB", _wrap_TriangleShape_setLengthB}, 
    {"setLengthC", _wrap_TriangleShape_setLengthC}, 
    {"realizeShape", _wrap_TriangleShape_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TriangleShape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TriangleShape_bases[] = {0};
static const char *swig_Procedural_TriangleShape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_TriangleShape = { "TriangleShape", &SWIGTYPE_p_Procedural__TriangleShape,_wrap_new_TriangleShape, swig_delete_TriangleShape, swig_Procedural_TriangleShape_methods, swig_Procedural_TriangleShape_attributes, swig_Procedural_TriangleShape_bases, swig_Procedural_TriangleShape_base_names };

static int _wrap_new_RoundedCornerSpline2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::RoundedCornerSpline2",0,0)
  result = (Procedural::RoundedCornerSpline2 *)new Procedural::RoundedCornerSpline2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline2_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::setRadius",1,"Procedural::RoundedCornerSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_setRadius",1,SWIGTYPE_p_Procedural__RoundedCornerSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline2_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::addPoint",1,"Procedural::RoundedCornerSpline2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::addPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_addPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline2_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::RoundedCornerSpline2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::addPoint",1,"Procedural::RoundedCornerSpline2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_addPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::RoundedCornerSpline2 *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline2_addPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RoundedCornerSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RoundedCornerSpline2_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RoundedCornerSpline2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_RoundedCornerSpline2_addPoint__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RoundedCornerSpline2_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RoundedCornerSpline2::addPoint(Ogre::Vector2 const &)\n"
    "    Procedural::RoundedCornerSpline2::addPoint(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RoundedCornerSpline2_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::safeGetPoint",1,"Procedural::RoundedCornerSpline2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_safeGetPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector2 *) &((Procedural::RoundedCornerSpline2 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline2_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline2::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline2::realizeShape",1,"Procedural::RoundedCornerSpline2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline2,0))){
    SWIG_fail_ptr("RoundedCornerSpline2_realizeShape",1,SWIGTYPE_p_Procedural__RoundedCornerSpline2);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RoundedCornerSpline2(void *obj) {
Procedural::RoundedCornerSpline2 *arg1 = (Procedural::RoundedCornerSpline2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RoundedCornerSpline2_methods[] = {
    {"setRadius", _wrap_RoundedCornerSpline2_setRadius}, 
    {"addPoint", _wrap_RoundedCornerSpline2_addPoint}, 
    {"safeGetPoint", _wrap_RoundedCornerSpline2_safeGetPoint}, 
    {"realizeShape", _wrap_RoundedCornerSpline2_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RoundedCornerSpline2_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RoundedCornerSpline2_bases[] = {0,0};
static const char *swig_Procedural_RoundedCornerSpline2_base_names[] = {"Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *",0};
static swig_lua_class _wrap_class_Procedural_RoundedCornerSpline2 = { "RoundedCornerSpline2", &SWIGTYPE_p_Procedural__RoundedCornerSpline2,_wrap_new_RoundedCornerSpline2, swig_delete_RoundedCornerSpline2, swig_Procedural_RoundedCornerSpline2_methods, swig_Procedural_RoundedCornerSpline2_attributes, swig_Procedural_RoundedCornerSpline2_bases, swig_Procedural_RoundedCornerSpline2_base_names };

static int _wrap_new_BezierCurve2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve2::BezierCurve2",0,0)
  result = (Procedural::BezierCurve2 *)new Procedural::BezierCurve2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve2_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) 0 ;
  unsigned int arg2 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve2::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve2::setNumSeg",1,"Procedural::BezierCurve2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve2::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve2,0))){
    SWIG_fail_ptr("BezierCurve2_setNumSeg",1,SWIGTYPE_p_Procedural__BezierCurve2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BezierCurve2 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve2_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve2::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve2::addPoint",1,"Procedural::BezierCurve2 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BezierCurve2::addPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve2,0))){
    SWIG_fail_ptr("BezierCurve2_addPoint",1,SWIGTYPE_p_Procedural__BezierCurve2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("BezierCurve2_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::BezierCurve2 *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve2_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::BezierCurve2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve2::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve2::addPoint",1,"Procedural::BezierCurve2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve2::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BezierCurve2::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve2,0))){
    SWIG_fail_ptr("BezierCurve2_addPoint",1,SWIGTYPE_p_Procedural__BezierCurve2);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::BezierCurve2 *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve2_addPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__BezierCurve2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_BezierCurve2_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__BezierCurve2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_BezierCurve2_addPoint__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'BezierCurve2_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::BezierCurve2::addPoint(Ogre::Vector2 const &)\n"
    "    Procedural::BezierCurve2::addPoint(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_BezierCurve2_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve2::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve2::safeGetPoint",1,"Procedural::BezierCurve2 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve2::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve2,0))){
    SWIG_fail_ptr("BezierCurve2_safeGetPoint",1,SWIGTYPE_p_Procedural__BezierCurve2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector2 *) &((Procedural::BezierCurve2 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve2_realizeShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) 0 ;
  Shape result;
  
  SWIG_check_num_args("Procedural::BezierCurve2::realizeShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve2::realizeShape",1,"Procedural::BezierCurve2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve2,0))){
    SWIG_fail_ptr("BezierCurve2_realizeShape",1,SWIGTYPE_p_Procedural__BezierCurve2);
  }
  
  result = (arg1)->realizeShape();
  {
    Shape * resultptr = new Shape((const Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BezierCurve2(void *obj) {
Procedural::BezierCurve2 *arg1 = (Procedural::BezierCurve2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BezierCurve2_methods[] = {
    {"setNumSeg", _wrap_BezierCurve2_setNumSeg}, 
    {"addPoint", _wrap_BezierCurve2_addPoint}, 
    {"safeGetPoint", _wrap_BezierCurve2_safeGetPoint}, 
    {"realizeShape", _wrap_BezierCurve2_realizeShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BezierCurve2_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BezierCurve2_bases[] = {0,0};
static const char *swig_Procedural_BezierCurve2_base_names[] = {"Procedural::BaseSpline2< Procedural::BezierCurve2 > *",0};
static swig_lua_class _wrap_class_Procedural_BezierCurve2 = { "BezierCurve2", &SWIGTYPE_p_Procedural__BezierCurve2,_wrap_new_BezierCurve2, swig_delete_BezierCurve2, swig_Procedural_BezierCurve2_methods, swig_Procedural_BezierCurve2_attributes, swig_Procedural_BezierCurve2_bases, swig_Procedural_BezierCurve2_base_names };

static int _wrap_new_CatmullRomSpline3__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::CatmullRomSpline3",0,0)
  result = (Procedural::CatmullRomSpline3 *)new Procedural::CatmullRomSpline3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CatmullRomSpline3__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::SimpleSpline *arg1 = 0 ;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::CatmullRomSpline3",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::CatmullRomSpline3",1,"Ogre::SimpleSpline const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__SimpleSpline,0))){
    SWIG_fail_ptr("new_CatmullRomSpline3",1,SWIGTYPE_p_Ogre__SimpleSpline);
  }
  
  result = (Procedural::CatmullRomSpline3 *)new Procedural::CatmullRomSpline3((Ogre::SimpleSpline const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CatmullRomSpline3(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_CatmullRomSpline3__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__SimpleSpline, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_CatmullRomSpline3__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_CatmullRomSpline3'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CatmullRomSpline3::CatmullRomSpline3()\n"
    "    Procedural::CatmullRomSpline3::CatmullRomSpline3(Ogre::SimpleSpline const &)\n");
  lua_error(L);return 0;
}


static int _wrap_CatmullRomSpline3_toSimpleSpline(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) 0 ;
  Ogre::SimpleSpline result;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::toSimpleSpline",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::toSimpleSpline",1,"Procedural::CatmullRomSpline3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_toSimpleSpline",1,SWIGTYPE_p_Procedural__CatmullRomSpline3);
  }
  
  result = ((Procedural::CatmullRomSpline3 const *)arg1)->toSimpleSpline();
  {
    Ogre::SimpleSpline * resultptr = new Ogre::SimpleSpline((const Ogre::SimpleSpline &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__SimpleSpline,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline3_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",1,"Procedural::CatmullRomSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_addPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CatmullRomSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline3_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CatmullRomSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",1,"Procedural::CatmullRomSpline3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CatmullRomSpline3::addPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_addPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CatmullRomSpline3 *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CatmullRomSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline3_addPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CatmullRomSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CatmullRomSpline3_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CatmullRomSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_CatmullRomSpline3_addPoint__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CatmullRomSpline3_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CatmullRomSpline3::addPoint(Ogre::Vector3 const &)\n"
    "    Procedural::CatmullRomSpline3::addPoint(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CatmullRomSpline3_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::safeGetPoint",1,"Procedural::CatmullRomSpline3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CatmullRomSpline3::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_safeGetPoint",1,SWIGTYPE_p_Procedural__CatmullRomSpline3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector3 *) &((Procedural::CatmullRomSpline3 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CatmullRomSpline3_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) 0 ;
  Path result;
  
  SWIG_check_num_args("Procedural::CatmullRomSpline3::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CatmullRomSpline3::realizePath",1,"Procedural::CatmullRomSpline3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CatmullRomSpline3,0))){
    SWIG_fail_ptr("CatmullRomSpline3_realizePath",1,SWIGTYPE_p_Procedural__CatmullRomSpline3);
  }
  
  result = (arg1)->realizePath();
  {
    Path * resultptr = new Path((const Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CatmullRomSpline3(void *obj) {
Procedural::CatmullRomSpline3 *arg1 = (Procedural::CatmullRomSpline3 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CatmullRomSpline3_methods[] = {
    {"toSimpleSpline", _wrap_CatmullRomSpline3_toSimpleSpline}, 
    {"addPoint", _wrap_CatmullRomSpline3_addPoint}, 
    {"safeGetPoint", _wrap_CatmullRomSpline3_safeGetPoint}, 
    {"realizePath", _wrap_CatmullRomSpline3_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CatmullRomSpline3_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CatmullRomSpline3_bases[] = {0,0};
static const char *swig_Procedural_CatmullRomSpline3_base_names[] = {"Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *",0};
static swig_lua_class _wrap_class_Procedural_CatmullRomSpline3 = { "CatmullRomSpline3", &SWIGTYPE_p_Procedural__CatmullRomSpline3,_wrap_new_CatmullRomSpline3, swig_delete_CatmullRomSpline3, swig_Procedural_CatmullRomSpline3_methods, swig_Procedural_CatmullRomSpline3_attributes, swig_Procedural_CatmullRomSpline3_bases, swig_Procedural_CatmullRomSpline3_base_names };

static int _wrap_CubicHermiteSpline3_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Ogre::Vector3 *arg4 = 0 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",3,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",4,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",4,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3,(Ogre::Vector3 const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CubicHermiteSplineAutoTangentMode arg3 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Vector3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",3,"Procedural::CubicHermiteSplineAutoTangentMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  arg3 = (Procedural::CubicHermiteSplineAutoTangentMode)(int)lua_tonumber(L, 3);
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CubicHermiteSplineAutoTangentMode arg5 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",5,"Procedural::CubicHermiteSplineAutoTangentMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Procedural::CubicHermiteSplineAutoTangentMode)(int)lua_tonumber(L, 5);
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",1,"Procedural::CubicHermiteSpline3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::addPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_addPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CubicHermiteSpline3 *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_addPoint(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CubicHermiteSpline3_addPoint__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_CubicHermiteSpline3_addPoint__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CubicHermiteSpline3_addPoint__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_CubicHermiteSpline3_addPoint__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_CubicHermiteSpline3_addPoint__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CubicHermiteSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_CubicHermiteSpline3_addPoint__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CubicHermiteSpline3_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Vector3 const &,Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Vector3 const &,Procedural::CubicHermiteSplineAutoTangentMode)\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Vector3 const &)\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Real,Ogre::Real,Ogre::Real,Procedural::CubicHermiteSplineAutoTangentMode)\n"
    "    Procedural::CubicHermiteSpline3::addPoint(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CubicHermiteSpline3_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  unsigned int arg2 ;
  Procedural::CubicHermiteSpline3::ControlPoint *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::safeGetPoint",1,"Procedural::CubicHermiteSpline3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_safeGetPoint",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CubicHermiteSpline3::ControlPoint *) &((Procedural::CubicHermiteSpline3 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicHermiteSpline3_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) 0 ;
  Path result;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CubicHermiteSpline3::realizePath",1,"Procedural::CubicHermiteSpline3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CubicHermiteSpline3,0))){
    SWIG_fail_ptr("CubicHermiteSpline3_realizePath",1,SWIGTYPE_p_Procedural__CubicHermiteSpline3);
  }
  
  result = (arg1)->realizePath();
  {
    Path * resultptr = new Path((const Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CubicHermiteSpline3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CubicHermiteSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::CubicHermiteSpline3::CubicHermiteSpline3",0,0)
  result = (Procedural::CubicHermiteSpline3 *)new Procedural::CubicHermiteSpline3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CubicHermiteSpline3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CubicHermiteSpline3(void *obj) {
Procedural::CubicHermiteSpline3 *arg1 = (Procedural::CubicHermiteSpline3 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CubicHermiteSpline3_methods[] = {
    {"addPoint", _wrap_CubicHermiteSpline3_addPoint}, 
    {"safeGetPoint", _wrap_CubicHermiteSpline3_safeGetPoint}, 
    {"realizePath", _wrap_CubicHermiteSpline3_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CubicHermiteSpline3_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CubicHermiteSpline3_bases[] = {0,0};
static const char *swig_Procedural_CubicHermiteSpline3_base_names[] = {"Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *",0};
static swig_lua_class _wrap_class_Procedural_CubicHermiteSpline3 = { "CubicHermiteSpline3", &SWIGTYPE_p_Procedural__CubicHermiteSpline3,_wrap_new_CubicHermiteSpline3, swig_delete_CubicHermiteSpline3, swig_Procedural_CubicHermiteSpline3_methods, swig_Procedural_CubicHermiteSpline3_attributes, swig_Procedural_CubicHermiteSpline3_bases, swig_Procedural_CubicHermiteSpline3_base_names };

static int _wrap_new_LinePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *result = 0 ;
  
  SWIG_check_num_args("Procedural::LinePath::LinePath",0,0)
  result = (Procedural::LinePath *)new Procedural::LinePath();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__LinePath,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinePath_setPoint1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *arg1 = (Procedural::LinePath *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::LinePath *result = 0 ;
  
  SWIG_check_num_args("Procedural::LinePath::setPoint1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::LinePath::setPoint1",1,"Procedural::LinePath *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::LinePath::setPoint1",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__LinePath,0))){
    SWIG_fail_ptr("LinePath_setPoint1",1,SWIGTYPE_p_Procedural__LinePath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("LinePath_setPoint1",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::LinePath *) &(arg1)->setPoint1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__LinePath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinePath_setPoint2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *arg1 = (Procedural::LinePath *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::LinePath *result = 0 ;
  
  SWIG_check_num_args("Procedural::LinePath::setPoint2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::LinePath::setPoint2",1,"Procedural::LinePath *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::LinePath::setPoint2",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__LinePath,0))){
    SWIG_fail_ptr("LinePath_setPoint2",1,SWIGTYPE_p_Procedural__LinePath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("LinePath_setPoint2",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::LinePath *) &(arg1)->setPoint2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__LinePath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinePath_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *arg1 = (Procedural::LinePath *) 0 ;
  unsigned int arg2 ;
  Procedural::LinePath *result = 0 ;
  
  SWIG_check_num_args("Procedural::LinePath::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::LinePath::setNumSeg",1,"Procedural::LinePath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::LinePath::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__LinePath,0))){
    SWIG_fail_ptr("LinePath_setNumSeg",1,SWIGTYPE_p_Procedural__LinePath);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::LinePath *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__LinePath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinePath_betweenPoints(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *arg1 = (Procedural::LinePath *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 arg3 ;
  Ogre::Vector3 *argp2 ;
  Ogre::Vector3 *argp3 ;
  Procedural::LinePath *result = 0 ;
  
  SWIG_check_num_args("Procedural::LinePath::betweenPoints",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::LinePath::betweenPoints",1,"Procedural::LinePath *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::LinePath::betweenPoints",2,"Ogre::Vector3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::LinePath::betweenPoints",3,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__LinePath,0))){
    SWIG_fail_ptr("LinePath_betweenPoints",1,SWIGTYPE_p_Procedural__LinePath);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("LinePath_betweenPoints",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("LinePath_betweenPoints",3,SWIGTYPE_p_Ogre__Vector3);
  }
  arg3 = *argp3;
  
  result = (Procedural::LinePath *) &(arg1)->betweenPoints(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__LinePath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinePath_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::LinePath *arg1 = (Procedural::LinePath *) 0 ;
  Path result;
  
  SWIG_check_num_args("Procedural::LinePath::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::LinePath::realizePath",1,"Procedural::LinePath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__LinePath,0))){
    SWIG_fail_ptr("LinePath_realizePath",1,SWIGTYPE_p_Procedural__LinePath);
  }
  
  result = (arg1)->realizePath();
  {
    Path * resultptr = new Path((const Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LinePath(void *obj) {
Procedural::LinePath *arg1 = (Procedural::LinePath *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_LinePath_methods[] = {
    {"setPoint1", _wrap_LinePath_setPoint1}, 
    {"setPoint2", _wrap_LinePath_setPoint2}, 
    {"setNumSeg", _wrap_LinePath_setNumSeg}, 
    {"betweenPoints", _wrap_LinePath_betweenPoints}, 
    {"realizePath", _wrap_LinePath_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_LinePath_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_LinePath_bases[] = {0};
static const char *swig_Procedural_LinePath_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_LinePath = { "LinePath", &SWIGTYPE_p_Procedural__LinePath,_wrap_new_LinePath, swig_delete_LinePath, swig_Procedural_LinePath_methods, swig_Procedural_LinePath_attributes, swig_Procedural_LinePath_bases, swig_Procedural_LinePath_base_names };

static int _wrap_new_RoundedCornerSpline3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::RoundedCornerSpline3",0,0)
  result = (Procedural::RoundedCornerSpline3 *)new Procedural::RoundedCornerSpline3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline3_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::setRadius",1,"Procedural::RoundedCornerSpline3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_setRadius",1,SWIGTYPE_p_Procedural__RoundedCornerSpline3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedCornerSpline3 *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline3_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",1,"Procedural::RoundedCornerSpline3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_addPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::RoundedCornerSpline3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline3_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::RoundedCornerSpline3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",1,"Procedural::RoundedCornerSpline3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::addPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_addPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::RoundedCornerSpline3 *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline3_addPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RoundedCornerSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RoundedCornerSpline3_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RoundedCornerSpline3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_RoundedCornerSpline3_addPoint__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RoundedCornerSpline3_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RoundedCornerSpline3::addPoint(Ogre::Vector3 const &)\n"
    "    Procedural::RoundedCornerSpline3::addPoint(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RoundedCornerSpline3_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::safeGetPoint",1,"Procedural::RoundedCornerSpline3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_safeGetPoint",1,SWIGTYPE_p_Procedural__RoundedCornerSpline3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector3 *) &((Procedural::RoundedCornerSpline3 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedCornerSpline3_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) 0 ;
  Path result;
  
  SWIG_check_num_args("Procedural::RoundedCornerSpline3::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedCornerSpline3::realizePath",1,"Procedural::RoundedCornerSpline3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedCornerSpline3,0))){
    SWIG_fail_ptr("RoundedCornerSpline3_realizePath",1,SWIGTYPE_p_Procedural__RoundedCornerSpline3);
  }
  
  result = (arg1)->realizePath();
  {
    Path * resultptr = new Path((const Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RoundedCornerSpline3(void *obj) {
Procedural::RoundedCornerSpline3 *arg1 = (Procedural::RoundedCornerSpline3 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RoundedCornerSpline3_methods[] = {
    {"setRadius", _wrap_RoundedCornerSpline3_setRadius}, 
    {"addPoint", _wrap_RoundedCornerSpline3_addPoint}, 
    {"safeGetPoint", _wrap_RoundedCornerSpline3_safeGetPoint}, 
    {"realizePath", _wrap_RoundedCornerSpline3_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RoundedCornerSpline3_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RoundedCornerSpline3_bases[] = {0,0};
static const char *swig_Procedural_RoundedCornerSpline3_base_names[] = {"Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *",0};
static swig_lua_class _wrap_class_Procedural_RoundedCornerSpline3 = { "RoundedCornerSpline3", &SWIGTYPE_p_Procedural__RoundedCornerSpline3,_wrap_new_RoundedCornerSpline3, swig_delete_RoundedCornerSpline3, swig_Procedural_RoundedCornerSpline3_methods, swig_Procedural_RoundedCornerSpline3_attributes, swig_Procedural_RoundedCornerSpline3_bases, swig_Procedural_RoundedCornerSpline3_base_names };

static int _wrap_new_BezierCurve3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve3::BezierCurve3",0,0)
  result = (Procedural::BezierCurve3 *)new Procedural::BezierCurve3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve3_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) 0 ;
  unsigned int arg2 ;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve3::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve3::setNumSeg",1,"Procedural::BezierCurve3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve3::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve3,0))){
    SWIG_fail_ptr("BezierCurve3_setNumSeg",1,SWIGTYPE_p_Procedural__BezierCurve3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BezierCurve3 *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve3_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve3::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",1,"Procedural::BezierCurve3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve3,0))){
    SWIG_fail_ptr("BezierCurve3_addPoint",1,SWIGTYPE_p_Procedural__BezierCurve3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("BezierCurve3_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::BezierCurve3 *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve3_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::BezierCurve3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve3::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",1,"Procedural::BezierCurve3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::BezierCurve3::addPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve3,0))){
    SWIG_fail_ptr("BezierCurve3_addPoint",1,SWIGTYPE_p_Procedural__BezierCurve3);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::BezierCurve3 *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BezierCurve3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve3_addPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__BezierCurve3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_BezierCurve3_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__BezierCurve3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_BezierCurve3_addPoint__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'BezierCurve3_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::BezierCurve3::addPoint(Ogre::Vector3 const &)\n"
    "    Procedural::BezierCurve3::addPoint(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_BezierCurve3_safeGetPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::BezierCurve3::safeGetPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve3::safeGetPoint",1,"Procedural::BezierCurve3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BezierCurve3::safeGetPoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve3,0))){
    SWIG_fail_ptr("BezierCurve3_safeGetPoint",1,SWIGTYPE_p_Procedural__BezierCurve3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Ogre::Vector3 *) &((Procedural::BezierCurve3 const *)arg1)->safeGetPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BezierCurve3_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) 0 ;
  Path result;
  
  SWIG_check_num_args("Procedural::BezierCurve3::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BezierCurve3::realizePath",1,"Procedural::BezierCurve3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BezierCurve3,0))){
    SWIG_fail_ptr("BezierCurve3_realizePath",1,SWIGTYPE_p_Procedural__BezierCurve3);
  }
  
  result = (arg1)->realizePath();
  {
    Path * resultptr = new Path((const Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BezierCurve3(void *obj) {
Procedural::BezierCurve3 *arg1 = (Procedural::BezierCurve3 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BezierCurve3_methods[] = {
    {"setNumSeg", _wrap_BezierCurve3_setNumSeg}, 
    {"addPoint", _wrap_BezierCurve3_addPoint}, 
    {"safeGetPoint", _wrap_BezierCurve3_safeGetPoint}, 
    {"realizePath", _wrap_BezierCurve3_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BezierCurve3_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BezierCurve3_bases[] = {0,0};
static const char *swig_Procedural_BezierCurve3_base_names[] = {"Procedural::BaseSpline3< Procedural::BezierCurve3 > *",0};
static swig_lua_class _wrap_class_Procedural_BezierCurve3 = { "BezierCurve3", &SWIGTYPE_p_Procedural__BezierCurve3,_wrap_new_BezierCurve3, swig_delete_BezierCurve3, swig_Procedural_BezierCurve3_methods, swig_Procedural_BezierCurve3_attributes, swig_Procedural_BezierCurve3_bases, swig_Procedural_BezierCurve3_base_names };

static int _wrap_mg1_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg1_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg1_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg1_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg1_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg1_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::SphereGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg1_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::SphereGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg1_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  bool arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::SphereGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  bool arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::SphereGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg1_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg1_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::SphereGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg1_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg1_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg1_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg1_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg1_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::SphereGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg1_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg1_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg1_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg1_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::SphereGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg1_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::SphereGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg1__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) 0 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SphereGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SphereGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::SphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0))){
    SWIG_fail_ptr("mg1__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t);
  }
  
  result = (Procedural::SphereGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg1(void *obj) {
Procedural::MeshGenerator< Procedural::SphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SphereGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg1_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg1_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg1_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg1_setUTile}, 
    {"setVTile", _wrap_mg1_setVTile}, 
    {"setTextureRectangle", _wrap_mg1_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg1_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg1_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg1_setSwitchUV}, 
    {"setOrientation", _wrap_mg1_setOrientation}, 
    {"setPosition", _wrap_mg1_setPosition}, 
    {"setScale", _wrap_mg1_setScale}, 
    {"resetTransforms", _wrap_mg1_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg1__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg1__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg_ = { "mg1", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,0, swig_delete_mg1, swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg__base_names };

static int _wrap_mg2_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg2_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg2_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg2_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg2_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg2_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::BoxGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg2_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::BoxGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg2_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  bool arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::BoxGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  bool arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::BoxGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg2_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg2_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::BoxGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg2_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg2_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg2_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg2_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg2_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::BoxGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg2_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg2_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg2_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg2_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::BoxGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg2_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::BoxGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg2__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) 0 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::BoxGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::BoxGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::BoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0))){
    SWIG_fail_ptr("mg2__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t);
  }
  
  result = (Procedural::BoxGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg2(void *obj) {
Procedural::MeshGenerator< Procedural::BoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::BoxGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg2_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg2_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg2_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg2_setUTile}, 
    {"setVTile", _wrap_mg2_setVTile}, 
    {"setTextureRectangle", _wrap_mg2_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg2_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg2_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg2_setSwitchUV}, 
    {"setOrientation", _wrap_mg2_setOrientation}, 
    {"setPosition", _wrap_mg2_setPosition}, 
    {"setScale", _wrap_mg2_setScale}, 
    {"resetTransforms", _wrap_mg2_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg2__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg2__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg_ = { "mg2", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,0, swig_delete_mg2, swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg__base_names };

static int _wrap_mg3_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg3_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg3_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg3_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg3_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg3_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::CapsuleGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg3_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::CapsuleGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg3_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  bool arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  bool arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg3_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg3_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg3_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg3_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg3_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg3_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg3_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg3_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg3_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg3_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg3_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::CapsuleGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg3_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::CapsuleGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg3__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) 0 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CapsuleGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0))){
    SWIG_fail_ptr("mg3__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t);
  }
  
  result = (Procedural::CapsuleGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg3(void *obj) {
Procedural::MeshGenerator< Procedural::CapsuleGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CapsuleGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg3_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg3_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg3_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg3_setUTile}, 
    {"setVTile", _wrap_mg3_setVTile}, 
    {"setTextureRectangle", _wrap_mg3_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg3_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg3_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg3_setSwitchUV}, 
    {"setOrientation", _wrap_mg3_setOrientation}, 
    {"setPosition", _wrap_mg3_setPosition}, 
    {"setScale", _wrap_mg3_setScale}, 
    {"resetTransforms", _wrap_mg3_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg3__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg3__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg_ = { "mg3", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,0, swig_delete_mg3, swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg__base_names };

static int _wrap_mg4_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg4_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg4_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg4_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg4_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg4_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::CylinderGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg4_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::CylinderGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg4_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  bool arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CylinderGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  bool arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CylinderGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg4_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg4_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CylinderGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg4_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg4_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg4_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg4_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg4_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CylinderGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg4_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg4_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg4_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg4_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::CylinderGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg4_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::CylinderGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg4__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) 0 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::CylinderGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::CylinderGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::CylinderGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0))){
    SWIG_fail_ptr("mg4__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t);
  }
  
  result = (Procedural::CylinderGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg4(void *obj) {
Procedural::MeshGenerator< Procedural::CylinderGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::CylinderGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg4_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg4_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg4_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg4_setUTile}, 
    {"setVTile", _wrap_mg4_setVTile}, 
    {"setTextureRectangle", _wrap_mg4_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg4_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg4_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg4_setSwitchUV}, 
    {"setOrientation", _wrap_mg4_setOrientation}, 
    {"setPosition", _wrap_mg4_setPosition}, 
    {"setScale", _wrap_mg4_setScale}, 
    {"resetTransforms", _wrap_mg4_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg4__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg4__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg_ = { "mg4", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,0, swig_delete_mg4, swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg__base_names };

static int _wrap_mg5_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg5_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg5_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg5_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg5_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg5_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::IcoSphereGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg5_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::IcoSphereGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg5_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  bool arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  bool arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg5_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg5_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg5_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg5_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg5_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg5_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg5_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg5_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg5_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg5_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg5_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg5_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::IcoSphereGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg5__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) 0 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::IcoSphereGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0))){
    SWIG_fail_ptr("mg5__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t);
  }
  
  result = (Procedural::IcoSphereGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg5(void *obj) {
Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg5_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg5_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg5_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg5_setUTile}, 
    {"setVTile", _wrap_mg5_setVTile}, 
    {"setTextureRectangle", _wrap_mg5_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg5_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg5_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg5_setSwitchUV}, 
    {"setOrientation", _wrap_mg5_setOrientation}, 
    {"setPosition", _wrap_mg5_setPosition}, 
    {"setScale", _wrap_mg5_setScale}, 
    {"resetTransforms", _wrap_mg5_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg5__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg5__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg_ = { "mg5", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,0, swig_delete_mg5, swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg__base_names };

static int _wrap_mg6_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg6_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg6_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg6_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg6_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg6_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg6_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg6_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  bool arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  bool arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg6_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg6_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg6_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg6_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg6_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg6_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg6_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg6_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg6_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg6_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg6_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg6_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg6__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) 0 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::RoundedBoxGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0))){
    SWIG_fail_ptr("mg6__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t);
  }
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg6(void *obj) {
Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg6_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg6_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg6_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg6_setUTile}, 
    {"setVTile", _wrap_mg6_setVTile}, 
    {"setTextureRectangle", _wrap_mg6_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg6_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg6_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg6_setSwitchUV}, 
    {"setOrientation", _wrap_mg6_setOrientation}, 
    {"setPosition", _wrap_mg6_setPosition}, 
    {"setScale", _wrap_mg6_setScale}, 
    {"resetTransforms", _wrap_mg6_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg6__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg6__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg_ = { "mg6", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,0, swig_delete_mg6, swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg__base_names };

static int _wrap_mg7_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg7_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg7_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg7_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg7_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg7_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::TorusGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg7_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::TorusGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg7_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TorusGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TorusGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg7_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg7_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TorusGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg7_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg7_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg7_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg7_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg7_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TorusGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg7_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg7_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg7_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg7_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::TorusGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg7_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::TorusGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg7__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) 0 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::TorusGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0))){
    SWIG_fail_ptr("mg7__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t);
  }
  
  result = (Procedural::TorusGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg7(void *obj) {
Procedural::MeshGenerator< Procedural::TorusGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg7_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg7_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg7_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg7_setUTile}, 
    {"setVTile", _wrap_mg7_setVTile}, 
    {"setTextureRectangle", _wrap_mg7_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg7_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg7_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg7_setSwitchUV}, 
    {"setOrientation", _wrap_mg7_setOrientation}, 
    {"setPosition", _wrap_mg7_setPosition}, 
    {"setScale", _wrap_mg7_setScale}, 
    {"resetTransforms", _wrap_mg7_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg7__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg7__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg_ = { "mg7", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,0, swig_delete_mg7, swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg__base_names };

static int _wrap_mg8_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg8_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg8_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg8_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg8_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg8_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::TorusKnotGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg8_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::TorusKnotGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg8_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg8_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg8_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg8_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg8_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg8_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg8_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg8_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg8_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg8_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg8_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg8_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg8_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::TorusKnotGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg8__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) 0 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TorusKnotGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0))){
    SWIG_fail_ptr("mg8__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t);
  }
  
  result = (Procedural::TorusKnotGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg8(void *obj) {
Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg8_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg8_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg8_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg8_setUTile}, 
    {"setVTile", _wrap_mg8_setVTile}, 
    {"setTextureRectangle", _wrap_mg8_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg8_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg8_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg8_setSwitchUV}, 
    {"setOrientation", _wrap_mg8_setOrientation}, 
    {"setPosition", _wrap_mg8_setPosition}, 
    {"setScale", _wrap_mg8_setScale}, 
    {"resetTransforms", _wrap_mg8_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg8__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg8__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg_ = { "mg8", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,0, swig_delete_mg8, swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg__base_names };

static int _wrap_mg9_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg9_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg9_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg9_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg9_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg9_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::TubeGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg9_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::TubeGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg9_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TubeGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  bool arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::TubeGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg9_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg9_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TubeGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg9_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg9_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg9_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg9_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg9_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::TubeGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg9_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg9_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg9_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg9_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::TubeGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg9_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::TubeGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg9__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) 0 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::TubeGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::TubeGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::TubeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0))){
    SWIG_fail_ptr("mg9__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t);
  }
  
  result = (Procedural::TubeGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg9(void *obj) {
Procedural::MeshGenerator< Procedural::TubeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::TubeGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg9_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg9_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg9_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg9_setUTile}, 
    {"setVTile", _wrap_mg9_setVTile}, 
    {"setTextureRectangle", _wrap_mg9_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg9_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg9_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg9_setSwitchUV}, 
    {"setOrientation", _wrap_mg9_setOrientation}, 
    {"setPosition", _wrap_mg9_setPosition}, 
    {"setScale", _wrap_mg9_setScale}, 
    {"resetTransforms", _wrap_mg9_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg9__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg9__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg_ = { "mg9", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,0, swig_delete_mg9, swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg__base_names };

static int _wrap_mg10_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg10_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg10_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg10_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg10_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg10_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::PlaneGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg10_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::PlaneGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg10_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  bool arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::PlaneGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  bool arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::PlaneGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg10_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg10_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::PlaneGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg10_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg10_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg10_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg10_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg10_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::PlaneGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg10_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg10_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg10_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg10_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::PlaneGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg10_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::PlaneGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg10__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) 0 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::PlaneGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::PlaneGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::PlaneGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0))){
    SWIG_fail_ptr("mg10__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t);
  }
  
  result = (Procedural::PlaneGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg10(void *obj) {
Procedural::MeshGenerator< Procedural::PlaneGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::PlaneGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg10_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg10_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg10_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg10_setUTile}, 
    {"setVTile", _wrap_mg10_setVTile}, 
    {"setTextureRectangle", _wrap_mg10_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg10_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg10_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg10_setSwitchUV}, 
    {"setOrientation", _wrap_mg10_setOrientation}, 
    {"setPosition", _wrap_mg10_setPosition}, 
    {"setScale", _wrap_mg10_setScale}, 
    {"resetTransforms", _wrap_mg10_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg10__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg10__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg_ = { "mg10", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,0, swig_delete_mg10, swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg__base_names };

static int _wrap_mg11_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg11_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg11_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg11_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg11_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg11_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Extruder > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::Extruder > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Extruder > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg11_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::Extruder > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setUTile",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Extruder *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setVTile",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Extruder *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg11_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  bool arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Extruder *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  unsigned char arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::Extruder *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  bool arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Extruder *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setOrientation",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg11_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg11_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Extruder *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg11_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg11_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg11_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg11_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg11_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Extruder *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Extruder *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg11_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg11_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg11_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg11_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::Extruder >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg11_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  result = (Procedural::Extruder *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::Extruder *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg11__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Extruder >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Extruder >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::Extruder > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0))){
    SWIG_fail_ptr("mg11__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t);
  }
  
  result = (Procedural::Extruder *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg11(void *obj) {
Procedural::MeshGenerator< Procedural::Extruder > *arg1 = (Procedural::MeshGenerator< Procedural::Extruder > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__methods[] = {
    {"realizeMesh", _wrap_mg11_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg11_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg11_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg11_setUTile}, 
    {"setVTile", _wrap_mg11_setVTile}, 
    {"setTextureRectangle", _wrap_mg11_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg11_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg11_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg11_setSwitchUV}, 
    {"setOrientation", _wrap_mg11_setOrientation}, 
    {"setPosition", _wrap_mg11_setPosition}, 
    {"setScale", _wrap_mg11_setScale}, 
    {"resetTransforms", _wrap_mg11_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg11__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg11__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg_ = { "mg11", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Extruder_t,0, swig_delete_mg11, swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg__base_names };

static int _wrap_mg12_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg12_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg12_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg12_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg12_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg12_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::ConeGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg12_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::ConeGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg12_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  bool arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::ConeGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  bool arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::ConeGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg12_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg12_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::ConeGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg12_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg12_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg12_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg12_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg12_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::ConeGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg12_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg12_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg12_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg12_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::ConeGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg12_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::ConeGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg12__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) 0 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::ConeGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::ConeGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::ConeGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0))){
    SWIG_fail_ptr("mg12__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t);
  }
  
  result = (Procedural::ConeGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg12(void *obj) {
Procedural::MeshGenerator< Procedural::ConeGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::ConeGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg12_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg12_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg12_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg12_setUTile}, 
    {"setVTile", _wrap_mg12_setVTile}, 
    {"setTextureRectangle", _wrap_mg12_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg12_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg12_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg12_setSwitchUV}, 
    {"setOrientation", _wrap_mg12_setOrientation}, 
    {"setPosition", _wrap_mg12_setPosition}, 
    {"setScale", _wrap_mg12_setScale}, 
    {"resetTransforms", _wrap_mg12_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg12__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg12__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg_ = { "mg12", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,0, swig_delete_mg12, swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg__base_names };

static int _wrap_mg13_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg13_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg13_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg13_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg13_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg13_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Lathe > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::Lathe > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Lathe > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg13_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::Lathe > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setUTile",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Lathe *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setVTile",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Lathe *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg13_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  bool arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Lathe *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  unsigned char arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::Lathe *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  bool arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Lathe *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setOrientation",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg13_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg13_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Lathe *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg13_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg13_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg13_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg13_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg13_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Lathe *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Lathe *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg13_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg13_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg13_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg13_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::Lathe >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg13_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  result = (Procedural::Lathe *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::Lathe *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg13__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Lathe >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Lathe >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::Lathe > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0))){
    SWIG_fail_ptr("mg13__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t);
  }
  
  result = (Procedural::Lathe *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg13(void *obj) {
Procedural::MeshGenerator< Procedural::Lathe > *arg1 = (Procedural::MeshGenerator< Procedural::Lathe > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__methods[] = {
    {"realizeMesh", _wrap_mg13_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg13_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg13_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg13_setUTile}, 
    {"setVTile", _wrap_mg13_setVTile}, 
    {"setTextureRectangle", _wrap_mg13_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg13_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg13_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg13_setSwitchUV}, 
    {"setOrientation", _wrap_mg13_setOrientation}, 
    {"setPosition", _wrap_mg13_setPosition}, 
    {"setScale", _wrap_mg13_setScale}, 
    {"resetTransforms", _wrap_mg13_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg13__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg13__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg_ = { "mg13", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Lathe_t,0, swig_delete_mg13, swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg__base_names };

static int _wrap_mg14_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg14_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg14_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg14_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg14_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg14_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Triangulator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::Triangulator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Triangulator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg14_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::Triangulator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setUTile",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Triangulator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setVTile",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Triangulator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg14_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  bool arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Triangulator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  unsigned char arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::Triangulator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  bool arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Triangulator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg14_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg14_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Triangulator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg14_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg14_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg14_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg14_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg14_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Triangulator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Triangulator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg14_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg14_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg14_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg14_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::Triangulator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg14_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::Triangulator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg14__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Triangulator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Triangulator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::Triangulator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0))){
    SWIG_fail_ptr("mg14__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg14(void *obj) {
Procedural::MeshGenerator< Procedural::Triangulator > *arg1 = (Procedural::MeshGenerator< Procedural::Triangulator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg14_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg14_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg14_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg14_setUTile}, 
    {"setVTile", _wrap_mg14_setVTile}, 
    {"setTextureRectangle", _wrap_mg14_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg14_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg14_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg14_setSwitchUV}, 
    {"setOrientation", _wrap_mg14_setOrientation}, 
    {"setPosition", _wrap_mg14_setPosition}, 
    {"setScale", _wrap_mg14_setScale}, 
    {"resetTransforms", _wrap_mg14_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg14__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg14__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg_ = { "mg14", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,0, swig_delete_mg14, swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg__base_names };

static int _wrap_mg15_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg15_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg15_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg15_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg15_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg15_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Boolean > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::Boolean > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::Boolean > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg15_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::Boolean > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setUTile",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Boolean *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setVTile",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Boolean *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg15_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  bool arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Boolean *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  unsigned char arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::Boolean *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  bool arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Boolean *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setOrientation",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg15_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg15_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Boolean *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg15_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg15_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg15_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg15_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg15_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Boolean *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Boolean *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg15_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg15_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg15_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg15_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::Boolean >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg15_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  result = (Procedural::Boolean *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::Boolean *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg15__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::Boolean >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::Boolean >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::Boolean > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0))){
    SWIG_fail_ptr("mg15__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t);
  }
  
  result = (Procedural::Boolean *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg15(void *obj) {
Procedural::MeshGenerator< Procedural::Boolean > *arg1 = (Procedural::MeshGenerator< Procedural::Boolean > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__methods[] = {
    {"realizeMesh", _wrap_mg15_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg15_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg15_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg15_setUTile}, 
    {"setVTile", _wrap_mg15_setVTile}, 
    {"setTextureRectangle", _wrap_mg15_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg15_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg15_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg15_setSwitchUV}, 
    {"setOrientation", _wrap_mg15_setOrientation}, 
    {"setPosition", _wrap_mg15_setPosition}, 
    {"setScale", _wrap_mg15_setScale}, 
    {"resetTransforms", _wrap_mg15_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg15__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg15__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg_ = { "mg15", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__Boolean_t,0, swig_delete_mg15, swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg__base_names };

static int _wrap_mg16_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = (arg1)->realizeMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_realizeMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_realizeMesh",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_realizeMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_mg16_realizeMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg16_realizeMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_mg16_realizeMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg16_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh(std::string const &,Ogre::String const &)\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh(std::string const &)\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_mg16_buildTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Procedural::TriangleBuffer result;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::buildTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::buildTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_buildTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  result = ((Procedural::MeshGenerator< Procedural::SpringGenerator > const *)arg1)->buildTriangleBuffer();
  {
    Procedural::TriangleBuffer * resultptr = new Procedural::TriangleBuffer((const Procedural::TriangleBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__TriangleBuffer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::addToTriangleBuffer",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("mg16_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::MeshGenerator< Procedural::SpringGenerator > const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setUTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setUTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setUTile",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setUTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setUTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setUTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setVTile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setVTile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setVTile",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setVTile",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setVTile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setVTile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setTextureRectangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setTextureRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setTextureRectangle",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setTextureRectangle",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setTextureRectangle",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("mg16_setTextureRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->setTextureRectangle((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setEnableNormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  bool arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setEnableNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setEnableNormals",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setEnableNormals",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setEnableNormals",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::SpringGenerator *) &(arg1)->setEnableNormals(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setNumTexCoordSet(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  unsigned char arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setNumTexCoordSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setNumTexCoordSet",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setNumTexCoordSet",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setNumTexCoordSet",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setNumTexCoordSet(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setSwitchUV(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  bool arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setSwitchUV",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setSwitchUV",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setSwitchUV",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setSwitchUV",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::SpringGenerator *) &(arg1)->setSwitchUV(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setOrientation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Quaternion *arg2 = 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setOrientation",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setOrientation",2,"Ogre::Quaternion const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setOrientation",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Quaternion,0))){
    SWIG_fail_ptr("mg16_setOrientation",2,SWIGTYPE_p_Ogre__Quaternion);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->setOrientation((Ogre::Quaternion const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg16_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->setPosition((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setPosition",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::SpringGenerator *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg16_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg16_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg16_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg16_setScale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("mg16_setScale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->setScale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setScale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setScale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setScale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_setScale",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::SpringGenerator *) &(arg1)->setScale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16_setScale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_mg16_setScale__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_mg16_setScale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_mg16_setScale__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'mg16_setScale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale(Ogre::Vector3 const &)\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale(Ogre::Real)\n"
    "    Procedural::MeshGenerator< Procedural::SpringGenerator >::setScale(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_mg16_resetTransforms(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::resetTransforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::resetTransforms",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16_resetTransforms",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->resetTransforms();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16__setDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::_setDumpToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::_setDumpToFile",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::_setDumpToFile",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16__setDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (Procedural::SpringGenerator *) &(arg1)->_setDumpToFile((std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mg16__disableDumpToFile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) 0 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::MeshGenerator< Procedural::SpringGenerator >::_disableDumpToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MeshGenerator< Procedural::SpringGenerator >::_disableDumpToFile",1,"Procedural::MeshGenerator< Procedural::SpringGenerator > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0))){
    SWIG_fail_ptr("mg16__disableDumpToFile",1,SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t);
  }
  
  result = (Procedural::SpringGenerator *) &(arg1)->_disableDumpToFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mg16(void *obj) {
Procedural::MeshGenerator< Procedural::SpringGenerator > *arg1 = (Procedural::MeshGenerator< Procedural::SpringGenerator > *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__methods[] = {
    {"realizeMesh", _wrap_mg16_realizeMesh}, 
    {"buildTriangleBuffer", _wrap_mg16_buildTriangleBuffer}, 
    {"addToTriangleBuffer", _wrap_mg16_addToTriangleBuffer}, 
    {"setUTile", _wrap_mg16_setUTile}, 
    {"setVTile", _wrap_mg16_setVTile}, 
    {"setTextureRectangle", _wrap_mg16_setTextureRectangle}, 
    {"setEnableNormals", _wrap_mg16_setEnableNormals}, 
    {"setNumTexCoordSet", _wrap_mg16_setNumTexCoordSet}, 
    {"setSwitchUV", _wrap_mg16_setSwitchUV}, 
    {"setOrientation", _wrap_mg16_setOrientation}, 
    {"setPosition", _wrap_mg16_setPosition}, 
    {"setScale", _wrap_mg16_setScale}, 
    {"resetTransforms", _wrap_mg16_resetTransforms}, 
    {"_setDumpToFile", _wrap_mg16__setDumpToFile}, 
    {"_disableDumpToFile", _wrap_mg16__disableDumpToFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__bases[] = {0};
static const char *swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg_ = { "mg16", &SWIGTYPE_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,0, swig_delete_mg16, swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__methods, swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__attributes, swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__bases, swig_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg__base_names };

static int _wrap_new_SphereGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::SphereGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",3,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (Procedural::SphereGenerator *)new Procedural::SphereGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SphereGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  unsigned int arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::SphereGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",2,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *)new Procedural::SphereGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SphereGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::SphereGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::SphereGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::SphereGenerator *)new Procedural::SphereGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SphereGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::SphereGenerator",0,0)
  result = (Procedural::SphereGenerator *)new Procedural::SphereGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SphereGenerator(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SphereGenerator__SWIG_3(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_SphereGenerator__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SphereGenerator__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_SphereGenerator__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_SphereGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::SphereGenerator::SphereGenerator(Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::SphereGenerator::SphereGenerator(Ogre::Real,unsigned int)\n"
    "    Procedural::SphereGenerator::SphereGenerator(Ogre::Real)\n"
    "    Procedural::SphereGenerator::SphereGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_SphereGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereGenerator *arg1 = (Procedural::SphereGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::setRadius",1,"Procedural::SphereGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereGenerator,0))){
    SWIG_fail_ptr("SphereGenerator_setRadius",1,SWIGTYPE_p_Procedural__SphereGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SphereGenerator_setNumRings(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereGenerator *arg1 = (Procedural::SphereGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::setNumRings",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::setNumRings",1,"Procedural::SphereGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::setNumRings",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereGenerator,0))){
    SWIG_fail_ptr("SphereGenerator_setNumRings",1,SWIGTYPE_p_Procedural__SphereGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setNumRings(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SphereGenerator_setNumSegments(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereGenerator *arg1 = (Procedural::SphereGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::SphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::setNumSegments",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::setNumSegments",1,"Procedural::SphereGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::setNumSegments",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereGenerator,0))){
    SWIG_fail_ptr("SphereGenerator_setNumSegments",1,SWIGTYPE_p_Procedural__SphereGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::SphereGenerator *) &(arg1)->setNumSegments(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SphereGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereGenerator *arg1 = (Procedural::SphereGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::SphereGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereGenerator::addToTriangleBuffer",1,"Procedural::SphereGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SphereGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereGenerator,0))){
    SWIG_fail_ptr("SphereGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__SphereGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("SphereGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::SphereGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SphereGenerator(void *obj) {
Procedural::SphereGenerator *arg1 = (Procedural::SphereGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_SphereGenerator_methods[] = {
    {"setRadius", _wrap_SphereGenerator_setRadius}, 
    {"setNumRings", _wrap_SphereGenerator_setNumRings}, 
    {"setNumSegments", _wrap_SphereGenerator_setNumSegments}, 
    {"addToTriangleBuffer", _wrap_SphereGenerator_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_SphereGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_SphereGenerator_bases[] = {0,0};
static const char *swig_Procedural_SphereGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::SphereGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_SphereGenerator = { "SphereGenerator", &SWIGTYPE_p_Procedural__SphereGenerator,_wrap_new_SphereGenerator, swig_delete_SphereGenerator, swig_Procedural_SphereGenerator_methods, swig_Procedural_SphereGenerator_attributes, swig_Procedural_SphereGenerator_bases, swig_Procedural_SphereGenerator_base_names };

static int _wrap_new_BoxGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",4,"unsigned int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",5,"unsigned int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",6,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",4,"unsigned int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",5,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",4,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",3,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::BoxGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::BoxGenerator",0,0)
  result = (Procedural::BoxGenerator *)new Procedural::BoxGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxGenerator(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_BoxGenerator__SWIG_6(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_BoxGenerator__SWIG_5(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_BoxGenerator__SWIG_4(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_BoxGenerator__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_BoxGenerator__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_BoxGenerator__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_new_BoxGenerator__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_BoxGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int,unsigned int)\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real,Ogre::Real,Ogre::Real,unsigned int)\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::BoxGenerator::BoxGenerator(Ogre::Real)\n"
    "    Procedural::BoxGenerator::BoxGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_BoxGenerator_setSizeX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setSizeX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeX",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setSizeX",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setSizeX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setSizeY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setSizeY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeY",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setSizeY",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setSizeY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setSizeZ(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setSizeZ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeZ",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setSizeZ",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setSizeZ",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setSizeZ(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setSize",1,"Procedural::BoxGenerator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setSize",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setSize",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("BoxGenerator_setSize",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::BoxGenerator *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setNumSegX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setNumSegX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegX",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegX",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setNumSegX",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setNumSegX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setNumSegY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setNumSegY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegY",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegY",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setNumSegY",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setNumSegY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_setNumSegZ(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::BoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::setNumSegZ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegZ",1,"Procedural::BoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::setNumSegZ",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_setNumSegZ",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::BoxGenerator *) &(arg1)->setNumSegZ(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::BoxGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxGenerator::addToTriangleBuffer",1,"Procedural::BoxGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BoxGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxGenerator,0))){
    SWIG_fail_ptr("BoxGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__BoxGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("BoxGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::BoxGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BoxGenerator(void *obj) {
Procedural::BoxGenerator *arg1 = (Procedural::BoxGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BoxGenerator_methods[] = {
    {"setSizeX", _wrap_BoxGenerator_setSizeX}, 
    {"setSizeY", _wrap_BoxGenerator_setSizeY}, 
    {"setSizeZ", _wrap_BoxGenerator_setSizeZ}, 
    {"setSize", _wrap_BoxGenerator_setSize}, 
    {"setNumSegX", _wrap_BoxGenerator_setNumSegX}, 
    {"setNumSegY", _wrap_BoxGenerator_setNumSegY}, 
    {"setNumSegZ", _wrap_BoxGenerator_setNumSegZ}, 
    {"addToTriangleBuffer", _wrap_BoxGenerator_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BoxGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BoxGenerator_bases[] = {0,0};
static const char *swig_Procedural_BoxGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::BoxGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_BoxGenerator = { "BoxGenerator", &SWIGTYPE_p_Procedural__BoxGenerator,_wrap_new_BoxGenerator, swig_delete_BoxGenerator, swig_Procedural_BoxGenerator_methods, swig_Procedural_BoxGenerator_attributes, swig_Procedural_BoxGenerator_bases, swig_Procedural_BoxGenerator_base_names };

static int _wrap_new_CapsuleGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::CapsuleGenerator",0,0)
  result = (Procedural::CapsuleGenerator *)new Procedural::CapsuleGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CapsuleGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::CapsuleGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::CapsuleGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::CapsuleGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CapsuleGenerator::CapsuleGenerator",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CapsuleGenerator::CapsuleGenerator",4,"unsigned int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::CapsuleGenerator::CapsuleGenerator",5,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  result = (Procedural::CapsuleGenerator *)new Procedural::CapsuleGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CapsuleGenerator(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_CapsuleGenerator__SWIG_0(L);
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_CapsuleGenerator__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_CapsuleGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CapsuleGenerator::CapsuleGenerator()\n"
    "    Procedural::CapsuleGenerator::CapsuleGenerator(Ogre::Real,Ogre::Real,unsigned int,unsigned int,unsigned int)\n");
  lua_error(L);return 0;
}


static int _wrap_CapsuleGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::addToTriangleBuffer",1,"Procedural::CapsuleGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("CapsuleGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::CapsuleGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CapsuleGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::setRadius",1,"Procedural::CapsuleGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_setRadius",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CapsuleGenerator_setNumRings(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::setNumRings",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumRings",1,"Procedural::CapsuleGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumRings",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_setNumRings",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setNumRings(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CapsuleGenerator_setNumSegments(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::setNumSegments",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumSegments",1,"Procedural::CapsuleGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumSegments",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_setNumSegments",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setNumSegments(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CapsuleGenerator_setNumSegHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::setNumSegHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumSegHeight",1,"Procedural::CapsuleGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::setNumSegHeight",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_setNumSegHeight",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setNumSegHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CapsuleGenerator_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CapsuleGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CapsuleGenerator::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CapsuleGenerator::setHeight",1,"Procedural::CapsuleGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CapsuleGenerator::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CapsuleGenerator,0))){
    SWIG_fail_ptr("CapsuleGenerator_setHeight",1,SWIGTYPE_p_Procedural__CapsuleGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CapsuleGenerator *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CapsuleGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CapsuleGenerator(void *obj) {
Procedural::CapsuleGenerator *arg1 = (Procedural::CapsuleGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CapsuleGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_CapsuleGenerator_addToTriangleBuffer}, 
    {"setRadius", _wrap_CapsuleGenerator_setRadius}, 
    {"setNumRings", _wrap_CapsuleGenerator_setNumRings}, 
    {"setNumSegments", _wrap_CapsuleGenerator_setNumSegments}, 
    {"setNumSegHeight", _wrap_CapsuleGenerator_setNumSegHeight}, 
    {"setHeight", _wrap_CapsuleGenerator_setHeight}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CapsuleGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CapsuleGenerator_bases[] = {0,0};
static const char *swig_Procedural_CapsuleGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::CapsuleGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_CapsuleGenerator = { "CapsuleGenerator", &SWIGTYPE_p_Procedural__CapsuleGenerator,_wrap_new_CapsuleGenerator, swig_delete_CapsuleGenerator, swig_Procedural_CapsuleGenerator_methods, swig_Procedural_CapsuleGenerator_attributes, swig_Procedural_CapsuleGenerator_bases, swig_Procedural_CapsuleGenerator_base_names };

static int _wrap_new_ConeGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::ConeGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",4,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Procedural::ConeGenerator *)new Procedural::ConeGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ConeGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::ConeGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",3,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (Procedural::ConeGenerator *)new Procedural::ConeGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ConeGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::ConeGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *)new Procedural::ConeGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ConeGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::ConeGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::ConeGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::ConeGenerator *)new Procedural::ConeGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ConeGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::ConeGenerator",0,0)
  result = (Procedural::ConeGenerator *)new Procedural::ConeGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ConeGenerator(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ConeGenerator__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_ConeGenerator__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ConeGenerator__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_ConeGenerator__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_ConeGenerator__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_ConeGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::ConeGenerator::ConeGenerator(Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::ConeGenerator::ConeGenerator(Ogre::Real,Ogre::Real,unsigned int)\n"
    "    Procedural::ConeGenerator::ConeGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::ConeGenerator::ConeGenerator(Ogre::Real)\n"
    "    Procedural::ConeGenerator::ConeGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_ConeGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::addToTriangleBuffer",1,"Procedural::ConeGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ConeGenerator,0))){
    SWIG_fail_ptr("ConeGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__ConeGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("ConeGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::ConeGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ConeGenerator_setNumSegBase(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::setNumSegBase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::setNumSegBase",1,"Procedural::ConeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::setNumSegBase",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ConeGenerator,0))){
    SWIG_fail_ptr("ConeGenerator_setNumSegBase",1,SWIGTYPE_p_Procedural__ConeGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setNumSegBase(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ConeGenerator_setNumSegHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::setNumSegHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::setNumSegHeight",1,"Procedural::ConeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::setNumSegHeight",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ConeGenerator,0))){
    SWIG_fail_ptr("ConeGenerator_setNumSegHeight",1,SWIGTYPE_p_Procedural__ConeGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setNumSegHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ConeGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::setRadius",1,"Procedural::ConeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ConeGenerator,0))){
    SWIG_fail_ptr("ConeGenerator_setRadius",1,SWIGTYPE_p_Procedural__ConeGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ConeGenerator_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ConeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ConeGenerator::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ConeGenerator::setHeight",1,"Procedural::ConeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ConeGenerator::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ConeGenerator,0))){
    SWIG_fail_ptr("ConeGenerator_setHeight",1,SWIGTYPE_p_Procedural__ConeGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ConeGenerator *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ConeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ConeGenerator(void *obj) {
Procedural::ConeGenerator *arg1 = (Procedural::ConeGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_ConeGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_ConeGenerator_addToTriangleBuffer}, 
    {"setNumSegBase", _wrap_ConeGenerator_setNumSegBase}, 
    {"setNumSegHeight", _wrap_ConeGenerator_setNumSegHeight}, 
    {"setRadius", _wrap_ConeGenerator_setRadius}, 
    {"setHeight", _wrap_ConeGenerator_setHeight}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_ConeGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_ConeGenerator_bases[] = {0,0};
static const char *swig_Procedural_ConeGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::ConeGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_ConeGenerator = { "ConeGenerator", &SWIGTYPE_p_Procedural__ConeGenerator,_wrap_new_ConeGenerator, swig_delete_ConeGenerator, swig_Procedural_ConeGenerator_methods, swig_Procedural_ConeGenerator_attributes, swig_Procedural_ConeGenerator_bases, swig_Procedural_ConeGenerator_base_names };

static int _wrap_new_CylinderGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  bool arg5 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",4,"unsigned int");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",5,"bool");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",4,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",3,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::CylinderGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::CylinderGenerator",0,0)
  result = (Procedural::CylinderGenerator *)new Procedural::CylinderGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderGenerator(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_CylinderGenerator__SWIG_5(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_CylinderGenerator__SWIG_4(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_CylinderGenerator__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_CylinderGenerator__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_CylinderGenerator__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_CylinderGenerator__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_CylinderGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CylinderGenerator::CylinderGenerator(Ogre::Real,Ogre::Real,unsigned int,unsigned int,bool)\n"
    "    Procedural::CylinderGenerator::CylinderGenerator(Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::CylinderGenerator::CylinderGenerator(Ogre::Real,Ogre::Real,unsigned int)\n"
    "    Procedural::CylinderGenerator::CylinderGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::CylinderGenerator::CylinderGenerator(Ogre::Real)\n"
    "    Procedural::CylinderGenerator::CylinderGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_CylinderGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::addToTriangleBuffer",1,"Procedural::CylinderGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("CylinderGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::CylinderGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderGenerator_setNumSegBase(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::setNumSegBase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::setNumSegBase",1,"Procedural::CylinderGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::setNumSegBase",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_setNumSegBase",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setNumSegBase(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderGenerator_setNumSegHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::setNumSegHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::setNumSegHeight",1,"Procedural::CylinderGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::setNumSegHeight",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_setNumSegHeight",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setNumSegHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderGenerator_setCapped(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  bool arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::setCapped",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::setCapped",1,"Procedural::CylinderGenerator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::setCapped",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_setCapped",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CylinderGenerator *) &(arg1)->setCapped(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::setRadius",1,"Procedural::CylinderGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_setRadius",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderGenerator_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderGenerator::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderGenerator::setHeight",1,"Procedural::CylinderGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderGenerator::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderGenerator,0))){
    SWIG_fail_ptr("CylinderGenerator_setHeight",1,SWIGTYPE_p_Procedural__CylinderGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderGenerator *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CylinderGenerator(void *obj) {
Procedural::CylinderGenerator *arg1 = (Procedural::CylinderGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CylinderGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_CylinderGenerator_addToTriangleBuffer}, 
    {"setNumSegBase", _wrap_CylinderGenerator_setNumSegBase}, 
    {"setNumSegHeight", _wrap_CylinderGenerator_setNumSegHeight}, 
    {"setCapped", _wrap_CylinderGenerator_setCapped}, 
    {"setRadius", _wrap_CylinderGenerator_setRadius}, 
    {"setHeight", _wrap_CylinderGenerator_setHeight}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CylinderGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CylinderGenerator_bases[] = {0,0};
static const char *swig_Procedural_CylinderGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::CylinderGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_CylinderGenerator = { "CylinderGenerator", &SWIGTYPE_p_Procedural__CylinderGenerator,_wrap_new_CylinderGenerator, swig_delete_CylinderGenerator, swig_Procedural_CylinderGenerator_methods, swig_Procedural_CylinderGenerator_attributes, swig_Procedural_CylinderGenerator_bases, swig_Procedural_CylinderGenerator_base_names };

static int _wrap_new_IcoSphereGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  unsigned int arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::IcoSphereGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::IcoSphereGenerator::IcoSphereGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::IcoSphereGenerator::IcoSphereGenerator",2,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *)new Procedural::IcoSphereGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IcoSphereGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::IcoSphereGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::IcoSphereGenerator::IcoSphereGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::IcoSphereGenerator *)new Procedural::IcoSphereGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IcoSphereGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::IcoSphereGenerator",0,0)
  result = (Procedural::IcoSphereGenerator *)new Procedural::IcoSphereGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IcoSphereGenerator(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_IcoSphereGenerator__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_IcoSphereGenerator__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_IcoSphereGenerator__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_IcoSphereGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::IcoSphereGenerator::IcoSphereGenerator(Ogre::Real,unsigned int)\n"
    "    Procedural::IcoSphereGenerator::IcoSphereGenerator(Ogre::Real)\n"
    "    Procedural::IcoSphereGenerator::IcoSphereGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_IcoSphereGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IcoSphereGenerator *arg1 = (Procedural::IcoSphereGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IcoSphereGenerator::addToTriangleBuffer",1,"Procedural::IcoSphereGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::IcoSphereGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IcoSphereGenerator,0))){
    SWIG_fail_ptr("IcoSphereGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__IcoSphereGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("IcoSphereGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::IcoSphereGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IcoSphereGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IcoSphereGenerator *arg1 = (Procedural::IcoSphereGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IcoSphereGenerator::setRadius",1,"Procedural::IcoSphereGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::IcoSphereGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IcoSphereGenerator,0))){
    SWIG_fail_ptr("IcoSphereGenerator_setRadius",1,SWIGTYPE_p_Procedural__IcoSphereGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IcoSphereGenerator_setNumIterations(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IcoSphereGenerator *arg1 = (Procedural::IcoSphereGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::IcoSphereGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::IcoSphereGenerator::setNumIterations",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IcoSphereGenerator::setNumIterations",1,"Procedural::IcoSphereGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::IcoSphereGenerator::setNumIterations",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IcoSphereGenerator,0))){
    SWIG_fail_ptr("IcoSphereGenerator_setNumIterations",1,SWIGTYPE_p_Procedural__IcoSphereGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::IcoSphereGenerator *) &(arg1)->setNumIterations(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IcoSphereGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IcoSphereGenerator(void *obj) {
Procedural::IcoSphereGenerator *arg1 = (Procedural::IcoSphereGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_IcoSphereGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_IcoSphereGenerator_addToTriangleBuffer}, 
    {"setRadius", _wrap_IcoSphereGenerator_setRadius}, 
    {"setNumIterations", _wrap_IcoSphereGenerator_setNumIterations}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_IcoSphereGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_IcoSphereGenerator_bases[] = {0,0};
static const char *swig_Procedural_IcoSphereGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_IcoSphereGenerator = { "IcoSphereGenerator", &SWIGTYPE_p_Procedural__IcoSphereGenerator,_wrap_new_IcoSphereGenerator, swig_delete_IcoSphereGenerator, swig_Procedural_IcoSphereGenerator_methods, swig_Procedural_IcoSphereGenerator_attributes, swig_Procedural_IcoSphereGenerator_bases, swig_Procedural_IcoSphereGenerator_base_names };

static int _wrap_new_RoundedBoxGenerator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::RoundedBoxGenerator",0,0)
  result = (Procedural::RoundedBoxGenerator *)new Procedural::RoundedBoxGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setSizeX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setSizeX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeX",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setSizeX",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setSizeX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setSizeY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setSizeY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeY",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setSizeY",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setSizeY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setSizeZ(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setSizeZ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeZ",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSizeZ",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setSizeZ",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setSizeZ(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSize",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setSize",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setSize",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setSize",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setNumSegX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  unsigned short arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setNumSegX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegX",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegX",2,"unsigned short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setNumSegX",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned short)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setNumSegX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setNumSegY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  unsigned short arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setNumSegY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegY",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegY",2,"unsigned short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setNumSegY",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned short)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setNumSegY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setNumSegZ(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  unsigned short arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setNumSegZ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegZ",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setNumSegZ",2,"unsigned short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setNumSegZ",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned short)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setNumSegZ(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_setChamferSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RoundedBoxGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::setChamferSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setChamferSize",1,"Procedural::RoundedBoxGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::setChamferSize",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_setChamferSize",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RoundedBoxGenerator *) &(arg1)->setChamferSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RoundedBoxGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::RoundedBoxGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::addToTriangleBuffer",1,"Procedural::RoundedBoxGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RoundedBoxGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RoundedBoxGenerator,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__RoundedBoxGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("RoundedBoxGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::RoundedBoxGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RoundedBoxGenerator(void *obj) {
Procedural::RoundedBoxGenerator *arg1 = (Procedural::RoundedBoxGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RoundedBoxGenerator_methods[] = {
    {"setSizeX", _wrap_RoundedBoxGenerator_setSizeX}, 
    {"setSizeY", _wrap_RoundedBoxGenerator_setSizeY}, 
    {"setSizeZ", _wrap_RoundedBoxGenerator_setSizeZ}, 
    {"setSize", _wrap_RoundedBoxGenerator_setSize}, 
    {"setNumSegX", _wrap_RoundedBoxGenerator_setNumSegX}, 
    {"setNumSegY", _wrap_RoundedBoxGenerator_setNumSegY}, 
    {"setNumSegZ", _wrap_RoundedBoxGenerator_setNumSegZ}, 
    {"setChamferSize", _wrap_RoundedBoxGenerator_setChamferSize}, 
    {"addToTriangleBuffer", _wrap_RoundedBoxGenerator_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RoundedBoxGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RoundedBoxGenerator_bases[] = {0,0};
static const char *swig_Procedural_RoundedBoxGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_RoundedBoxGenerator = { "RoundedBoxGenerator", &SWIGTYPE_p_Procedural__RoundedBoxGenerator,_wrap_new_RoundedBoxGenerator, swig_delete_RoundedBoxGenerator, swig_Procedural_RoundedBoxGenerator_methods, swig_Procedural_RoundedBoxGenerator_attributes, swig_Procedural_RoundedBoxGenerator_bases, swig_Procedural_RoundedBoxGenerator_base_names };

static int _wrap_new_TorusGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::TorusGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",4,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Procedural::TorusGenerator *)new Procedural::TorusGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  unsigned int arg3 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::TorusGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",3,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (Procedural::TorusGenerator *)new Procedural::TorusGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::TorusGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *)new Procedural::TorusGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::TorusGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::TorusGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::TorusGenerator *)new Procedural::TorusGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::TorusGenerator",0,0)
  result = (Procedural::TorusGenerator *)new Procedural::TorusGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusGenerator(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_TorusGenerator__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_TorusGenerator__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_TorusGenerator__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_TorusGenerator__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_TorusGenerator__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_TorusGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TorusGenerator::TorusGenerator(Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::TorusGenerator::TorusGenerator(Ogre::Real,Ogre::Real,unsigned int)\n"
    "    Procedural::TorusGenerator::TorusGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::TorusGenerator::TorusGenerator(Ogre::Real)\n"
    "    Procedural::TorusGenerator::TorusGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_TorusGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::addToTriangleBuffer",1,"Procedural::TorusGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusGenerator,0))){
    SWIG_fail_ptr("TorusGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__TorusGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TorusGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::TorusGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusGenerator_setNumSegSection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::setNumSegSection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::setNumSegSection",1,"Procedural::TorusGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::setNumSegSection",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusGenerator,0))){
    SWIG_fail_ptr("TorusGenerator_setNumSegSection",1,SWIGTYPE_p_Procedural__TorusGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setNumSegSection(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusGenerator_setNumSegCircle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::setNumSegCircle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::setNumSegCircle",1,"Procedural::TorusGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::setNumSegCircle",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusGenerator,0))){
    SWIG_fail_ptr("TorusGenerator_setNumSegCircle",1,SWIGTYPE_p_Procedural__TorusGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setNumSegCircle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::setRadius",1,"Procedural::TorusGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusGenerator,0))){
    SWIG_fail_ptr("TorusGenerator_setRadius",1,SWIGTYPE_p_Procedural__TorusGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusGenerator_setSectionRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusGenerator::setSectionRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusGenerator::setSectionRadius",1,"Procedural::TorusGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusGenerator::setSectionRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusGenerator,0))){
    SWIG_fail_ptr("TorusGenerator_setSectionRadius",1,SWIGTYPE_p_Procedural__TorusGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusGenerator *) &(arg1)->setSectionRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TorusGenerator(void *obj) {
Procedural::TorusGenerator *arg1 = (Procedural::TorusGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TorusGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_TorusGenerator_addToTriangleBuffer}, 
    {"setNumSegSection", _wrap_TorusGenerator_setNumSegSection}, 
    {"setNumSegCircle", _wrap_TorusGenerator_setNumSegCircle}, 
    {"setRadius", _wrap_TorusGenerator_setRadius}, 
    {"setSectionRadius", _wrap_TorusGenerator_setSectionRadius}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TorusGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TorusGenerator_bases[] = {0,0};
static const char *swig_Procedural_TorusGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::TorusGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_TorusGenerator = { "TorusGenerator", &SWIGTYPE_p_Procedural__TorusGenerator,_wrap_new_TorusGenerator, swig_delete_TorusGenerator, swig_Procedural_TorusGenerator_methods, swig_Procedural_TorusGenerator_attributes, swig_Procedural_TorusGenerator_bases, swig_Procedural_TorusGenerator_base_names };

static int _wrap_new_TorusKnotGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  int arg3 ;
  int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",5,"unsigned int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",6,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned int)lua_tonumber(L, 6);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  int arg3 ;
  int arg4 ;
  unsigned int arg5 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",5,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  int arg3 ;
  int arg4 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",4,"int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  int arg3 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",3,"int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::TorusKnotGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::TorusKnotGenerator",0,0)
  result = (Procedural::TorusKnotGenerator *)new Procedural::TorusKnotGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TorusKnotGenerator(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_TorusKnotGenerator__SWIG_6(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_TorusKnotGenerator__SWIG_5(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_TorusKnotGenerator__SWIG_4(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_TorusKnotGenerator__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_TorusKnotGenerator__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_TorusKnotGenerator__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_new_TorusKnotGenerator__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_TorusKnotGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real,Ogre::Real,int,int,unsigned int,unsigned int)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real,Ogre::Real,int,int,unsigned int)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real,Ogre::Real,int,int)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real,Ogre::Real,int)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator(Ogre::Real)\n"
    "    Procedural::TorusKnotGenerator::TorusKnotGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_TorusKnotGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::addToTriangleBuffer",1,"Procedural::TorusKnotGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TorusKnotGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::TorusKnotGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setNumSegSection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setNumSegSection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setNumSegSection",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setNumSegSection",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setNumSegSection",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setNumSegSection(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setNumSegCircle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setNumSegCircle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setNumSegCircle",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setNumSegCircle",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setNumSegCircle",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setNumSegCircle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setRadius",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setRadius",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setSectionRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setSectionRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setSectionRadius",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setSectionRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setSectionRadius",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setSectionRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setP(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  int arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setP",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setP",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setP",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setP(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TorusKnotGenerator_setQ(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) 0 ;
  int arg2 ;
  Procedural::TorusKnotGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TorusKnotGenerator::setQ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setQ",1,"Procedural::TorusKnotGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TorusKnotGenerator::setQ",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TorusKnotGenerator,0))){
    SWIG_fail_ptr("TorusKnotGenerator_setQ",1,SWIGTYPE_p_Procedural__TorusKnotGenerator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Procedural::TorusKnotGenerator *) &(arg1)->setQ(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TorusKnotGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TorusKnotGenerator(void *obj) {
Procedural::TorusKnotGenerator *arg1 = (Procedural::TorusKnotGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TorusKnotGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_TorusKnotGenerator_addToTriangleBuffer}, 
    {"setNumSegSection", _wrap_TorusKnotGenerator_setNumSegSection}, 
    {"setNumSegCircle", _wrap_TorusKnotGenerator_setNumSegCircle}, 
    {"setRadius", _wrap_TorusKnotGenerator_setRadius}, 
    {"setSectionRadius", _wrap_TorusKnotGenerator_setSectionRadius}, 
    {"setP", _wrap_TorusKnotGenerator_setP}, 
    {"setQ", _wrap_TorusKnotGenerator_setQ}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TorusKnotGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TorusKnotGenerator_bases[] = {0,0};
static const char *swig_Procedural_TorusKnotGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_TorusKnotGenerator = { "TorusKnotGenerator", &SWIGTYPE_p_Procedural__TorusKnotGenerator,_wrap_new_TorusKnotGenerator, swig_delete_TorusKnotGenerator, swig_Procedural_TorusKnotGenerator_methods, swig_Procedural_TorusKnotGenerator_attributes, swig_Procedural_TorusKnotGenerator_bases, swig_Procedural_TorusKnotGenerator_base_names };

static int _wrap_new_TubeGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",4,"unsigned int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",5,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (unsigned int)lua_tonumber(L, 5);
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",4,"unsigned int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",3,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::TubeGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::TubeGenerator",0,0)
  result = (Procedural::TubeGenerator *)new Procedural::TubeGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TubeGenerator(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_TubeGenerator__SWIG_5(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_TubeGenerator__SWIG_4(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_TubeGenerator__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_TubeGenerator__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_TubeGenerator__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_TubeGenerator__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_TubeGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TubeGenerator::TubeGenerator(Ogre::Real,Ogre::Real,Ogre::Real,unsigned int,unsigned int)\n"
    "    Procedural::TubeGenerator::TubeGenerator(Ogre::Real,Ogre::Real,Ogre::Real,unsigned int)\n"
    "    Procedural::TubeGenerator::TubeGenerator(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::TubeGenerator::TubeGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::TubeGenerator::TubeGenerator(Ogre::Real)\n"
    "    Procedural::TubeGenerator::TubeGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_TubeGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::addToTriangleBuffer",1,"Procedural::TubeGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("TubeGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::TubeGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TubeGenerator_setNumSegBase(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::setNumSegBase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::setNumSegBase",1,"Procedural::TubeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::setNumSegBase",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_setNumSegBase",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setNumSegBase(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TubeGenerator_setNumSegHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::setNumSegHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::setNumSegHeight",1,"Procedural::TubeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::setNumSegHeight",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_setNumSegHeight",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setNumSegHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TubeGenerator_setOuterRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::setOuterRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::setOuterRadius",1,"Procedural::TubeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::setOuterRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_setOuterRadius",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setOuterRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TubeGenerator_setInnerRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::setInnerRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::setInnerRadius",1,"Procedural::TubeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::setInnerRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_setInnerRadius",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setInnerRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TubeGenerator_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::TubeGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::TubeGenerator::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TubeGenerator::setHeight",1,"Procedural::TubeGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TubeGenerator::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TubeGenerator,0))){
    SWIG_fail_ptr("TubeGenerator_setHeight",1,SWIGTYPE_p_Procedural__TubeGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::TubeGenerator *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TubeGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TubeGenerator(void *obj) {
Procedural::TubeGenerator *arg1 = (Procedural::TubeGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TubeGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_TubeGenerator_addToTriangleBuffer}, 
    {"setNumSegBase", _wrap_TubeGenerator_setNumSegBase}, 
    {"setNumSegHeight", _wrap_TubeGenerator_setNumSegHeight}, 
    {"setOuterRadius", _wrap_TubeGenerator_setOuterRadius}, 
    {"setInnerRadius", _wrap_TubeGenerator_setInnerRadius}, 
    {"setHeight", _wrap_TubeGenerator_setHeight}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TubeGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TubeGenerator_bases[] = {0,0};
static const char *swig_Procedural_TubeGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::TubeGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_TubeGenerator = { "TubeGenerator", &SWIGTYPE_p_Procedural__TubeGenerator,_wrap_new_TubeGenerator, swig_delete_TubeGenerator, swig_Procedural_TubeGenerator_methods, swig_Procedural_TubeGenerator_attributes, swig_Procedural_TubeGenerator_bases, swig_Procedural_TubeGenerator_base_names };

static int _wrap_new_PlaneGenerator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::PlaneGenerator",0,0)
  result = (Procedural::PlaneGenerator *)new Procedural::PlaneGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::addToTriangleBuffer",1,"Procedural::PlaneGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("PlaneGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::PlaneGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setNumSegX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setNumSegX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setNumSegX",1,"Procedural::PlaneGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setNumSegX",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setNumSegX",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setNumSegX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setNumSegY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  unsigned int arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setNumSegY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setNumSegY",1,"Procedural::PlaneGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setNumSegY",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setNumSegY",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setNumSegY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setNormal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setNormal",1,"Procedural::PlaneGenerator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setNormal",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setNormal",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("PlaneGenerator_setNormal",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setNormal(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setSizeX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setSizeX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setSizeX",1,"Procedural::PlaneGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setSizeX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setSizeX",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setSizeX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setSizeY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setSizeY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setSizeY",1,"Procedural::PlaneGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setSizeY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setSizeY",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PlaneGenerator *) &(arg1)->setSizeY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneGenerator_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp2 ;
  Procedural::PlaneGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneGenerator::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneGenerator::setSize",1,"Procedural::PlaneGenerator *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneGenerator::setSize",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneGenerator,0))){
    SWIG_fail_ptr("PlaneGenerator_setSize",1,SWIGTYPE_p_Procedural__PlaneGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("PlaneGenerator_setSize",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::PlaneGenerator *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PlaneGenerator(void *obj) {
Procedural::PlaneGenerator *arg1 = (Procedural::PlaneGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_PlaneGenerator_methods[] = {
    {"addToTriangleBuffer", _wrap_PlaneGenerator_addToTriangleBuffer}, 
    {"setNumSegX", _wrap_PlaneGenerator_setNumSegX}, 
    {"setNumSegY", _wrap_PlaneGenerator_setNumSegY}, 
    {"setNormal", _wrap_PlaneGenerator_setNormal}, 
    {"setSizeX", _wrap_PlaneGenerator_setSizeX}, 
    {"setSizeY", _wrap_PlaneGenerator_setSizeY}, 
    {"setSize", _wrap_PlaneGenerator_setSize}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_PlaneGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_PlaneGenerator_bases[] = {0,0};
static const char *swig_Procedural_PlaneGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::PlaneGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_PlaneGenerator = { "PlaneGenerator", &SWIGTYPE_p_Procedural__PlaneGenerator,_wrap_new_PlaneGenerator, swig_delete_PlaneGenerator, swig_Procedural_PlaneGenerator_methods, swig_Procedural_PlaneGenerator_attributes, swig_Procedural_PlaneGenerator_bases, swig_Procedural_PlaneGenerator_base_names };

static int _wrap_new_Extruder(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::Extruder",0,0)
  result = (Procedural::Extruder *)new Procedural::Extruder();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::addToTriangleBuffer",1,"Procedural::Extruder const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Extruder::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Extruder_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::Extruder const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setShapeToExtrude(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Shape *arg2 = (Shape *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setShapeToExtrude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setShapeToExtrude",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setShapeToExtrude",2,"Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setShapeToExtrude",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Shape,0))){
    SWIG_fail_ptr("Extruder_setShapeToExtrude",2,SWIGTYPE_p_Shape);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setShapeToExtrude(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setMultiShapeToExtrude(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  MultiShape *arg2 = (MultiShape *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setMultiShapeToExtrude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setMultiShapeToExtrude",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setMultiShapeToExtrude",2,"MultiShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setMultiShapeToExtrude",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MultiShape,0))){
    SWIG_fail_ptr("Extruder_setMultiShapeToExtrude",2,SWIGTYPE_p_MultiShape);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setMultiShapeToExtrude(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setExtrusionPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Path *arg2 = (Path *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setExtrusionPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setExtrusionPath",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setExtrusionPath",2,"Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setExtrusionPath",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Path,0))){
    SWIG_fail_ptr("Extruder_setExtrusionPath",2,SWIGTYPE_p_Path);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setExtrusionPath(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setRotationTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Track *arg2 = (Track *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setRotationTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setRotationTrack",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setRotationTrack",2,"Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setRotationTrack",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Extruder_setRotationTrack",2,SWIGTYPE_p_Track);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setRotationTrack(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setScaleTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Track *arg2 = (Track *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setScaleTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setScaleTrack",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setScaleTrack",2,"Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setScaleTrack",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Extruder_setScaleTrack",2,SWIGTYPE_p_Track);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setScaleTrack(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setShapeTextureTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Track *arg2 = (Track *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setShapeTextureTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setShapeTextureTrack",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setShapeTextureTrack",2,"Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setShapeTextureTrack",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Extruder_setShapeTextureTrack",2,SWIGTYPE_p_Track);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setShapeTextureTrack(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setPathTextureTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  Track *arg2 = (Track *) 0 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setPathTextureTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setPathTextureTrack",1,"Procedural::Extruder *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Extruder::setPathTextureTrack",2,"Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setPathTextureTrack",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Extruder_setPathTextureTrack",2,SWIGTYPE_p_Track);
  }
  
  result = (Procedural::Extruder *) &(arg1)->setPathTextureTrack(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Extruder_setCapped(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Extruder *arg1 = (Procedural::Extruder *) 0 ;
  bool arg2 ;
  Procedural::Extruder *result = 0 ;
  
  SWIG_check_num_args("Procedural::Extruder::setCapped",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Extruder::setCapped",1,"Procedural::Extruder *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Extruder::setCapped",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Extruder,0))){
    SWIG_fail_ptr("Extruder_setCapped",1,SWIGTYPE_p_Procedural__Extruder);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Extruder *) &(arg1)->setCapped(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Extruder,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Extruder(void *obj) {
Procedural::Extruder *arg1 = (Procedural::Extruder *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Extruder_methods[] = {
    {"addToTriangleBuffer", _wrap_Extruder_addToTriangleBuffer}, 
    {"setShapeToExtrude", _wrap_Extruder_setShapeToExtrude}, 
    {"setMultiShapeToExtrude", _wrap_Extruder_setMultiShapeToExtrude}, 
    {"setExtrusionPath", _wrap_Extruder_setExtrusionPath}, 
    {"setRotationTrack", _wrap_Extruder_setRotationTrack}, 
    {"setScaleTrack", _wrap_Extruder_setScaleTrack}, 
    {"setShapeTextureTrack", _wrap_Extruder_setShapeTextureTrack}, 
    {"setPathTextureTrack", _wrap_Extruder_setPathTextureTrack}, 
    {"setCapped", _wrap_Extruder_setCapped}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Extruder_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Extruder_bases[] = {0,0};
static const char *swig_Procedural_Extruder_base_names[] = {"Procedural::MeshGenerator< Procedural::Extruder > *",0};
static swig_lua_class _wrap_class_Procedural_Extruder = { "Extruder", &SWIGTYPE_p_Procedural__Extruder,_wrap_new_Extruder, swig_delete_Extruder, swig_Procedural_Extruder_methods, swig_Procedural_Extruder_attributes, swig_Procedural_Extruder_bases, swig_Procedural_Extruder_base_names };

static int _wrap_new_Lathe__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Shape *arg1 = (Shape *) 0 ;
  unsigned int arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::Lathe",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::Lathe",1,"Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Lathe::Lathe",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Shape,0))){
    SWIG_fail_ptr("new_Lathe",1,SWIGTYPE_p_Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::Lathe *)new Procedural::Lathe(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Lathe__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Shape *arg1 = (Shape *) 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::Lathe",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::Lathe",1,"Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Shape,0))){
    SWIG_fail_ptr("new_Lathe",1,SWIGTYPE_p_Shape);
  }
  
  result = (Procedural::Lathe *)new Procedural::Lathe(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Lathe__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::Lathe",0,0)
  result = (Procedural::Lathe *)new Procedural::Lathe();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Lathe(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Lathe__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Lathe__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Lathe__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Lathe'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Lathe::Lathe(Shape *,unsigned int)\n"
    "    Procedural::Lathe::Lathe(Shape *)\n"
    "    Procedural::Lathe::Lathe()\n");
  lua_error(L);return 0;
}


static int _wrap_Lathe_setNumSeg(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  unsigned int arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setNumSeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setNumSeg",1,"Procedural::Lathe *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Lathe::setNumSeg",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setNumSeg",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::Lathe *) &(arg1)->setNumSeg(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setAngleBegin(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setAngleBegin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setAngleBegin",1,"Procedural::Lathe *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Lathe::setAngleBegin",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setAngleBegin",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Lathe_setAngleBegin",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::Lathe *) &(arg1)->setAngleBegin(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setAngleEnd(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setAngleEnd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setAngleEnd",1,"Procedural::Lathe *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Lathe::setAngleEnd",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setAngleEnd",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Lathe_setAngleEnd",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::Lathe *) &(arg1)->setAngleEnd(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setClosed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  bool arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setClosed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setClosed",1,"Procedural::Lathe *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Lathe::setClosed",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setClosed",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Lathe *) &(arg1)->setClosed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setCapped(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  bool arg2 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setCapped",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setCapped",1,"Procedural::Lathe *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Lathe::setCapped",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setCapped",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Lathe *) &(arg1)->setCapped(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setShapeToExtrude(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  Shape *arg2 = (Shape *) 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setShapeToExtrude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setShapeToExtrude",1,"Procedural::Lathe *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Lathe::setShapeToExtrude",2,"Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setShapeToExtrude",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Shape,0))){
    SWIG_fail_ptr("Lathe_setShapeToExtrude",2,SWIGTYPE_p_Shape);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setShapeToExtrude(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_setMultiShapeToExtrude(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  MultiShape *arg2 = (MultiShape *) 0 ;
  Procedural::Lathe *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::setMultiShapeToExtrude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::setMultiShapeToExtrude",1,"Procedural::Lathe *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Lathe::setMultiShapeToExtrude",2,"MultiShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_setMultiShapeToExtrude",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MultiShape,0))){
    SWIG_fail_ptr("Lathe_setMultiShapeToExtrude",2,SWIGTYPE_p_MultiShape);
  }
  
  result = (Procedural::Lathe *) &(arg1)->setMultiShapeToExtrude(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lathe,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lathe_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lathe *arg1 = (Procedural::Lathe *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::Lathe::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lathe::addToTriangleBuffer",1,"Procedural::Lathe const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Lathe::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lathe,0))){
    SWIG_fail_ptr("Lathe_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__Lathe);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Lathe_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::Lathe const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Lathe(void *obj) {
Procedural::Lathe *arg1 = (Procedural::Lathe *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Lathe_methods[] = {
    {"setNumSeg", _wrap_Lathe_setNumSeg}, 
    {"setAngleBegin", _wrap_Lathe_setAngleBegin}, 
    {"setAngleEnd", _wrap_Lathe_setAngleEnd}, 
    {"setClosed", _wrap_Lathe_setClosed}, 
    {"setCapped", _wrap_Lathe_setCapped}, 
    {"setShapeToExtrude", _wrap_Lathe_setShapeToExtrude}, 
    {"setMultiShapeToExtrude", _wrap_Lathe_setMultiShapeToExtrude}, 
    {"addToTriangleBuffer", _wrap_Lathe_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Lathe_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Lathe_bases[] = {0,0};
static const char *swig_Procedural_Lathe_base_names[] = {"Procedural::MeshGenerator< Procedural::Lathe > *",0};
static swig_lua_class _wrap_class_Procedural_Lathe = { "Lathe", &SWIGTYPE_p_Procedural__Lathe,_wrap_new_Lathe, swig_delete_Lathe, swig_Procedural_Lathe_methods, swig_Procedural_Lathe_attributes, swig_Procedural_Lathe_bases, swig_Procedural_Lathe_base_names };

static int _wrap_new_Shape__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::Shape",0,0)
  result = (Procedural::Shape *)new Procedural::Shape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::addPoint",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::addPoint",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_addPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_addPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->addPoint((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::addPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::addPoint",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::addPoint",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_addPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Shape *) &(arg1)->addPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_addPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_addPoint__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::addPoint(Ogre::Vector2 const &)\n"
    "    Procedural::Shape::addPoint(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_insertPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  size_t arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::insertPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::insertPoint",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::insertPoint",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::insertPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Shape::insertPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_insertPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Shape *) &(arg1)->insertPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_insertPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  size_t arg2 ;
  Ogre::Vector2 *arg3 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::insertPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::insertPoint",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::insertPoint",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Shape::insertPoint",3,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_insertPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_insertPoint",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->insertPoint(arg2,(Ogre::Vector2 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_insertPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Shape_insertPoint__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Shape_insertPoint__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_insertPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::insertPoint(size_t,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Shape::insertPoint(size_t,Ogre::Vector2 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_addPointRel__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::addPointRel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::addPointRel",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::addPointRel",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_addPointRel",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_addPointRel",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->addPointRel((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_addPointRel__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::addPointRel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::addPointRel",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::addPointRel",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::addPointRel",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_addPointRel",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Shape *) &(arg1)->addPointRel(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_addPointRel(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_addPointRel__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_addPointRel__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_addPointRel'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::addPointRel(Ogre::Vector2 const &)\n"
    "    Procedural::Shape::addPointRel(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_appendShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::appendShape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::appendShape",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::appendShape",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_appendShape",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_appendShape",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->appendShape((Procedural::Shape const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_appendShapeRel(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::appendShapeRel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::appendShapeRel",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::appendShapeRel",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_appendShapeRel",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_appendShapeRel",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->appendShapeRel((Procedural::Shape const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_extractSubShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  Procedural::Shape result;
  
  SWIG_check_num_args("Procedural::Shape::extractSubShape",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::extractSubShape",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::extractSubShape",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::extractSubShape",3,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_extractSubShape",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (arg1)->extractSubShape(arg2,arg3);
  {
    Procedural::Shape * resultptr = new Procedural::Shape((const Procedural::Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_reverse(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::reverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::reverse",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_reverse",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->reverse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_reset(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::reset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::reset",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_reset",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->reset();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_convertToPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Path result;
  
  SWIG_check_num_args("Procedural::Shape::convertToPath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::convertToPath",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_convertToPath",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->convertToPath();
  {
    Procedural::Path * resultptr = new Procedural::Path((const Procedural::Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_convertToTrack__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Track::AddressingMode arg2 ;
  Track::AddressingMode *argp2 ;
  Track result;
  
  SWIG_check_num_args("Procedural::Shape::convertToTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::convertToTrack",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::convertToTrack",2,"Track::AddressingMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_convertToTrack",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Track__AddressingMode,0))){
    SWIG_fail_ptr("Shape_convertToTrack",2,SWIGTYPE_p_Track__AddressingMode);
  }
  arg2 = *argp2;
  
  result = ((Procedural::Shape const *)arg1)->convertToTrack(arg2);
  {
    Track * resultptr = new Track((const Track &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Track,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_convertToTrack__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Track result;
  
  SWIG_check_num_args("Procedural::Shape::convertToTrack",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::convertToTrack",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_convertToTrack",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->convertToTrack();
  {
    Track * resultptr = new Track((const Track &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Track,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_convertToTrack(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Shape_convertToTrack__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Track__AddressingMode, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_convertToTrack__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_convertToTrack'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::convertToTrack(Track::AddressingMode) const\n"
    "    Procedural::Shape::convertToTrack() const\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_getPoints(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  SwigValueWrapper< std::vector< Ogre::Vector2 > > result;
  
  SWIG_check_num_args("Procedural::Shape::getPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPoints",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPoints",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->getPoints();
  {
    std::vector< Ogre::Vector2 > * resultptr = new std::vector< Ogre::Vector2 >((const std::vector< Ogre::Vector2 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPointsReference__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  std::vector< Ogre::Vector2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::getPointsReference",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPointsReference",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPointsReference",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (std::vector< Ogre::Vector2 > *) &(arg1)->getPointsReference();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPointsReference__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  std::vector< Ogre::Vector2 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::getPointsReference",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPointsReference",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPointsReference",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (std::vector< Ogre::Vector2 > *) &((Procedural::Shape const *)arg1)->getPointsReference();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPointsReference(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Shape_getPointsReference__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Shape_getPointsReference__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_getPointsReference'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::getPointsReference()\n"
    "    Procedural::Shape::getPointsReference() const\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_getPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  int arg2 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::getPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPoint",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getPoint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Ogre::Vector2 *) &((Procedural::Shape const *)arg1)->getPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getBoundedIndex(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  int arg2 ;
  unsigned int result;
  
  SWIG_check_num_args("Procedural::Shape::getBoundedIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getBoundedIndex",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getBoundedIndex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getBoundedIndex",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (unsigned int)((Procedural::Shape const *)arg1)->getBoundedIndex(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPointCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  SwigValueWrapper< std::vector< Ogre::Vector2 >::size_type > result;
  
  SWIG_check_num_args("Procedural::Shape::getPointCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPointCount",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPointCount",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->getPointCount();
  {
    std::vector< Ogre::Vector2 >::size_type * resultptr = new std::vector< Ogre::Vector2 >::size_type((const std::vector< Ogre::Vector2 >::size_type &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t__size_type,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::close",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_close",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_setOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Side arg2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::setOutSide",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::setOutSide",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::setOutSide",2,"Procedural::Side");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_setOutSide",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Procedural::Side)(int)lua_tonumber(L, 2);
  result = (Procedural::Shape *) &(arg1)->setOutSide(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Side result;
  
  SWIG_check_num_args("Procedural::Shape::getOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getOutSide",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getOutSide",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Side)((Procedural::Shape const *)arg1)->getOutSide();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_switchSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::switchSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::switchSide",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_switchSide",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->switchSide();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getSegCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Procedural::Shape::getSegCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getSegCount",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getSegCount",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->getSegCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_isClosed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Shape::isClosed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::isClosed",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_isClosed",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (bool)((Procedural::Shape const *)arg1)->isClosed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getDirectionAfter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getDirectionAfter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getDirectionAfter",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getDirectionAfter",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getDirectionAfter",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getDirectionAfter(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getDirectionBefore(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getDirectionBefore",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getDirectionBefore",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getDirectionBefore",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getDirectionBefore",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getDirectionBefore(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getAvgDirection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getAvgDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getAvgDirection",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getAvgDirection",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getAvgDirection",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getAvgDirection(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getNormalAfter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getNormalAfter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getNormalAfter",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getNormalAfter",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getNormalAfter",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getNormalAfter(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getNormalBefore(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getNormalBefore",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getNormalBefore",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getNormalBefore",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getNormalBefore",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getNormalBefore(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getAvgNormal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getAvgNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getAvgNormal",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getAvgNormal",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getAvgNormal",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getAvgNormal(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::Shape::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::realizeMesh",1,"Procedural::Shape const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::Shape::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_realizeMesh",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = ((Procedural::Shape const *)arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::Shape::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::realizeMesh",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_realizeMesh",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_realizeMesh(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Shape_realizeMesh__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Shape_realizeMesh__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::realizeMesh(std::string const &) const\n"
    "    Procedural::Shape::realizeMesh() const\n");
  lua_error(L);return 0;
}


static int _wrap_Shape__appendToManualObject(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::ManualObject *arg2 = (Ogre::ManualObject *) 0 ;
  
  SWIG_check_num_args("Procedural::Shape::_appendToManualObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::_appendToManualObject",1,"Procedural::Shape const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Shape::_appendToManualObject",2,"Ogre::ManualObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape__appendToManualObject",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__ManualObject,0))){
    SWIG_fail_ptr("Shape__appendToManualObject",2,SWIGTYPE_p_Ogre__ManualObject);
  }
  
  ((Procedural::Shape const *)arg1)->_appendToManualObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_isPointInside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Shape::isPointInside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::isPointInside",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::isPointInside",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_isPointInside",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_isPointInside",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::Shape const *)arg1)->isPointInside((Ogre::Vector2 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_booleanIntersect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  MultiShape result;
  
  SWIG_check_num_args("Procedural::Shape::booleanIntersect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::booleanIntersect",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::booleanIntersect",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanIntersect",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanIntersect",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->booleanIntersect((Procedural::Shape const &)*arg2);
  {
    MultiShape * resultptr = new MultiShape((const MultiShape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_MultiShape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_booleanUnion(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  MultiShape result;
  
  SWIG_check_num_args("Procedural::Shape::booleanUnion",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::booleanUnion",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::booleanUnion",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanUnion",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanUnion",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->booleanUnion((Procedural::Shape const &)*arg2);
  {
    MultiShape * resultptr = new MultiShape((const MultiShape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_MultiShape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_booleanDifference(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  MultiShape result;
  
  SWIG_check_num_args("Procedural::Shape::booleanDifference",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::booleanDifference",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::booleanDifference",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanDifference",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_booleanDifference",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = ((Procedural::Shape const *)arg1)->booleanDifference((Procedural::Shape const &)*arg2);
  {
    MultiShape * resultptr = new MultiShape((const MultiShape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_MultiShape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_findRealOutSide(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Side result;
  
  SWIG_check_num_args("Procedural::Shape::findRealOutSide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::findRealOutSide",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_findRealOutSide",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Side)((Procedural::Shape const *)arg1)->findRealOutSide();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_isOutsideRealOutside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Shape::isOutsideRealOutside",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::isOutsideRealOutside",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_isOutsideRealOutside",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (bool)((Procedural::Shape const *)arg1)->isOutsideRealOutside();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mergeKeysWithTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Track *arg2 = 0 ;
  Procedural::Shape result;
  
  SWIG_check_num_args("Procedural::Shape::mergeKeysWithTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mergeKeysWithTrack",1,"Procedural::Shape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::mergeKeysWithTrack",2,"Track const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mergeKeysWithTrack",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Shape_mergeKeysWithTrack",2,SWIGTYPE_p_Track);
  }
  
  result = ((Procedural::Shape const *)arg1)->mergeKeysWithTrack((Track const &)*arg2);
  {
    Procedural::Shape * resultptr = new Procedural::Shape((const Procedural::Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_translate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::translate",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::translate",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_translate",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_translate",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->translate((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_translate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::translate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::translate",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::translate",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::translate",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_translate",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Shape *) &(arg1)->translate(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_translate(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_translate__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_translate__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_translate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::translate(Ogre::Vector2 const &)\n"
    "    Procedural::Shape::translate(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_rotate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::rotate",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::rotate",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_rotate",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Shape_rotate",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::Shape *) &(arg1)->rotate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_scale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::scale",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::scale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_scale",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Shape *) &(arg1)->scale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_scale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::scale",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::scale",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::scale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::scale",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_scale",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Shape *) &(arg1)->scale(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_scale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::scale",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::scale",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_scale",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_scale",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->scale((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_scale(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_scale__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Shape_scale__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_scale__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_scale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::scale(Ogre::Real)\n"
    "    Procedural::Shape::scale(Ogre::Real,Ogre::Real)\n"
    "    Procedural::Shape::scale(Ogre::Vector2 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_reflect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::reflect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::reflect",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::reflect",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_reflect",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_reflect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->reflect((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirror__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  bool arg2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirror",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirror",1,"Procedural::Shape *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Shape::mirror",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirror",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Shape *) &(arg1)->mirror(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirror__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirror",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirror",1,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirror",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *) &(arg1)->mirror();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirror__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  bool arg4 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirror",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirror",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::mirror",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::mirror",3,"Ogre::Real");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::Shape::mirror",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirror",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::Shape *) &(arg1)->mirror(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirror__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirror",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::mirror",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::mirror",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirror",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Shape *) &(arg1)->mirror(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirror(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Shape_mirror__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Shape_mirror__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_mirror__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Shape_mirror__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_mirror'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::mirror(bool)\n"
    "    Procedural::Shape::mirror()\n"
    "    Procedural::Shape::mirror(Ogre::Real,Ogre::Real,bool)\n"
    "    Procedural::Shape::mirror(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_mirrorAroundPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 arg2 ;
  bool arg3 ;
  Ogre::Vector2 *argp2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirrorAroundPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirrorAroundPoint",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::mirrorAroundPoint",2,"Ogre::Vector2");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::Shape::mirrorAroundPoint",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirrorAroundPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_mirrorAroundPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::Shape *) &(arg1)->mirrorAroundPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirrorAroundPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirrorAroundPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirrorAroundPoint",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::mirrorAroundPoint",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirrorAroundPoint",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_mirrorAroundPoint",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::Shape *) &(arg1)->mirrorAroundPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirrorAroundPoint(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_mirrorAroundPoint__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_mirrorAroundPoint__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_mirrorAroundPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::mirrorAroundPoint(Ogre::Vector2,bool)\n"
    "    Procedural::Shape::mirrorAroundPoint(Ogre::Vector2)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_mirrorAroundAxis__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool arg3 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirrorAroundAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirrorAroundAxis",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::mirrorAroundAxis",2,"Ogre::Vector2 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::Shape::mirrorAroundAxis",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirrorAroundAxis",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_mirrorAroundAxis",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::Shape *) &(arg1)->mirrorAroundAxis((Ogre::Vector2 const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirrorAroundAxis__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::mirrorAroundAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::mirrorAroundAxis",1,"Procedural::Shape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Shape::mirrorAroundAxis",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_mirrorAroundAxis",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Shape_mirrorAroundAxis",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Shape *) &(arg1)->mirrorAroundAxis((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_mirrorAroundAxis(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Shape_mirrorAroundAxis__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_mirrorAroundAxis__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_mirrorAroundAxis'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::mirrorAroundAxis(Ogre::Vector2 const &,bool)\n"
    "    Procedural::Shape::mirrorAroundAxis(Ogre::Vector2 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_getTotalLength(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Shape::getTotalLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getTotalLength",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getTotalLength",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Ogre::Real)((Procedural::Shape const *)arg1)->getTotalLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  unsigned int arg2 ;
  Ogre::Real arg3 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPosition",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getPosition",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Shape::getPosition",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPosition",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = ((Procedural::Shape const *)arg1)->getPosition(arg2,arg3);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 result;
  
  SWIG_check_num_args("Procedural::Shape::getPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::getPosition",1,"Procedural::Shape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::getPosition",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_getPosition",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Procedural::Shape const *)arg1)->getPosition(arg2);
  {
    Ogre::Vector2 * resultptr = new Ogre::Vector2((const Ogre::Vector2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector2,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_getPosition(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Shape_getPosition__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Shape_getPosition__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Shape_getPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::getPosition(unsigned int,Ogre::Real) const\n"
    "    Procedural::Shape::getPosition(Ogre::Real) const\n");
  lua_error(L);return 0;
}


static int _wrap_Shape_findBoundingRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Shape::findBoundingRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::findBoundingRadius",1,"Procedural::Shape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_findBoundingRadius",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Ogre::Real)((Procedural::Shape const *)arg1)->findBoundingRadius();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Shape_thicken(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = (Procedural::Shape *) 0 ;
  Ogre::Real arg2 ;
  MultiShape result;
  
  SWIG_check_num_args("Procedural::Shape::thicken",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Shape::thicken",1,"Procedural::Shape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Shape::thicken",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Shape_thicken",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (arg1)->thicken(arg2);
  {
    MultiShape * resultptr = new MultiShape((const MultiShape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_MultiShape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Shape__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = 0 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::Shape::Shape",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Shape::Shape",1,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("new_Shape",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Shape *)new Procedural::Shape((Procedural::Shape const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Shape(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Shape__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Shape__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Shape'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Shape::Shape()\n"
    "    Procedural::Shape::Shape(Procedural::Shape const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_Shape(void *obj) {
Procedural::Shape *arg1 = (Procedural::Shape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Shape_methods[] = {
    {"addPoint", _wrap_Shape_addPoint}, 
    {"insertPoint", _wrap_Shape_insertPoint}, 
    {"addPointRel", _wrap_Shape_addPointRel}, 
    {"appendShape", _wrap_Shape_appendShape}, 
    {"appendShapeRel", _wrap_Shape_appendShapeRel}, 
    {"extractSubShape", _wrap_Shape_extractSubShape}, 
    {"reverse", _wrap_Shape_reverse}, 
    {"reset", _wrap_Shape_reset}, 
    {"convertToPath", _wrap_Shape_convertToPath}, 
    {"convertToTrack", _wrap_Shape_convertToTrack}, 
    {"getPoints", _wrap_Shape_getPoints}, 
    {"getPointsReference", _wrap_Shape_getPointsReference}, 
    {"getPoint", _wrap_Shape_getPoint}, 
    {"getBoundedIndex", _wrap_Shape_getBoundedIndex}, 
    {"getPointCount", _wrap_Shape_getPointCount}, 
    {"close", _wrap_Shape_close}, 
    {"setOutSide", _wrap_Shape_setOutSide}, 
    {"getOutSide", _wrap_Shape_getOutSide}, 
    {"switchSide", _wrap_Shape_switchSide}, 
    {"getSegCount", _wrap_Shape_getSegCount}, 
    {"isClosed", _wrap_Shape_isClosed}, 
    {"getDirectionAfter", _wrap_Shape_getDirectionAfter}, 
    {"getDirectionBefore", _wrap_Shape_getDirectionBefore}, 
    {"getAvgDirection", _wrap_Shape_getAvgDirection}, 
    {"getNormalAfter", _wrap_Shape_getNormalAfter}, 
    {"getNormalBefore", _wrap_Shape_getNormalBefore}, 
    {"getAvgNormal", _wrap_Shape_getAvgNormal}, 
    {"realizeMesh", _wrap_Shape_realizeMesh}, 
    {"_appendToManualObject", _wrap_Shape__appendToManualObject}, 
    {"isPointInside", _wrap_Shape_isPointInside}, 
    {"booleanIntersect", _wrap_Shape_booleanIntersect}, 
    {"booleanUnion", _wrap_Shape_booleanUnion}, 
    {"booleanDifference", _wrap_Shape_booleanDifference}, 
    {"findRealOutSide", _wrap_Shape_findRealOutSide}, 
    {"isOutsideRealOutside", _wrap_Shape_isOutsideRealOutside}, 
    {"mergeKeysWithTrack", _wrap_Shape_mergeKeysWithTrack}, 
    {"translate", _wrap_Shape_translate}, 
    {"rotate", _wrap_Shape_rotate}, 
    {"scale", _wrap_Shape_scale}, 
    {"reflect", _wrap_Shape_reflect}, 
    {"mirror", _wrap_Shape_mirror}, 
    {"mirrorAroundPoint", _wrap_Shape_mirrorAroundPoint}, 
    {"mirrorAroundAxis", _wrap_Shape_mirrorAroundAxis}, 
    {"getTotalLength", _wrap_Shape_getTotalLength}, 
    {"getPosition", _wrap_Shape_getPosition}, 
    {"findBoundingRadius", _wrap_Shape_findBoundingRadius}, 
    {"thicken", _wrap_Shape_thicken}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Shape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Shape_bases[] = {0};
static const char *swig_Procedural_Shape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Shape = { "Shape", &SWIGTYPE_p_Procedural__Shape,_wrap_new_Shape, swig_delete_Shape, swig_Procedural_Shape_methods, swig_Procedural_Shape_attributes, swig_Procedural_Shape_bases, swig_Procedural_Shape_base_names };

static int _wrap_new_MultiShape__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::MultiShape",0,0)
  result = (Procedural::MultiShape *)new Procedural::MultiShape();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__MultiShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MultiShape__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Shape *arg1 = 0 ;
  Procedural::MultiShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::MultiShape",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::MultiShape::MultiShape",1,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("new_MultiShape",1,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::MultiShape *)new Procedural::MultiShape((Procedural::Shape const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__MultiShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MultiShape__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  void *arg2 = 0 ;
  Procedural::MultiShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::MultiShape",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::MultiShape::MultiShape",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (Procedural::MultiShape *)new Procedural::MultiShape(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__MultiShape,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MultiShape(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_MultiShape__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Shape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_MultiShape__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_MultiShape__SWIG_2(L);
      }
      return _wrap_new_MultiShape__SWIG_2(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_MultiShape'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MultiShape::MultiShape()\n"
    "    Procedural::MultiShape::MultiShape(Procedural::Shape const &)\n"
    "    Procedural::MultiShape::MultiShape(int,...)\n");
  lua_error(L);return 0;
}


static int _wrap_MultiShape_addShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  Procedural::Shape *arg2 = 0 ;
  Procedural::MultiShape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::addShape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::addShape",1,"Procedural::MultiShape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MultiShape::addShape",2,"Procedural::Shape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_addShape",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("MultiShape_addShape",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::MultiShape *) &(arg1)->addShape((Procedural::Shape const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__MultiShape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_getShape__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  unsigned int arg2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::getShape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::getShape",1,"Procedural::MultiShape const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MultiShape::getShape",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_getShape",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::Shape *) &((Procedural::MultiShape const *)arg1)->getShape(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_getShape__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  unsigned int arg2 ;
  Procedural::Shape *result = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::getShape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::getShape",1,"Procedural::MultiShape *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::MultiShape::getShape",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_getShape",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::Shape *) &(arg1)->getShape(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Shape,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_getShape(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_MultiShape_getShape__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_MultiShape_getShape__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'MultiShape_getShape'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MultiShape::getShape(unsigned int) const\n"
    "    Procedural::MultiShape::getShape(unsigned int)\n");
  lua_error(L);return 0;
}


static int _wrap_MultiShape_getPoints(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  SwigValueWrapper< std::vector< Ogre::Vector2 > > result;
  
  SWIG_check_num_args("Procedural::MultiShape::getPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::getPoints",1,"Procedural::MultiShape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_getPoints",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = ((Procedural::MultiShape const *)arg1)->getPoints();
  {
    std::vector< Ogre::Vector2 > * resultptr = new std::vector< Ogre::Vector2 >((const std::vector< Ogre::Vector2 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_getShapeCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("Procedural::MultiShape::getShapeCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::getShapeCount",1,"Procedural::MultiShape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_getShapeCount",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = (unsigned int)((Procedural::MultiShape const *)arg1)->getShapeCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_addMultiShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  Procedural::MultiShape *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::addMultiShape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::addMultiShape",1,"Procedural::MultiShape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MultiShape::addMultiShape",2,"Procedural::MultiShape const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_addMultiShape",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_addMultiShape",2,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  (arg1)->addMultiShape((Procedural::MultiShape const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MultiShape::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::realizeMesh",1,"Procedural::MultiShape *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::MultiShape::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_realizeMesh",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::MultiShape::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::realizeMesh",1,"Procedural::MultiShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_realizeMesh",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = (arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_realizeMesh(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_MultiShape_realizeMesh__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_MultiShape_realizeMesh__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'MultiShape_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::MultiShape::realizeMesh(std::string const &)\n"
    "    Procedural::MultiShape::realizeMesh()\n");
  lua_error(L);return 0;
}


static int _wrap_MultiShape_isPointInside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::MultiShape::isPointInside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::isPointInside",1,"Procedural::MultiShape const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MultiShape::isPointInside",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_isPointInside",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("MultiShape_isPointInside",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::MultiShape const *)arg1)->isPointInside((Ogre::Vector2 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_isClosed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::MultiShape::isClosed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::isClosed",1,"Procedural::MultiShape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_isClosed",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = (bool)((Procedural::MultiShape const *)arg1)->isClosed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::close",1,"Procedural::MultiShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_close",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  (arg1)->close();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_isOutsideRealOutside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::MultiShape::isOutsideRealOutside",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::isOutsideRealOutside",1,"Procedural::MultiShape const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_isOutsideRealOutside",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = (bool)((Procedural::MultiShape const *)arg1)->isOutsideRealOutside();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MultiShape_buildFromSegmentSoup(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::MultiShape *arg1 = (Procedural::MultiShape *) 0 ;
  std::vector< Segment2D > *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::MultiShape::buildFromSegmentSoup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::MultiShape::buildFromSegmentSoup",1,"Procedural::MultiShape *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::MultiShape::buildFromSegmentSoup",2,"std::vector< Segment2D > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("MultiShape_buildFromSegmentSoup",1,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_Segment2D_t,0))){
    SWIG_fail_ptr("MultiShape_buildFromSegmentSoup",2,SWIGTYPE_p_std__vectorT_Segment2D_t);
  }
  
  (arg1)->buildFromSegmentSoup((std::vector< Segment2D > const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MultiShape(void *obj) {
Procedural::MultiShape *arg1 = (Procedural::MultiShape *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_MultiShape_methods[] = {
    {"addShape", _wrap_MultiShape_addShape}, 
    {"getShape", _wrap_MultiShape_getShape}, 
    {"getPoints", _wrap_MultiShape_getPoints}, 
    {"getShapeCount", _wrap_MultiShape_getShapeCount}, 
    {"addMultiShape", _wrap_MultiShape_addMultiShape}, 
    {"realizeMesh", _wrap_MultiShape_realizeMesh}, 
    {"isPointInside", _wrap_MultiShape_isPointInside}, 
    {"isClosed", _wrap_MultiShape_isClosed}, 
    {"close", _wrap_MultiShape_close}, 
    {"isOutsideRealOutside", _wrap_MultiShape_isOutsideRealOutside}, 
    {"buildFromSegmentSoup", _wrap_MultiShape_buildFromSegmentSoup}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_MultiShape_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_MultiShape_bases[] = {0};
static const char *swig_Procedural_MultiShape_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_MultiShape = { "MultiShape", &SWIGTYPE_p_Procedural__MultiShape,_wrap_new_MultiShape, swig_delete_MultiShape, swig_Procedural_MultiShape_methods, swig_Procedural_MultiShape_attributes, swig_Procedural_MultiShape_bases, swig_Procedural_MultiShape_base_names };

static int _wrap_new_Path__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::Path",0,0)
  result = (Procedural::Path *)new Procedural::Path();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_addPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::addPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::addPoint",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::addPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_addPoint",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Path_addPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Path *) &(arg1)->addPoint((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_addPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::addPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::addPoint",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::addPoint",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::addPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Path::addPoint",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_addPoint",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Path *) &(arg1)->addPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_addPoint(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Path_addPoint__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Path_addPoint__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_addPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::addPoint(Ogre::Vector3 const &)\n"
    "    Procedural::Path::addPoint(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Path_insertPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  size_t arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::insertPoint",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::insertPoint",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::insertPoint",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::insertPoint",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Path::insertPoint",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Path::insertPoint",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_insertPoint",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Path *) &(arg1)->insertPoint(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_insertPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  size_t arg2 ;
  Ogre::Vector3 *arg3 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::insertPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::insertPoint",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::insertPoint",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Path::insertPoint",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_insertPoint",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Path_insertPoint",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Path *) &(arg1)->insertPoint(arg2,(Ogre::Vector3 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_insertPoint(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Path_insertPoint__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Path_insertPoint__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_insertPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::insertPoint(size_t,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Path::insertPoint(size_t,Ogre::Vector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Path_appendPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Path *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::appendPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::appendPath",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::appendPath",2,"Procedural::Path const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_appendPath",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_appendPath",2,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *) &(arg1)->appendPath((Procedural::Path const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_appendPathRel(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Path *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::appendPathRel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::appendPathRel",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::appendPathRel",2,"Procedural::Path const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_appendPathRel",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_appendPathRel",2,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *) &(arg1)->appendPathRel((Procedural::Path const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_reset(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::reset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::reset",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_reset",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *) &(arg1)->reset();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_close(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::close",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_close",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *) &(arg1)->close();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_isClosed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Path::isClosed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::isClosed",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_isClosed",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (bool)(arg1)->isClosed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPoints(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  SwigValueWrapper< std::vector< Ogre::Vector3 > > result;
  
  SWIG_check_num_args("Procedural::Path::getPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getPoints",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getPoints",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (arg1)->getPoints();
  {
    std::vector< Ogre::Vector3 > * resultptr = new std::vector< Ogre::Vector3 >((const std::vector< Ogre::Vector3 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_Ogre__Vector3_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPointsReference(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  std::vector< Ogre::Vector3 > *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::getPointsReference",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getPointsReference",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getPointsReference",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (std::vector< Ogre::Vector3 > *) &(arg1)->getPointsReference();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Ogre__Vector3_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  int arg2 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::getPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getPoint",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getPoint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getPoint",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Ogre::Vector3 *) &((Procedural::Path const *)arg1)->getPoint(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getSegCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  int result;
  
  SWIG_check_num_args("Procedural::Path::getSegCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getSegCount",1,"Procedural::Path const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getSegCount",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (int)((Procedural::Path const *)arg1)->getSegCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getDirectionAfter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Path::getDirectionAfter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getDirectionAfter",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getDirectionAfter",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getDirectionAfter",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Path const *)arg1)->getDirectionAfter(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getDirectionBefore(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Path::getDirectionBefore",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getDirectionBefore",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getDirectionBefore",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getDirectionBefore",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Path const *)arg1)->getDirectionBefore(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getAvgDirection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  unsigned int arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Path::getAvgDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getAvgDirection",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getAvgDirection",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getAvgDirection",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((Procedural::Path const *)arg1)->getAvgDirection(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getTotalLength(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Path::getTotalLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getTotalLength",1,"Procedural::Path const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getTotalLength",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Ogre::Real)((Procedural::Path const *)arg1)->getTotalLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  unsigned int arg2 ;
  Ogre::Real arg3 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Path::getPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getPosition",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getPosition",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::getPosition",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getPosition",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = ((Procedural::Path const *)arg1)->getPosition(arg2,arg3);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Path::getPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::getPosition",1,"Procedural::Path const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::getPosition",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_getPosition",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Procedural::Path const *)arg1)->getPosition(arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_getPosition(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Path_getPosition__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Path_getPosition__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_getPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::getPosition(unsigned int,Ogre::Real) const\n"
    "    Procedural::Path::getPosition(Ogre::Real) const\n");
  lua_error(L);return 0;
}


static int _wrap_Path_realizeMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::Path::realizeMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::realizeMesh",1,"Procedural::Path const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::Path::realizeMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_realizeMesh",1,SWIGTYPE_p_Procedural__Path);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = ((Procedural::Path const *)arg1)->realizeMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_realizeMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::Path::realizeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::realizeMesh",1,"Procedural::Path const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_realizeMesh",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = ((Procedural::Path const *)arg1)->realizeMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_realizeMesh(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Path_realizeMesh__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Path_realizeMesh__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_realizeMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::realizeMesh(std::string const &) const\n"
    "    Procedural::Path::realizeMesh() const\n");
  lua_error(L);return 0;
}


static int _wrap_Path_mergeKeysWithTrack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Track *arg2 = 0 ;
  Procedural::Path result;
  
  SWIG_check_num_args("Procedural::Path::mergeKeysWithTrack",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::mergeKeysWithTrack",1,"Procedural::Path const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::mergeKeysWithTrack",2,"Track const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_mergeKeysWithTrack",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Track,0))){
    SWIG_fail_ptr("Path_mergeKeysWithTrack",2,SWIGTYPE_p_Track);
  }
  
  result = ((Procedural::Path const *)arg1)->mergeKeysWithTrack((Track const &)*arg2);
  {
    Procedural::Path * resultptr = new Procedural::Path((const Procedural::Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_translate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::translate",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::translate",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_translate",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Path_translate",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Path *) &(arg1)->translate((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_translate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::translate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::translate",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::translate",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::translate",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Path::translate",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_translate",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Path *) &(arg1)->translate(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_translate(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Path_translate__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Path_translate__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_translate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::translate(Ogre::Vector3 const &)\n"
    "    Procedural::Path::translate(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Path_scale__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::scale",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::scale",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_scale",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Path *) &(arg1)->scale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_scale__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::scale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::scale",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::scale",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::scale",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Path::scale",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_scale",1,SWIGTYPE_p_Procedural__Path);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Path *) &(arg1)->scale(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_scale__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::scale",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::scale",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_scale",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Path_scale",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Path *) &(arg1)->scale((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_scale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Path_scale__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Path_scale__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Path_scale__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Path_scale'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::scale(Ogre::Real)\n"
    "    Procedural::Path::scale(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Path::scale(Ogre::Vector3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_Path_reflect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::reflect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::reflect",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::reflect",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_reflect",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Path_reflect",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Path *) &(arg1)->reflect((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_extractSubPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  Procedural::Path result;
  
  SWIG_check_num_args("Procedural::Path::extractSubPath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::extractSubPath",1,"Procedural::Path *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Path::extractSubPath",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Path::extractSubPath",3,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_extractSubPath",1,SWIGTYPE_p_Procedural__Path);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (unsigned int)lua_tonumber(L, 3);
  result = (arg1)->extractSubPath(arg2,arg3);
  {
    Procedural::Path * resultptr = new Procedural::Path((const Procedural::Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_reverse(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::reverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::reverse",1,"Procedural::Path *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_reverse",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *) &(arg1)->reverse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_buildFromSegmentSoup(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  std::vector< Segment3D > *arg2 = 0 ;
  std::vector< Procedural::Path > *arg3 = 0 ;
  
  SWIG_check_num_args("Procedural::Path::buildFromSegmentSoup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::buildFromSegmentSoup",1,"Procedural::Path *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Path::buildFromSegmentSoup",2,"std::vector< Segment3D > const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Path::buildFromSegmentSoup",3,"std::vector< Procedural::Path > &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_buildFromSegmentSoup",1,SWIGTYPE_p_Procedural__Path);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_Segment3D_t,0))){
    SWIG_fail_ptr("Path_buildFromSegmentSoup",2,SWIGTYPE_p_std__vectorT_Segment3D_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_std__vectorT_Procedural__Path_t,0))){
    SWIG_fail_ptr("Path_buildFromSegmentSoup",3,SWIGTYPE_p_std__vectorT_Procedural__Path_t);
  }
  
  (arg1)->buildFromSegmentSoup((std::vector< Segment3D > const &)*arg2,*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Path_convertToShape(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = (Procedural::Path *) 0 ;
  Procedural::Shape result;
  
  SWIG_check_num_args("Procedural::Path::convertToShape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Path::convertToShape",1,"Procedural::Path const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("Path_convertToShape",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = ((Procedural::Path const *)arg1)->convertToShape();
  {
    Procedural::Shape * resultptr = new Procedural::Shape((const Procedural::Shape &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Shape,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Path__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Path *arg1 = 0 ;
  Procedural::Path *result = 0 ;
  
  SWIG_check_num_args("Procedural::Path::Path",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Path::Path",1,"Procedural::Path const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Path,0))){
    SWIG_fail_ptr("new_Path",1,SWIGTYPE_p_Procedural__Path);
  }
  
  result = (Procedural::Path *)new Procedural::Path((Procedural::Path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Path(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Path__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Path, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Path__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Path'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Path::Path()\n"
    "    Procedural::Path::Path(Procedural::Path const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_Path(void *obj) {
Procedural::Path *arg1 = (Procedural::Path *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Path_methods[] = {
    {"addPoint", _wrap_Path_addPoint}, 
    {"insertPoint", _wrap_Path_insertPoint}, 
    {"appendPath", _wrap_Path_appendPath}, 
    {"appendPathRel", _wrap_Path_appendPathRel}, 
    {"reset", _wrap_Path_reset}, 
    {"close", _wrap_Path_close}, 
    {"isClosed", _wrap_Path_isClosed}, 
    {"getPoints", _wrap_Path_getPoints}, 
    {"getPointsReference", _wrap_Path_getPointsReference}, 
    {"getPoint", _wrap_Path_getPoint}, 
    {"getSegCount", _wrap_Path_getSegCount}, 
    {"getDirectionAfter", _wrap_Path_getDirectionAfter}, 
    {"getDirectionBefore", _wrap_Path_getDirectionBefore}, 
    {"getAvgDirection", _wrap_Path_getAvgDirection}, 
    {"getTotalLength", _wrap_Path_getTotalLength}, 
    {"getPosition", _wrap_Path_getPosition}, 
    {"realizeMesh", _wrap_Path_realizeMesh}, 
    {"mergeKeysWithTrack", _wrap_Path_mergeKeysWithTrack}, 
    {"translate", _wrap_Path_translate}, 
    {"scale", _wrap_Path_scale}, 
    {"reflect", _wrap_Path_reflect}, 
    {"extractSubPath", _wrap_Path_extractSubPath}, 
    {"reverse", _wrap_Path_reverse}, 
    {"buildFromSegmentSoup", _wrap_Path_buildFromSegmentSoup}, 
    {"convertToShape", _wrap_Path_convertToShape}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Path_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Path_bases[] = {0};
static const char *swig_Procedural_Path_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Path = { "Path", &SWIGTYPE_p_Procedural__Path,_wrap_new_Path, swig_delete_Path, swig_Procedural_Path_methods, swig_Procedural_Path_attributes, swig_Procedural_Path_bases, swig_Procedural_Path_base_names };

static int _wrap_new_Triangulator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::Triangulator",0,0)
  result = (Procedural::Triangulator *)new Procedural::Triangulator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_setShapeToTriangulate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  Procedural::Shape *arg2 = (Procedural::Shape *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::setShapeToTriangulate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::setShapeToTriangulate",1,"Procedural::Triangulator *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangulator::setShapeToTriangulate",2,"Procedural::Shape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_setShapeToTriangulate",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Shape,0))){
    SWIG_fail_ptr("Triangulator_setShapeToTriangulate",2,SWIGTYPE_p_Procedural__Shape);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setShapeToTriangulate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_setMultiShapeToTriangulate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  Procedural::MultiShape *arg2 = (Procedural::MultiShape *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::setMultiShapeToTriangulate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::setMultiShapeToTriangulate",1,"Procedural::Triangulator *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangulator::setMultiShapeToTriangulate",2,"Procedural::MultiShape *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_setMultiShapeToTriangulate",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("Triangulator_setMultiShapeToTriangulate",2,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setMultiShapeToTriangulate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_setSegmentListToTriangulate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  std::vector< Segment2D > *arg2 = (std::vector< Segment2D > *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::setSegmentListToTriangulate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::setSegmentListToTriangulate",1,"Procedural::Triangulator *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangulator::setSegmentListToTriangulate",2,"std::vector< Segment2D > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_setSegmentListToTriangulate",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_Segment2D_t,0))){
    SWIG_fail_ptr("Triangulator_setSegmentListToTriangulate",2,SWIGTYPE_p_std__vectorT_Segment2D_t);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setSegmentListToTriangulate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_setManualSuperTriangle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  Procedural::Triangle2D *arg2 = (Procedural::Triangle2D *) 0 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::setManualSuperTriangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::setManualSuperTriangle",1,"Procedural::Triangulator *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangulator::setManualSuperTriangle",2,"Procedural::Triangle2D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_setManualSuperTriangle",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Triangle2D,0))){
    SWIG_fail_ptr("Triangulator_setManualSuperTriangle",2,SWIGTYPE_p_Procedural__Triangle2D);
  }
  
  result = (Procedural::Triangulator *) &(arg1)->setManualSuperTriangle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_setRemoveOutside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  bool arg2 ;
  Procedural::Triangulator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::setRemoveOutside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::setRemoveOutside",1,"Procedural::Triangulator *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Triangulator::setRemoveOutside",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_setRemoveOutside",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Triangulator *) &(arg1)->setRemoveOutside(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangulator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_triangulate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  std::vector< int > *arg2 = 0 ;
  Procedural::PointList *arg3 = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::triangulate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::triangulate",1,"Procedural::Triangulator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Triangulator::triangulate",2,"std::vector< int > &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Triangulator::triangulate",3,"Procedural::PointList &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_triangulate",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("Triangulator_triangulate",2,SWIGTYPE_p_std__vectorT_int_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t,0))){
    SWIG_fail_ptr("Triangulator_triangulate",3,SWIGTYPE_p_std__vectorT_Ogre__Vector2_t);
  }
  
  ((Procedural::Triangulator const *)arg1)->triangulate(*arg2,*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangulator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangulator *arg1 = (Procedural::Triangulator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::Triangulator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangulator::addToTriangleBuffer",1,"Procedural::Triangulator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Triangulator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangulator,0))){
    SWIG_fail_ptr("Triangulator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__Triangulator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Triangulator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::Triangulator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Triangulator(void *obj) {
Procedural::Triangulator *arg1 = (Procedural::Triangulator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Triangulator_methods[] = {
    {"setShapeToTriangulate", _wrap_Triangulator_setShapeToTriangulate}, 
    {"setMultiShapeToTriangulate", _wrap_Triangulator_setMultiShapeToTriangulate}, 
    {"setSegmentListToTriangulate", _wrap_Triangulator_setSegmentListToTriangulate}, 
    {"setManualSuperTriangle", _wrap_Triangulator_setManualSuperTriangle}, 
    {"setRemoveOutside", _wrap_Triangulator_setRemoveOutside}, 
    {"triangulate", _wrap_Triangulator_triangulate}, 
    {"addToTriangleBuffer", _wrap_Triangulator_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Triangulator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Triangulator_bases[] = {0,0};
static const char *swig_Procedural_Triangulator_base_names[] = {"Procedural::MeshGenerator< Procedural::Triangulator > *",0};
static swig_lua_class _wrap_class_Procedural_Triangulator = { "Triangulator", &SWIGTYPE_p_Procedural__Triangulator,_wrap_new_Triangulator, swig_delete_Triangulator, swig_Procedural_Triangulator_methods, swig_Procedural_Triangulator_attributes, swig_Procedural_Triangulator_bases, swig_Procedural_Triangulator_base_names };

static int _wrap_new_Track__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track::AddressingMode arg1 ;
  bool arg2 ;
  Procedural::Track *result = 0 ;
  
  SWIG_check_num_args("Procedural::Track::Track",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::Track::Track",1,"Procedural::Track::AddressingMode");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Track::Track",2,"bool");
  arg1 = (Procedural::Track::AddressingMode)(int)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Track *)new Procedural::Track(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Track,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Track__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track::AddressingMode arg1 ;
  Procedural::Track *result = 0 ;
  
  SWIG_check_num_args("Procedural::Track::Track",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::Track::Track",1,"Procedural::Track::AddressingMode");
  arg1 = (Procedural::Track::AddressingMode)(int)lua_tonumber(L, 1);
  result = (Procedural::Track *)new Procedural::Track(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Track,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Track__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *result = 0 ;
  
  SWIG_check_num_args("Procedural::Track::Track",0,0)
  result = (Procedural::Track *)new Procedural::Track();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Track,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_getAddressingMode(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Procedural::Track::AddressingMode result;
  
  SWIG_check_num_args("Procedural::Track::getAddressingMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::getAddressingMode",1,"Procedural::Track const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_getAddressingMode",1,SWIGTYPE_p_Procedural__Track);
  }
  
  result = (Procedural::Track::AddressingMode)((Procedural::Track const *)arg1)->getAddressingMode();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_addKeyFrame(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Track *result = 0 ;
  
  SWIG_check_num_args("Procedural::Track::addKeyFrame",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::addKeyFrame",1,"Procedural::Track *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::addKeyFrame",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Track::addKeyFrame",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_addKeyFrame",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Track *) &(arg1)->addKeyFrame(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Track,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_isInsertPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Track::isInsertPoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::isInsertPoint",1,"Procedural::Track const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_isInsertPoint",1,SWIGTYPE_p_Procedural__Track);
  }
  
  result = (bool)((Procedural::Track const *)arg1)->isInsertPoint();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_getValue__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Track::getValue",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::getValue",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::getValue",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Track::getValue",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Track::getValue",4,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_getValue",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = (Ogre::Real)((Procedural::Track const *)arg1)->getValue(arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_getValue__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Track::getValue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::getValue",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::getValue",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_getValue",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Ogre::Real)((Procedural::Track const *)arg1)->getValue(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_getValue(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Track_getValue__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Track_getValue__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Track_getValue'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Track::getValue(Ogre::Real,Ogre::Real,unsigned int) const\n"
    "    Procedural::Track::getValue(Ogre::Real) const\n");
  lua_error(L);return 0;
}


static int _wrap_Track__getKeyValueBefore__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  SwigValueWrapper< std::map< Ogre::Real,Ogre::Real >::const_iterator > result;
  
  SWIG_check_num_args("Procedural::Track::_getKeyValueBefore",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",4,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track__getKeyValueBefore",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = ((Procedural::Track const *)arg1)->_getKeyValueBefore(arg2,arg3,arg4);
  {
    std::map< Ogre::Real,Ogre::Real >::const_iterator * resultptr = new std::map< Ogre::Real,Ogre::Real >::const_iterator((const std::map< Ogre::Real,Ogre::Real >::const_iterator &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track__getKeyValueBefore__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  SwigValueWrapper< std::map< Ogre::Real,Ogre::Real >::const_iterator > result;
  
  SWIG_check_num_args("Procedural::Track::_getKeyValueBefore",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::_getKeyValueBefore",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track__getKeyValueBefore",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Procedural::Track const *)arg1)->_getKeyValueBefore(arg2);
  {
    std::map< Ogre::Real,Ogre::Real >::const_iterator * resultptr = new std::map< Ogre::Real,Ogre::Real >::const_iterator((const std::map< Ogre::Real,Ogre::Real >::const_iterator &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track__getKeyValueBefore(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Track__getKeyValueBefore__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Track__getKeyValueBefore__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Track__getKeyValueBefore'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Track::_getKeyValueBefore(Ogre::Real,Ogre::Real,unsigned int) const\n"
    "    Procedural::Track::_getKeyValueBefore(Ogre::Real) const\n");
  lua_error(L);return 0;
}


static int _wrap_Track__getKeyValueAfter__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  unsigned int arg4 ;
  SwigValueWrapper< std::map< Ogre::Real,Ogre::Real >::const_iterator > result;
  
  SWIG_check_num_args("Procedural::Track::_getKeyValueAfter",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",4,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track__getKeyValueAfter",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (unsigned int)lua_tonumber(L, 4);
  result = ((Procedural::Track const *)arg1)->_getKeyValueAfter(arg2,arg3,arg4);
  {
    std::map< Ogre::Real,Ogre::Real >::const_iterator * resultptr = new std::map< Ogre::Real,Ogre::Real >::const_iterator((const std::map< Ogre::Real,Ogre::Real >::const_iterator &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track__getKeyValueAfter__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real arg2 ;
  SwigValueWrapper< std::map< Ogre::Real,Ogre::Real >::const_iterator > result;
  
  SWIG_check_num_args("Procedural::Track::_getKeyValueAfter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",1,"Procedural::Track const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Track::_getKeyValueAfter",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track__getKeyValueAfter",1,SWIGTYPE_p_Procedural__Track);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = ((Procedural::Track const *)arg1)->_getKeyValueAfter(arg2);
  {
    std::map< Ogre::Real,Ogre::Real >::const_iterator * resultptr = new std::map< Ogre::Real,Ogre::Real >::const_iterator((const std::map< Ogre::Real,Ogre::Real >::const_iterator &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track__getKeyValueAfter(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Track__getKeyValueAfter__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Track__getKeyValueAfter__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Track__getKeyValueAfter'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Track::_getKeyValueAfter(Ogre::Real,Ogre::Real,unsigned int) const\n"
    "    Procedural::Track::_getKeyValueAfter(Ogre::Real) const\n");
  lua_error(L);return 0;
}


static int _wrap_Track_getFirstValue(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Track::getFirstValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::getFirstValue",1,"Procedural::Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_getFirstValue",1,SWIGTYPE_p_Procedural__Track);
  }
  
  result = (Ogre::Real)(arg1)->getFirstValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Track_getLastValue(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = (Procedural::Track *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::Track::getLastValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Track::getLastValue",1,"Procedural::Track *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("Track_getLastValue",1,SWIGTYPE_p_Procedural__Track);
  }
  
  result = (Ogre::Real)(arg1)->getLastValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Track__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Track *arg1 = 0 ;
  Procedural::Track *result = 0 ;
  
  SWIG_check_num_args("Procedural::Track::Track",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Track::Track",1,"Procedural::Track const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Track,0))){
    SWIG_fail_ptr("new_Track",1,SWIGTYPE_p_Procedural__Track);
  }
  
  result = (Procedural::Track *)new Procedural::Track((Procedural::Track const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Track,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Track(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Track__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Track, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_Track__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Track__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Track__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Track'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Track::Track(Procedural::Track::AddressingMode,bool)\n"
    "    Procedural::Track::Track(Procedural::Track::AddressingMode)\n"
    "    Procedural::Track::Track()\n"
    "    Procedural::Track::Track(Procedural::Track const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_Track(void *obj) {
Procedural::Track *arg1 = (Procedural::Track *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Track_methods[] = {
    {"getAddressingMode", _wrap_Track_getAddressingMode}, 
    {"addKeyFrame", _wrap_Track_addKeyFrame}, 
    {"isInsertPoint", _wrap_Track_isInsertPoint}, 
    {"getValue", _wrap_Track_getValue}, 
    {"_getKeyValueBefore", _wrap_Track__getKeyValueBefore}, 
    {"_getKeyValueAfter", _wrap_Track__getKeyValueAfter}, 
    {"getFirstValue", _wrap_Track_getFirstValue}, 
    {"getLastValue", _wrap_Track_getLastValue}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Track_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Track_bases[] = {0};
static const char *swig_Procedural_Track_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Track = { "Track", &SWIGTYPE_p_Procedural__Track,_wrap_new_Track, swig_delete_Track, swig_Procedural_Track_methods, swig_Procedural_Track_attributes, swig_Procedural_Track_bases, swig_Procedural_Track_base_names };

static int _wrap_new_Boolean(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::Boolean::Boolean",0,0)
  result = (Procedural::Boolean *)new Procedural::Boolean();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Boolean_setMesh1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Boolean *arg1 = (Procedural::Boolean *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::Boolean::setMesh1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Boolean::setMesh1",1,"Procedural::Boolean *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Boolean::setMesh1",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Boolean,0))){
    SWIG_fail_ptr("Boolean_setMesh1",1,SWIGTYPE_p_Procedural__Boolean);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Boolean_setMesh1",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setMesh1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Boolean_setMesh2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Boolean *arg1 = (Procedural::Boolean *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::Boolean::setMesh2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Boolean::setMesh2",1,"Procedural::Boolean *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Boolean::setMesh2",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Boolean,0))){
    SWIG_fail_ptr("Boolean_setMesh2",1,SWIGTYPE_p_Procedural__Boolean);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Boolean_setMesh2",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::Boolean *) &(arg1)->setMesh2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Boolean_setBooleanOperation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Boolean *arg1 = (Procedural::Boolean *) 0 ;
  Procedural::Boolean::BooleanOperation arg2 ;
  Procedural::Boolean *result = 0 ;
  
  SWIG_check_num_args("Procedural::Boolean::setBooleanOperation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Boolean::setBooleanOperation",1,"Procedural::Boolean *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Boolean::setBooleanOperation",2,"Procedural::Boolean::BooleanOperation");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Boolean,0))){
    SWIG_fail_ptr("Boolean_setBooleanOperation",1,SWIGTYPE_p_Procedural__Boolean);
  }
  
  arg2 = (Procedural::Boolean::BooleanOperation)(int)lua_tonumber(L, 2);
  result = (Procedural::Boolean *) &(arg1)->setBooleanOperation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Boolean,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Boolean_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Boolean *arg1 = (Procedural::Boolean *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::Boolean::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Boolean::addToTriangleBuffer",1,"Procedural::Boolean const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Boolean::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Boolean,0))){
    SWIG_fail_ptr("Boolean_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__Boolean);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("Boolean_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::Boolean const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Boolean(void *obj) {
Procedural::Boolean *arg1 = (Procedural::Boolean *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Boolean_methods[] = {
    {"setMesh1", _wrap_Boolean_setMesh1}, 
    {"setMesh2", _wrap_Boolean_setMesh2}, 
    {"setBooleanOperation", _wrap_Boolean_setBooleanOperation}, 
    {"addToTriangleBuffer", _wrap_Boolean_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Boolean_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Boolean_bases[] = {0,0};
static const char *swig_Procedural_Boolean_base_names[] = {"Procedural::MeshGenerator< Procedural::Boolean > *",0};
static swig_lua_class _wrap_class_Procedural_Boolean = { "Boolean", &SWIGTYPE_p_Procedural__Boolean,_wrap_new_Boolean, swig_delete_Boolean, swig_Procedural_Boolean_methods, swig_Procedural_Boolean_attributes, swig_Procedural_Boolean_bases, swig_Procedural_Boolean_base_names };

static int _wrap_new_HelixPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *result = 0 ;
  
  SWIG_check_num_args("Procedural::HelixPath::HelixPath",0,0)
  result = (Procedural::HelixPath *)new Procedural::HelixPath();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HelixPath,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HelixPath_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *arg1 = (Procedural::HelixPath *) 0 ;
  Ogre::Real arg2 ;
  Procedural::HelixPath *result = 0 ;
  
  SWIG_check_num_args("Procedural::HelixPath::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HelixPath::setHeight",1,"Procedural::HelixPath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::HelixPath::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HelixPath,0))){
    SWIG_fail_ptr("HelixPath_setHeight",1,SWIGTYPE_p_Procedural__HelixPath);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::HelixPath *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HelixPath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HelixPath_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *arg1 = (Procedural::HelixPath *) 0 ;
  Ogre::Real arg2 ;
  Procedural::HelixPath *result = 0 ;
  
  SWIG_check_num_args("Procedural::HelixPath::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HelixPath::setRadius",1,"Procedural::HelixPath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::HelixPath::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HelixPath,0))){
    SWIG_fail_ptr("HelixPath_setRadius",1,SWIGTYPE_p_Procedural__HelixPath);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::HelixPath *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HelixPath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HelixPath_setNumRound(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *arg1 = (Procedural::HelixPath *) 0 ;
  Ogre::Real arg2 ;
  Procedural::HelixPath *result = 0 ;
  
  SWIG_check_num_args("Procedural::HelixPath::setNumRound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HelixPath::setNumRound",1,"Procedural::HelixPath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::HelixPath::setNumRound",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HelixPath,0))){
    SWIG_fail_ptr("HelixPath_setNumRound",1,SWIGTYPE_p_Procedural__HelixPath);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::HelixPath *) &(arg1)->setNumRound(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HelixPath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HelixPath_setNumSegPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *arg1 = (Procedural::HelixPath *) 0 ;
  unsigned int arg2 ;
  Procedural::HelixPath *result = 0 ;
  
  SWIG_check_num_args("Procedural::HelixPath::setNumSegPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HelixPath::setNumSegPath",1,"Procedural::HelixPath *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::HelixPath::setNumSegPath",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HelixPath,0))){
    SWIG_fail_ptr("HelixPath_setNumSegPath",1,SWIGTYPE_p_Procedural__HelixPath);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (Procedural::HelixPath *) &(arg1)->setNumSegPath(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HelixPath,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HelixPath_realizePath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HelixPath *arg1 = (Procedural::HelixPath *) 0 ;
  Procedural::Path result;
  
  SWIG_check_num_args("Procedural::HelixPath::realizePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HelixPath::realizePath",1,"Procedural::HelixPath *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HelixPath,0))){
    SWIG_fail_ptr("HelixPath_realizePath",1,SWIGTYPE_p_Procedural__HelixPath);
  }
  
  result = (arg1)->realizePath();
  {
    Procedural::Path * resultptr = new Procedural::Path((const Procedural::Path &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Path,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_HelixPath(void *obj) {
Procedural::HelixPath *arg1 = (Procedural::HelixPath *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_HelixPath_methods[] = {
    {"setHeight", _wrap_HelixPath_setHeight}, 
    {"setRadius", _wrap_HelixPath_setRadius}, 
    {"setNumRound", _wrap_HelixPath_setNumRound}, 
    {"setNumSegPath", _wrap_HelixPath_setNumSegPath}, 
    {"realizePath", _wrap_HelixPath_realizePath}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_HelixPath_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_HelixPath_bases[] = {0};
static const char *swig_Procedural_HelixPath_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_HelixPath = { "HelixPath", &SWIGTYPE_p_Procedural__HelixPath,_wrap_new_HelixPath, swig_delete_HelixPath, swig_Procedural_HelixPath_methods, swig_Procedural_HelixPath_attributes, swig_Procedural_HelixPath_bases, swig_Procedural_HelixPath_base_names };

static int _wrap_new_SpringGenerator__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  int arg5 ;
  int arg6 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",6,"int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  int arg5 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",5,"int");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",4,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",3,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",2,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::SpringGenerator",1,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::SpringGenerator",0,0)
  result = (Procedural::SpringGenerator *)new Procedural::SpringGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SpringGenerator(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_SpringGenerator__SWIG_6(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_SpringGenerator__SWIG_5(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_SpringGenerator__SWIG_4(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_SpringGenerator__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_SpringGenerator__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_new_SpringGenerator__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_new_SpringGenerator__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_SpringGenerator'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real,int,int)\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real,int)\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real,Ogre::Real)\n"
    "    Procedural::SpringGenerator::SpringGenerator(Ogre::Real)\n"
    "    Procedural::SpringGenerator::SpringGenerator()\n");
  lua_error(L);return 0;
}


static int _wrap_SpringGenerator_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setHeight",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setHeight",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_setRadiusHelix(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setRadiusHelix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setRadiusHelix",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setRadiusHelix",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setRadiusHelix",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setRadiusHelix(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_setRadiusCircle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setRadiusCircle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setRadiusCircle",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setRadiusCircle",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setRadiusCircle",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setRadiusCircle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_setNumRound(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setNumRound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setNumRound",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setNumRound",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setNumRound",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setNumRound(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_setNumSegPath(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  int arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setNumSegPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setNumSegPath",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setNumSegPath",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setNumSegPath",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setNumSegPath(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_setNumSegCircle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  int arg2 ;
  Procedural::SpringGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::setNumSegCircle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::setNumSegCircle",1,"Procedural::SpringGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::setNumSegCircle",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_setNumSegCircle",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Procedural::SpringGenerator *) &(arg1)->setNumSegCircle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpringGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpringGenerator_addToTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = 0 ;
  
  SWIG_check_num_args("Procedural::SpringGenerator::addToTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpringGenerator::addToTriangleBuffer",1,"Procedural::SpringGenerator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SpringGenerator::addToTriangleBuffer",2,"Procedural::TriangleBuffer &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpringGenerator,0))){
    SWIG_fail_ptr("SpringGenerator_addToTriangleBuffer",1,SWIGTYPE_p_Procedural__SpringGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("SpringGenerator_addToTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  ((Procedural::SpringGenerator const *)arg1)->addToTriangleBuffer(*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SpringGenerator(void *obj) {
Procedural::SpringGenerator *arg1 = (Procedural::SpringGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_SpringGenerator_methods[] = {
    {"setHeight", _wrap_SpringGenerator_setHeight}, 
    {"setRadiusHelix", _wrap_SpringGenerator_setRadiusHelix}, 
    {"setRadiusCircle", _wrap_SpringGenerator_setRadiusCircle}, 
    {"setNumRound", _wrap_SpringGenerator_setNumRound}, 
    {"setNumSegPath", _wrap_SpringGenerator_setNumSegPath}, 
    {"setNumSegCircle", _wrap_SpringGenerator_setNumSegCircle}, 
    {"addToTriangleBuffer", _wrap_SpringGenerator_addToTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_SpringGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_SpringGenerator_bases[] = {0,0};
static const char *swig_Procedural_SpringGenerator_base_names[] = {"Procedural::MeshGenerator< Procedural::SpringGenerator > *",0};
static swig_lua_class _wrap_class_Procedural_SpringGenerator = { "SpringGenerator", &SWIGTYPE_p_Procedural__SpringGenerator,_wrap_new_SpringGenerator, swig_delete_SpringGenerator, swig_Procedural_SpringGenerator_methods, swig_Procedural_SpringGenerator_attributes, swig_Procedural_SpringGenerator_bases, swig_Procedural_SpringGenerator_base_names };

static int _wrap_SvgLoader_parseSvgFile__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SvgLoader *arg1 = (Procedural::SvgLoader *) 0 ;
  Procedural::MultiShape *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  Ogre::String *arg4 = 0 ;
  int arg5 ;
  std::string temp3 ;
  std::string temp4 ;
  
  SWIG_check_num_args("Procedural::SvgLoader::parseSvgFile",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",1,"Procedural::SvgLoader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",2,"Procedural::MultiShape &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",3,"Ogre::String const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",4,"Ogre::String const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SvgLoader,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",1,SWIGTYPE_p_Procedural__SvgLoader);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",2,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  temp4.assign(lua_tostring(L,4),lua_strlen(L,4)); arg4=&temp4;
  arg5 = (int)lua_tonumber(L, 5);
  (arg1)->parseSvgFile(*arg2,(Ogre::String const &)*arg3,(Ogre::String const &)*arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SvgLoader_parseSvgFile__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SvgLoader *arg1 = (Procedural::SvgLoader *) 0 ;
  Procedural::MultiShape *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  Ogre::String *arg4 = 0 ;
  std::string temp3 ;
  std::string temp4 ;
  
  SWIG_check_num_args("Procedural::SvgLoader::parseSvgFile",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",1,"Procedural::SvgLoader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",2,"Procedural::MultiShape &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",3,"Ogre::String const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",4,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SvgLoader,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",1,SWIGTYPE_p_Procedural__SvgLoader);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",2,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  temp4.assign(lua_tostring(L,4),lua_strlen(L,4)); arg4=&temp4;
  (arg1)->parseSvgFile(*arg2,(Ogre::String const &)*arg3,(Ogre::String const &)*arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SvgLoader_parseSvgFile__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SvgLoader *arg1 = (Procedural::SvgLoader *) 0 ;
  Procedural::MultiShape *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp3 ;
  
  SWIG_check_num_args("Procedural::SvgLoader::parseSvgFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",1,"Procedural::SvgLoader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",2,"Procedural::MultiShape &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::SvgLoader::parseSvgFile",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SvgLoader,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",1,SWIGTYPE_p_Procedural__SvgLoader);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__MultiShape,0))){
    SWIG_fail_ptr("SvgLoader_parseSvgFile",2,SWIGTYPE_p_Procedural__MultiShape);
  }
  
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  (arg1)->parseSvgFile(*arg2,(Ogre::String const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SvgLoader_parseSvgFile(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__SvgLoader, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_SvgLoader_parseSvgFile__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__SvgLoader, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_SvgLoader_parseSvgFile__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__SvgLoader, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__MultiShape, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_SvgLoader_parseSvgFile__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'SvgLoader_parseSvgFile'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::SvgLoader::parseSvgFile(Procedural::MultiShape &,Ogre::String const &,Ogre::String const &,int)\n"
    "    Procedural::SvgLoader::parseSvgFile(Procedural::MultiShape &,Ogre::String const &,Ogre::String const &)\n"
    "    Procedural::SvgLoader::parseSvgFile(Procedural::MultiShape &,Ogre::String const &)\n");
  lua_error(L);return 0;
}


static int _wrap_new_SvgLoader(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SvgLoader *result = 0 ;
  
  SWIG_check_num_args("Procedural::SvgLoader::SvgLoader",0,0)
  result = (Procedural::SvgLoader *)new Procedural::SvgLoader();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SvgLoader,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SvgLoader(void *obj) {
Procedural::SvgLoader *arg1 = (Procedural::SvgLoader *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_SvgLoader_methods[] = {
    {"parseSvgFile", _wrap_SvgLoader_parseSvgFile}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_SvgLoader_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_SvgLoader_bases[] = {0};
static const char *swig_Procedural_SvgLoader_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_SvgLoader = { "SvgLoader", &SWIGTYPE_p_Procedural__SvgLoader,_wrap_new_SvgLoader, swig_delete_SvgLoader, swig_Procedural_SvgLoader_methods, swig_Procedural_SvgLoader_attributes, swig_Procedural_SvgLoader_bases, swig_Procedural_SvgLoader_base_names };

static int _wrap_new_ShowNormalsGenerator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::ShowNormalsGenerator",0,0)
  result = (Procedural::ShowNormalsGenerator *)new Procedural::ShowNormalsGenerator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ShowNormalsGenerator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_setTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::ShowNormalsGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::setTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setTriangleBuffer",1,"Procedural::ShowNormalsGenerator *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_setTriangleBuffer",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_setTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::ShowNormalsGenerator *) &(arg1)->setTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  Ogre::Real arg2 ;
  Procedural::ShowNormalsGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setSize",1,"Procedural::ShowNormalsGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setSize",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_setSize",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::ShowNormalsGenerator *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_setVisualStyle(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  Procedural::ShowNormalsGenerator::VisualStyle arg2 ;
  Procedural::ShowNormalsGenerator *result = 0 ;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::setVisualStyle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setVisualStyle",1,"Procedural::ShowNormalsGenerator *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::setVisualStyle",2,"Procedural::ShowNormalsGenerator::VisualStyle");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_setVisualStyle",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  arg2 = (Procedural::ShowNormalsGenerator::VisualStyle)(int)lua_tonumber(L, 2);
  result = (Procedural::ShowNormalsGenerator *) &(arg1)->setVisualStyle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_buildManualObject(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  Ogre::ManualObject *result = 0 ;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::buildManualObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildManualObject",1,"Procedural::ShowNormalsGenerator const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_buildManualObject",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  result = (Ogre::ManualObject *)((Procedural::ShowNormalsGenerator const *)arg1)->buildManualObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__ManualObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_buildMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  std::string *arg2 = 0 ;
  Ogre::String *arg3 = 0 ;
  std::string temp2 ;
  std::string temp3 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::buildMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",1,"Procedural::ShowNormalsGenerator const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",3,"Ogre::String const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_buildMesh",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_strlen(L,3)); arg3=&temp3;
  result = ((Procedural::ShowNormalsGenerator const *)arg1)->buildMesh((std::string const &)*arg2,(Ogre::String const &)*arg3);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_buildMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::buildMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",1,"Procedural::ShowNormalsGenerator const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",2,"std::string const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_buildMesh",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = ((Procedural::ShowNormalsGenerator const *)arg1)->buildMesh((std::string const &)*arg2);
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_buildMesh__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) 0 ;
  Ogre::MeshPtr result;
  
  SWIG_check_num_args("Procedural::ShowNormalsGenerator::buildMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::ShowNormalsGenerator::buildMesh",1,"Procedural::ShowNormalsGenerator const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__ShowNormalsGenerator,0))){
    SWIG_fail_ptr("ShowNormalsGenerator_buildMesh",1,SWIGTYPE_p_Procedural__ShowNormalsGenerator);
  }
  
  result = ((Procedural::ShowNormalsGenerator const *)arg1)->buildMesh();
  {
    Ogre::MeshPtr * resultptr = new Ogre::MeshPtr((const Ogre::MeshPtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__MeshPtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShowNormalsGenerator_buildMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__ShowNormalsGenerator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_ShowNormalsGenerator_buildMesh__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__ShowNormalsGenerator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_ShowNormalsGenerator_buildMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__ShowNormalsGenerator, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_ShowNormalsGenerator_buildMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'ShowNormalsGenerator_buildMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::ShowNormalsGenerator::buildMesh(std::string const &,Ogre::String const &) const\n"
    "    Procedural::ShowNormalsGenerator::buildMesh(std::string const &) const\n"
    "    Procedural::ShowNormalsGenerator::buildMesh() const\n");
  lua_error(L);return 0;
}


static void swig_delete_ShowNormalsGenerator(void *obj) {
Procedural::ShowNormalsGenerator *arg1 = (Procedural::ShowNormalsGenerator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_ShowNormalsGenerator_methods[] = {
    {"setTriangleBuffer", _wrap_ShowNormalsGenerator_setTriangleBuffer}, 
    {"setSize", _wrap_ShowNormalsGenerator_setSize}, 
    {"setVisualStyle", _wrap_ShowNormalsGenerator_setVisualStyle}, 
    {"buildManualObject", _wrap_ShowNormalsGenerator_buildManualObject}, 
    {"buildMesh", _wrap_ShowNormalsGenerator_buildMesh}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_ShowNormalsGenerator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_ShowNormalsGenerator_bases[] = {0};
static const char *swig_Procedural_ShowNormalsGenerator_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_ShowNormalsGenerator = { "ShowNormalsGenerator", &SWIGTYPE_p_Procedural__ShowNormalsGenerator,_wrap_new_ShowNormalsGenerator, swig_delete_ShowNormalsGenerator, swig_Procedural_ShowNormalsGenerator_methods, swig_Procedural_ShowNormalsGenerator_attributes, swig_Procedural_ShowNormalsGenerator_bases, swig_Procedural_ShowNormalsGenerator_base_names };

static int _wrap_new_vectorSeg2__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *result = 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::vector",0,0)
  result = (std::vector< Procedural::Segment2D > *)new std::vector< Procedural::Segment2D >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_vectorSeg2__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  unsigned int arg1 ;
  std::vector< Procedural::Segment2D > *result = 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< Procedural::Segment2D > *)new std::vector< Procedural::Segment2D >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_vectorSeg2__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = 0 ;
  std::vector< Procedural::Segment2D > *result = 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::vector",1,"std::vector< Procedural::Segment2D > const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("new_vectorSeg2",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = (std::vector< Procedural::Segment2D > *)new std::vector< Procedural::Segment2D >((std::vector< Procedural::Segment2D > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_vectorSeg2__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  unsigned int arg1 ;
  Procedural::Segment2D arg2 ;
  Procedural::Segment2D *argp2 ;
  std::vector< Procedural::Segment2D > *result = 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::vector",1,"unsigned int");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::vector",2,"Procedural::Segment2D");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("new_vectorSeg2",2,SWIGTYPE_p_Procedural__Segment2D);
  }
  arg2 = *argp2;
  
  result = (std::vector< Procedural::Segment2D > *)new std::vector< Procedural::Segment2D >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_vectorSeg2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_vectorSeg2__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_vectorSeg2__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_vectorSeg2__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__Segment2D, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_vectorSeg2__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_vectorSeg2'\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::vector< Procedural::Segment2D >::vector()\n"
    "    std::vector< Procedural::Segment2D >::vector(unsigned int)\n"
    "    std::vector< Procedural::Segment2D >::vector(std::vector< Procedural::Segment2D > const &)\n"
    "    std::vector< Procedural::Segment2D >::vector(unsigned int,Procedural::Segment2D)\n");
  lua_error(L);return 0;
}


static int _wrap_vectorSeg2_size(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::size",1,"std::vector< Procedural::Segment2D > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_size",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = (unsigned int)((std::vector< Procedural::Segment2D > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_max_size(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::max_size",1,"std::vector< Procedural::Segment2D > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_max_size",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = (unsigned int)((std::vector< Procedural::Segment2D > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_empty(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  bool result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::empty",1,"std::vector< Procedural::Segment2D > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_empty",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = (bool)((std::vector< Procedural::Segment2D > const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_clear(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::clear",1,"std::vector< Procedural::Segment2D > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_clear",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  (arg1)->clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_push_back(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  Procedural::Segment2D arg2 ;
  Procedural::Segment2D *argp2 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::push_back",1,"std::vector< Procedural::Segment2D > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::push_back",2,"Procedural::Segment2D");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_push_back",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("vectorSeg2_push_back",2,SWIGTYPE_p_Procedural__Segment2D);
  }
  arg2 = *argp2;
  
  (arg1)->push_back(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_pop_back(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::pop_back",1,"std::vector< Procedural::Segment2D > *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_pop_back",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  (arg1)->pop_back();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_front(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  Procedural::Segment2D result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::front",1,"std::vector< Procedural::Segment2D > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_front",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = ((std::vector< Procedural::Segment2D > const *)arg1)->front();
  {
    Procedural::Segment2D * resultptr = new Procedural::Segment2D((const Procedural::Segment2D &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Segment2D,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2_back(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  Procedural::Segment2D result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::back",1,"std::vector< Procedural::Segment2D > const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2_back",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  result = ((std::vector< Procedural::Segment2D > const *)arg1)->back();
  {
    Procedural::Segment2D * resultptr = new Procedural::Segment2D((const Procedural::Segment2D &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Segment2D,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2___getitem(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  unsigned int arg2 ;
  Procedural::Segment2D result;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::__getitem__",1,"std::vector< Procedural::Segment2D > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::__getitem__",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2___getitem",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = std_vector_Sl_Procedural_Segment2D_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what());
  }
  
  {
    Procedural::Segment2D * resultptr = new Procedural::Segment2D((const Procedural::Segment2D &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Segment2D,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vectorSeg2___setitem(lua_State* L) {
  int SWIG_arg = 0;
  std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) 0 ;
  unsigned int arg2 ;
  Procedural::Segment2D arg3 ;
  Procedural::Segment2D *argp3 ;
  
  SWIG_check_num_args("std::vector< Procedural::Segment2D >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::__setitem__",1,"std::vector< Procedural::Segment2D > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::__setitem__",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("std::vector< Procedural::Segment2D >::__setitem__",3,"Procedural::Segment2D");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,0))){
    SWIG_fail_ptr("vectorSeg2___setitem",1,SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("vectorSeg2___setitem",3,SWIGTYPE_p_Procedural__Segment2D);
  }
  arg3 = *argp3;
  
  try {
    std_vector_Sl_Procedural_Segment2D_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what());
  }
  
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_vectorSeg2(void *obj) {
std::vector< Procedural::Segment2D > *arg1 = (std::vector< Procedural::Segment2D > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_Procedural_Segment2D_Sg__methods[] = {
    {"size", _wrap_vectorSeg2_size}, 
    {"max_size", _wrap_vectorSeg2_max_size}, 
    {"empty", _wrap_vectorSeg2_empty}, 
    {"clear", _wrap_vectorSeg2_clear}, 
    {"push_back", _wrap_vectorSeg2_push_back}, 
    {"pop_back", _wrap_vectorSeg2_pop_back}, 
    {"front", _wrap_vectorSeg2_front}, 
    {"back", _wrap_vectorSeg2_back}, 
    {"__getitem", _wrap_vectorSeg2___getitem}, 
    {"__setitem", _wrap_vectorSeg2___setitem}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_Procedural_Segment2D_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_Procedural_Segment2D_Sg__bases[] = {0};
static const char *swig_std_vector_Sl_Procedural_Segment2D_Sg__base_names[] = {0};
static swig_lua_class _wrap_class_std_vector_Sl_Procedural_Segment2D_Sg_ = { "vectorSeg2", &SWIGTYPE_p_std__vectorT_Procedural__Segment2D_t,_wrap_new_vectorSeg2, swig_delete_vectorSeg2, swig_std_vector_Sl_Procedural_Segment2D_Sg__methods, swig_std_vector_Sl_Procedural_Segment2D_Sg__attributes, swig_std_vector_Sl_Procedural_Segment2D_Sg__bases, swig_std_vector_Sl_Procedural_Segment2D_Sg__base_names };

static int _wrap_new_Circle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Circle *result = 0 ;
  
  SWIG_check_num_args("Procedural::Circle::Circle",0,0)
  result = (Procedural::Circle *)new Procedural::Circle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Circle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Circle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 arg1 ;
  Ogre::Real arg2 ;
  Ogre::Vector2 *argp1 ;
  Procedural::Circle *result = 0 ;
  
  SWIG_check_num_args("Procedural::Circle::Circle",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Circle::Circle",1,"Ogre::Vector2");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Circle::Circle",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Circle",1,SWIGTYPE_p_Ogre__Vector2);
  }
  arg1 = *argp1;
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Circle *)new Procedural::Circle(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Circle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Circle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 arg1 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  Ogre::Vector2 *argp1 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::Circle *result = 0 ;
  
  SWIG_check_num_args("Procedural::Circle::Circle",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Circle::Circle",1,"Ogre::Vector2");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Circle::Circle",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Circle::Circle",3,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Circle",1,SWIGTYPE_p_Ogre__Vector2);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Circle",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Circle",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  result = (Procedural::Circle *)new Procedural::Circle(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Circle,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Circle(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Circle__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Circle__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_new_Circle__SWIG_2(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Circle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Circle::Circle()\n"
    "    Procedural::Circle::Circle(Ogre::Vector2,Ogre::Real)\n"
    "    Procedural::Circle::Circle(Ogre::Vector2,Ogre::Vector2,Ogre::Vector2)\n");
  lua_error(L);return 0;
}


static int _wrap_Circle_isPointInside(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Circle *arg1 = (Procedural::Circle *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Circle::isPointInside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Circle::isPointInside",1,"Procedural::Circle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Circle::isPointInside",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Circle,0))){
    SWIG_fail_ptr("Circle_isPointInside",1,SWIGTYPE_p_Procedural__Circle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Circle_isPointInside",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::Circle const *)arg1)->isPointInside((Ogre::Vector2 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Circle(void *obj) {
Procedural::Circle *arg1 = (Procedural::Circle *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Circle_methods[] = {
    {"isPointInside", _wrap_Circle_isPointInside}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Circle_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Circle_bases[] = {0};
static const char *swig_Procedural_Circle_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Circle = { "Circle", &SWIGTYPE_p_Procedural__Circle,_wrap_new_Circle, swig_delete_Circle, swig_Procedural_Circle_methods, swig_Procedural_Circle_attributes, swig_Procedural_Circle_bases, swig_Procedural_Circle_base_names };

static int _wrap_new_Plane__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Plane *result = 0 ;
  
  SWIG_check_num_args("Procedural::Plane::Plane",0,0)
  result = (Procedural::Plane *)new Procedural::Plane();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::Plane *result = 0 ;
  
  SWIG_check_num_args("Procedural::Plane::Plane",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Plane::Plane",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Plane::Plane",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Plane",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Plane",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Plane *)new Procedural::Plane((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Real arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Plane *result = 0 ;
  
  SWIG_check_num_args("Procedural::Plane::Plane",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::Plane::Plane",1,"Ogre::Real");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Plane::Plane",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Plane::Plane",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Plane::Plane",4,"Ogre::Real");
  arg1 = (Ogre::Real)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Plane *)new Procedural::Plane(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Plane__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Plane__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Plane__SWIG_2(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Plane'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Plane::Plane()\n"
    "    Procedural::Plane::Plane(Ogre::Vector3 const &,Ogre::Vector3 const &)\n"
    "    Procedural::Plane::Plane(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Plane_intersect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Plane *arg1 = (Procedural::Plane *) 0 ;
  Procedural::Plane *arg2 = 0 ;
  Procedural::Line *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Plane::intersect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Plane::intersect",1,"Procedural::Plane const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Plane::intersect",2,"Procedural::Plane const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Plane::intersect",3,"Procedural::Line &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Plane,0))){
    SWIG_fail_ptr("Plane_intersect",1,SWIGTYPE_p_Procedural__Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Plane,0))){
    SWIG_fail_ptr("Plane_intersect",2,SWIGTYPE_p_Procedural__Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Plane_intersect",3,SWIGTYPE_p_Procedural__Line);
  }
  
  result = (bool)((Procedural::Plane const *)arg1)->intersect((Procedural::Plane const &)*arg2,*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Plane(void *obj) {
Procedural::Plane *arg1 = (Procedural::Plane *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Plane_methods[] = {
    {"intersect", _wrap_Plane_intersect}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Plane_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Plane_bases[] = {0};
static const char *swig_Procedural_Plane_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Plane = { "Plane", &SWIGTYPE_p_Procedural__Plane,_wrap_new_Plane, swig_delete_Plane, swig_Procedural_Plane_methods, swig_Procedural_Plane_attributes, swig_Procedural_Plane_bases, swig_Procedural_Plane_base_names };

static int _wrap_Line_mPoint_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Procedural::Line::mPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::mPoint",1,"Procedural::Line *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Line::mPoint",2,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_mPoint_set",1,SWIGTYPE_p_Procedural__Line);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Line_mPoint_set",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  if (arg1) (arg1)->mPoint = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Line_mPoint_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line::mPoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::mPoint",1,"Procedural::Line *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_mPoint_get",1,SWIGTYPE_p_Procedural__Line);
  }
  
  result = (Ogre::Vector3 *)& ((arg1)->mPoint);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Line_mDirection_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Procedural::Line::mDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::mDirection",1,"Procedural::Line *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Line::mDirection",2,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_mDirection_set",1,SWIGTYPE_p_Procedural__Line);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Line_mDirection_set",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  if (arg1) (arg1)->mDirection = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Line_mDirection_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line::mDirection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::mDirection",1,"Procedural::Line *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_mDirection_get",1,SWIGTYPE_p_Procedural__Line);
  }
  
  result = (Ogre::Vector3 *)& ((arg1)->mDirection);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Line__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line::Line",0,0)
  result = (Procedural::Line *)new Procedural::Line();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Line,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Line__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 arg1 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp1 ;
  Ogre::Vector3 *argp2 ;
  Procedural::Line *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line::Line",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Line::Line",1,"Ogre::Vector3");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line::Line",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Line",1,SWIGTYPE_p_Ogre__Vector3);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Line",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::Line *)new Procedural::Line(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Line,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Line(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Line__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Line__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Line'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Line::Line()\n"
    "    Procedural::Line::Line(Ogre::Vector3,Ogre::Vector3)\n");
  lua_error(L);return 0;
}


static int _wrap_Line_setFrom2Points(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  
  SWIG_check_num_args("Procedural::Line::setFrom2Points",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::setFrom2Points",1,"Procedural::Line *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line::setFrom2Points",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Line::setFrom2Points",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_setFrom2Points",1,SWIGTYPE_p_Procedural__Line);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Line_setFrom2Points",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Line_setFrom2Points",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  (arg1)->setFrom2Points((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Line_shortestPathToPoint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line *arg1 = (Procedural::Line *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 result;
  
  SWIG_check_num_args("Procedural::Line::shortestPathToPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line::shortestPathToPoint",1,"Procedural::Line const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line::shortestPathToPoint",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line,0))){
    SWIG_fail_ptr("Line_shortestPathToPoint",1,SWIGTYPE_p_Procedural__Line);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Line_shortestPathToPoint",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = ((Procedural::Line const *)arg1)->shortestPathToPoint((Ogre::Vector3 const &)*arg2);
  {
    Ogre::Vector3 * resultptr = new Ogre::Vector3((const Ogre::Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Line(void *obj) {
Procedural::Line *arg1 = (Procedural::Line *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Line_methods[] = {
    {"setFrom2Points", _wrap_Line_setFrom2Points}, 
    {"shortestPathToPoint", _wrap_Line_shortestPathToPoint}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Line_attributes[] = {
    { "mPoint", _wrap_Line_mPoint_get, _wrap_Line_mPoint_set},
    { "mDirection", _wrap_Line_mDirection_get, _wrap_Line_mDirection_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Line_bases[] = {0};
static const char *swig_Procedural_Line_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Line = { "Line", &SWIGTYPE_p_Procedural__Line,_wrap_new_Line, swig_delete_Line, swig_Procedural_Line_methods, swig_Procedural_Line_attributes, swig_Procedural_Line_bases, swig_Procedural_Line_base_names };

static int _wrap_new_Line2D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line2D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line2D::Line2D",0,0)
  result = (Procedural::Line2D *)new Procedural::Line2D();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Line2D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Line2D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 arg1 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp1 ;
  Ogre::Vector2 *argp2 ;
  Procedural::Line2D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Line2D::Line2D",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Line2D::Line2D",1,"Ogre::Vector2");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line2D::Line2D",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Line2D",1,SWIGTYPE_p_Ogre__Vector2);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Line2D",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::Line2D *)new Procedural::Line2D(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Line2D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Line2D(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Line2D__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Line2D__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Line2D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Line2D::Line2D()\n"
    "    Procedural::Line2D::Line2D(Ogre::Vector2,Ogre::Vector2)\n");
  lua_error(L);return 0;
}


static int _wrap_Line2D_setFrom2Points(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line2D *arg1 = (Procedural::Line2D *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  
  SWIG_check_num_args("Procedural::Line2D::setFrom2Points",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line2D::setFrom2Points",1,"Procedural::Line2D *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line2D::setFrom2Points",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Line2D::setFrom2Points",3,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line2D,0))){
    SWIG_fail_ptr("Line2D_setFrom2Points",1,SWIGTYPE_p_Procedural__Line2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Line2D_setFrom2Points",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Line2D_setFrom2Points",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  (arg1)->setFrom2Points((Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Line2D_findIntersect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Line2D *arg1 = (Procedural::Line2D *) 0 ;
  Procedural::Line2D *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Line2D::findIntersect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Line2D::findIntersect",1,"Procedural::Line2D const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Line2D::findIntersect",2,"Procedural::Line2D const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Line2D::findIntersect",3,"Ogre::Vector2 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Line2D,0))){
    SWIG_fail_ptr("Line2D_findIntersect",1,SWIGTYPE_p_Procedural__Line2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Line2D,0))){
    SWIG_fail_ptr("Line2D_findIntersect",2,SWIGTYPE_p_Procedural__Line2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Line2D_findIntersect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::Line2D const *)arg1)->findIntersect((Procedural::Line2D const &)*arg2,*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Line2D(void *obj) {
Procedural::Line2D *arg1 = (Procedural::Line2D *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Line2D_methods[] = {
    {"setFrom2Points", _wrap_Line2D_setFrom2Points}, 
    {"findIntersect", _wrap_Line2D_findIntersect}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Line2D_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Line2D_bases[] = {0};
static const char *swig_Procedural_Line2D_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Line2D = { "Line2D", &SWIGTYPE_p_Procedural__Line2D,_wrap_new_Line2D, swig_delete_Line2D, swig_Procedural_Line2D_methods, swig_Procedural_Line2D_attributes, swig_Procedural_Line2D_bases, swig_Procedural_Line2D_base_names };

static int _wrap_Segment2D_mA_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Ogre::Vector2 *arg2 = (Ogre::Vector2 *) 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::mA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::mA",1,"Procedural::Segment2D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Segment2D::mA",2,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_mA_set",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Segment2D_mA_set",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  if (arg1) (arg1)->mA = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment2D_mA_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::mA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::mA",1,"Procedural::Segment2D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_mA_get",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  result = (Ogre::Vector2 *)& ((arg1)->mA);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment2D_mB_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Ogre::Vector2 *arg2 = (Ogre::Vector2 *) 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::mB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::mB",1,"Procedural::Segment2D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Segment2D::mB",2,"Ogre::Vector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_mB_set",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Segment2D_mB_set",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  if (arg1) (arg1)->mB = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment2D_mB_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::mB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::mB",1,"Procedural::Segment2D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_mB_get",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  result = (Ogre::Vector2 *)& ((arg1)->mB);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment2D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::Segment2D",0,0)
  result = (Procedural::Segment2D *)new Procedural::Segment2D();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment2D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment2D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 arg1 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp1 ;
  Ogre::Vector2 *argp2 ;
  Procedural::Segment2D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment2D::Segment2D",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Segment2D::Segment2D",1,"Ogre::Vector2");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Segment2D::Segment2D",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Segment2D",1,SWIGTYPE_p_Ogre__Vector2);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Segment2D",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::Segment2D *)new Procedural::Segment2D(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment2D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment2D(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Segment2D__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Segment2D__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Segment2D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Segment2D::Segment2D()\n"
    "    Procedural::Segment2D::Segment2D(Ogre::Vector2,Ogre::Vector2)\n");
  lua_error(L);return 0;
}


static int _wrap_Segment2D_findIntersect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Procedural::Segment2D *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Segment2D::findIntersect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::findIntersect",1,"Procedural::Segment2D const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Segment2D::findIntersect",2,"Procedural::Segment2D const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Segment2D::findIntersect",3,"Ogre::Vector2 &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_findIntersect",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_findIntersect",2,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Segment2D_findIntersect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::Segment2D const *)arg1)->findIntersect((Procedural::Segment2D const &)*arg2,*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment2D_intersects(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment2D *arg1 = (Procedural::Segment2D *) 0 ;
  Procedural::Segment2D *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Segment2D::intersects",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment2D::intersects",1,"Procedural::Segment2D const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Segment2D::intersects",2,"Procedural::Segment2D const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_intersects",1,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Segment2D,0))){
    SWIG_fail_ptr("Segment2D_intersects",2,SWIGTYPE_p_Procedural__Segment2D);
  }
  
  result = (bool)((Procedural::Segment2D const *)arg1)->intersects((Procedural::Segment2D const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Segment2D(void *obj) {
Procedural::Segment2D *arg1 = (Procedural::Segment2D *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Segment2D_methods[] = {
    {"findIntersect", _wrap_Segment2D_findIntersect}, 
    {"intersects", _wrap_Segment2D_intersects}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Segment2D_attributes[] = {
    { "mA", _wrap_Segment2D_mA_get, _wrap_Segment2D_mA_set},
    { "mB", _wrap_Segment2D_mB_get, _wrap_Segment2D_mB_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Segment2D_bases[] = {0};
static const char *swig_Procedural_Segment2D_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Segment2D = { "Segment2D", &SWIGTYPE_p_Procedural__Segment2D,_wrap_new_Segment2D, swig_delete_Segment2D, swig_Procedural_Segment2D_methods, swig_Procedural_Segment2D_attributes, swig_Procedural_Segment2D_bases, swig_Procedural_Segment2D_base_names };

static int _wrap_Vector2Comparator___call(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vector2Comparator *arg1 = (Procedural::Vector2Comparator *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Vector2Comparator::operator ()",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vector2Comparator::operator ()",1,"Procedural::Vector2Comparator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Vector2Comparator::operator ()",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Vector2Comparator::operator ()",3,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vector2Comparator,0))){
    SWIG_fail_ptr("Vector2Comparator___call",1,SWIGTYPE_p_Procedural__Vector2Comparator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2Comparator___call",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Vector2Comparator___call",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (bool)((Procedural::Vector2Comparator const *)arg1)->operator ()((Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2Comparator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vector2Comparator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vector2Comparator::Vector2Comparator",0,0)
  result = (Procedural::Vector2Comparator *)new Procedural::Vector2Comparator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vector2Comparator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector2Comparator(void *obj) {
Procedural::Vector2Comparator *arg1 = (Procedural::Vector2Comparator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Vector2Comparator_methods[] = {
    {"__call", _wrap_Vector2Comparator___call}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Vector2Comparator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Vector2Comparator_bases[] = {0};
static const char *swig_Procedural_Vector2Comparator_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Vector2Comparator = { "Vector2Comparator", &SWIGTYPE_p_Procedural__Vector2Comparator,_wrap_new_Vector2Comparator, swig_delete_Vector2Comparator, swig_Procedural_Vector2Comparator_methods, swig_Procedural_Vector2Comparator_attributes, swig_Procedural_Vector2Comparator_bases, swig_Procedural_Vector2Comparator_base_names };

static int _wrap_Vector3Comparator___call(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vector3Comparator *arg1 = (Procedural::Vector3Comparator *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Vector3Comparator::operator ()",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vector3Comparator::operator ()",1,"Procedural::Vector3Comparator const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Vector3Comparator::operator ()",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Vector3Comparator::operator ()",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vector3Comparator,0))){
    SWIG_fail_ptr("Vector3Comparator___call",1,SWIGTYPE_p_Procedural__Vector3Comparator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3Comparator___call",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Vector3Comparator___call",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (bool)((Procedural::Vector3Comparator const *)arg1)->operator ()((Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3Comparator(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vector3Comparator *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vector3Comparator::Vector3Comparator",0,0)
  result = (Procedural::Vector3Comparator *)new Procedural::Vector3Comparator();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vector3Comparator,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector3Comparator(void *obj) {
Procedural::Vector3Comparator *arg1 = (Procedural::Vector3Comparator *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Vector3Comparator_methods[] = {
    {"__call", _wrap_Vector3Comparator___call}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Vector3Comparator_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Vector3Comparator_bases[] = {0};
static const char *swig_Procedural_Vector3Comparator_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Vector3Comparator = { "Vector3Comparator", &SWIGTYPE_p_Procedural__Vector3Comparator,_wrap_new_Vector3Comparator, swig_delete_Vector3Comparator, swig_Procedural_Vector3Comparator_methods, swig_Procedural_Vector3Comparator_attributes, swig_Procedural_Vector3Comparator_bases, swig_Procedural_Vector3Comparator_base_names };

static int _wrap_Segment3D_mA_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::mA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::mA",1,"Procedural::Segment3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Segment3D::mA",2,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_mA_set",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Segment3D_mA_set",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  if (arg1) (arg1)->mA = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment3D_mA_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::mA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::mA",1,"Procedural::Segment3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_mA_get",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  result = (Ogre::Vector3 *)& ((arg1)->mA);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment3D_mB_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Ogre::Vector3 *arg2 = (Ogre::Vector3 *) 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::mB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::mB",1,"Procedural::Segment3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Segment3D::mB",2,"Ogre::Vector3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_mB_set",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Segment3D_mB_set",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  if (arg1) (arg1)->mB = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment3D_mB_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::mB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::mB",1,"Procedural::Segment3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_mB_get",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  result = (Ogre::Vector3 *)& ((arg1)->mB);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment3D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::Segment3D",0,0)
  result = (Procedural::Segment3D *)new Procedural::Segment3D();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment3D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 arg1 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp1 ;
  Ogre::Vector3 *argp2 ;
  Procedural::Segment3D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment3D::Segment3D",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Segment3D::Segment3D",1,"Ogre::Vector3");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Segment3D::Segment3D",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Segment3D",1,SWIGTYPE_p_Ogre__Vector3);
  }
  arg1 = *argp1;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Segment3D",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::Segment3D *)new Procedural::Segment3D(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Segment3D(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Segment3D__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_Segment3D__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_Segment3D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Segment3D::Segment3D()\n"
    "    Procedural::Segment3D::Segment3D(Ogre::Vector3,Ogre::Vector3)\n");
  lua_error(L);return 0;
}


static int _wrap_Segment3D_epsilonEquivalent(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Procedural::Segment3D *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Segment3D::epsilonEquivalent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::epsilonEquivalent",1,"Procedural::Segment3D const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Segment3D::epsilonEquivalent",2,"Procedural::Segment3D const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_epsilonEquivalent",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_epsilonEquivalent",2,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  result = (bool)((Procedural::Segment3D const *)arg1)->epsilonEquivalent((Procedural::Segment3D const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment3D_orderedCopy(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment3D *arg1 = (Procedural::Segment3D *) 0 ;
  Procedural::Segment3D result;
  
  SWIG_check_num_args("Procedural::Segment3D::orderedCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment3D::orderedCopy",1,"Procedural::Segment3D const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Segment3D_orderedCopy",1,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  result = ((Procedural::Segment3D const *)arg1)->orderedCopy();
  {
    Procedural::Segment3D * resultptr = new Procedural::Segment3D((const Procedural::Segment3D &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Procedural__Segment3D,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Segment3D(void *obj) {
Procedural::Segment3D *arg1 = (Procedural::Segment3D *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Segment3D_methods[] = {
    {"epsilonEquivalent", _wrap_Segment3D_epsilonEquivalent}, 
    {"orderedCopy", _wrap_Segment3D_orderedCopy}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Segment3D_attributes[] = {
    { "mA", _wrap_Segment3D_mA_get, _wrap_Segment3D_mA_set},
    { "mB", _wrap_Segment3D_mB_get, _wrap_Segment3D_mB_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Segment3D_bases[] = {0};
static const char *swig_Procedural_Segment3D_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Segment3D = { "Segment3D", &SWIGTYPE_p_Procedural__Segment3D,_wrap_new_Segment3D, swig_delete_Segment3D, swig_Procedural_Segment3D_methods, swig_Procedural_Segment3D_attributes, swig_Procedural_Segment3D_bases, swig_Procedural_Segment3D_base_names };

static int _wrap_Triangle2D_mPoints_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangle2D *arg1 = (Procedural::Triangle2D *) 0 ;
  Ogre::Vector2 *arg2 ;
  
  SWIG_check_num_args("Procedural::Triangle2D::mPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangle2D::mPoints",1,"Procedural::Triangle2D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangle2D::mPoints",2,"Ogre::Vector2 [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangle2D,0))){
    SWIG_fail_ptr("Triangle2D_mPoints_set",1,SWIGTYPE_p_Procedural__Triangle2D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Triangle2D_mPoints_set",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  {
    size_t ii;
    Ogre::Vector2 *b = (Ogre::Vector2 *) arg1->mPoints;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((Ogre::Vector2 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangle2D_mPoints_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangle2D *arg1 = (Procedural::Triangle2D *) 0 ;
  Ogre::Vector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangle2D::mPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangle2D::mPoints",1,"Procedural::Triangle2D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangle2D,0))){
    SWIG_fail_ptr("Triangle2D_mPoints_get",1,SWIGTYPE_p_Procedural__Triangle2D);
  }
  
  result = (Ogre::Vector2 *)(Ogre::Vector2 *) ((arg1)->mPoints);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Triangle2D(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector2 *arg1 = 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Ogre::Vector2 *arg3 = 0 ;
  Procedural::Triangle2D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangle2D::Triangle2D",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Triangle2D::Triangle2D",1,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Triangle2D::Triangle2D",2,"Ogre::Vector2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Triangle2D::Triangle2D",3,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Triangle2D",1,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Triangle2D",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("new_Triangle2D",3,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::Triangle2D *)new Procedural::Triangle2D((Ogre::Vector2 const &)*arg1,(Ogre::Vector2 const &)*arg2,(Ogre::Vector2 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangle2D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Triangle2D(void *obj) {
Procedural::Triangle2D *arg1 = (Procedural::Triangle2D *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Triangle2D_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Procedural_Triangle2D_attributes[] = {
    { "mPoints", _wrap_Triangle2D_mPoints_get, _wrap_Triangle2D_mPoints_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Triangle2D_bases[] = {0};
static const char *swig_Procedural_Triangle2D_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Triangle2D = { "Triangle2D", &SWIGTYPE_p_Procedural__Triangle2D,_wrap_new_Triangle2D, swig_delete_Triangle2D, swig_Procedural_Triangle2D_methods, swig_Procedural_Triangle2D_attributes, swig_Procedural_Triangle2D_bases, swig_Procedural_Triangle2D_base_names };

static int _wrap_Triangle3D_mPoints_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangle3D *arg1 = (Procedural::Triangle3D *) 0 ;
  Ogre::Vector3 *arg2 ;
  
  SWIG_check_num_args("Procedural::Triangle3D::mPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangle3D::mPoints",1,"Procedural::Triangle3D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Triangle3D::mPoints",2,"Ogre::Vector3 [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangle3D,0))){
    SWIG_fail_ptr("Triangle3D_mPoints_set",1,SWIGTYPE_p_Procedural__Triangle3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Triangle3D_mPoints_set",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  {
    size_t ii;
    Ogre::Vector3 *b = (Ogre::Vector3 *) arg1->mPoints;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((Ogre::Vector3 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangle3D_mPoints_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangle3D *arg1 = (Procedural::Triangle3D *) 0 ;
  Ogre::Vector3 *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangle3D::mPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangle3D::mPoints",1,"Procedural::Triangle3D *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangle3D,0))){
    SWIG_fail_ptr("Triangle3D_mPoints_get",1,SWIGTYPE_p_Procedural__Triangle3D);
  }
  
  result = (Ogre::Vector3 *)(Ogre::Vector3 *) ((arg1)->mPoints);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Triangle3D(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::Vector3 *arg1 = 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Ogre::Vector3 *arg3 = 0 ;
  Procedural::Triangle3D *result = 0 ;
  
  SWIG_check_num_args("Procedural::Triangle3D::Triangle3D",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::Triangle3D::Triangle3D",1,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Triangle3D::Triangle3D",2,"Ogre::Vector3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Triangle3D::Triangle3D",3,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Triangle3D",1,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Triangle3D",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("new_Triangle3D",3,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::Triangle3D *)new Procedural::Triangle3D((Ogre::Vector3 const &)*arg1,(Ogre::Vector3 const &)*arg2,(Ogre::Vector3 const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Triangle3D,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangle3D_findIntersect(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Triangle3D *arg1 = (Procedural::Triangle3D *) 0 ;
  Procedural::Triangle3D *arg2 = 0 ;
  Procedural::Segment3D *arg3 = 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::Triangle3D::findIntersect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Triangle3D::findIntersect",1,"Procedural::Triangle3D const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Triangle3D::findIntersect",2,"Procedural::Triangle3D const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Triangle3D::findIntersect",3,"Procedural::Segment3D &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Triangle3D,0))){
    SWIG_fail_ptr("Triangle3D_findIntersect",1,SWIGTYPE_p_Procedural__Triangle3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__Triangle3D,0))){
    SWIG_fail_ptr("Triangle3D_findIntersect",2,SWIGTYPE_p_Procedural__Triangle3D);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Procedural__Segment3D,0))){
    SWIG_fail_ptr("Triangle3D_findIntersect",3,SWIGTYPE_p_Procedural__Segment3D);
  }
  
  result = (bool)((Procedural::Triangle3D const *)arg1)->findIntersect((Procedural::Triangle3D const &)*arg2,*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Triangle3D(void *obj) {
Procedural::Triangle3D *arg1 = (Procedural::Triangle3D *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Triangle3D_methods[] = {
    {"findIntersect", _wrap_Triangle3D_findIntersect}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Triangle3D_attributes[] = {
    { "mPoints", _wrap_Triangle3D_mPoints_get, _wrap_Triangle3D_mPoints_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Triangle3D_bases[] = {0};
static const char *swig_Procedural_Triangle3D_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_Triangle3D = { "Triangle3D", &SWIGTYPE_p_Procedural__Triangle3D,_wrap_new_Triangle3D, swig_delete_Triangle3D, swig_Procedural_Triangle3D_methods, swig_Procedural_Triangle3D_attributes, swig_Procedural_Triangle3D_bases, swig_Procedural_Triangle3D_base_names };

static int _wrap_IntVector2_x_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IntVector2 *arg1 = (Procedural::IntVector2 *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Procedural::IntVector2::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IntVector2::x",1,"Procedural::IntVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::IntVector2::x",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IntVector2,0))){
    SWIG_fail_ptr("IntVector2_x_set",1,SWIGTYPE_p_Procedural__IntVector2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntVector2_x_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IntVector2 *arg1 = (Procedural::IntVector2 *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Procedural::IntVector2::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IntVector2::x",1,"Procedural::IntVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IntVector2,0))){
    SWIG_fail_ptr("IntVector2_x_get",1,SWIGTYPE_p_Procedural__IntVector2);
  }
  
  result =  ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntVector2_y_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IntVector2 *arg1 = (Procedural::IntVector2 *) 0 ;
  size_t arg2 ;
  
  SWIG_check_num_args("Procedural::IntVector2::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IntVector2::y",1,"Procedural::IntVector2 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::IntVector2::y",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IntVector2,0))){
    SWIG_fail_ptr("IntVector2_y_set",1,SWIGTYPE_p_Procedural__IntVector2);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntVector2_y_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IntVector2 *arg1 = (Procedural::IntVector2 *) 0 ;
  size_t result;
  
  SWIG_check_num_args("Procedural::IntVector2::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::IntVector2::y",1,"Procedural::IntVector2 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__IntVector2,0))){
    SWIG_fail_ptr("IntVector2_y_get",1,SWIGTYPE_p_Procedural__IntVector2);
  }
  
  result =  ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IntVector2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::IntVector2 *result = 0 ;
  
  SWIG_check_num_args("Procedural::IntVector2::IntVector2",0,0)
  result = (Procedural::IntVector2 *)new Procedural::IntVector2();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__IntVector2,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IntVector2(void *obj) {
Procedural::IntVector2 *arg1 = (Procedural::IntVector2 *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_IntVector2_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Procedural_IntVector2_attributes[] = {
    { "x", _wrap_IntVector2_x_get, _wrap_IntVector2_x_set},
    { "y", _wrap_IntVector2_y_get, _wrap_IntVector2_y_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_IntVector2_bases[] = {0};
static const char *swig_Procedural_IntVector2_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_IntVector2 = { "IntVector2", &SWIGTYPE_p_Procedural__IntVector2,_wrap_new_IntVector2, swig_delete_IntVector2, swig_Procedural_IntVector2_methods, swig_Procedural_IntVector2_attributes, swig_Procedural_IntVector2_bases, swig_Procedural_IntVector2_base_names };

static int _wrap_new_SpherifyModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpherifyModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpherifyModifier::SpherifyModifier",0,0)
  result = (Procedural::SpherifyModifier *)new Procedural::SpherifyModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpherifyModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpherifyModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpherifyModifier *arg1 = (Procedural::SpherifyModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::SpherifyModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpherifyModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpherifyModifier::setInputTriangleBuffer",1,"Procedural::SpherifyModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::SpherifyModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpherifyModifier,0))){
    SWIG_fail_ptr("SpherifyModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__SpherifyModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("SpherifyModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::SpherifyModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpherifyModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpherifyModifier_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpherifyModifier *arg1 = (Procedural::SpherifyModifier *) 0 ;
  Ogre::Real arg2 ;
  Procedural::SpherifyModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpherifyModifier::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpherifyModifier::setRadius",1,"Procedural::SpherifyModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::SpherifyModifier::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpherifyModifier,0))){
    SWIG_fail_ptr("SpherifyModifier_setRadius",1,SWIGTYPE_p_Procedural__SpherifyModifier);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::SpherifyModifier *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpherifyModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpherifyModifier_setCenter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpherifyModifier *arg1 = (Procedural::SpherifyModifier *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::SpherifyModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SpherifyModifier::setCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpherifyModifier::setCenter",1,"Procedural::SpherifyModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::SpherifyModifier::setCenter",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpherifyModifier,0))){
    SWIG_fail_ptr("SpherifyModifier_setCenter",1,SWIGTYPE_p_Procedural__SpherifyModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("SpherifyModifier_setCenter",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::SpherifyModifier *) &(arg1)->setCenter(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SpherifyModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpherifyModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SpherifyModifier *arg1 = (Procedural::SpherifyModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::SpherifyModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SpherifyModifier::modify",1,"Procedural::SpherifyModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SpherifyModifier,0))){
    SWIG_fail_ptr("SpherifyModifier_modify",1,SWIGTYPE_p_Procedural__SpherifyModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SpherifyModifier(void *obj) {
Procedural::SpherifyModifier *arg1 = (Procedural::SpherifyModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_SpherifyModifier_methods[] = {
    {"setInputTriangleBuffer", _wrap_SpherifyModifier_setInputTriangleBuffer}, 
    {"setRadius", _wrap_SpherifyModifier_setRadius}, 
    {"setCenter", _wrap_SpherifyModifier_setCenter}, 
    {"modify", _wrap_SpherifyModifier_modify}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_SpherifyModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_SpherifyModifier_bases[] = {0};
static const char *swig_Procedural_SpherifyModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_SpherifyModifier = { "SpherifyModifier", &SWIGTYPE_p_Procedural__SpherifyModifier,_wrap_new_SpherifyModifier, swig_delete_SpherifyModifier, swig_Procedural_SpherifyModifier_methods, swig_Procedural_SpherifyModifier_attributes, swig_Procedural_SpherifyModifier_bases, swig_Procedural_SpherifyModifier_base_names };

static int _wrap_new_CalculateNormalsModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::CalculateNormalsModifier",0,0)
  result = (Procedural::CalculateNormalsModifier *)new Procedural::CalculateNormalsModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CalculateNormalsModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mComputeMode_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::CalculateNormalsModifier::NormalComputeMode arg2 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mComputeMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mComputeMode",1,"Procedural::CalculateNormalsModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mComputeMode",2,"Procedural::CalculateNormalsModifier::NormalComputeMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mComputeMode_set",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  arg2 = (Procedural::CalculateNormalsModifier::NormalComputeMode)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->mComputeMode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mComputeMode_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::CalculateNormalsModifier::NormalComputeMode result;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mComputeMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mComputeMode",1,"Procedural::CalculateNormalsModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mComputeMode_get",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  result = (Procedural::CalculateNormalsModifier::NormalComputeMode) ((arg1)->mComputeMode);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mInputTriangleBuffer_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mInputTriangleBuffer",1,"Procedural::CalculateNormalsModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mInputTriangleBuffer_set",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("CalculateNormalsModifier_mInputTriangleBuffer_set",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  if (arg1) (arg1)->mInputTriangleBuffer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mInputTriangleBuffer_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mInputTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mInputTriangleBuffer",1,"Procedural::CalculateNormalsModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mInputTriangleBuffer_get",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  result = (Procedural::TriangleBuffer *) ((arg1)->mInputTriangleBuffer);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mMustWeldUnweldFirst_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mMustWeldUnweldFirst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mMustWeldUnweldFirst",1,"Procedural::CalculateNormalsModifier *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mMustWeldUnweldFirst",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mMustWeldUnweldFirst_set",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->mMustWeldUnweldFirst = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_mMustWeldUnweldFirst_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  bool result;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::mMustWeldUnweldFirst",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::mMustWeldUnweldFirst",1,"Procedural::CalculateNormalsModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_mMustWeldUnweldFirst_get",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  result = (bool) ((arg1)->mMustWeldUnweldFirst);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_setComputeMode(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::CalculateNormalsModifier::NormalComputeMode arg2 ;
  Procedural::CalculateNormalsModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::setComputeMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setComputeMode",1,"Procedural::CalculateNormalsModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setComputeMode",2,"Procedural::CalculateNormalsModifier::NormalComputeMode");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_setComputeMode",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  arg2 = (Procedural::CalculateNormalsModifier::NormalComputeMode)(int)lua_tonumber(L, 2);
  result = (Procedural::CalculateNormalsModifier *) &(arg1)->setComputeMode(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::CalculateNormalsModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setInputTriangleBuffer",1,"Procedural::CalculateNormalsModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::CalculateNormalsModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_setMustWeldUnweldFirst(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  bool arg2 ;
  Procedural::CalculateNormalsModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::setMustWeldUnweldFirst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setMustWeldUnweldFirst",1,"Procedural::CalculateNormalsModifier *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::setMustWeldUnweldFirst",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_setMustWeldUnweldFirst",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::CalculateNormalsModifier *) &(arg1)->setMustWeldUnweldFirst(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CalculateNormalsModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::CalculateNormalsModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CalculateNormalsModifier::modify",1,"Procedural::CalculateNormalsModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CalculateNormalsModifier,0))){
    SWIG_fail_ptr("CalculateNormalsModifier_modify",1,SWIGTYPE_p_Procedural__CalculateNormalsModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CalculateNormalsModifier(void *obj) {
Procedural::CalculateNormalsModifier *arg1 = (Procedural::CalculateNormalsModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CalculateNormalsModifier_methods[] = {
    {"setComputeMode", _wrap_CalculateNormalsModifier_setComputeMode}, 
    {"setInputTriangleBuffer", _wrap_CalculateNormalsModifier_setInputTriangleBuffer}, 
    {"setMustWeldUnweldFirst", _wrap_CalculateNormalsModifier_setMustWeldUnweldFirst}, 
    {"modify", _wrap_CalculateNormalsModifier_modify}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CalculateNormalsModifier_attributes[] = {
    { "mComputeMode", _wrap_CalculateNormalsModifier_mComputeMode_get, _wrap_CalculateNormalsModifier_mComputeMode_set},
    { "mInputTriangleBuffer", _wrap_CalculateNormalsModifier_mInputTriangleBuffer_get, _wrap_CalculateNormalsModifier_mInputTriangleBuffer_set},
    { "mMustWeldUnweldFirst", _wrap_CalculateNormalsModifier_mMustWeldUnweldFirst_get, _wrap_CalculateNormalsModifier_mMustWeldUnweldFirst_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CalculateNormalsModifier_bases[] = {0};
static const char *swig_Procedural_CalculateNormalsModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_CalculateNormalsModifier = { "CalculateNormalsModifier", &SWIGTYPE_p_Procedural__CalculateNormalsModifier,_wrap_new_CalculateNormalsModifier, swig_delete_CalculateNormalsModifier, swig_Procedural_CalculateNormalsModifier_methods, swig_Procedural_CalculateNormalsModifier_attributes, swig_Procedural_CalculateNormalsModifier_bases, swig_Procedural_CalculateNormalsModifier_base_names };

static int _wrap_new_WeldVerticesModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::WeldVerticesModifier",0,0)
  result = (Procedural::WeldVerticesModifier *)new Procedural::WeldVerticesModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__WeldVerticesModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_mInputTriangleBuffer_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::mInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mInputTriangleBuffer",1,"Procedural::WeldVerticesModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_mInputTriangleBuffer_set",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("WeldVerticesModifier_mInputTriangleBuffer_set",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  if (arg1) (arg1)->mInputTriangleBuffer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_mInputTriangleBuffer_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::mInputTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mInputTriangleBuffer",1,"Procedural::WeldVerticesModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_mInputTriangleBuffer_get",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  result = (Procedural::TriangleBuffer *) ((arg1)->mInputTriangleBuffer);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_mTolerance_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::mTolerance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mTolerance",1,"Procedural::WeldVerticesModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mTolerance",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_mTolerance_set",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  if (arg1) (arg1)->mTolerance = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_mTolerance_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::mTolerance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::mTolerance",1,"Procedural::WeldVerticesModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_mTolerance_get",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  result = (Ogre::Real) ((arg1)->mTolerance);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::WeldVerticesModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::setInputTriangleBuffer",1,"Procedural::WeldVerticesModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::WeldVerticesModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("WeldVerticesModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::WeldVerticesModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__WeldVerticesModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_setTolerance(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  Ogre::Real arg2 ;
  Procedural::WeldVerticesModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::setTolerance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::setTolerance",1,"Procedural::WeldVerticesModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::WeldVerticesModifier::setTolerance",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_setTolerance",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::WeldVerticesModifier *) &(arg1)->setTolerance(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__WeldVerticesModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WeldVerticesModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::WeldVerticesModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WeldVerticesModifier::modify",1,"Procedural::WeldVerticesModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WeldVerticesModifier,0))){
    SWIG_fail_ptr("WeldVerticesModifier_modify",1,SWIGTYPE_p_Procedural__WeldVerticesModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_WeldVerticesModifier(void *obj) {
Procedural::WeldVerticesModifier *arg1 = (Procedural::WeldVerticesModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_WeldVerticesModifier_methods[] = {
    {"setInputTriangleBuffer", _wrap_WeldVerticesModifier_setInputTriangleBuffer}, 
    {"setTolerance", _wrap_WeldVerticesModifier_setTolerance}, 
    {"modify", _wrap_WeldVerticesModifier_modify}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_WeldVerticesModifier_attributes[] = {
    { "mInputTriangleBuffer", _wrap_WeldVerticesModifier_mInputTriangleBuffer_get, _wrap_WeldVerticesModifier_mInputTriangleBuffer_set},
    { "mTolerance", _wrap_WeldVerticesModifier_mTolerance_get, _wrap_WeldVerticesModifier_mTolerance_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_WeldVerticesModifier_bases[] = {0};
static const char *swig_Procedural_WeldVerticesModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_WeldVerticesModifier = { "WeldVerticesModifier", &SWIGTYPE_p_Procedural__WeldVerticesModifier,_wrap_new_WeldVerticesModifier, swig_delete_WeldVerticesModifier, swig_Procedural_WeldVerticesModifier_methods, swig_Procedural_WeldVerticesModifier_attributes, swig_Procedural_WeldVerticesModifier_bases, swig_Procedural_WeldVerticesModifier_base_names };

static int _wrap_new_UnweldVerticesModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::UnweldVerticesModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::UnweldVerticesModifier::UnweldVerticesModifier",0,0)
  result = (Procedural::UnweldVerticesModifier *)new Procedural::UnweldVerticesModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__UnweldVerticesModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnweldVerticesModifier_mInputTriangleBuffer_set(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::UnweldVerticesModifier *arg1 = (Procedural::UnweldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  
  SWIG_check_num_args("Procedural::UnweldVerticesModifier::mInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::mInputTriangleBuffer",1,"Procedural::UnweldVerticesModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::mInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__UnweldVerticesModifier,0))){
    SWIG_fail_ptr("UnweldVerticesModifier_mInputTriangleBuffer_set",1,SWIGTYPE_p_Procedural__UnweldVerticesModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("UnweldVerticesModifier_mInputTriangleBuffer_set",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  if (arg1) (arg1)->mInputTriangleBuffer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnweldVerticesModifier_mInputTriangleBuffer_get(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::UnweldVerticesModifier *arg1 = (Procedural::UnweldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::UnweldVerticesModifier::mInputTriangleBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::mInputTriangleBuffer",1,"Procedural::UnweldVerticesModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__UnweldVerticesModifier,0))){
    SWIG_fail_ptr("UnweldVerticesModifier_mInputTriangleBuffer_get",1,SWIGTYPE_p_Procedural__UnweldVerticesModifier);
  }
  
  result = (Procedural::TriangleBuffer *) ((arg1)->mInputTriangleBuffer);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TriangleBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnweldVerticesModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::UnweldVerticesModifier *arg1 = (Procedural::UnweldVerticesModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::UnweldVerticesModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::UnweldVerticesModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::setInputTriangleBuffer",1,"Procedural::UnweldVerticesModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__UnweldVerticesModifier,0))){
    SWIG_fail_ptr("UnweldVerticesModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__UnweldVerticesModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("UnweldVerticesModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::UnweldVerticesModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__UnweldVerticesModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnweldVerticesModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::UnweldVerticesModifier *arg1 = (Procedural::UnweldVerticesModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::UnweldVerticesModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::UnweldVerticesModifier::modify",1,"Procedural::UnweldVerticesModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__UnweldVerticesModifier,0))){
    SWIG_fail_ptr("UnweldVerticesModifier_modify",1,SWIGTYPE_p_Procedural__UnweldVerticesModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_UnweldVerticesModifier(void *obj) {
Procedural::UnweldVerticesModifier *arg1 = (Procedural::UnweldVerticesModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_UnweldVerticesModifier_methods[] = {
    {"setInputTriangleBuffer", _wrap_UnweldVerticesModifier_setInputTriangleBuffer}, 
    {"modify", _wrap_UnweldVerticesModifier_modify}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_UnweldVerticesModifier_attributes[] = {
    { "mInputTriangleBuffer", _wrap_UnweldVerticesModifier_mInputTriangleBuffer_get, _wrap_UnweldVerticesModifier_mInputTriangleBuffer_set},
    {0,0,0}
};
static swig_lua_class *swig_Procedural_UnweldVerticesModifier_bases[] = {0};
static const char *swig_Procedural_UnweldVerticesModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_UnweldVerticesModifier = { "UnweldVerticesModifier", &SWIGTYPE_p_Procedural__UnweldVerticesModifier,_wrap_new_UnweldVerticesModifier, swig_delete_UnweldVerticesModifier, swig_Procedural_UnweldVerticesModifier_methods, swig_Procedural_UnweldVerticesModifier_attributes, swig_Procedural_UnweldVerticesModifier_bases, swig_Procedural_UnweldVerticesModifier_base_names };

static int _wrap_new_PlaneUVModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::PlaneUVModifier",0,0)
  result = (Procedural::PlaneUVModifier *)new Procedural::PlaneUVModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneUVModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneUVModifier_setPlaneNormal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::PlaneUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::setPlaneNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneNormal",1,"Procedural::PlaneUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneNormal",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneUVModifier,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneNormal",1,SWIGTYPE_p_Procedural__PlaneUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneNormal",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::PlaneUVModifier *) &(arg1)->setPlaneNormal((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneUVModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::PlaneUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneUVModifier::setInputTriangleBuffer",1,"Procedural::PlaneUVModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::PlaneUVModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneUVModifier,0))){
    SWIG_fail_ptr("PlaneUVModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__PlaneUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("PlaneUVModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::PlaneUVModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneUVModifier_setPlaneCenter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::PlaneUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::setPlaneCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneCenter",1,"Procedural::PlaneUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneCenter",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneUVModifier,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneCenter",1,SWIGTYPE_p_Procedural__PlaneUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneCenter",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::PlaneUVModifier *) &(arg1)->setPlaneCenter((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneUVModifier_setPlaneSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) 0 ;
  Ogre::Vector2 *arg2 = 0 ;
  Procedural::PlaneUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::setPlaneSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneSize",1,"Procedural::PlaneUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::PlaneUVModifier::setPlaneSize",2,"Ogre::Vector2 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneUVModifier,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneSize",1,SWIGTYPE_p_Procedural__PlaneUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("PlaneUVModifier_setPlaneSize",2,SWIGTYPE_p_Ogre__Vector2);
  }
  
  result = (Procedural::PlaneUVModifier *) &(arg1)->setPlaneSize((Ogre::Vector2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PlaneUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PlaneUVModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::PlaneUVModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PlaneUVModifier::modify",1,"Procedural::PlaneUVModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PlaneUVModifier,0))){
    SWIG_fail_ptr("PlaneUVModifier_modify",1,SWIGTYPE_p_Procedural__PlaneUVModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PlaneUVModifier(void *obj) {
Procedural::PlaneUVModifier *arg1 = (Procedural::PlaneUVModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_PlaneUVModifier_methods[] = {
    {"setPlaneNormal", _wrap_PlaneUVModifier_setPlaneNormal}, 
    {"setInputTriangleBuffer", _wrap_PlaneUVModifier_setInputTriangleBuffer}, 
    {"setPlaneCenter", _wrap_PlaneUVModifier_setPlaneCenter}, 
    {"setPlaneSize", _wrap_PlaneUVModifier_setPlaneSize}, 
    {"modify", _wrap_PlaneUVModifier_modify}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_PlaneUVModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_PlaneUVModifier_bases[] = {0};
static const char *swig_Procedural_PlaneUVModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_PlaneUVModifier = { "PlaneUVModifier", &SWIGTYPE_p_Procedural__PlaneUVModifier,_wrap_new_PlaneUVModifier, swig_delete_PlaneUVModifier, swig_Procedural_PlaneUVModifier_methods, swig_Procedural_PlaneUVModifier_attributes, swig_Procedural_PlaneUVModifier_bases, swig_Procedural_PlaneUVModifier_base_names };

static int _wrap_SphereUVModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereUVModifier *arg1 = (Procedural::SphereUVModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::SphereUVModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereUVModifier::modify",1,"Procedural::SphereUVModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereUVModifier,0))){
    SWIG_fail_ptr("SphereUVModifier_modify",1,SWIGTYPE_p_Procedural__SphereUVModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SphereUVModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereUVModifier::SphereUVModifier",0,0)
  result = (Procedural::SphereUVModifier *)new Procedural::SphereUVModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereUVModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SphereUVModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::SphereUVModifier *arg1 = (Procedural::SphereUVModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::SphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::SphereUVModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::SphereUVModifier::setInputTriangleBuffer",1,"Procedural::SphereUVModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::SphereUVModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__SphereUVModifier,0))){
    SWIG_fail_ptr("SphereUVModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__SphereUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("SphereUVModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::SphereUVModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__SphereUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SphereUVModifier(void *obj) {
Procedural::SphereUVModifier *arg1 = (Procedural::SphereUVModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_SphereUVModifier_methods[] = {
    {"modify", _wrap_SphereUVModifier_modify}, 
    {"setInputTriangleBuffer", _wrap_SphereUVModifier_setInputTriangleBuffer}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_SphereUVModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_SphereUVModifier_bases[] = {0};
static const char *swig_Procedural_SphereUVModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_SphereUVModifier = { "SphereUVModifier", &SWIGTYPE_p_Procedural__SphereUVModifier,_wrap_new_SphereUVModifier, swig_delete_SphereUVModifier, swig_Procedural_SphereUVModifier_methods, swig_Procedural_SphereUVModifier_attributes, swig_Procedural_SphereUVModifier_bases, swig_Procedural_SphereUVModifier_base_names };

static int _wrap_HemisphereUVModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HemisphereUVModifier *arg1 = (Procedural::HemisphereUVModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::HemisphereUVModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HemisphereUVModifier::modify",1,"Procedural::HemisphereUVModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HemisphereUVModifier,0))){
    SWIG_fail_ptr("HemisphereUVModifier_modify",1,SWIGTYPE_p_Procedural__HemisphereUVModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_HemisphereUVModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HemisphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::HemisphereUVModifier::HemisphereUVModifier",0,0)
  result = (Procedural::HemisphereUVModifier *)new Procedural::HemisphereUVModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HemisphereUVModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HemisphereUVModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HemisphereUVModifier *arg1 = (Procedural::HemisphereUVModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::HemisphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::HemisphereUVModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setInputTriangleBuffer",1,"Procedural::HemisphereUVModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HemisphereUVModifier,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__HemisphereUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::HemisphereUVModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HemisphereUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HemisphereUVModifier_setTextureRectangleTop(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HemisphereUVModifier *arg1 = (Procedural::HemisphereUVModifier *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::HemisphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::HemisphereUVModifier::setTextureRectangleTop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setTextureRectangleTop",1,"Procedural::HemisphereUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setTextureRectangleTop",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HemisphereUVModifier,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setTextureRectangleTop",1,SWIGTYPE_p_Procedural__HemisphereUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setTextureRectangleTop",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::HemisphereUVModifier *) &(arg1)->setTextureRectangleTop((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HemisphereUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HemisphereUVModifier_setTextureRectangleBottom(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::HemisphereUVModifier *arg1 = (Procedural::HemisphereUVModifier *) 0 ;
  Ogre::RealRect *arg2 = 0 ;
  Procedural::HemisphereUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::HemisphereUVModifier::setTextureRectangleBottom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setTextureRectangleBottom",1,"Procedural::HemisphereUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::HemisphereUVModifier::setTextureRectangleBottom",2,"Ogre::RealRect const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__HemisphereUVModifier,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setTextureRectangleBottom",1,SWIGTYPE_p_Procedural__HemisphereUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("HemisphereUVModifier_setTextureRectangleBottom",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  
  result = (Procedural::HemisphereUVModifier *) &(arg1)->setTextureRectangleBottom((Ogre::RealRect const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__HemisphereUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_HemisphereUVModifier(void *obj) {
Procedural::HemisphereUVModifier *arg1 = (Procedural::HemisphereUVModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_HemisphereUVModifier_methods[] = {
    {"modify", _wrap_HemisphereUVModifier_modify}, 
    {"setInputTriangleBuffer", _wrap_HemisphereUVModifier_setInputTriangleBuffer}, 
    {"setTextureRectangleTop", _wrap_HemisphereUVModifier_setTextureRectangleTop}, 
    {"setTextureRectangleBottom", _wrap_HemisphereUVModifier_setTextureRectangleBottom}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_HemisphereUVModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_HemisphereUVModifier_bases[] = {0};
static const char *swig_Procedural_HemisphereUVModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_HemisphereUVModifier = { "HemisphereUVModifier", &SWIGTYPE_p_Procedural__HemisphereUVModifier,_wrap_new_HemisphereUVModifier, swig_delete_HemisphereUVModifier, swig_Procedural_HemisphereUVModifier_methods, swig_Procedural_HemisphereUVModifier_attributes, swig_Procedural_HemisphereUVModifier_bases, swig_Procedural_HemisphereUVModifier_base_names };

static int _wrap_CylinderUVModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderUVModifier *arg1 = (Procedural::CylinderUVModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::CylinderUVModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderUVModifier::modify",1,"Procedural::CylinderUVModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderUVModifier,0))){
    SWIG_fail_ptr("CylinderUVModifier_modify",1,SWIGTYPE_p_Procedural__CylinderUVModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CylinderUVModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderUVModifier::CylinderUVModifier",0,0)
  result = (Procedural::CylinderUVModifier *)new Procedural::CylinderUVModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderUVModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderUVModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderUVModifier *arg1 = (Procedural::CylinderUVModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::CylinderUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderUVModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderUVModifier::setInputTriangleBuffer",1,"Procedural::CylinderUVModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::CylinderUVModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderUVModifier,0))){
    SWIG_fail_ptr("CylinderUVModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__CylinderUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("CylinderUVModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::CylinderUVModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderUVModifier_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderUVModifier *arg1 = (Procedural::CylinderUVModifier *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderUVModifier::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderUVModifier::setRadius",1,"Procedural::CylinderUVModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderUVModifier::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderUVModifier,0))){
    SWIG_fail_ptr("CylinderUVModifier_setRadius",1,SWIGTYPE_p_Procedural__CylinderUVModifier);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderUVModifier *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CylinderUVModifier_setHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CylinderUVModifier *arg1 = (Procedural::CylinderUVModifier *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CylinderUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::CylinderUVModifier::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CylinderUVModifier::setHeight",1,"Procedural::CylinderUVModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CylinderUVModifier::setHeight",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CylinderUVModifier,0))){
    SWIG_fail_ptr("CylinderUVModifier_setHeight",1,SWIGTYPE_p_Procedural__CylinderUVModifier);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CylinderUVModifier *) &(arg1)->setHeight(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CylinderUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CylinderUVModifier(void *obj) {
Procedural::CylinderUVModifier *arg1 = (Procedural::CylinderUVModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CylinderUVModifier_methods[] = {
    {"modify", _wrap_CylinderUVModifier_modify}, 
    {"setInputTriangleBuffer", _wrap_CylinderUVModifier_setInputTriangleBuffer}, 
    {"setRadius", _wrap_CylinderUVModifier_setRadius}, 
    {"setHeight", _wrap_CylinderUVModifier_setHeight}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CylinderUVModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CylinderUVModifier_bases[] = {0};
static const char *swig_Procedural_CylinderUVModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_CylinderUVModifier = { "CylinderUVModifier", &SWIGTYPE_p_Procedural__CylinderUVModifier,_wrap_new_CylinderUVModifier, swig_delete_CylinderUVModifier, swig_Procedural_CylinderUVModifier_methods, swig_Procedural_CylinderUVModifier_attributes, swig_Procedural_CylinderUVModifier_bases, swig_Procedural_CylinderUVModifier_base_names };

static int _wrap_BoxUVModifier_modify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::modify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxUVModifier::modify",1,"Procedural::BoxUVModifier *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxUVModifier,0))){
    SWIG_fail_ptr("BoxUVModifier_modify",1,SWIGTYPE_p_Procedural__BoxUVModifier);
  }
  
  (arg1)->modify();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BoxUVModifier(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::BoxUVModifier",0,0)
  result = (Procedural::BoxUVModifier *)new Procedural::BoxUVModifier();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxUVModifier,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxUVModifier_setInputTriangleBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) 0 ;
  Procedural::TriangleBuffer *arg2 = (Procedural::TriangleBuffer *) 0 ;
  Procedural::BoxUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::setInputTriangleBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxUVModifier::setInputTriangleBuffer",1,"Procedural::BoxUVModifier *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::BoxUVModifier::setInputTriangleBuffer",2,"Procedural::TriangleBuffer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxUVModifier,0))){
    SWIG_fail_ptr("BoxUVModifier_setInputTriangleBuffer",1,SWIGTYPE_p_Procedural__BoxUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TriangleBuffer,0))){
    SWIG_fail_ptr("BoxUVModifier_setInputTriangleBuffer",2,SWIGTYPE_p_Procedural__TriangleBuffer);
  }
  
  result = (Procedural::BoxUVModifier *) &(arg1)->setInputTriangleBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxUVModifier_setBoxSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::BoxUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::setBoxSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxUVModifier::setBoxSize",1,"Procedural::BoxUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BoxUVModifier::setBoxSize",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxUVModifier,0))){
    SWIG_fail_ptr("BoxUVModifier_setBoxSize",1,SWIGTYPE_p_Procedural__BoxUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("BoxUVModifier_setBoxSize",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::BoxUVModifier *) &(arg1)->setBoxSize((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxUVModifier_setBoxCenter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) 0 ;
  Ogre::Vector3 *arg2 = 0 ;
  Procedural::BoxUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::setBoxCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxUVModifier::setBoxCenter",1,"Procedural::BoxUVModifier *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::BoxUVModifier::setBoxCenter",2,"Ogre::Vector3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxUVModifier,0))){
    SWIG_fail_ptr("BoxUVModifier_setBoxCenter",1,SWIGTYPE_p_Procedural__BoxUVModifier);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("BoxUVModifier_setBoxCenter",2,SWIGTYPE_p_Ogre__Vector3);
  }
  
  result = (Procedural::BoxUVModifier *) &(arg1)->setBoxCenter((Ogre::Vector3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BoxUVModifier_setMappingType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) 0 ;
  Procedural::BoxUVModifier::MappingType arg2 ;
  Procedural::BoxUVModifier *result = 0 ;
  
  SWIG_check_num_args("Procedural::BoxUVModifier::setMappingType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::BoxUVModifier::setMappingType",1,"Procedural::BoxUVModifier *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::BoxUVModifier::setMappingType",2,"Procedural::BoxUVModifier::MappingType");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__BoxUVModifier,0))){
    SWIG_fail_ptr("BoxUVModifier_setMappingType",1,SWIGTYPE_p_Procedural__BoxUVModifier);
  }
  
  arg2 = (Procedural::BoxUVModifier::MappingType)(int)lua_tonumber(L, 2);
  result = (Procedural::BoxUVModifier *) &(arg1)->setMappingType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__BoxUVModifier,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BoxUVModifier(void *obj) {
Procedural::BoxUVModifier *arg1 = (Procedural::BoxUVModifier *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_BoxUVModifier_methods[] = {
    {"modify", _wrap_BoxUVModifier_modify}, 
    {"setInputTriangleBuffer", _wrap_BoxUVModifier_setInputTriangleBuffer}, 
    {"setBoxSize", _wrap_BoxUVModifier_setBoxSize}, 
    {"setBoxCenter", _wrap_BoxUVModifier_setBoxCenter}, 
    {"setMappingType", _wrap_BoxUVModifier_setMappingType}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_BoxUVModifier_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_BoxUVModifier_bases[] = {0};
static const char *swig_Procedural_BoxUVModifier_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_BoxUVModifier = { "BoxUVModifier", &SWIGTYPE_p_Procedural__BoxUVModifier,_wrap_new_BoxUVModifier, swig_delete_BoxUVModifier, swig_Procedural_BoxUVModifier_methods, swig_Procedural_BoxUVModifier_attributes, swig_Procedural_BoxUVModifier_bases, swig_Procedural_BoxUVModifier_base_names };

static int _wrap_NoiseBase_function1D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::NoiseBase *arg1 = (Procedural::NoiseBase *) 0 ;
  size_t arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::NoiseBase::function1D",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::NoiseBase::function1D",1,"Procedural::NoiseBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::NoiseBase::function1D",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__NoiseBase,0))){
    SWIG_fail_ptr("NoiseBase_function1D",1,SWIGTYPE_p_Procedural__NoiseBase);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Ogre::Real)(arg1)->function1D(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NoiseBase_function2D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::NoiseBase *arg1 = (Procedural::NoiseBase *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::NoiseBase::function2D",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::NoiseBase::function2D",1,"Procedural::NoiseBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::NoiseBase::function2D",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::NoiseBase::function2D",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__NoiseBase,0))){
    SWIG_fail_ptr("NoiseBase_function2D",1,SWIGTYPE_p_Procedural__NoiseBase);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)(arg1)->function2D(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NoiseBase_field1D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::NoiseBase *arg1 = (Procedural::NoiseBase *) 0 ;
  size_t arg2 ;
  Ogre::uchar *result = 0 ;
  
  SWIG_check_num_args("Procedural::NoiseBase::field1D",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::NoiseBase::field1D",1,"Procedural::NoiseBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::NoiseBase::field1D",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__NoiseBase,0))){
    SWIG_fail_ptr("NoiseBase_field1D",1,SWIGTYPE_p_Procedural__NoiseBase);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Ogre::uchar *)(arg1)->field1D(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NoiseBase_field2D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::NoiseBase *arg1 = (Procedural::NoiseBase *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar *result = 0 ;
  
  SWIG_check_num_args("Procedural::NoiseBase::field2D",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::NoiseBase::field2D",1,"Procedural::NoiseBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::NoiseBase::field2D",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::NoiseBase::field2D",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__NoiseBase,0))){
    SWIG_fail_ptr("NoiseBase_field2D",1,SWIGTYPE_p_Procedural__NoiseBase);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::uchar *)(arg1)->field2D(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NoiseBase(void *obj) {
Procedural::NoiseBase *arg1 = (Procedural::NoiseBase *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_NoiseBase_methods[] = {
    {"function1D", _wrap_NoiseBase_function1D}, 
    {"function2D", _wrap_NoiseBase_function2D}, 
    {"field1D", _wrap_NoiseBase_field1D}, 
    {"field2D", _wrap_NoiseBase_field2D}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_NoiseBase_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_NoiseBase_bases[] = {0};
static const char *swig_Procedural_NoiseBase_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_NoiseBase = { "NoiseBase", &SWIGTYPE_p_Procedural__NoiseBase,0, swig_delete_NoiseBase, swig_Procedural_NoiseBase_methods, swig_Procedural_NoiseBase_attributes, swig_Procedural_NoiseBase_bases, swig_Procedural_NoiseBase_base_names };

static int _wrap_new_WhiteNoise__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Procedural::WhiteNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::WhiteNoise::WhiteNoise",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::WhiteNoise::WhiteNoise",1,"Ogre::uint");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  result = (Procedural::WhiteNoise *)new Procedural::WhiteNoise(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__WhiteNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_WhiteNoise__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WhiteNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::WhiteNoise::WhiteNoise",0,0)
  result = (Procedural::WhiteNoise *)new Procedural::WhiteNoise();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__WhiteNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_WhiteNoise(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_WhiteNoise__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_WhiteNoise__SWIG_0(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_WhiteNoise'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::WhiteNoise::WhiteNoise(Ogre::uint)\n"
    "    Procedural::WhiteNoise::WhiteNoise()\n");
  lua_error(L);return 0;
}


static int _wrap_WhiteNoise_function1D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WhiteNoise *arg1 = (Procedural::WhiteNoise *) 0 ;
  size_t arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::WhiteNoise::function1D",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WhiteNoise::function1D",1,"Procedural::WhiteNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::WhiteNoise::function1D",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WhiteNoise,0))){
    SWIG_fail_ptr("WhiteNoise_function1D",1,SWIGTYPE_p_Procedural__WhiteNoise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Ogre::Real)(arg1)->function1D(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WhiteNoise_function2D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::WhiteNoise *arg1 = (Procedural::WhiteNoise *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::WhiteNoise::function2D",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::WhiteNoise::function2D",1,"Procedural::WhiteNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::WhiteNoise::function2D",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::WhiteNoise::function2D",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__WhiteNoise,0))){
    SWIG_fail_ptr("WhiteNoise_function2D",1,SWIGTYPE_p_Procedural__WhiteNoise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)(arg1)->function2D(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_WhiteNoise(void *obj) {
Procedural::WhiteNoise *arg1 = (Procedural::WhiteNoise *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_WhiteNoise_methods[] = {
    {"function1D", _wrap_WhiteNoise_function1D}, 
    {"function2D", _wrap_WhiteNoise_function2D}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_WhiteNoise_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_WhiteNoise_bases[] = {0,0};
static const char *swig_Procedural_WhiteNoise_base_names[] = {"Procedural::NoiseBase *",0};
static swig_lua_class _wrap_class_Procedural_WhiteNoise = { "WhiteNoise", &SWIGTYPE_p_Procedural__WhiteNoise,_wrap_new_WhiteNoise, swig_delete_WhiteNoise, swig_Procedural_WhiteNoise_methods, swig_Procedural_WhiteNoise_attributes, swig_Procedural_WhiteNoise_bases, swig_Procedural_WhiteNoise_base_names };

static int _wrap_new_PerlinNoise__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::PerlinNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::PerlinNoise",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",1,"Ogre::uint");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",4,"Ogre::Real");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::PerlinNoise *)new Procedural::PerlinNoise(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PerlinNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PerlinNoise__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::PerlinNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::PerlinNoise",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",1,"Ogre::uint");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",3,"Ogre::Real");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::PerlinNoise *)new Procedural::PerlinNoise(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PerlinNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PerlinNoise__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Ogre::Real arg2 ;
  Procedural::PerlinNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::PerlinNoise",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",1,"Ogre::uint");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",2,"Ogre::Real");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::PerlinNoise *)new Procedural::PerlinNoise(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PerlinNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PerlinNoise__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Procedural::PerlinNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::PerlinNoise",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::PerlinNoise",1,"Ogre::uint");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  result = (Procedural::PerlinNoise *)new Procedural::PerlinNoise(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PerlinNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PerlinNoise__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *result = 0 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::PerlinNoise",0,0)
  result = (Procedural::PerlinNoise *)new Procedural::PerlinNoise();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__PerlinNoise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PerlinNoise(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_PerlinNoise__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_PerlinNoise__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_PerlinNoise__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_PerlinNoise__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_PerlinNoise__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_PerlinNoise'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::PerlinNoise::PerlinNoise(Ogre::uint,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::PerlinNoise::PerlinNoise(Ogre::uint,Ogre::Real,Ogre::Real)\n"
    "    Procedural::PerlinNoise::PerlinNoise(Ogre::uint,Ogre::Real)\n"
    "    Procedural::PerlinNoise::PerlinNoise(Ogre::uint)\n"
    "    Procedural::PerlinNoise::PerlinNoise()\n");
  lua_error(L);return 0;
}


static int _wrap_PerlinNoise_setFrequency(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::setFrequency",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::setFrequency",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::setFrequency",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_setFrequency",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  (arg1)->setFrequency(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PerlinNoise_setAmplitude(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::setAmplitude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::setAmplitude",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::setAmplitude",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_setAmplitude",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  (arg1)->setAmplitude(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PerlinNoise_setPersistence(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  Ogre::Real arg2 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::setPersistence",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::setPersistence",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::setPersistence",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_setPersistence",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  (arg1)->setPersistence(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PerlinNoise_setOctaves(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  Ogre::uint arg2 ;
  
  SWIG_check_num_args("Procedural::PerlinNoise::setOctaves",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::setOctaves",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::setOctaves",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_setOctaves",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  (arg1)->setOctaves(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PerlinNoise_function1D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  size_t arg2 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::PerlinNoise::function1D",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::function1D",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::function1D",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_function1D",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Ogre::Real)(arg1)->function1D(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PerlinNoise_function2D(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::PerlinNoise::function2D",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::PerlinNoise::function2D",1,"Procedural::PerlinNoise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::PerlinNoise::function2D",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::PerlinNoise::function2D",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__PerlinNoise,0))){
    SWIG_fail_ptr("PerlinNoise_function2D",1,SWIGTYPE_p_Procedural__PerlinNoise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)(arg1)->function2D(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PerlinNoise(void *obj) {
Procedural::PerlinNoise *arg1 = (Procedural::PerlinNoise *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_PerlinNoise_methods[] = {
    {"setFrequency", _wrap_PerlinNoise_setFrequency}, 
    {"setAmplitude", _wrap_PerlinNoise_setAmplitude}, 
    {"setPersistence", _wrap_PerlinNoise_setPersistence}, 
    {"setOctaves", _wrap_PerlinNoise_setOctaves}, 
    {"function1D", _wrap_PerlinNoise_function1D}, 
    {"function2D", _wrap_PerlinNoise_function2D}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_PerlinNoise_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_PerlinNoise_bases[] = {0,0};
static const char *swig_Procedural_PerlinNoise_base_names[] = {"Procedural::NoiseBase *",0};
static swig_lua_class _wrap_class_Procedural_PerlinNoise = { "PerlinNoise", &SWIGTYPE_p_Procedural__PerlinNoise,_wrap_new_PerlinNoise, swig_delete_PerlinNoise, swig_Procedural_PerlinNoise_methods, swig_Procedural_PerlinNoise_attributes, swig_Procedural_PerlinNoise_bases, swig_Procedural_PerlinNoise_base_names };

static int _wrap_TextureBuffer_setPixel__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::ColourValue arg4 ;
  Ogre::ColourValue *argp4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setPixel",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",3,"size_t");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",4,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",4,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg4 = *argp4;
  
  (arg1)->setPixel(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setPixel__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  Ogre::uchar arg5 ;
  Ogre::uchar arg6 ;
  Ogre::uchar arg7 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setPixel",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",4,"Ogre::uchar");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",5,"Ogre::uchar");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",6,"Ogre::uchar");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",7,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (Ogre::uchar)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (Ogre::uchar)lua_tonumber(L, 6);
  SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (Ogre::uchar)lua_tonumber(L, 7);
  (arg1)->setPixel(arg2,arg3,arg4,arg5,arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setPixel__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  Ogre::uchar arg5 ;
  Ogre::uchar arg6 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setPixel",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",4,"Ogre::uchar");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",5,"Ogre::uchar");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",6,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (Ogre::uchar)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (Ogre::uchar)lua_tonumber(L, 6);
  (arg1)->setPixel(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setPixel__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Ogre::Real arg6 ;
  Ogre::Real arg7 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setPixel",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",6,"Ogre::Real");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",7,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  arg6 = (Ogre::Real)lua_tonumber(L, 6);
  arg7 = (Ogre::Real)lua_tonumber(L, 7);
  (arg1)->setPixel(arg2,arg3,arg4,arg5,arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setPixel__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Ogre::Real arg6 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setPixel",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",5,"Ogre::Real");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Procedural::TextureBuffer::setPixel",6,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  arg6 = (Ogre::Real)lua_tonumber(L, 6);
  (arg1)->setPixel(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setPixel(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_TextureBuffer_setPixel__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_TextureBuffer_setPixel__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_TextureBuffer_setPixel__SWIG_4(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_TextureBuffer_setPixel__SWIG_3(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_TextureBuffer_setPixel__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setPixel'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setPixel(size_t,size_t,Ogre::ColourValue)\n"
    "    Procedural::TextureBuffer::setPixel(size_t,size_t,Ogre::uchar,Ogre::uchar,Ogre::uchar,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setPixel(size_t,size_t,Ogre::uchar,Ogre::uchar,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setPixel(size_t,size_t,Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::TextureBuffer::setPixel(size_t,size_t,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_setRed__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setRed",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",4,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setRed",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  (arg1)->setRed(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setGreen__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setGreen",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",4,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setGreen",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  (arg1)->setGreen(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setBlue__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setBlue",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",4,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setBlue",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  (arg1)->setBlue(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setAlpha__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setAlpha",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",4,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setAlpha",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (Ogre::uchar)lua_tonumber(L, 4);
  (arg1)->setAlpha(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setRed__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setRed",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setRed",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setRed",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  (arg1)->setRed(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setRed(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setRed__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setRed__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setRed'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setRed(size_t,size_t,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setRed(size_t,size_t,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_setGreen__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setGreen",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setGreen",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setGreen",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  (arg1)->setGreen(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setGreen(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setGreen__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setGreen__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setGreen'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setGreen(size_t,size_t,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setGreen(size_t,size_t,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_setBlue__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setBlue",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setBlue",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setBlue",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  (arg1)->setBlue(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setBlue(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setBlue__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setBlue__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setBlue'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setBlue(size_t,size_t,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setBlue(size_t,size_t,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_setAlpha__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real arg4 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setAlpha",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setAlpha",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setAlpha",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  (arg1)->setAlpha(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setAlpha(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setAlpha__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_TextureBuffer_setAlpha__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setAlpha'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setAlpha(size_t,size_t,Ogre::uchar)\n"
    "    Procedural::TextureBuffer::setAlpha(size_t,size_t,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_setData__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar *arg4 = (Ogre::uchar *) 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setData",1,"Procedural::TextureBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setData",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::setData",3,"size_t");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("Procedural::TextureBuffer::setData",4,"Ogre::uchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setData",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("TextureBuffer_setData",4,SWIGTYPE_p_unsigned_char);
  }
  
  (arg1)->setData(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setData__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::setData",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::setData",1,"Procedural::TextureBuffer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::setData",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setData",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_setData",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  (arg1)->setData(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_setData(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TextureBuffer_setData__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_unsigned_char, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_TextureBuffer_setData__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_setData'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::setData(size_t,size_t,Ogre::uchar *)\n"
    "    Procedural::TextureBuffer::setData(Procedural::TextureBufferPtr)\n");
  lua_error(L);return 0;
}


static int _wrap_TextureBuffer_getPixel(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::ColourValue result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixel",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixel",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixel",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = ((Procedural::TextureBuffer const *)arg1)->getPixel(arg2,arg3);
  {
    Ogre::ColourValue * resultptr = new Ogre::ColourValue((const Ogre::ColourValue &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__ColourValue,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelRedByte(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelRedByte",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedByte",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedByte",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedByte",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelRedByte",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::uchar)((Procedural::TextureBuffer const *)arg1)->getPixelRedByte(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelGreenByte(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelGreenByte",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenByte",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenByte",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenByte",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelGreenByte",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::uchar)((Procedural::TextureBuffer const *)arg1)->getPixelGreenByte(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelBlueByte(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelBlueByte",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueByte",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueByte",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueByte",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelBlueByte",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::uchar)((Procedural::TextureBuffer const *)arg1)->getPixelBlueByte(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelAlphaByte(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::uchar result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelAlphaByte",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaByte",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaByte",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaByte",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelAlphaByte",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::uchar)((Procedural::TextureBuffer const *)arg1)->getPixelAlphaByte(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelRedReal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelRedReal",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedReal",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedReal",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelRedReal",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelRedReal",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)((Procedural::TextureBuffer const *)arg1)->getPixelRedReal(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelGreenReal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelGreenReal",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenReal",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenReal",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelGreenReal",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelGreenReal",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)((Procedural::TextureBuffer const *)arg1)->getPixelGreenReal(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelBlueReal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelBlueReal",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueReal",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueReal",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelBlueReal",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelBlueReal",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)((Procedural::TextureBuffer const *)arg1)->getPixelBlueReal(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getPixelAlphaReal(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Ogre::Real result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getPixelAlphaReal",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaReal",1,"Procedural::TextureBuffer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaReal",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::getPixelAlphaReal",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getPixelAlphaReal",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Ogre::Real)((Procedural::TextureBuffer const *)arg1)->getPixelAlphaReal(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_clone(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::clone",1,"Procedural::TextureBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_clone",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::TextureBufferPtr)((Procedural::TextureBuffer const *)arg1)->clone();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TextureBuffer__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::TextureBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::TextureBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::TextureBuffer",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_TextureBuffer",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::TextureBuffer *)new Procedural::TextureBuffer(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TextureBuffer__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Ogre::uint arg1 ;
  Procedural::TextureBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::TextureBuffer",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::TextureBuffer",1,"Ogre::uint");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (Ogre::uint)lua_tonumber(L, 1);
  result = (Procedural::TextureBuffer *)new Procedural::TextureBuffer(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getWidth(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::uint result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getWidth",1,"Procedural::TextureBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getWidth",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Ogre::uint)((Procedural::TextureBuffer const *)arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getHeight(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::uint result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getHeight",1,"Procedural::TextureBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getHeight",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Ogre::uint)((Procedural::TextureBuffer const *)arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_getImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::Image *result = 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::getImage",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::getImage",1,"Procedural::TextureBuffer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_getImage",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Ogre::Image *)((Procedural::TextureBuffer const *)arg1)->getImage();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Ogre__Image,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_saveImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::String arg2 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::saveImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::saveImage",1,"Procedural::TextureBuffer const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::saveImage",2,"Ogre::String");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_saveImage",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  ((Procedural::TextureBuffer const *)arg1)->saveImage(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_createTexture__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::String arg2 ;
  Ogre::String arg3 ;
  Ogre::TexturePtr result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::createTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::createTexture",1,"Procedural::TextureBuffer const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::createTexture",2,"Ogre::String");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::TextureBuffer::createTexture",3,"Ogre::String");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_createTexture",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  (&arg3)->assign(lua_tostring(L,3),lua_strlen(L,3));
  result = ((Procedural::TextureBuffer const *)arg1)->createTexture(arg2,arg3);
  {
    Ogre::TexturePtr * resultptr = new Ogre::TexturePtr((const Ogre::TexturePtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__TexturePtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_createTexture__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) 0 ;
  Ogre::String arg2 ;
  Ogre::TexturePtr result;
  
  SWIG_check_num_args("Procedural::TextureBuffer::createTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::createTexture",1,"Procedural::TextureBuffer const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::TextureBuffer::createTexture",2,"Ogre::String");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("TextureBuffer_createTexture",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  result = ((Procedural::TextureBuffer const *)arg1)->createTexture(arg2);
  {
    Ogre::TexturePtr * resultptr = new Ogre::TexturePtr((const Ogre::TexturePtr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Ogre__TexturePtr,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBuffer_createTexture(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_TextureBuffer_createTexture__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_TextureBuffer_createTexture__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureBuffer_createTexture'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::createTexture(Ogre::String,Ogre::String) const\n"
    "    Procedural::TextureBuffer::createTexture(Ogre::String) const\n");
  lua_error(L);return 0;
}


static int _wrap_new_TextureBuffer__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBuffer *arg1 = 0 ;
  Procedural::TextureBuffer *result = 0 ;
  
  SWIG_check_num_args("Procedural::TextureBuffer::TextureBuffer",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("Procedural::TextureBuffer::TextureBuffer",1,"Procedural::TextureBuffer const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_TextureBuffer",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::TextureBuffer *)new Procedural::TextureBuffer((Procedural::TextureBuffer const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TextureBuffer(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_TextureBuffer__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_TextureBuffer__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_TextureBuffer__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_TextureBuffer'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureBuffer::TextureBuffer(Procedural::TextureBufferPtr)\n"
    "    Procedural::TextureBuffer::TextureBuffer(Ogre::uint)\n"
    "    Procedural::TextureBuffer::TextureBuffer(Procedural::TextureBuffer const &)\n");
  lua_error(L);return 0;
}


static void swig_delete_TextureBuffer(void *obj) {
Procedural::TextureBuffer *arg1 = (Procedural::TextureBuffer *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TextureBuffer_methods[] = {
    {"setPixel", _wrap_TextureBuffer_setPixel}, 
    {"setRed", _wrap_TextureBuffer_setRed}, 
    {"setGreen", _wrap_TextureBuffer_setGreen}, 
    {"setBlue", _wrap_TextureBuffer_setBlue}, 
    {"setAlpha", _wrap_TextureBuffer_setAlpha}, 
    {"setData", _wrap_TextureBuffer_setData}, 
    {"getPixel", _wrap_TextureBuffer_getPixel}, 
    {"getPixelRedByte", _wrap_TextureBuffer_getPixelRedByte}, 
    {"getPixelGreenByte", _wrap_TextureBuffer_getPixelGreenByte}, 
    {"getPixelBlueByte", _wrap_TextureBuffer_getPixelBlueByte}, 
    {"getPixelAlphaByte", _wrap_TextureBuffer_getPixelAlphaByte}, 
    {"getPixelRedReal", _wrap_TextureBuffer_getPixelRedReal}, 
    {"getPixelGreenReal", _wrap_TextureBuffer_getPixelGreenReal}, 
    {"getPixelBlueReal", _wrap_TextureBuffer_getPixelBlueReal}, 
    {"getPixelAlphaReal", _wrap_TextureBuffer_getPixelAlphaReal}, 
    {"clone", _wrap_TextureBuffer_clone}, 
    {"getWidth", _wrap_TextureBuffer_getWidth}, 
    {"getHeight", _wrap_TextureBuffer_getHeight}, 
    {"getImage", _wrap_TextureBuffer_getImage}, 
    {"saveImage", _wrap_TextureBuffer_saveImage}, 
    {"createTexture", _wrap_TextureBuffer_createTexture}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TextureBuffer_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TextureBuffer_bases[] = {0};
static const char *swig_Procedural_TextureBuffer_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_TextureBuffer = { "TextureBuffer", &SWIGTYPE_p_Procedural__TextureBuffer,_wrap_new_TextureBuffer, swig_delete_TextureBuffer, swig_Procedural_TextureBuffer_methods, swig_Procedural_TextureBuffer_attributes, swig_Procedural_TextureBuffer_bases, swig_Procedural_TextureBuffer_base_names };

static int _wrap_TextureProcessing_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureProcessing *arg1 = (Procedural::TextureProcessing *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::TextureProcessing::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureProcessing::process",1,"Procedural::TextureProcessing *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureProcessing,0))){
    SWIG_fail_ptr("TextureProcessing_process",1,SWIGTYPE_p_Procedural__TextureProcessing);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureProcessing_getName(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureProcessing *arg1 = (Procedural::TextureProcessing *) 0 ;
  Ogre::String result;
  
  SWIG_check_num_args("Procedural::TextureProcessing::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureProcessing::getName",1,"Procedural::TextureProcessing *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureProcessing,0))){
    SWIG_fail_ptr("TextureProcessing_getName",1,SWIGTYPE_p_Procedural__TextureProcessing);
  }
  
  result = (arg1)->getName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureProcessing_setLog__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureProcessing *arg1 = (Procedural::TextureProcessing *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("Procedural::TextureProcessing::setLog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureProcessing::setLog",1,"Procedural::TextureProcessing *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::TextureProcessing::setLog",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureProcessing,0))){
    SWIG_fail_ptr("TextureProcessing_setLog",1,SWIGTYPE_p_Procedural__TextureProcessing);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setLog(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureProcessing_setLog__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureProcessing *arg1 = (Procedural::TextureProcessing *) 0 ;
  
  SWIG_check_num_args("Procedural::TextureProcessing::setLog",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::TextureProcessing::setLog",1,"Procedural::TextureProcessing *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureProcessing,0))){
    SWIG_fail_ptr("TextureProcessing_setLog",1,SWIGTYPE_p_Procedural__TextureProcessing);
  }
  
  (arg1)->setLog();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureProcessing_setLog(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureProcessing, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_TextureProcessing_setLog__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__TextureProcessing, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_TextureProcessing_setLog__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TextureProcessing_setLog'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::TextureProcessing::setLog(bool)\n"
    "    Procedural::TextureProcessing::setLog()\n");
  lua_error(L);return 0;
}


static void swig_delete_TextureProcessing(void *obj) {
Procedural::TextureProcessing *arg1 = (Procedural::TextureProcessing *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_TextureProcessing_methods[] = {
    {"process", _wrap_TextureProcessing_process}, 
    {"getName", _wrap_TextureProcessing_getName}, 
    {"setLog", _wrap_TextureProcessing_setLog}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_TextureProcessing_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_TextureProcessing_bases[] = {0};
static const char *swig_Procedural_TextureProcessing_base_names[] = {0};
static swig_lua_class _wrap_class_Procedural_TextureProcessing = { "TextureProcessing", &SWIGTYPE_p_Procedural__TextureProcessing,0, swig_delete_TextureProcessing, swig_Procedural_TextureProcessing_methods, swig_Procedural_TextureProcessing_attributes, swig_Procedural_TextureProcessing_bases, swig_Procedural_TextureProcessing_base_names };

static int _wrap_new_Cell(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::Cell",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::Cell",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Cell",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Cell *)new Procedural::Cell(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setColour",1,"Procedural::Cell *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Cell::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setColour",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Cell_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Cell *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setColour",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cell::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cell::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Cell::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setColour",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Cell *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setColour",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cell::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cell::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setColour",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Cell *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cell, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Cell_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cell, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Cell_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cell, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Cell_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Cell_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Cell::setColour(Ogre::ColourValue)\n"
    "    Procedural::Cell::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Cell::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Cell_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setSeed",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setSeed",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Cell *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setRegularity(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setRegularity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setRegularity",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setRegularity",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setRegularity",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Cell *) &(arg1)->setRegularity(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setDensity(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setDensity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setDensity",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setDensity",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setDensity",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Cell *) &(arg1)->setDensity(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setMode(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Procedural::Cell::CELL_MODE arg2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setMode",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setMode",2,"Procedural::Cell::CELL_MODE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setMode",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  arg2 = (Procedural::Cell::CELL_MODE)(int)lua_tonumber(L, 2);
  result = (Procedural::Cell *) &(arg1)->setMode(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_setPattern(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Procedural::Cell::CELL_PATTERN arg2 ;
  Procedural::Cell *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cell::setPattern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::setPattern",1,"Procedural::Cell *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cell::setPattern",2,"Procedural::Cell::CELL_PATTERN");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_setPattern",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  arg2 = (Procedural::Cell::CELL_PATTERN)(int)lua_tonumber(L, 2);
  result = (Procedural::Cell *) &(arg1)->setPattern(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cell,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cell_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cell *arg1 = (Procedural::Cell *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Cell::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cell::process",1,"Procedural::Cell *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cell,0))){
    SWIG_fail_ptr("Cell_process",1,SWIGTYPE_p_Procedural__Cell);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Cell(void *obj) {
Procedural::Cell *arg1 = (Procedural::Cell *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Cell_methods[] = {
    {"setColour", _wrap_Cell_setColour}, 
    {"setSeed", _wrap_Cell_setSeed}, 
    {"setRegularity", _wrap_Cell_setRegularity}, 
    {"setDensity", _wrap_Cell_setDensity}, 
    {"setMode", _wrap_Cell_setMode}, 
    {"setPattern", _wrap_Cell_setPattern}, 
    {"process", _wrap_Cell_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Cell_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Cell_bases[] = {0,0};
static const char *swig_Procedural_Cell_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Cell = { "Cell", &SWIGTYPE_p_Procedural__Cell,_wrap_new_Cell, swig_delete_Cell, swig_Procedural_Cell_methods, swig_Procedural_Cell_attributes, swig_Procedural_Cell_bases, swig_Procedural_Cell_base_names };

static int _wrap_new_Cloud(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Cloud *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cloud::Cloud",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::Cloud",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Cloud",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Cloud *)new Procedural::Cloud(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cloud,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cloud_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cloud *arg1 = (Procedural::Cloud *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Cloud *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cloud::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::setColour",1,"Procedural::Cloud *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Cloud::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cloud,0))){
    SWIG_fail_ptr("Cloud_setColour",1,SWIGTYPE_p_Procedural__Cloud);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Cloud_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Cloud *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cloud,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cloud_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cloud *arg1 = (Procedural::Cloud *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Cloud *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cloud::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::setColour",1,"Procedural::Cloud *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cloud::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cloud::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cloud::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Cloud::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cloud,0))){
    SWIG_fail_ptr("Cloud_setColour",1,SWIGTYPE_p_Procedural__Cloud);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Cloud *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cloud,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cloud_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cloud *arg1 = (Procedural::Cloud *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Cloud *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cloud::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::setColour",1,"Procedural::Cloud *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cloud::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cloud::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cloud::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cloud,0))){
    SWIG_fail_ptr("Cloud_setColour",1,SWIGTYPE_p_Procedural__Cloud);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Cloud *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cloud,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cloud_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cloud, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Cloud_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cloud, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Cloud_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cloud, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Cloud_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Cloud_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Cloud::setColour(Ogre::ColourValue)\n"
    "    Procedural::Cloud::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Cloud::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Cloud_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cloud *arg1 = (Procedural::Cloud *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Cloud *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cloud::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::setSeed",1,"Procedural::Cloud *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cloud::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cloud,0))){
    SWIG_fail_ptr("Cloud_setSeed",1,SWIGTYPE_p_Procedural__Cloud);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Cloud *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cloud,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cloud_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cloud *arg1 = (Procedural::Cloud *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Cloud::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cloud::process",1,"Procedural::Cloud *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cloud,0))){
    SWIG_fail_ptr("Cloud_process",1,SWIGTYPE_p_Procedural__Cloud);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Cloud(void *obj) {
Procedural::Cloud *arg1 = (Procedural::Cloud *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Cloud_methods[] = {
    {"setColour", _wrap_Cloud_setColour}, 
    {"setSeed", _wrap_Cloud_setSeed}, 
    {"process", _wrap_Cloud_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Cloud_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Cloud_bases[] = {0,0};
static const char *swig_Procedural_Cloud_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Cloud = { "Cloud", &SWIGTYPE_p_Procedural__Cloud,_wrap_new_Cloud, swig_delete_Cloud, swig_Procedural_Cloud_methods, swig_Procedural_Cloud_attributes, swig_Procedural_Cloud_bases, swig_Procedural_Cloud_base_names };

static int _wrap_new_Gradient(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::Gradient",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::Gradient",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Gradient",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Gradient *)new Procedural::Gradient(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourA__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourA",1,"Procedural::Gradient *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourA",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourA",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColourA",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Gradient *) &(arg1)->setColourA(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourA__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourA",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourA",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourA",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourA",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourA",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Gradient::setColourA",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourA",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Gradient *) &(arg1)->setColourA(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourA__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourA",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourA",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourA",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourA",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourA",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourA",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Gradient *) &(arg1)->setColourA(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourA(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Gradient_setColourA__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Gradient_setColourA__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Gradient_setColourA__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Gradient_setColourA'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Gradient::setColourA(Ogre::ColourValue)\n"
    "    Procedural::Gradient::setColourA(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Gradient::setColourA(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Gradient_setColourB__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourB",1,"Procedural::Gradient *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourB",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourB",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColourB",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Gradient *) &(arg1)->setColourB(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourB__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourB",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourB",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourB",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourB",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourB",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Gradient::setColourB",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourB",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Gradient *) &(arg1)->setColourB(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourB__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourB",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourB",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourB",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourB",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourB",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourB",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Gradient *) &(arg1)->setColourB(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourB(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Gradient_setColourB__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Gradient_setColourB__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Gradient_setColourB__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Gradient_setColourB'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Gradient::setColourB(Ogre::ColourValue)\n"
    "    Procedural::Gradient::setColourB(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Gradient::setColourB(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Gradient_setColourC__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourC",1,"Procedural::Gradient *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourC",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourC",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColourC",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Gradient *) &(arg1)->setColourC(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourC__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourC",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourC",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourC",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourC",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourC",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Gradient::setColourC",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourC",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Gradient *) &(arg1)->setColourC(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourC__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourC",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourC",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourC",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourC",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourC",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourC",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Gradient *) &(arg1)->setColourC(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourC(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Gradient_setColourC__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Gradient_setColourC__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Gradient_setColourC__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Gradient_setColourC'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Gradient::setColourC(Ogre::ColourValue)\n"
    "    Procedural::Gradient::setColourC(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Gradient::setColourC(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Gradient_setColourD__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourD",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourD",1,"Procedural::Gradient *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourD",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourD",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColourD",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Gradient *) &(arg1)->setColourD(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourD__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourD",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourD",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourD",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourD",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourD",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Gradient::setColourD",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourD",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Gradient *) &(arg1)->setColourD(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourD__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColourD",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColourD",1,"Procedural::Gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Gradient::setColourD",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Gradient::setColourD",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Gradient::setColourD",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColourD",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Gradient *) &(arg1)->setColourD(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_setColourD(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Gradient_setColourD__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Gradient_setColourD__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Gradient, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Gradient_setColourD__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Gradient_setColourD'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Gradient::setColourD(Ogre::ColourValue)\n"
    "    Procedural::Gradient::setColourD(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Gradient::setColourD(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Gradient_setColours(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue arg3 ;
  Ogre::ColourValue arg4 ;
  Ogre::ColourValue arg5 ;
  Ogre::ColourValue *argp2 ;
  Ogre::ColourValue *argp3 ;
  Ogre::ColourValue *argp4 ;
  Ogre::ColourValue *argp5 ;
  Procedural::Gradient *result = 0 ;
  
  SWIG_check_num_args("Procedural::Gradient::setColours",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::setColours",1,"Procedural::Gradient *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Gradient::setColours",2,"Ogre::ColourValue");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Gradient::setColours",3,"Ogre::ColourValue");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Procedural::Gradient::setColours",4,"Ogre::ColourValue");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("Procedural::Gradient::setColours",5,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_setColours",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColours",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColours",3,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColours",4,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg4 = *argp4;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Gradient_setColours",5,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg5 = *argp5;
  
  result = (Procedural::Gradient *) &(arg1)->setColours(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Gradient_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Gradient *arg1 = (Procedural::Gradient *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Gradient::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Gradient::process",1,"Procedural::Gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Gradient,0))){
    SWIG_fail_ptr("Gradient_process",1,SWIGTYPE_p_Procedural__Gradient);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Gradient(void *obj) {
Procedural::Gradient *arg1 = (Procedural::Gradient *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Gradient_methods[] = {
    {"setColourA", _wrap_Gradient_setColourA}, 
    {"setColourB", _wrap_Gradient_setColourB}, 
    {"setColourC", _wrap_Gradient_setColourC}, 
    {"setColourD", _wrap_Gradient_setColourD}, 
    {"setColours", _wrap_Gradient_setColours}, 
    {"process", _wrap_Gradient_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Gradient_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Gradient_bases[] = {0,0};
static const char *swig_Procedural_Gradient_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Gradient = { "Gradient", &SWIGTYPE_p_Procedural__Gradient,_wrap_new_Gradient, swig_delete_Gradient, swig_Procedural_Gradient_methods, swig_Procedural_Gradient_attributes, swig_Procedural_Gradient_bases, swig_Procedural_Gradient_base_names };

static int _wrap_new_Image(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Image *result = 0 ;
  
  SWIG_check_num_args("Procedural::Image::Image",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Image::Image",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Image",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Image *)new Procedural::Image(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Image,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Image_setFile__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Image *arg1 = (Procedural::Image *) 0 ;
  Ogre::String arg2 ;
  Ogre::String arg3 ;
  Procedural::Image *result = 0 ;
  
  SWIG_check_num_args("Procedural::Image::setFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Image::setFile",1,"Procedural::Image *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::Image::setFile",2,"Ogre::String");
  if(!lua_isstring(L,3)) SWIG_fail_arg("Procedural::Image::setFile",3,"Ogre::String");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Image,0))){
    SWIG_fail_ptr("Image_setFile",1,SWIGTYPE_p_Procedural__Image);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  (&arg3)->assign(lua_tostring(L,3),lua_strlen(L,3));
  result = (Procedural::Image *) &(arg1)->setFile(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Image,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Image_setFile__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Image *arg1 = (Procedural::Image *) 0 ;
  Ogre::String arg2 ;
  Procedural::Image *result = 0 ;
  
  SWIG_check_num_args("Procedural::Image::setFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Image::setFile",1,"Procedural::Image *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Procedural::Image::setFile",2,"Ogre::String");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Image,0))){
    SWIG_fail_ptr("Image_setFile",1,SWIGTYPE_p_Procedural__Image);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  result = (Procedural::Image *) &(arg1)->setFile(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Image,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Image_setFile(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Image, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Image_setFile__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Image, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_Image_setFile__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Image_setFile'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Image::setFile(Ogre::String,Ogre::String)\n"
    "    Procedural::Image::setFile(Ogre::String)\n");
  lua_error(L);return 0;
}


static int _wrap_Image_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Image *arg1 = (Procedural::Image *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Image::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Image::process",1,"Procedural::Image *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Image,0))){
    SWIG_fail_ptr("Image_process",1,SWIGTYPE_p_Procedural__Image);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Image(void *obj) {
Procedural::Image *arg1 = (Procedural::Image *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Image_methods[] = {
    {"setFile", _wrap_Image_setFile}, 
    {"process", _wrap_Image_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Image_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Image_bases[] = {0,0};
static const char *swig_Procedural_Image_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Image = { "Image", &SWIGTYPE_p_Procedural__Image,_wrap_new_Image, swig_delete_Image, swig_Procedural_Image_methods, swig_Procedural_Image_attributes, swig_Procedural_Image_bases, swig_Procedural_Image_base_names };

static int _wrap_new_Labyrinth(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Labyrinth *result = 0 ;
  
  SWIG_check_num_args("Procedural::Labyrinth::Labyrinth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::Labyrinth",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Labyrinth",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Labyrinth *)new Procedural::Labyrinth(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Labyrinth,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Labyrinth_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Labyrinth *result = 0 ;
  
  SWIG_check_num_args("Procedural::Labyrinth::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::setColour",1,"Procedural::Labyrinth *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Labyrinth::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Labyrinth,0))){
    SWIG_fail_ptr("Labyrinth_setColour",1,SWIGTYPE_p_Procedural__Labyrinth);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Labyrinth_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Labyrinth *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Labyrinth,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Labyrinth_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Labyrinth *result = 0 ;
  
  SWIG_check_num_args("Procedural::Labyrinth::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::setColour",1,"Procedural::Labyrinth *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Labyrinth::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Labyrinth::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Labyrinth::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Labyrinth::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Labyrinth,0))){
    SWIG_fail_ptr("Labyrinth_setColour",1,SWIGTYPE_p_Procedural__Labyrinth);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Labyrinth *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Labyrinth,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Labyrinth_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Labyrinth *result = 0 ;
  
  SWIG_check_num_args("Procedural::Labyrinth::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::setColour",1,"Procedural::Labyrinth *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Labyrinth::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Labyrinth::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Labyrinth::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Labyrinth,0))){
    SWIG_fail_ptr("Labyrinth_setColour",1,SWIGTYPE_p_Procedural__Labyrinth);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Labyrinth *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Labyrinth,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Labyrinth_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Labyrinth, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Labyrinth_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Labyrinth, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Labyrinth_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Labyrinth, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Labyrinth_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Labyrinth_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Labyrinth::setColour(Ogre::ColourValue)\n"
    "    Procedural::Labyrinth::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Labyrinth::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Labyrinth_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Labyrinth *result = 0 ;
  
  SWIG_check_num_args("Procedural::Labyrinth::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::setSeed",1,"Procedural::Labyrinth *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Labyrinth::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Labyrinth,0))){
    SWIG_fail_ptr("Labyrinth_setSeed",1,SWIGTYPE_p_Procedural__Labyrinth);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Labyrinth *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Labyrinth,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Labyrinth_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Labyrinth::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Labyrinth::process",1,"Procedural::Labyrinth *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Labyrinth,0))){
    SWIG_fail_ptr("Labyrinth_process",1,SWIGTYPE_p_Procedural__Labyrinth);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Labyrinth(void *obj) {
Procedural::Labyrinth *arg1 = (Procedural::Labyrinth *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Labyrinth_methods[] = {
    {"setColour", _wrap_Labyrinth_setColour}, 
    {"setSeed", _wrap_Labyrinth_setSeed}, 
    {"process", _wrap_Labyrinth_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Labyrinth_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Labyrinth_bases[] = {0,0};
static const char *swig_Procedural_Labyrinth_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Labyrinth = { "Labyrinth", &SWIGTYPE_p_Procedural__Labyrinth,_wrap_new_Labyrinth, swig_delete_Labyrinth, swig_Procedural_Labyrinth_methods, swig_Procedural_Labyrinth_attributes, swig_Procedural_Labyrinth_bases, swig_Procedural_Labyrinth_base_names };

static int _wrap_new_Marble(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Marble *result = 0 ;
  
  SWIG_check_num_args("Procedural::Marble::Marble",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::Marble",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Marble",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Marble *)new Procedural::Marble(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Marble,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Marble_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Marble *arg1 = (Procedural::Marble *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Marble *result = 0 ;
  
  SWIG_check_num_args("Procedural::Marble::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::setColour",1,"Procedural::Marble *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Marble::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Marble,0))){
    SWIG_fail_ptr("Marble_setColour",1,SWIGTYPE_p_Procedural__Marble);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Marble_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Marble *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Marble,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Marble_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Marble *arg1 = (Procedural::Marble *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Marble *result = 0 ;
  
  SWIG_check_num_args("Procedural::Marble::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::setColour",1,"Procedural::Marble *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Marble::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Marble::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Marble::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Marble::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Marble,0))){
    SWIG_fail_ptr("Marble_setColour",1,SWIGTYPE_p_Procedural__Marble);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Marble *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Marble,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Marble_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Marble *arg1 = (Procedural::Marble *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Marble *result = 0 ;
  
  SWIG_check_num_args("Procedural::Marble::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::setColour",1,"Procedural::Marble *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Marble::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Marble::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Marble::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Marble,0))){
    SWIG_fail_ptr("Marble_setColour",1,SWIGTYPE_p_Procedural__Marble);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Marble *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Marble,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Marble_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Marble, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Marble_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Marble, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Marble_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Marble, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Marble_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Marble_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Marble::setColour(Ogre::ColourValue)\n"
    "    Procedural::Marble::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Marble::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Marble_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Marble *arg1 = (Procedural::Marble *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Marble *result = 0 ;
  
  SWIG_check_num_args("Procedural::Marble::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::setSeed",1,"Procedural::Marble *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Marble::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Marble,0))){
    SWIG_fail_ptr("Marble_setSeed",1,SWIGTYPE_p_Procedural__Marble);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Marble *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Marble,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Marble_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Marble *arg1 = (Procedural::Marble *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Marble::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Marble::process",1,"Procedural::Marble *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Marble,0))){
    SWIG_fail_ptr("Marble_process",1,SWIGTYPE_p_Procedural__Marble);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Marble(void *obj) {
Procedural::Marble *arg1 = (Procedural::Marble *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Marble_methods[] = {
    {"setColour", _wrap_Marble_setColour}, 
    {"setSeed", _wrap_Marble_setSeed}, 
    {"process", _wrap_Marble_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Marble_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Marble_bases[] = {0,0};
static const char *swig_Procedural_Marble_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Marble = { "Marble", &SWIGTYPE_p_Procedural__Marble,_wrap_new_Marble, swig_delete_Marble, swig_Procedural_Marble_methods, swig_Procedural_Marble_attributes, swig_Procedural_Marble_bases, swig_Procedural_Marble_base_names };

static int _wrap_new_Noise(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::Noise",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::Noise",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Noise",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Noise *)new Procedural::Noise(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::setColour",1,"Procedural::Noise *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Noise::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_setColour",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Noise_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Noise *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::setColour",1,"Procedural::Noise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Noise::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Noise::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Noise::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Noise::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_setColour",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Noise *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::setColour",1,"Procedural::Noise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Noise::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Noise::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Noise::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_setColour",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Noise *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Noise, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Noise_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Noise, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Noise_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Noise, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Noise_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Noise_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Noise::setColour(Ogre::ColourValue)\n"
    "    Procedural::Noise::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Noise::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Noise_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::setSeed",1,"Procedural::Noise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Noise::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_setSeed",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Noise *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_setType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Procedural::Noise::NOISE_TYPE arg2 ;
  Procedural::Noise *result = 0 ;
  
  SWIG_check_num_args("Procedural::Noise::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::setType",1,"Procedural::Noise *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Noise::setType",2,"Procedural::Noise::NOISE_TYPE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_setType",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  arg2 = (Procedural::Noise::NOISE_TYPE)(int)lua_tonumber(L, 2);
  result = (Procedural::Noise *) &(arg1)->setType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Noise,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Noise_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Noise *arg1 = (Procedural::Noise *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Noise::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Noise::process",1,"Procedural::Noise *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Noise,0))){
    SWIG_fail_ptr("Noise_process",1,SWIGTYPE_p_Procedural__Noise);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Noise(void *obj) {
Procedural::Noise *arg1 = (Procedural::Noise *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Noise_methods[] = {
    {"setColour", _wrap_Noise_setColour}, 
    {"setSeed", _wrap_Noise_setSeed}, 
    {"setType", _wrap_Noise_setType}, 
    {"process", _wrap_Noise_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Noise_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Noise_bases[] = {0,0};
static const char *swig_Procedural_Noise_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Noise = { "Noise", &SWIGTYPE_p_Procedural__Noise,_wrap_new_Noise, swig_delete_Noise, swig_Procedural_Noise_methods, swig_Procedural_Noise_attributes, swig_Procedural_Noise_bases, swig_Procedural_Noise_base_names };

static int _wrap_new_Solid(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Solid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Solid::Solid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Solid::Solid",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Solid",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Solid *)new Procedural::Solid(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Solid,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Solid_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Solid *arg1 = (Procedural::Solid *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Solid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Solid::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Solid::setColour",1,"Procedural::Solid *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Solid::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Solid,0))){
    SWIG_fail_ptr("Solid_setColour",1,SWIGTYPE_p_Procedural__Solid);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Solid_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Solid *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Solid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Solid_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Solid *arg1 = (Procedural::Solid *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Solid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Solid::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Solid::setColour",1,"Procedural::Solid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Solid::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Solid::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Solid::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Solid::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Solid,0))){
    SWIG_fail_ptr("Solid_setColour",1,SWIGTYPE_p_Procedural__Solid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Solid *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Solid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Solid_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Solid *arg1 = (Procedural::Solid *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Solid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Solid::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Solid::setColour",1,"Procedural::Solid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Solid::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Solid::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Solid::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Solid,0))){
    SWIG_fail_ptr("Solid_setColour",1,SWIGTYPE_p_Procedural__Solid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Solid *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Solid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Solid_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Solid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Solid_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Solid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Solid_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Solid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Solid_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Solid_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Solid::setColour(Ogre::ColourValue)\n"
    "    Procedural::Solid::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Solid::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Solid_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Solid *arg1 = (Procedural::Solid *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Solid::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Solid::process",1,"Procedural::Solid *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Solid,0))){
    SWIG_fail_ptr("Solid_process",1,SWIGTYPE_p_Procedural__Solid);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Solid(void *obj) {
Procedural::Solid *arg1 = (Procedural::Solid *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Solid_methods[] = {
    {"setColour", _wrap_Solid_setColour}, 
    {"process", _wrap_Solid_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Solid_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Solid_bases[] = {0,0};
static const char *swig_Procedural_Solid_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Solid = { "Solid", &SWIGTYPE_p_Procedural__Solid,_wrap_new_Solid, swig_delete_Solid, swig_Procedural_Solid_methods, swig_Procedural_Solid_attributes, swig_Procedural_Solid_bases, swig_Procedural_Solid_base_names };

static int _wrap_new_Textile(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Textile *result = 0 ;
  
  SWIG_check_num_args("Procedural::Textile::Textile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::Textile",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Textile",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Textile *)new Procedural::Textile(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Textile,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Textile_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Textile *arg1 = (Procedural::Textile *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Textile *result = 0 ;
  
  SWIG_check_num_args("Procedural::Textile::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::setColour",1,"Procedural::Textile *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Textile::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Textile,0))){
    SWIG_fail_ptr("Textile_setColour",1,SWIGTYPE_p_Procedural__Textile);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Textile_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Textile *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Textile,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Textile_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Textile *arg1 = (Procedural::Textile *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Textile *result = 0 ;
  
  SWIG_check_num_args("Procedural::Textile::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::setColour",1,"Procedural::Textile *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Textile::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Textile::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Textile::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Textile::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Textile,0))){
    SWIG_fail_ptr("Textile_setColour",1,SWIGTYPE_p_Procedural__Textile);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Textile *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Textile,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Textile_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Textile *arg1 = (Procedural::Textile *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Textile *result = 0 ;
  
  SWIG_check_num_args("Procedural::Textile::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::setColour",1,"Procedural::Textile *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Textile::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Textile::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Textile::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Textile,0))){
    SWIG_fail_ptr("Textile_setColour",1,SWIGTYPE_p_Procedural__Textile);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Textile *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Textile,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Textile_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Textile, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Textile_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Textile, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Textile_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Textile, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Textile_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Textile_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Textile::setColour(Ogre::ColourValue)\n"
    "    Procedural::Textile::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Textile::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Textile_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Textile *arg1 = (Procedural::Textile *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Textile *result = 0 ;
  
  SWIG_check_num_args("Procedural::Textile::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::setSeed",1,"Procedural::Textile *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Textile::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Textile,0))){
    SWIG_fail_ptr("Textile_setSeed",1,SWIGTYPE_p_Procedural__Textile);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Textile *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Textile,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Textile_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Textile *arg1 = (Procedural::Textile *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Textile::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Textile::process",1,"Procedural::Textile *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Textile,0))){
    SWIG_fail_ptr("Textile_process",1,SWIGTYPE_p_Procedural__Textile);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Textile(void *obj) {
Procedural::Textile *arg1 = (Procedural::Textile *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Textile_methods[] = {
    {"setColour", _wrap_Textile_setColour}, 
    {"setSeed", _wrap_Textile_setSeed}, 
    {"process", _wrap_Textile_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Textile_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Textile_bases[] = {0,0};
static const char *swig_Procedural_Textile_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Textile = { "Textile", &SWIGTYPE_p_Procedural__Textile,_wrap_new_Textile, swig_delete_Textile, swig_Procedural_Textile_methods, swig_Procedural_Textile_attributes, swig_Procedural_Textile_bases, swig_Procedural_Textile_base_names };

static int _wrap_new_Wood(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::Wood",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::Wood",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Wood",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Wood *)new Procedural::Wood(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::setColour",1,"Procedural::Wood *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Wood::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_setColour",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Wood_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Wood *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::setColour",1,"Procedural::Wood *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Wood::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Wood::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Wood::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Wood::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_setColour",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Wood *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::setColour",1,"Procedural::Wood *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Wood::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Wood::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Wood::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_setColour",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Wood *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Wood, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Wood_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Wood, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Wood_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Wood, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Wood_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Wood_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Wood::setColour(Ogre::ColourValue)\n"
    "    Procedural::Wood::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Wood::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Wood_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::setSeed",1,"Procedural::Wood *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Wood::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_setSeed",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Wood *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_setRings(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Wood *result = 0 ;
  
  SWIG_check_num_args("Procedural::Wood::setRings",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::setRings",1,"Procedural::Wood *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Wood::setRings",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_setRings",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Wood *) &(arg1)->setRings(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Wood,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Wood_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Wood *arg1 = (Procedural::Wood *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Wood::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Wood::process",1,"Procedural::Wood *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Wood,0))){
    SWIG_fail_ptr("Wood_process",1,SWIGTYPE_p_Procedural__Wood);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Wood(void *obj) {
Procedural::Wood *arg1 = (Procedural::Wood *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Wood_methods[] = {
    {"setColour", _wrap_Wood_setColour}, 
    {"setSeed", _wrap_Wood_setSeed}, 
    {"setRings", _wrap_Wood_setRings}, 
    {"process", _wrap_Wood_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Wood_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Wood_bases[] = {0,0};
static const char *swig_Procedural_Wood_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Wood = { "Wood", &SWIGTYPE_p_Procedural__Wood,_wrap_new_Wood, swig_delete_Wood, swig_Procedural_Wood_methods, swig_Procedural_Wood_attributes, swig_Procedural_Wood_bases, swig_Procedural_Wood_base_names };

static int _wrap_new_Abnormals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::Abnormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::Abnormals",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Abnormals",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Abnormals *)new Procedural::Abnormals(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setParameterImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setParameterImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setParameterImage",1,"Procedural::Abnormals *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Abnormals::setParameterImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setParameterImage",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Abnormals_setParameterImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Abnormals *) &(arg1)->setParameterImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setRotation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setRotation",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setRotation",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setRotation",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Abnormals *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setRotation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setRotation",1,"Procedural::Abnormals *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Abnormals::setRotation",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setRotation",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Abnormals_setRotation",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::Abnormals *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setRotation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Degree arg2 ;
  Ogre::Degree *argp2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setRotation",1,"Procedural::Abnormals *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Abnormals::setRotation",2,"Ogre::Degree");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setRotation",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Abnormals_setRotation",2,SWIGTYPE_p_Ogre__Degree);
  }
  arg2 = *argp2;
  
  result = (Procedural::Abnormals *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setRotation(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Abnormals_setRotation__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Abnormals_setRotation__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Abnormals_setRotation__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Abnormals_setRotation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Abnormals::setRotation(Ogre::Real)\n"
    "    Procedural::Abnormals::setRotation(Ogre::Radian)\n"
    "    Procedural::Abnormals::setRotation(Ogre::Degree)\n");
  lua_error(L);return 0;
}


static int _wrap_Abnormals_setAxis__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setAxis",1,"Procedural::Abnormals *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Abnormals::setAxis",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setAxis",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Abnormals_setAxis",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::Abnormals *) &(arg1)->setAxis(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setAxis__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setAxis",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setAxis",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setAxis",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Abnormals::setAxis",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Abnormals::setAxis",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setAxis",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Abnormals *) &(arg1)->setAxis(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setAxis__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setAxis",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setAxis",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Abnormals::setAxis",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setAxis",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Abnormals *) &(arg1)->setAxis(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setAxis(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Abnormals_setAxis__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Abnormals_setAxis__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Abnormals, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Abnormals_setAxis__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Abnormals_setAxis'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Abnormals::setAxis(Ogre::Vector3)\n"
    "    Procedural::Abnormals::setAxis(Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Abnormals::setAxis(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Abnormals_setSensitivity(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setSensitivity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setSensitivity",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setSensitivity",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setSensitivity",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Abnormals *) &(arg1)->setSensitivity(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setCompensation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Procedural::Abnormals::ABNORMALS_COMPENSATION arg2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setCompensation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setCompensation",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setCompensation",2,"Procedural::Abnormals::ABNORMALS_COMPENSATION");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setCompensation",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  arg2 = (Procedural::Abnormals::ABNORMALS_COMPENSATION)(int)lua_tonumber(L, 2);
  result = (Procedural::Abnormals *) &(arg1)->setCompensation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_setMirror(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Procedural::Abnormals::ABNORMALS_MIRROR arg2 ;
  Procedural::Abnormals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Abnormals::setMirror",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::setMirror",1,"Procedural::Abnormals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Abnormals::setMirror",2,"Procedural::Abnormals::ABNORMALS_MIRROR");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_setMirror",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  arg2 = (Procedural::Abnormals::ABNORMALS_MIRROR)(int)lua_tonumber(L, 2);
  result = (Procedural::Abnormals *) &(arg1)->setMirror(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Abnormals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Abnormals_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Abnormals *arg1 = (Procedural::Abnormals *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Abnormals::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Abnormals::process",1,"Procedural::Abnormals *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Abnormals,0))){
    SWIG_fail_ptr("Abnormals_process",1,SWIGTYPE_p_Procedural__Abnormals);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Abnormals(void *obj) {
Procedural::Abnormals *arg1 = (Procedural::Abnormals *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Abnormals_methods[] = {
    {"setParameterImage", _wrap_Abnormals_setParameterImage}, 
    {"setRotation", _wrap_Abnormals_setRotation}, 
    {"setAxis", _wrap_Abnormals_setAxis}, 
    {"setSensitivity", _wrap_Abnormals_setSensitivity}, 
    {"setCompensation", _wrap_Abnormals_setCompensation}, 
    {"setMirror", _wrap_Abnormals_setMirror}, 
    {"process", _wrap_Abnormals_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Abnormals_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Abnormals_bases[] = {0,0};
static const char *swig_Procedural_Abnormals_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Abnormals = { "Abnormals", &SWIGTYPE_p_Procedural__Abnormals,_wrap_new_Abnormals, swig_delete_Abnormals, swig_Procedural_Abnormals_methods, swig_Procedural_Abnormals_attributes, swig_Procedural_Abnormals_bases, swig_Procedural_Abnormals_base_names };

static int _wrap_new_Alpha(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Alpha *result = 0 ;
  
  SWIG_check_num_args("Procedural::Alpha::Alpha",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Alpha::Alpha",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Alpha",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Alpha *)new Procedural::Alpha(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Alpha,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Alpha_setExtractColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Alpha *arg1 = (Procedural::Alpha *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Alpha *result = 0 ;
  
  SWIG_check_num_args("Procedural::Alpha::setExtractColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",1,"Procedural::Alpha *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Alpha,0))){
    SWIG_fail_ptr("Alpha_setExtractColour",1,SWIGTYPE_p_Procedural__Alpha);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Alpha_setExtractColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Alpha *) &(arg1)->setExtractColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Alpha,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Alpha_setExtractColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Alpha *arg1 = (Procedural::Alpha *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Alpha *result = 0 ;
  
  SWIG_check_num_args("Procedural::Alpha::setExtractColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",1,"Procedural::Alpha *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Alpha,0))){
    SWIG_fail_ptr("Alpha_setExtractColour",1,SWIGTYPE_p_Procedural__Alpha);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Alpha *) &(arg1)->setExtractColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Alpha,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Alpha_setExtractColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Alpha *arg1 = (Procedural::Alpha *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Alpha *result = 0 ;
  
  SWIG_check_num_args("Procedural::Alpha::setExtractColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",1,"Procedural::Alpha *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Alpha::setExtractColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Alpha,0))){
    SWIG_fail_ptr("Alpha_setExtractColour",1,SWIGTYPE_p_Procedural__Alpha);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Alpha *) &(arg1)->setExtractColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Alpha,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Alpha_setExtractColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Alpha, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Alpha_setExtractColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Alpha, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Alpha_setExtractColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Alpha, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Alpha_setExtractColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Alpha_setExtractColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Alpha::setExtractColour(Ogre::ColourValue)\n"
    "    Procedural::Alpha::setExtractColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Alpha::setExtractColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Alpha_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Alpha *arg1 = (Procedural::Alpha *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Alpha::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Alpha::process",1,"Procedural::Alpha *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Alpha,0))){
    SWIG_fail_ptr("Alpha_process",1,SWIGTYPE_p_Procedural__Alpha);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Alpha(void *obj) {
Procedural::Alpha *arg1 = (Procedural::Alpha *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Alpha_methods[] = {
    {"setExtractColour", _wrap_Alpha_setExtractColour}, 
    {"process", _wrap_Alpha_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Alpha_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Alpha_bases[] = {0,0};
static const char *swig_Procedural_Alpha_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Alpha = { "Alpha", &SWIGTYPE_p_Procedural__Alpha,_wrap_new_Alpha, swig_delete_Alpha, swig_Procedural_Alpha_methods, swig_Procedural_Alpha_attributes, swig_Procedural_Alpha_bases, swig_Procedural_Alpha_base_names };

static int _wrap_new_AlphaMask(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::AlphaMask *result = 0 ;
  
  SWIG_check_num_args("Procedural::AlphaMask::AlphaMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::AlphaMask::AlphaMask",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_AlphaMask",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::AlphaMask *)new Procedural::AlphaMask(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__AlphaMask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AlphaMask_setColourAlphaMask(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::AlphaMask *arg1 = (Procedural::AlphaMask *) 0 ;
  bool arg2 ;
  Procedural::AlphaMask *result = 0 ;
  
  SWIG_check_num_args("Procedural::AlphaMask::setColourAlphaMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::AlphaMask::setColourAlphaMask",1,"Procedural::AlphaMask *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::AlphaMask::setColourAlphaMask",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__AlphaMask,0))){
    SWIG_fail_ptr("AlphaMask_setColourAlphaMask",1,SWIGTYPE_p_Procedural__AlphaMask);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::AlphaMask *) &(arg1)->setColourAlphaMask(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__AlphaMask,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AlphaMask_setParameterImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::AlphaMask *arg1 = (Procedural::AlphaMask *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::AlphaMask *result = 0 ;
  
  SWIG_check_num_args("Procedural::AlphaMask::setParameterImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::AlphaMask::setParameterImage",1,"Procedural::AlphaMask *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::AlphaMask::setParameterImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__AlphaMask,0))){
    SWIG_fail_ptr("AlphaMask_setParameterImage",1,SWIGTYPE_p_Procedural__AlphaMask);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("AlphaMask_setParameterImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::AlphaMask *) &(arg1)->setParameterImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__AlphaMask,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AlphaMask_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::AlphaMask *arg1 = (Procedural::AlphaMask *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::AlphaMask::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::AlphaMask::process",1,"Procedural::AlphaMask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__AlphaMask,0))){
    SWIG_fail_ptr("AlphaMask_process",1,SWIGTYPE_p_Procedural__AlphaMask);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AlphaMask(void *obj) {
Procedural::AlphaMask *arg1 = (Procedural::AlphaMask *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_AlphaMask_methods[] = {
    {"setColourAlphaMask", _wrap_AlphaMask_setColourAlphaMask}, 
    {"setParameterImage", _wrap_AlphaMask_setParameterImage}, 
    {"process", _wrap_AlphaMask_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_AlphaMask_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_AlphaMask_bases[] = {0,0};
static const char *swig_Procedural_AlphaMask_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_AlphaMask = { "AlphaMask", &SWIGTYPE_p_Procedural__AlphaMask,_wrap_new_AlphaMask, swig_delete_AlphaMask, swig_Procedural_AlphaMask_methods, swig_Procedural_AlphaMask_attributes, swig_Procedural_AlphaMask_bases, swig_Procedural_AlphaMask_base_names };

static int _wrap_new_Blit(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::Blit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::Blit",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Blit",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Blit *)new Procedural::Blit(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputBuffer(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputBuffer",1,"Procedural::Blit *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Blit::setInputBuffer",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputBuffer",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Blit_setInputBuffer",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Blit *) &(arg1)->setInputBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::RealRect arg2 ;
  bool arg3 ;
  Ogre::RealRect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::RealRect");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::Blit::setInputRect",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("Blit_setInputRect",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::RealRect arg2 ;
  Ogre::RealRect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::RealRect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("Blit_setInputRect",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Rect arg2 ;
  Ogre::Rect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::Rect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Blit_setInputRect",2,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  bool arg4 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Blit::setInputRect",3,"Ogre::Vector2");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::Blit::setInputRect",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setInputRect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setInputRect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Blit::setInputRect",3,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setInputRect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setInputRect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Blit::setInputRect",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Blit::setInputRect",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Blit::setInputRect",5,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (size_t)lua_tonumber(L, 5);
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setInputRect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setInputRect",1,"Procedural::Blit *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blit::setInputRect",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Blit::setInputRect",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Blit::setInputRect",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Blit::setInputRect",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setInputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Blit *) &(arg1)->setInputRect(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setInputRect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Blit_setInputRect__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_long_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Blit_setInputRect__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Blit_setInputRect__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Blit_setInputRect__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Blit_setInputRect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Blit_setInputRect__SWIG_5(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Blit_setInputRect__SWIG_6(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Blit_setInputRect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Blit::setInputRect(Ogre::RealRect,bool)\n"
    "    Procedural::Blit::setInputRect(Ogre::RealRect)\n"
    "    Procedural::Blit::setInputRect(Ogre::Rect)\n"
    "    Procedural::Blit::setInputRect(Ogre::Vector2,Ogre::Vector2,bool)\n"
    "    Procedural::Blit::setInputRect(Ogre::Vector2,Ogre::Vector2)\n"
    "    Procedural::Blit::setInputRect(size_t,size_t,size_t,size_t)\n"
    "    Procedural::Blit::setInputRect(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Blit_setOutputRect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::RealRect arg2 ;
  bool arg3 ;
  Ogre::RealRect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::RealRect");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::Blit::setOutputRect",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("Blit_setOutputRect",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::RealRect arg2 ;
  Ogre::RealRect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::RealRect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("Blit_setOutputRect",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Rect arg2 ;
  Ogre::Rect *argp2 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::Rect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("Blit_setOutputRect",2,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  bool arg4 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Blit::setOutputRect",3,"Ogre::Vector2");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::Blit::setOutputRect",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setOutputRect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setOutputRect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Blit::setOutputRect",3,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setOutputRect",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("Blit_setOutputRect",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Blit::setOutputRect",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Blit::setOutputRect",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Blit::setOutputRect",5,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (size_t)lua_tonumber(L, 5);
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Blit *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blit::setOutputRect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::setOutputRect",1,"Procedural::Blit *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blit::setOutputRect",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Blit::setOutputRect",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Blit::setOutputRect",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Blit::setOutputRect",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_setOutputRect",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Blit *) &(arg1)->setOutputRect(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blit_setOutputRect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Blit_setOutputRect__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_long_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Blit_setOutputRect__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_Blit_setOutputRect__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Blit_setOutputRect__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_Blit_setOutputRect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Blit_setOutputRect__SWIG_5(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Blit, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Blit_setOutputRect__SWIG_6(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Blit_setOutputRect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Blit::setOutputRect(Ogre::RealRect,bool)\n"
    "    Procedural::Blit::setOutputRect(Ogre::RealRect)\n"
    "    Procedural::Blit::setOutputRect(Ogre::Rect)\n"
    "    Procedural::Blit::setOutputRect(Ogre::Vector2,Ogre::Vector2,bool)\n"
    "    Procedural::Blit::setOutputRect(Ogre::Vector2,Ogre::Vector2)\n"
    "    Procedural::Blit::setOutputRect(size_t,size_t,size_t,size_t)\n"
    "    Procedural::Blit::setOutputRect(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Blit_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blit *arg1 = (Procedural::Blit *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Blit::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blit::process",1,"Procedural::Blit *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blit,0))){
    SWIG_fail_ptr("Blit_process",1,SWIGTYPE_p_Procedural__Blit);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Blit(void *obj) {
Procedural::Blit *arg1 = (Procedural::Blit *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Blit_methods[] = {
    {"setInputBuffer", _wrap_Blit_setInputBuffer}, 
    {"setInputRect", _wrap_Blit_setInputRect}, 
    {"setOutputRect", _wrap_Blit_setOutputRect}, 
    {"process", _wrap_Blit_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Blit_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Blit_bases[] = {0,0};
static const char *swig_Procedural_Blit_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Blit = { "Blit", &SWIGTYPE_p_Procedural__Blit,_wrap_new_Blit, swig_delete_Blit, swig_Procedural_Blit_methods, swig_Procedural_Blit_attributes, swig_Procedural_Blit_bases, swig_Procedural_Blit_base_names };

static int _wrap_new_Blur(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Blur *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blur::Blur",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blur::Blur",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Blur",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Blur *)new Procedural::Blur(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blur,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blur_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blur *arg1 = (Procedural::Blur *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Blur *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blur::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blur::setSize",1,"Procedural::Blur *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blur::setSize",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blur,0))){
    SWIG_fail_ptr("Blur_setSize",1,SWIGTYPE_p_Procedural__Blur);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Blur *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blur,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blur_setSigma(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blur *arg1 = (Procedural::Blur *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Blur *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blur::setSigma",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blur::setSigma",1,"Procedural::Blur *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blur::setSigma",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blur,0))){
    SWIG_fail_ptr("Blur_setSigma",1,SWIGTYPE_p_Procedural__Blur);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Blur *) &(arg1)->setSigma(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blur,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blur_setType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blur *arg1 = (Procedural::Blur *) 0 ;
  Procedural::Blur::BLUR_TYPE arg2 ;
  Procedural::Blur *result = 0 ;
  
  SWIG_check_num_args("Procedural::Blur::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blur::setType",1,"Procedural::Blur *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Blur::setType",2,"Procedural::Blur::BLUR_TYPE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blur,0))){
    SWIG_fail_ptr("Blur_setType",1,SWIGTYPE_p_Procedural__Blur);
  }
  
  arg2 = (Procedural::Blur::BLUR_TYPE)(int)lua_tonumber(L, 2);
  result = (Procedural::Blur *) &(arg1)->setType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Blur,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Blur_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Blur *arg1 = (Procedural::Blur *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Blur::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Blur::process",1,"Procedural::Blur *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Blur,0))){
    SWIG_fail_ptr("Blur_process",1,SWIGTYPE_p_Procedural__Blur);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Blur(void *obj) {
Procedural::Blur *arg1 = (Procedural::Blur *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Blur_methods[] = {
    {"setSize", _wrap_Blur_setSize}, 
    {"setSigma", _wrap_Blur_setSigma}, 
    {"setType", _wrap_Blur_setType}, 
    {"process", _wrap_Blur_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Blur_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Blur_bases[] = {0,0};
static const char *swig_Procedural_Blur_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Blur = { "Blur", &SWIGTYPE_p_Procedural__Blur,_wrap_new_Blur, swig_delete_Blur, swig_Procedural_Blur_methods, swig_Procedural_Blur_attributes, swig_Procedural_Blur_bases, swig_Procedural_Blur_base_names };

static int _wrap_new_Channel(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Channel *result = 0 ;
  
  SWIG_check_num_args("Procedural::Channel::Channel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Channel::Channel",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Channel",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Channel *)new Procedural::Channel(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Channel,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Channel_setSelection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Channel *arg1 = (Procedural::Channel *) 0 ;
  Procedural::Channel::CANNEL_SELECTION arg2 ;
  Procedural::Channel *result = 0 ;
  
  SWIG_check_num_args("Procedural::Channel::setSelection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Channel::setSelection",1,"Procedural::Channel *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Channel::setSelection",2,"Procedural::Channel::CANNEL_SELECTION");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Channel,0))){
    SWIG_fail_ptr("Channel_setSelection",1,SWIGTYPE_p_Procedural__Channel);
  }
  
  arg2 = (Procedural::Channel::CANNEL_SELECTION)(int)lua_tonumber(L, 2);
  result = (Procedural::Channel *) &(arg1)->setSelection(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Channel,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Channel_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Channel *arg1 = (Procedural::Channel *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Channel::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Channel::process",1,"Procedural::Channel *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Channel,0))){
    SWIG_fail_ptr("Channel_process",1,SWIGTYPE_p_Procedural__Channel);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Channel(void *obj) {
Procedural::Channel *arg1 = (Procedural::Channel *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Channel_methods[] = {
    {"setSelection", _wrap_Channel_setSelection}, 
    {"process", _wrap_Channel_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Channel_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Channel_bases[] = {0,0};
static const char *swig_Procedural_Channel_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Channel = { "Channel", &SWIGTYPE_p_Procedural__Channel,_wrap_new_Channel, swig_delete_Channel, swig_Procedural_Channel_methods, swig_Procedural_Channel_attributes, swig_Procedural_Channel_bases, swig_Procedural_Channel_base_names };

static int _wrap_new_CircleTexture(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::CircleTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::CircleTexture",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_CircleTexture",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::CircleTexture *)new Procedural::CircleTexture(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setColour",1,"Procedural::CircleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setColour",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("CircleTexture_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::CircleTexture *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setColour",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CircleTexture::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::CircleTexture::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setColour",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::CircleTexture *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setColour",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::CircleTexture::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setColour",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::CircleTexture *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CircleTexture_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_CircleTexture_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_CircleTexture_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CircleTexture_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CircleTexture::setColour(Ogre::ColourValue)\n"
    "    Procedural::CircleTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::CircleTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CircleTexture_setRadius__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  size_t arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setRadius",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setRadius",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setRadius",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setRadius__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setRadius",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setRadius",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setRadius",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setRadius(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setRadius__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setRadius__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CircleTexture_setRadius'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CircleTexture::setRadius(size_t)\n"
    "    Procedural::CircleTexture::setRadius(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CircleTexture_setCenterX__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  size_t arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenterX",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenterX",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenterX",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenterX__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenterX",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenterX",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenterX(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setCenterX__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setCenterX__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CircleTexture_setCenterX'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CircleTexture::setCenterX(size_t)\n"
    "    Procedural::CircleTexture::setCenterX(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CircleTexture_setCenterY__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  size_t arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenterY",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenterY",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenterY",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenterY__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenterY",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenterY",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::CircleTexture *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenterY(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setCenterY__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_CircleTexture_setCenterY__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CircleTexture_setCenterY'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CircleTexture::setCenterY(size_t)\n"
    "    Procedural::CircleTexture::setCenterY(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CircleTexture_setCenter__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  bool arg3 ;
  Ogre::Vector2 *argp2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",1,"Procedural::CircleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",2,"Ogre::Vector2");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::CircleTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenter__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp2 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",1,"Procedural::CircleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::CircleTexture *) &(arg1)->setCenter(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenter__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Procedural::CircleTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenter__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  bool arg4 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenter",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",3,"Ogre::Real");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::CircleTexture *) &(arg1)->setCenter(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenter__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::CircleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::CircleTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",1,"Procedural::CircleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::CircleTexture::setCenter",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_setCenter",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::CircleTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__CircleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CircleTexture_setCenter(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CircleTexture_setCenter__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_CircleTexture_setCenter__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CircleTexture_setCenter__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_CircleTexture_setCenter__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__CircleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_CircleTexture_setCenter__SWIG_3(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'CircleTexture_setCenter'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::CircleTexture::setCenter(Ogre::Vector2,bool)\n"
    "    Procedural::CircleTexture::setCenter(Ogre::Vector2)\n"
    "    Procedural::CircleTexture::setCenter(size_t,size_t)\n"
    "    Procedural::CircleTexture::setCenter(Ogre::Real,Ogre::Real,bool)\n"
    "    Procedural::CircleTexture::setCenter(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_CircleTexture_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::CircleTexture::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::CircleTexture::process",1,"Procedural::CircleTexture *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__CircleTexture,0))){
    SWIG_fail_ptr("CircleTexture_process",1,SWIGTYPE_p_Procedural__CircleTexture);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CircleTexture(void *obj) {
Procedural::CircleTexture *arg1 = (Procedural::CircleTexture *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_CircleTexture_methods[] = {
    {"setColour", _wrap_CircleTexture_setColour}, 
    {"setRadius", _wrap_CircleTexture_setRadius}, 
    {"setCenterX", _wrap_CircleTexture_setCenterX}, 
    {"setCenterY", _wrap_CircleTexture_setCenterY}, 
    {"setCenter", _wrap_CircleTexture_setCenter}, 
    {"process", _wrap_CircleTexture_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_CircleTexture_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_CircleTexture_bases[] = {0,0};
static const char *swig_Procedural_CircleTexture_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_CircleTexture = { "CircleTexture", &SWIGTYPE_p_Procedural__CircleTexture,_wrap_new_CircleTexture, swig_delete_CircleTexture, swig_Procedural_CircleTexture_methods, swig_Procedural_CircleTexture_attributes, swig_Procedural_CircleTexture_bases, swig_Procedural_CircleTexture_base_names };

static int _wrap_new_Colours(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::Colours",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::Colours",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Colours",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Colours *)new Procedural::Colours(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourBase__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourBase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourBase",1,"Procedural::Colours *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Colours::setColourBase",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourBase",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Colours_setColourBase",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Colours *) &(arg1)->setColourBase(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourBase__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourBase",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourBase",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setColourBase",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Colours::setColourBase",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Colours::setColourBase",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Colours::setColourBase",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourBase",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Colours *) &(arg1)->setColourBase(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourBase__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourBase",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourBase",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setColourBase",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Colours::setColourBase",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Colours::setColourBase",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourBase",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Colours *) &(arg1)->setColourBase(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourBase(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Colours_setColourBase__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Colours_setColourBase__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Colours_setColourBase__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Colours_setColourBase'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Colours::setColourBase(Ogre::ColourValue)\n"
    "    Procedural::Colours::setColourBase(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Colours::setColourBase(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Colours_setColourPercent__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourPercent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourPercent",1,"Procedural::Colours *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Colours::setColourPercent",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourPercent",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Colours_setColourPercent",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Colours *) &(arg1)->setColourPercent(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourPercent__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourPercent",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourPercent",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setColourPercent",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Colours::setColourPercent",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Colours::setColourPercent",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Colours::setColourPercent",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourPercent",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Colours *) &(arg1)->setColourPercent(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourPercent__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setColourPercent",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setColourPercent",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setColourPercent",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Colours::setColourPercent",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Colours::setColourPercent",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setColourPercent",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Colours *) &(arg1)->setColourPercent(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setColourPercent(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Colours_setColourPercent__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Colours_setColourPercent__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Colours, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Colours_setColourPercent__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Colours_setColourPercent'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Colours::setColourPercent(Ogre::ColourValue)\n"
    "    Procedural::Colours::setColourPercent(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Colours::setColourPercent(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Colours_setBrithness(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setBrithness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setBrithness",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setBrithness",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setBrithness",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Colours *) &(arg1)->setBrithness(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setContrast(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setContrast",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setContrast",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setContrast",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setContrast",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Colours *) &(arg1)->setContrast(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setSaturation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setSaturation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setSaturation",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setSaturation",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setSaturation",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Colours *) &(arg1)->setSaturation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_setAlpha(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Colours *result = 0 ;
  
  SWIG_check_num_args("Procedural::Colours::setAlpha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::setAlpha",1,"Procedural::Colours *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Colours::setAlpha",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_setAlpha",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Colours *) &(arg1)->setAlpha(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Colours,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Colours_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Colours *arg1 = (Procedural::Colours *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Colours::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Colours::process",1,"Procedural::Colours *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Colours,0))){
    SWIG_fail_ptr("Colours_process",1,SWIGTYPE_p_Procedural__Colours);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Colours(void *obj) {
Procedural::Colours *arg1 = (Procedural::Colours *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Colours_methods[] = {
    {"setColourBase", _wrap_Colours_setColourBase}, 
    {"setColourPercent", _wrap_Colours_setColourPercent}, 
    {"setBrithness", _wrap_Colours_setBrithness}, 
    {"setContrast", _wrap_Colours_setContrast}, 
    {"setSaturation", _wrap_Colours_setSaturation}, 
    {"setAlpha", _wrap_Colours_setAlpha}, 
    {"process", _wrap_Colours_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Colours_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Colours_bases[] = {0,0};
static const char *swig_Procedural_Colours_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Colours = { "Colours", &SWIGTYPE_p_Procedural__Colours,_wrap_new_Colours, swig_delete_Colours, swig_Procedural_Colours_methods, swig_Procedural_Colours_attributes, swig_Procedural_Colours_bases, swig_Procedural_Colours_base_names };

static int _wrap_new_Combine(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::Combine",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::Combine",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Combine",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Combine *)new Procedural::Combine(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_addImage__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Combine::COMBINE_METHOD arg3 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::addImage",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::addImage",1,"Procedural::Combine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Combine::addImage",2,"Procedural::TextureBufferPtr");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Combine::addImage",3,"Procedural::Combine::COMBINE_METHOD");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_addImage",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Combine_addImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  arg3 = (Procedural::Combine::COMBINE_METHOD)(int)lua_tonumber(L, 3);
  result = (Procedural::Combine *) &(arg1)->addImage(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_addImage__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::addImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::addImage",1,"Procedural::Combine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Combine::addImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_addImage",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Combine_addImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Combine *) &(arg1)->addImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_addImage(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Combine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Combine_addImage__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Combine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Procedural__TextureBuffer, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Combine_addImage__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Combine_addImage'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Combine::addImage(Procedural::TextureBufferPtr,Procedural::Combine::COMBINE_METHOD)\n"
    "    Procedural::Combine::addImage(Procedural::TextureBufferPtr)\n");
  lua_error(L);return 0;
}


static int _wrap_Combine_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::setColour",1,"Procedural::Combine *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Combine::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_setColour",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Combine_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Combine *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::setColour",1,"Procedural::Combine *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Combine::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Combine::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Combine::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Combine::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_setColour",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Combine *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Combine *result = 0 ;
  
  SWIG_check_num_args("Procedural::Combine::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::setColour",1,"Procedural::Combine *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Combine::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Combine::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Combine::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_setColour",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Combine *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Combine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Combine_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Combine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Combine_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Combine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Combine_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Combine, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Combine_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Combine_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Combine::setColour(Ogre::ColourValue)\n"
    "    Procedural::Combine::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Combine::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Combine_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Combine *arg1 = (Procedural::Combine *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Combine::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Combine::process",1,"Procedural::Combine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Combine,0))){
    SWIG_fail_ptr("Combine_process",1,SWIGTYPE_p_Procedural__Combine);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Combine(void *obj) {
Procedural::Combine *arg1 = (Procedural::Combine *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Combine_methods[] = {
    {"addImage", _wrap_Combine_addImage}, 
    {"setColour", _wrap_Combine_setColour}, 
    {"process", _wrap_Combine_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Combine_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Combine_bases[] = {0,0};
static const char *swig_Procedural_Combine_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Combine = { "Combine", &SWIGTYPE_p_Procedural__Combine,_wrap_new_Combine, swig_delete_Combine, swig_Procedural_Combine_methods, swig_Procedural_Combine_attributes, swig_Procedural_Combine_bases, swig_Procedural_Combine_base_names };

static int _wrap_new_Convolution(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::Convolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::Convolution",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Convolution",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Convolution *)new Procedural::Convolution(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setKernel__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Ogre::uchar arg2 ;
  Ogre::Real *arg3 = (Ogre::Real *) 0 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setKernel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setKernel",1,"Procedural::Convolution *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Convolution::setKernel",2,"Ogre::uchar");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Procedural::Convolution::setKernel",3,"Ogre::Real *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setKernel",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Convolution_setKernel",3,SWIGTYPE_p_float);
  }
  
  result = (Procedural::Convolution *) &(arg1)->setKernel(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setKernel__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Ogre::uchar arg2 ;
  int *arg3 = (int *) 0 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setKernel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setKernel",1,"Procedural::Convolution *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Convolution::setKernel",2,"Ogre::uchar");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Procedural::Convolution::setKernel",3,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setKernel",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("Convolution_setKernel",3,SWIGTYPE_p_int);
  }
  
  result = (Procedural::Convolution *) &(arg1)->setKernel(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setKernel__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Ogre::Matrix3 arg2 ;
  Ogre::Matrix3 *argp2 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setKernel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setKernel",1,"Procedural::Convolution *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Convolution::setKernel",2,"Ogre::Matrix3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setKernel",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Matrix3,0))){
    SWIG_fail_ptr("Convolution_setKernel",2,SWIGTYPE_p_Ogre__Matrix3);
  }
  arg2 = *argp2;
  
  result = (Procedural::Convolution *) &(arg1)->setKernel(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setKernel(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Convolution, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Matrix3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Convolution_setKernel__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Convolution, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Convolution_setKernel__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Convolution, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Convolution_setKernel__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Convolution_setKernel'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Convolution::setKernel(Ogre::uchar,Ogre::Real *)\n"
    "    Procedural::Convolution::setKernel(Ogre::uchar,int *)\n"
    "    Procedural::Convolution::setKernel(Ogre::Matrix3)\n");
  lua_error(L);return 0;
}


static int _wrap_Convolution_setDivisor(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setDivisor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setDivisor",1,"Procedural::Convolution *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Convolution::setDivisor",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setDivisor",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Convolution *) &(arg1)->setDivisor(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_calculateDivisor(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::calculateDivisor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::calculateDivisor",1,"Procedural::Convolution *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_calculateDivisor",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  result = (Procedural::Convolution *) &(arg1)->calculateDivisor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setThreshold(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setThreshold",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setThreshold",1,"Procedural::Convolution *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Convolution::setThreshold",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setThreshold",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Convolution *) &(arg1)->setThreshold(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setCalculateEdgeDivisor(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  bool arg2 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setCalculateEdgeDivisor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setCalculateEdgeDivisor",1,"Procedural::Convolution *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Convolution::setCalculateEdgeDivisor",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setCalculateEdgeDivisor",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Convolution *) &(arg1)->setCalculateEdgeDivisor(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_setIncludeAlphaChannel(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  bool arg2 ;
  Procedural::Convolution *result = 0 ;
  
  SWIG_check_num_args("Procedural::Convolution::setIncludeAlphaChannel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::setIncludeAlphaChannel",1,"Procedural::Convolution *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::Convolution::setIncludeAlphaChannel",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_setIncludeAlphaChannel",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::Convolution *) &(arg1)->setIncludeAlphaChannel(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Convolution,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Convolution_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Convolution *arg1 = (Procedural::Convolution *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Convolution::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Convolution::process",1,"Procedural::Convolution *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Convolution,0))){
    SWIG_fail_ptr("Convolution_process",1,SWIGTYPE_p_Procedural__Convolution);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Convolution(void *obj) {
Procedural::Convolution *arg1 = (Procedural::Convolution *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Convolution_methods[] = {
    {"setKernel", _wrap_Convolution_setKernel}, 
    {"setDivisor", _wrap_Convolution_setDivisor}, 
    {"calculateDivisor", _wrap_Convolution_calculateDivisor}, 
    {"setThreshold", _wrap_Convolution_setThreshold}, 
    {"setCalculateEdgeDivisor", _wrap_Convolution_setCalculateEdgeDivisor}, 
    {"setIncludeAlphaChannel", _wrap_Convolution_setIncludeAlphaChannel}, 
    {"process", _wrap_Convolution_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Convolution_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Convolution_bases[] = {0,0};
static const char *swig_Procedural_Convolution_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Convolution = { "Convolution", &SWIGTYPE_p_Procedural__Convolution,_wrap_new_Convolution, swig_delete_Convolution, swig_Procedural_Convolution_methods, swig_Procedural_Convolution_attributes, swig_Procedural_Convolution_bases, swig_Procedural_Convolution_base_names };

static int _wrap_new_Crack(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::Crack",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::Crack",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Crack",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Crack *)new Procedural::Crack(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setParameterImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setParameterImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setParameterImage",1,"Procedural::Crack *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Crack::setParameterImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setParameterImage",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Crack_setParameterImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Crack *) &(arg1)->setParameterImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setColour",1,"Procedural::Crack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Crack::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setColour",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Crack_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Crack *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setColour",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Crack::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Crack::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Crack::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setColour",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Crack *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setColour",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Crack::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Crack::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setColour",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Crack *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Crack, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Crack_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Crack, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Crack_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Crack, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Crack_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Crack_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Crack::setColour(Ogre::ColourValue)\n"
    "    Procedural::Crack::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Crack::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Crack_setCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setCount",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setCount",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setCount",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setCount(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setVariation(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setVariation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setVariation",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setVariation",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setVariation",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setVariation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setLength(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setLength",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setLength",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setLength",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setLength(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setSeed",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setSeed",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setLengthDecision(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Procedural::Crack::CRACK_LENGTH_DECISION arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setLengthDecision",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setLengthDecision",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setLengthDecision",2,"Procedural::Crack::CRACK_LENGTH_DECISION");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setLengthDecision",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  arg2 = (Procedural::Crack::CRACK_LENGTH_DECISION)(int)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setLengthDecision(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_setQuality(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Procedural::Crack::CRACK_QUALITY arg2 ;
  Procedural::Crack *result = 0 ;
  
  SWIG_check_num_args("Procedural::Crack::setQuality",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::setQuality",1,"Procedural::Crack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Crack::setQuality",2,"Procedural::Crack::CRACK_QUALITY");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_setQuality",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  arg2 = (Procedural::Crack::CRACK_QUALITY)(int)lua_tonumber(L, 2);
  result = (Procedural::Crack *) &(arg1)->setQuality(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Crack,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Crack_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Crack *arg1 = (Procedural::Crack *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Crack::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Crack::process",1,"Procedural::Crack *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Crack,0))){
    SWIG_fail_ptr("Crack_process",1,SWIGTYPE_p_Procedural__Crack);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Crack(void *obj) {
Procedural::Crack *arg1 = (Procedural::Crack *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Crack_methods[] = {
    {"setParameterImage", _wrap_Crack_setParameterImage}, 
    {"setColour", _wrap_Crack_setColour}, 
    {"setCount", _wrap_Crack_setCount}, 
    {"setVariation", _wrap_Crack_setVariation}, 
    {"setLength", _wrap_Crack_setLength}, 
    {"setSeed", _wrap_Crack_setSeed}, 
    {"setLengthDecision", _wrap_Crack_setLengthDecision}, 
    {"setQuality", _wrap_Crack_setQuality}, 
    {"process", _wrap_Crack_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Crack_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Crack_bases[] = {0,0};
static const char *swig_Procedural_Crack_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Crack = { "Crack", &SWIGTYPE_p_Procedural__Crack,_wrap_new_Crack, swig_delete_Crack, swig_Procedural_Crack_methods, swig_Procedural_Crack_attributes, swig_Procedural_Crack_bases, swig_Procedural_Crack_base_names };

static int _wrap_new_Cycloid(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::Cycloid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::Cycloid",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Cycloid",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Cycloid *)new Procedural::Cycloid(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Procedural::Cycloid::CYCLOID_TYPE arg2 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setType",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setType",2,"Procedural::Cycloid::CYCLOID_TYPE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setType",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Procedural::Cycloid::CYCLOID_TYPE)(int)lua_tonumber(L, 2);
  result = (Procedural::Cycloid *) &(arg1)->setType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setColour",1,"Procedural::Cycloid *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Cycloid::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setColour",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Cycloid_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Cycloid *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setColour",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cycloid::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cycloid::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Cycloid::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setColour",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Cycloid *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setColour",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cycloid::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Cycloid::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setColour",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Cycloid *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cycloid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Cycloid_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cycloid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Cycloid_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Cycloid, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Cycloid_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Cycloid_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Cycloid::setColour(Ogre::ColourValue)\n"
    "    Procedural::Cycloid::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Cycloid::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Cycloid_setCenterX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setCenterX",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setCenterX",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Cycloid *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setCenterY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setCenterY",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setCenterY",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Cycloid *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setParameter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Procedural::Cycloid::CYCLOID_PARAMETER arg2 ;
  Ogre::Real arg3 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setParameter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setParameter",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setParameter",2,"Procedural::Cycloid::CYCLOID_PARAMETER");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Cycloid::setParameter",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setParameter",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  arg2 = (Procedural::Cycloid::CYCLOID_PARAMETER)(int)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::Cycloid *) &(arg1)->setParameter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_setPenSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Cycloid *result = 0 ;
  
  SWIG_check_num_args("Procedural::Cycloid::setPenSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::setPenSize",1,"Procedural::Cycloid *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Cycloid::setPenSize",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_setPenSize",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Cycloid *) &(arg1)->setPenSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Cycloid,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Cycloid_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Cycloid *arg1 = (Procedural::Cycloid *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Cycloid::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Cycloid::process",1,"Procedural::Cycloid *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Cycloid,0))){
    SWIG_fail_ptr("Cycloid_process",1,SWIGTYPE_p_Procedural__Cycloid);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Cycloid(void *obj) {
Procedural::Cycloid *arg1 = (Procedural::Cycloid *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Cycloid_methods[] = {
    {"setType", _wrap_Cycloid_setType}, 
    {"setColour", _wrap_Cycloid_setColour}, 
    {"setCenterX", _wrap_Cycloid_setCenterX}, 
    {"setCenterY", _wrap_Cycloid_setCenterY}, 
    {"setParameter", _wrap_Cycloid_setParameter}, 
    {"setPenSize", _wrap_Cycloid_setPenSize}, 
    {"process", _wrap_Cycloid_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Cycloid_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Cycloid_bases[] = {0,0};
static const char *swig_Procedural_Cycloid_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Cycloid = { "Cycloid", &SWIGTYPE_p_Procedural__Cycloid,_wrap_new_Cycloid, swig_delete_Cycloid, swig_Procedural_Cycloid_methods, swig_Procedural_Cycloid_attributes, swig_Procedural_Cycloid_bases, swig_Procedural_Cycloid_base_names };

static int _wrap_new_Dilate(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Dilate *result = 0 ;
  
  SWIG_check_num_args("Procedural::Dilate::Dilate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Dilate::Dilate",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Dilate",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Dilate *)new Procedural::Dilate(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Dilate,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Dilate_setIterations(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Dilate *arg1 = (Procedural::Dilate *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Dilate *result = 0 ;
  
  SWIG_check_num_args("Procedural::Dilate::setIterations",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Dilate::setIterations",1,"Procedural::Dilate *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Dilate::setIterations",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Dilate,0))){
    SWIG_fail_ptr("Dilate_setIterations",1,SWIGTYPE_p_Procedural__Dilate);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Dilate *) &(arg1)->setIterations(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Dilate,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Dilate_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Dilate *arg1 = (Procedural::Dilate *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Dilate::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Dilate::process",1,"Procedural::Dilate *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Dilate,0))){
    SWIG_fail_ptr("Dilate_process",1,SWIGTYPE_p_Procedural__Dilate);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Dilate(void *obj) {
Procedural::Dilate *arg1 = (Procedural::Dilate *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Dilate_methods[] = {
    {"setIterations", _wrap_Dilate_setIterations}, 
    {"process", _wrap_Dilate_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Dilate_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Dilate_bases[] = {0,0};
static const char *swig_Procedural_Dilate_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Dilate = { "Dilate", &SWIGTYPE_p_Procedural__Dilate,_wrap_new_Dilate, swig_delete_Dilate, swig_Procedural_Dilate_methods, swig_Procedural_Dilate_attributes, swig_Procedural_Dilate_bases, swig_Procedural_Dilate_base_names };

static int _wrap_new_Distort(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Distort *result = 0 ;
  
  SWIG_check_num_args("Procedural::Distort::Distort",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Distort::Distort",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Distort",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Distort *)new Procedural::Distort(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Distort,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Distort_setParameterImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Distort *arg1 = (Procedural::Distort *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Distort *result = 0 ;
  
  SWIG_check_num_args("Procedural::Distort::setParameterImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Distort::setParameterImage",1,"Procedural::Distort *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Distort::setParameterImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Distort,0))){
    SWIG_fail_ptr("Distort_setParameterImage",1,SWIGTYPE_p_Procedural__Distort);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Distort_setParameterImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Distort *) &(arg1)->setParameterImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Distort,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Distort_setPower(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Distort *arg1 = (Procedural::Distort *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Distort *result = 0 ;
  
  SWIG_check_num_args("Procedural::Distort::setPower",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Distort::setPower",1,"Procedural::Distort *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Distort::setPower",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Distort,0))){
    SWIG_fail_ptr("Distort_setPower",1,SWIGTYPE_p_Procedural__Distort);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Distort *) &(arg1)->setPower(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Distort,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Distort_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Distort *arg1 = (Procedural::Distort *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Distort::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Distort::process",1,"Procedural::Distort *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Distort,0))){
    SWIG_fail_ptr("Distort_process",1,SWIGTYPE_p_Procedural__Distort);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Distort(void *obj) {
Procedural::Distort *arg1 = (Procedural::Distort *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Distort_methods[] = {
    {"setParameterImage", _wrap_Distort_setParameterImage}, 
    {"setPower", _wrap_Distort_setPower}, 
    {"process", _wrap_Distort_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Distort_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Distort_bases[] = {0,0};
static const char *swig_Procedural_Distort_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Distort = { "Distort", &SWIGTYPE_p_Procedural__Distort,_wrap_new_Distort, swig_delete_Distort, swig_Procedural_Distort_methods, swig_Procedural_Distort_attributes, swig_Procedural_Distort_bases, swig_Procedural_Distort_base_names };

static int _wrap_new_EdgeDetection(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::EdgeDetection *result = 0 ;
  
  SWIG_check_num_args("Procedural::EdgeDetection::EdgeDetection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::EdgeDetection",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_EdgeDetection",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::EdgeDetection *)new Procedural::EdgeDetection(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EdgeDetection,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EdgeDetection_setThresholdLow(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::EdgeDetection *result = 0 ;
  
  SWIG_check_num_args("Procedural::EdgeDetection::setThresholdLow",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::setThresholdLow",1,"Procedural::EdgeDetection *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EdgeDetection::setThresholdLow",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EdgeDetection,0))){
    SWIG_fail_ptr("EdgeDetection_setThresholdLow",1,SWIGTYPE_p_Procedural__EdgeDetection);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::EdgeDetection *) &(arg1)->setThresholdLow(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EdgeDetection,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EdgeDetection_setThresholdHigh(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::EdgeDetection *result = 0 ;
  
  SWIG_check_num_args("Procedural::EdgeDetection::setThresholdHigh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::setThresholdHigh",1,"Procedural::EdgeDetection *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EdgeDetection::setThresholdHigh",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EdgeDetection,0))){
    SWIG_fail_ptr("EdgeDetection_setThresholdHigh",1,SWIGTYPE_p_Procedural__EdgeDetection);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::EdgeDetection *) &(arg1)->setThresholdHigh(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EdgeDetection,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EdgeDetection_setSigma(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::EdgeDetection *result = 0 ;
  
  SWIG_check_num_args("Procedural::EdgeDetection::setSigma",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::setSigma",1,"Procedural::EdgeDetection *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EdgeDetection::setSigma",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EdgeDetection,0))){
    SWIG_fail_ptr("EdgeDetection_setSigma",1,SWIGTYPE_p_Procedural__EdgeDetection);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::EdgeDetection *) &(arg1)->setSigma(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EdgeDetection,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EdgeDetection_setType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) 0 ;
  Procedural::EdgeDetection::DETECTION_TYPE arg2 ;
  Procedural::EdgeDetection *result = 0 ;
  
  SWIG_check_num_args("Procedural::EdgeDetection::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::setType",1,"Procedural::EdgeDetection *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EdgeDetection::setType",2,"Procedural::EdgeDetection::DETECTION_TYPE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EdgeDetection,0))){
    SWIG_fail_ptr("EdgeDetection_setType",1,SWIGTYPE_p_Procedural__EdgeDetection);
  }
  
  arg2 = (Procedural::EdgeDetection::DETECTION_TYPE)(int)lua_tonumber(L, 2);
  result = (Procedural::EdgeDetection *) &(arg1)->setType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EdgeDetection,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EdgeDetection_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::EdgeDetection::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EdgeDetection::process",1,"Procedural::EdgeDetection *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EdgeDetection,0))){
    SWIG_fail_ptr("EdgeDetection_process",1,SWIGTYPE_p_Procedural__EdgeDetection);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_EdgeDetection(void *obj) {
Procedural::EdgeDetection *arg1 = (Procedural::EdgeDetection *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_EdgeDetection_methods[] = {
    {"setThresholdLow", _wrap_EdgeDetection_setThresholdLow}, 
    {"setThresholdHigh", _wrap_EdgeDetection_setThresholdHigh}, 
    {"setSigma", _wrap_EdgeDetection_setSigma}, 
    {"setType", _wrap_EdgeDetection_setType}, 
    {"process", _wrap_EdgeDetection_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_EdgeDetection_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_EdgeDetection_bases[] = {0,0};
static const char *swig_Procedural_EdgeDetection_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_EdgeDetection = { "EdgeDetection", &SWIGTYPE_p_Procedural__EdgeDetection,_wrap_new_EdgeDetection, swig_delete_EdgeDetection, swig_Procedural_EdgeDetection_methods, swig_Procedural_EdgeDetection_attributes, swig_Procedural_EdgeDetection_bases, swig_Procedural_EdgeDetection_base_names };

static int _wrap_new_EllipseTexture(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::EllipseTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::EllipseTexture",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_EllipseTexture",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::EllipseTexture *)new Procedural::EllipseTexture(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",1,"Procedural::EllipseTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setColour",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("EllipseTexture_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::EllipseTexture *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setColour",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::EllipseTexture *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::EllipseTexture::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setColour",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::EllipseTexture *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_EllipseTexture_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_EllipseTexture_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_EllipseTexture_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setColour(Ogre::ColourValue)\n"
    "    Procedural::EllipseTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::EllipseTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setRadiusX__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadiusX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusX",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusX",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadiusX",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadiusX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadiusX__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadiusX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusX",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadiusX",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadiusX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadiusX(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setRadiusX__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setRadiusX__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setRadiusX'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setRadiusX(size_t)\n"
    "    Procedural::EllipseTexture::setRadiusX(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setRadiusY__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadiusY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusY",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusY",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadiusY",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadiusY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadiusY__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadiusY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusY",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadiusY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadiusY",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadiusY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadiusY(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setRadiusY__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setRadiusY__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setRadiusY'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setRadiusY(size_t)\n"
    "    Procedural::EllipseTexture::setRadiusY(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setRadius__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadius",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadius",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadius(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadius__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setRadius",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setRadius",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setRadius",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::EllipseTexture *) &(arg1)->setRadius(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setRadius(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_EllipseTexture_setRadius__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_EllipseTexture_setRadius__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setRadius'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setRadius(size_t,size_t)\n"
    "    Procedural::EllipseTexture::setRadius(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setCenterX__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterX",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterX",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenterX",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenterX__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterX",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenterX",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenterX(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setCenterX__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setCenterX__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setCenterX'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setCenterX(size_t)\n"
    "    Procedural::EllipseTexture::setCenterX(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setCenterY__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterY",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterY",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenterY",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenterY__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterY",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenterY",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenterY(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setCenterY__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_EllipseTexture_setCenterY__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setCenterY'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setCenterY(size_t)\n"
    "    Procedural::EllipseTexture::setCenterY(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_setCenter__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  bool arg3 ;
  Ogre::Vector2 *argp2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",1,"Procedural::EllipseTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",2,"Ogre::Vector2");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenter__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 *argp2 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",1,"Procedural::EllipseTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",2,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  result = (Procedural::EllipseTexture *) &(arg1)->setCenter(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenter__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",3,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenter__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  bool arg4 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenter",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",3,"Ogre::Real");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenter(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenter__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Procedural::EllipseTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::EllipseTexture::setCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",1,"Procedural::EllipseTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::EllipseTexture::setCenter",3,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_setCenter",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  result = (Procedural::EllipseTexture *) &(arg1)->setCenter(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__EllipseTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EllipseTexture_setCenter(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_EllipseTexture_setCenter__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_EllipseTexture_setCenter__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_EllipseTexture_setCenter__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_EllipseTexture_setCenter__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__EllipseTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_EllipseTexture_setCenter__SWIG_3(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'EllipseTexture_setCenter'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::EllipseTexture::setCenter(Ogre::Vector2,bool)\n"
    "    Procedural::EllipseTexture::setCenter(Ogre::Vector2)\n"
    "    Procedural::EllipseTexture::setCenter(size_t,size_t)\n"
    "    Procedural::EllipseTexture::setCenter(Ogre::Real,Ogre::Real,bool)\n"
    "    Procedural::EllipseTexture::setCenter(Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_EllipseTexture_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::EllipseTexture::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::EllipseTexture::process",1,"Procedural::EllipseTexture *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__EllipseTexture,0))){
    SWIG_fail_ptr("EllipseTexture_process",1,SWIGTYPE_p_Procedural__EllipseTexture);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_EllipseTexture(void *obj) {
Procedural::EllipseTexture *arg1 = (Procedural::EllipseTexture *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_EllipseTexture_methods[] = {
    {"setColour", _wrap_EllipseTexture_setColour}, 
    {"setRadiusX", _wrap_EllipseTexture_setRadiusX}, 
    {"setRadiusY", _wrap_EllipseTexture_setRadiusY}, 
    {"setRadius", _wrap_EllipseTexture_setRadius}, 
    {"setCenterX", _wrap_EllipseTexture_setCenterX}, 
    {"setCenterY", _wrap_EllipseTexture_setCenterY}, 
    {"setCenter", _wrap_EllipseTexture_setCenter}, 
    {"process", _wrap_EllipseTexture_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_EllipseTexture_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_EllipseTexture_bases[] = {0,0};
static const char *swig_Procedural_EllipseTexture_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_EllipseTexture = { "EllipseTexture", &SWIGTYPE_p_Procedural__EllipseTexture,_wrap_new_EllipseTexture, swig_delete_EllipseTexture, swig_Procedural_EllipseTexture_methods, swig_Procedural_EllipseTexture_attributes, swig_Procedural_EllipseTexture_bases, swig_Procedural_EllipseTexture_base_names };

static int _wrap_new_Flip(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Flip *result = 0 ;
  
  SWIG_check_num_args("Procedural::Flip::Flip",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Flip::Flip",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Flip",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Flip *)new Procedural::Flip(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Flip,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Flip_setAxis(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Flip *arg1 = (Procedural::Flip *) 0 ;
  Procedural::Flip::FLIP_AXIS arg2 ;
  Procedural::Flip *result = 0 ;
  
  SWIG_check_num_args("Procedural::Flip::setAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Flip::setAxis",1,"Procedural::Flip *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Flip::setAxis",2,"Procedural::Flip::FLIP_AXIS");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Flip,0))){
    SWIG_fail_ptr("Flip_setAxis",1,SWIGTYPE_p_Procedural__Flip);
  }
  
  arg2 = (Procedural::Flip::FLIP_AXIS)(int)lua_tonumber(L, 2);
  result = (Procedural::Flip *) &(arg1)->setAxis(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Flip,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Flip_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Flip *arg1 = (Procedural::Flip *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Flip::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Flip::process",1,"Procedural::Flip *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Flip,0))){
    SWIG_fail_ptr("Flip_process",1,SWIGTYPE_p_Procedural__Flip);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Flip(void *obj) {
Procedural::Flip *arg1 = (Procedural::Flip *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Flip_methods[] = {
    {"setAxis", _wrap_Flip_setAxis}, 
    {"process", _wrap_Flip_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Flip_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Flip_bases[] = {0,0};
static const char *swig_Procedural_Flip_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Flip = { "Flip", &SWIGTYPE_p_Procedural__Flip,_wrap_new_Flip, swig_delete_Flip, swig_Procedural_Flip_methods, swig_Procedural_Flip_attributes, swig_Procedural_Flip_bases, swig_Procedural_Flip_base_names };

static int _wrap_new_Glow(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::Glow",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::Glow",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Glow",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Glow *)new Procedural::Glow(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setColour",1,"Procedural::Glow *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Glow::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setColour",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Glow_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Glow *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setColour",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Glow::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Glow::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Glow::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setColour",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Glow *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setColour",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Glow::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Glow::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setColour",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Glow *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Glow, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Glow_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Glow, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Glow_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Glow, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Glow_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Glow_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Glow::setColour(Ogre::ColourValue)\n"
    "    Procedural::Glow::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Glow::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Glow_setCenterX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setCenterX",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setCenterX",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setCenterY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setCenterY",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setCenterY",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setRadiusX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setRadiusX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setRadiusX",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setRadiusX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setRadiusX",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setRadiusX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setRadiusY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setRadiusY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setRadiusY",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setRadiusY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setRadiusY",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setRadiusY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setAlpha(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setAlpha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setAlpha",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setAlpha",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setAlpha",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setAlpha(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_setGamma(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Glow *result = 0 ;
  
  SWIG_check_num_args("Procedural::Glow::setGamma",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::setGamma",1,"Procedural::Glow *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Glow::setGamma",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_setGamma",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Glow *) &(arg1)->setGamma(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Glow,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Glow_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Glow *arg1 = (Procedural::Glow *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Glow::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Glow::process",1,"Procedural::Glow *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Glow,0))){
    SWIG_fail_ptr("Glow_process",1,SWIGTYPE_p_Procedural__Glow);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Glow(void *obj) {
Procedural::Glow *arg1 = (Procedural::Glow *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Glow_methods[] = {
    {"setColour", _wrap_Glow_setColour}, 
    {"setCenterX", _wrap_Glow_setCenterX}, 
    {"setCenterY", _wrap_Glow_setCenterY}, 
    {"setRadiusX", _wrap_Glow_setRadiusX}, 
    {"setRadiusY", _wrap_Glow_setRadiusY}, 
    {"setAlpha", _wrap_Glow_setAlpha}, 
    {"setGamma", _wrap_Glow_setGamma}, 
    {"process", _wrap_Glow_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Glow_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Glow_bases[] = {0,0};
static const char *swig_Procedural_Glow_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Glow = { "Glow", &SWIGTYPE_p_Procedural__Glow,_wrap_new_Glow, swig_delete_Glow, swig_Procedural_Glow_methods, swig_Procedural_Glow_attributes, swig_Procedural_Glow_bases, swig_Procedural_Glow_base_names };

static int _wrap_new_Invert(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Invert *result = 0 ;
  
  SWIG_check_num_args("Procedural::Invert::Invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Invert::Invert",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Invert",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Invert *)new Procedural::Invert(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Invert,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Invert_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Invert *arg1 = (Procedural::Invert *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Invert::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Invert::process",1,"Procedural::Invert *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Invert,0))){
    SWIG_fail_ptr("Invert_process",1,SWIGTYPE_p_Procedural__Invert);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Invert(void *obj) {
Procedural::Invert *arg1 = (Procedural::Invert *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Invert_methods[] = {
    {"process", _wrap_Invert_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Invert_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Invert_bases[] = {0,0};
static const char *swig_Procedural_Invert_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Invert = { "Invert", &SWIGTYPE_p_Procedural__Invert,_wrap_new_Invert, swig_delete_Invert, swig_Procedural_Invert_methods, swig_Procedural_Invert_attributes, swig_Procedural_Invert_bases, swig_Procedural_Invert_base_names };

static int _wrap_new_Jitter(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Jitter *result = 0 ;
  
  SWIG_check_num_args("Procedural::Jitter::Jitter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Jitter::Jitter",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Jitter",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Jitter *)new Procedural::Jitter(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Jitter,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Jitter_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Jitter *arg1 = (Procedural::Jitter *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Jitter *result = 0 ;
  
  SWIG_check_num_args("Procedural::Jitter::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Jitter::setRadius",1,"Procedural::Jitter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Jitter::setRadius",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Jitter,0))){
    SWIG_fail_ptr("Jitter_setRadius",1,SWIGTYPE_p_Procedural__Jitter);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Jitter *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Jitter,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Jitter_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Jitter *arg1 = (Procedural::Jitter *) 0 ;
  Ogre::uint arg2 ;
  Procedural::Jitter *result = 0 ;
  
  SWIG_check_num_args("Procedural::Jitter::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Jitter::setSeed",1,"Procedural::Jitter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Jitter::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Jitter,0))){
    SWIG_fail_ptr("Jitter_setSeed",1,SWIGTYPE_p_Procedural__Jitter);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::Jitter *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Jitter,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Jitter_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Jitter *arg1 = (Procedural::Jitter *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Jitter::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Jitter::process",1,"Procedural::Jitter *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Jitter,0))){
    SWIG_fail_ptr("Jitter_process",1,SWIGTYPE_p_Procedural__Jitter);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Jitter(void *obj) {
Procedural::Jitter *arg1 = (Procedural::Jitter *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Jitter_methods[] = {
    {"setRadius", _wrap_Jitter_setRadius}, 
    {"setSeed", _wrap_Jitter_setSeed}, 
    {"process", _wrap_Jitter_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Jitter_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Jitter_bases[] = {0,0};
static const char *swig_Procedural_Jitter_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Jitter = { "Jitter", &SWIGTYPE_p_Procedural__Jitter,_wrap_new_Jitter, swig_delete_Jitter, swig_Procedural_Jitter_methods, swig_Procedural_Jitter_attributes, swig_Procedural_Jitter_bases, swig_Procedural_Jitter_base_names };

static int _wrap_new_Lerp(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Lerp *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lerp::Lerp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lerp::Lerp",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Lerp",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Lerp *)new Procedural::Lerp(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lerp,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lerp_setImageA(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lerp *arg1 = (Procedural::Lerp *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Lerp *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lerp::setImageA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lerp::setImageA",1,"Procedural::Lerp *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Lerp::setImageA",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lerp,0))){
    SWIG_fail_ptr("Lerp_setImageA",1,SWIGTYPE_p_Procedural__Lerp);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Lerp_setImageA",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Lerp *) &(arg1)->setImageA(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lerp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lerp_setImageB(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lerp *arg1 = (Procedural::Lerp *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Lerp *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lerp::setImageB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lerp::setImageB",1,"Procedural::Lerp *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Lerp::setImageB",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lerp,0))){
    SWIG_fail_ptr("Lerp_setImageB",1,SWIGTYPE_p_Procedural__Lerp);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Lerp_setImageB",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Lerp *) &(arg1)->setImageB(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lerp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lerp_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lerp *arg1 = (Procedural::Lerp *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Lerp::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lerp::process",1,"Procedural::Lerp *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lerp,0))){
    SWIG_fail_ptr("Lerp_process",1,SWIGTYPE_p_Procedural__Lerp);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Lerp(void *obj) {
Procedural::Lerp *arg1 = (Procedural::Lerp *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Lerp_methods[] = {
    {"setImageA", _wrap_Lerp_setImageA}, 
    {"setImageB", _wrap_Lerp_setImageB}, 
    {"process", _wrap_Lerp_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Lerp_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Lerp_bases[] = {0,0};
static const char *swig_Procedural_Lerp_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Lerp = { "Lerp", &SWIGTYPE_p_Procedural__Lerp,_wrap_new_Lerp, swig_delete_Lerp, swig_Procedural_Lerp_methods, swig_Procedural_Lerp_attributes, swig_Procedural_Lerp_bases, swig_Procedural_Lerp_base_names };

static int _wrap_new_Light(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::Light",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::Light",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Light",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Light *)new Procedural::Light(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setNormalMap(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setNormalMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setNormalMap",1,"Procedural::Light *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Light::setNormalMap",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setNormalMap",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Light_setNormalMap",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Light *) &(arg1)->setNormalMap(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourAmbient__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourAmbient",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourAmbient",1,"Procedural::Light *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Light::setColourAmbient",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourAmbient",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColourAmbient",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Light *) &(arg1)->setColourAmbient(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourAmbient__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourAmbient",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourAmbient",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourAmbient",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourAmbient",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourAmbient",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Light::setColourAmbient",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourAmbient",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Light *) &(arg1)->setColourAmbient(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourAmbient__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourAmbient",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourAmbient",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourAmbient",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourAmbient",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourAmbient",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourAmbient",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Light *) &(arg1)->setColourAmbient(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourAmbient(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Light_setColourAmbient__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Light_setColourAmbient__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Light_setColourAmbient__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Light_setColourAmbient'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Light::setColourAmbient(Ogre::ColourValue)\n"
    "    Procedural::Light::setColourAmbient(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Light::setColourAmbient(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Light_setColourDiffuse__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourDiffuse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",1,"Procedural::Light *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourDiffuse",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColourDiffuse",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Light *) &(arg1)->setColourDiffuse(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourDiffuse__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourDiffuse",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourDiffuse",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Light *) &(arg1)->setColourDiffuse(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourDiffuse__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourDiffuse",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourDiffuse",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourDiffuse",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Light *) &(arg1)->setColourDiffuse(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourDiffuse(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Light_setColourDiffuse__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Light_setColourDiffuse__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Light_setColourDiffuse__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Light_setColourDiffuse'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Light::setColourDiffuse(Ogre::ColourValue)\n"
    "    Procedural::Light::setColourDiffuse(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Light::setColourDiffuse(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Light_setColourSpecular__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourSpecular",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourSpecular",1,"Procedural::Light *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Light::setColourSpecular",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourSpecular",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColourSpecular",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::Light *) &(arg1)->setColourSpecular(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourSpecular__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourSpecular",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourSpecular",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourSpecular",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourSpecular",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourSpecular",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::Light::setColourSpecular",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourSpecular",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::Light *) &(arg1)->setColourSpecular(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourSpecular__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColourSpecular",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColourSpecular",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setColourSpecular",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setColourSpecular",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setColourSpecular",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColourSpecular",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Light *) &(arg1)->setColourSpecular(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setColourSpecular(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Light_setColourSpecular__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Light_setColourSpecular__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_Light_setColourSpecular__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Light_setColourSpecular'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Light::setColourSpecular(Ogre::ColourValue)\n"
    "    Procedural::Light::setColourSpecular(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::Light::setColourSpecular(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Light_setColours(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue arg3 ;
  Ogre::ColourValue arg4 ;
  Ogre::ColourValue *argp2 ;
  Ogre::ColourValue *argp3 ;
  Ogre::ColourValue *argp4 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setColours",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setColours",1,"Procedural::Light *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Light::setColours",2,"Ogre::ColourValue");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::Light::setColours",3,"Ogre::ColourValue");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Procedural::Light::setColours",4,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setColours",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColours",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColours",3,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg3 = *argp3;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("Light_setColours",4,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg4 = *argp4;
  
  result = (Procedural::Light *) &(arg1)->setColours(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Vector3 arg2 ;
  Ogre::Vector3 *argp2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setPosition",1,"Procedural::Light *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Light::setPosition",2,"Ogre::Vector3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setPosition",1,SWIGTYPE_p_Procedural__Light);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector3,0))){
    SWIG_fail_ptr("Light_setPosition",2,SWIGTYPE_p_Ogre__Vector3);
  }
  arg2 = *argp2;
  
  result = (Procedural::Light *) &(arg1)->setPosition(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setPosition",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setPosition",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::Light::setPosition",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::Light::setPosition",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setPosition",1,SWIGTYPE_p_Procedural__Light);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::Light *) &(arg1)->setPosition(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Light_setPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Light, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Light_setPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Light_setPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Light::setPosition(Ogre::Vector3)\n"
    "    Procedural::Light::setPosition(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_Light_setSpecularPower(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setSpecularPower",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setSpecularPower",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setSpecularPower",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setSpecularPower",1,SWIGTYPE_p_Procedural__Light);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Light *) &(arg1)->setSpecularPower(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_setBumpPower(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Light *result = 0 ;
  
  SWIG_check_num_args("Procedural::Light::setBumpPower",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::setBumpPower",1,"Procedural::Light *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Light::setBumpPower",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_setBumpPower",1,SWIGTYPE_p_Procedural__Light);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Light *) &(arg1)->setBumpPower(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Light,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Light_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Light *arg1 = (Procedural::Light *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Light::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Light::process",1,"Procedural::Light *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Light,0))){
    SWIG_fail_ptr("Light_process",1,SWIGTYPE_p_Procedural__Light);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Light(void *obj) {
Procedural::Light *arg1 = (Procedural::Light *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Light_methods[] = {
    {"setNormalMap", _wrap_Light_setNormalMap}, 
    {"setColourAmbient", _wrap_Light_setColourAmbient}, 
    {"setColourDiffuse", _wrap_Light_setColourDiffuse}, 
    {"setColourSpecular", _wrap_Light_setColourSpecular}, 
    {"setColours", _wrap_Light_setColours}, 
    {"setPosition", _wrap_Light_setPosition}, 
    {"setSpecularPower", _wrap_Light_setSpecularPower}, 
    {"setBumpPower", _wrap_Light_setBumpPower}, 
    {"process", _wrap_Light_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Light_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Light_bases[] = {0,0};
static const char *swig_Procedural_Light_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Light = { "Light", &SWIGTYPE_p_Procedural__Light,_wrap_new_Light, swig_delete_Light, swig_Procedural_Light_methods, swig_Procedural_Light_attributes, swig_Procedural_Light_bases, swig_Procedural_Light_base_names };

static int _wrap_new_Lookup(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Lookup *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lookup::Lookup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lookup::Lookup",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Lookup",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Lookup *)new Procedural::Lookup(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lookup,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lookup_setParameterImage(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lookup *arg1 = (Procedural::Lookup *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Lookup *result = 0 ;
  
  SWIG_check_num_args("Procedural::Lookup::setParameterImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lookup::setParameterImage",1,"Procedural::Lookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Lookup::setParameterImage",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lookup,0))){
    SWIG_fail_ptr("Lookup_setParameterImage",1,SWIGTYPE_p_Procedural__Lookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Lookup_setParameterImage",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Lookup *) &(arg1)->setParameterImage(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Lookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Lookup_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Lookup *arg1 = (Procedural::Lookup *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Lookup::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Lookup::process",1,"Procedural::Lookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Lookup,0))){
    SWIG_fail_ptr("Lookup_process",1,SWIGTYPE_p_Procedural__Lookup);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Lookup(void *obj) {
Procedural::Lookup *arg1 = (Procedural::Lookup *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Lookup_methods[] = {
    {"setParameterImage", _wrap_Lookup_setParameterImage}, 
    {"process", _wrap_Lookup_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Lookup_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Lookup_bases[] = {0,0};
static const char *swig_Procedural_Lookup_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Lookup = { "Lookup", &SWIGTYPE_p_Procedural__Lookup,_wrap_new_Lookup, swig_delete_Lookup, swig_Procedural_Lookup_methods, swig_Procedural_Lookup_attributes, swig_Procedural_Lookup_bases, swig_Procedural_Lookup_base_names };

static int _wrap_new_Normals(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Normals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Normals::Normals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Normals::Normals",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Normals",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Normals *)new Procedural::Normals(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Normals,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Normals_setAmplify(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Normals *arg1 = (Procedural::Normals *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Normals *result = 0 ;
  
  SWIG_check_num_args("Procedural::Normals::setAmplify",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Normals::setAmplify",1,"Procedural::Normals *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Normals::setAmplify",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Normals,0))){
    SWIG_fail_ptr("Normals_setAmplify",1,SWIGTYPE_p_Procedural__Normals);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Normals *) &(arg1)->setAmplify(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Normals,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Normals_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Normals *arg1 = (Procedural::Normals *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Normals::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Normals::process",1,"Procedural::Normals *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Normals,0))){
    SWIG_fail_ptr("Normals_process",1,SWIGTYPE_p_Procedural__Normals);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Normals(void *obj) {
Procedural::Normals *arg1 = (Procedural::Normals *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Normals_methods[] = {
    {"setAmplify", _wrap_Normals_setAmplify}, 
    {"process", _wrap_Normals_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Normals_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Normals_bases[] = {0,0};
static const char *swig_Procedural_Normals_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Normals = { "Normals", &SWIGTYPE_p_Procedural__Normals,_wrap_new_Normals, swig_delete_Normals, swig_Procedural_Normals_methods, swig_Procedural_Normals_attributes, swig_Procedural_Normals_bases, swig_Procedural_Normals_base_names };

static int _wrap_new_OilPaint(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::OilPaint *result = 0 ;
  
  SWIG_check_num_args("Procedural::OilPaint::OilPaint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::OilPaint::OilPaint",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_OilPaint",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::OilPaint *)new Procedural::OilPaint(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__OilPaint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OilPaint_setRadius(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::OilPaint *arg1 = (Procedural::OilPaint *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::OilPaint *result = 0 ;
  
  SWIG_check_num_args("Procedural::OilPaint::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::OilPaint::setRadius",1,"Procedural::OilPaint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::OilPaint::setRadius",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__OilPaint,0))){
    SWIG_fail_ptr("OilPaint_setRadius",1,SWIGTYPE_p_Procedural__OilPaint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::OilPaint *) &(arg1)->setRadius(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__OilPaint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OilPaint_setIntensity(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::OilPaint *arg1 = (Procedural::OilPaint *) 0 ;
  Ogre::Real arg2 ;
  Procedural::OilPaint *result = 0 ;
  
  SWIG_check_num_args("Procedural::OilPaint::setIntensity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::OilPaint::setIntensity",1,"Procedural::OilPaint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::OilPaint::setIntensity",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__OilPaint,0))){
    SWIG_fail_ptr("OilPaint_setIntensity",1,SWIGTYPE_p_Procedural__OilPaint);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::OilPaint *) &(arg1)->setIntensity(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__OilPaint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OilPaint_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::OilPaint *arg1 = (Procedural::OilPaint *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::OilPaint::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::OilPaint::process",1,"Procedural::OilPaint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__OilPaint,0))){
    SWIG_fail_ptr("OilPaint_process",1,SWIGTYPE_p_Procedural__OilPaint);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_OilPaint(void *obj) {
Procedural::OilPaint *arg1 = (Procedural::OilPaint *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_OilPaint_methods[] = {
    {"setRadius", _wrap_OilPaint_setRadius}, 
    {"setIntensity", _wrap_OilPaint_setIntensity}, 
    {"process", _wrap_OilPaint_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_OilPaint_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_OilPaint_bases[] = {0,0};
static const char *swig_Procedural_OilPaint_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_OilPaint = { "OilPaint", &SWIGTYPE_p_Procedural__OilPaint,_wrap_new_OilPaint, swig_delete_OilPaint, swig_Procedural_OilPaint_methods, swig_Procedural_OilPaint_attributes, swig_Procedural_OilPaint_bases, swig_Procedural_OilPaint_base_names };

static int _wrap_new_RandomPixels(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::RandomPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::RandomPixels",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_RandomPixels",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::RandomPixels *)new Procedural::RandomPixels(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::setColour",1,"Procedural::RandomPixels *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RandomPixels::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_setColour",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("RandomPixels_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::RandomPixels *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::setColour",1,"Procedural::RandomPixels *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RandomPixels::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RandomPixels::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RandomPixels::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::RandomPixels::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_setColour",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::RandomPixels *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::setColour",1,"Procedural::RandomPixels *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RandomPixels::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RandomPixels::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RandomPixels::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_setColour",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::RandomPixels *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RandomPixels, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RandomPixels_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RandomPixels, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_RandomPixels_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RandomPixels, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_RandomPixels_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RandomPixels_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RandomPixels::setColour(Ogre::ColourValue)\n"
    "    Procedural::RandomPixels::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::RandomPixels::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RandomPixels_setSeed(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Ogre::uint arg2 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::setSeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::setSeed",1,"Procedural::RandomPixels *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RandomPixels::setSeed",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_setSeed",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::RandomPixels *) &(arg1)->setSeed(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_setCount(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Ogre::uint arg2 ;
  Procedural::RandomPixels *result = 0 ;
  
  SWIG_check_num_args("Procedural::RandomPixels::setCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::setCount",1,"Procedural::RandomPixels *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RandomPixels::setCount",2,"Ogre::uint");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_setCount",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uint)lua_tonumber(L, 2);
  result = (Procedural::RandomPixels *) &(arg1)->setCount(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RandomPixels,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomPixels_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::RandomPixels::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RandomPixels::process",1,"Procedural::RandomPixels *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RandomPixels,0))){
    SWIG_fail_ptr("RandomPixels_process",1,SWIGTYPE_p_Procedural__RandomPixels);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RandomPixels(void *obj) {
Procedural::RandomPixels *arg1 = (Procedural::RandomPixels *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RandomPixels_methods[] = {
    {"setColour", _wrap_RandomPixels_setColour}, 
    {"setSeed", _wrap_RandomPixels_setSeed}, 
    {"setCount", _wrap_RandomPixels_setCount}, 
    {"process", _wrap_RandomPixels_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RandomPixels_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RandomPixels_bases[] = {0,0};
static const char *swig_Procedural_RandomPixels_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_RandomPixels = { "RandomPixels", &SWIGTYPE_p_Procedural__RandomPixels,_wrap_new_RandomPixels, swig_delete_RandomPixels, swig_Procedural_RandomPixels_methods, swig_Procedural_RandomPixels_attributes, swig_Procedural_RandomPixels_bases, swig_Procedural_RandomPixels_base_names };

static int _wrap_new_RectangleTexture(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::RectangleTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::RectangleTexture",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_RectangleTexture",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::RectangleTexture *)new Procedural::RectangleTexture(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setColour__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::ColourValue arg2 ;
  Ogre::ColourValue *argp2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setColour",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",2,"Ogre::ColourValue");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setColour",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__ColourValue,0))){
    SWIG_fail_ptr("RectangleTexture_setColour",2,SWIGTYPE_p_Ogre__ColourValue);
  }
  arg2 = *argp2;
  
  result = (Procedural::RectangleTexture *) &(arg1)->setColour(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setColour__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setColour",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setColour",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::RectangleTexture *) &(arg1)->setColour(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setColour__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setColour",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RectangleTexture::setColour",4,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setColour",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  result = (Procedural::RectangleTexture *) &(arg1)->setColour(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setColour(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__ColourValue, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RectangleTexture_setColour__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_RectangleTexture_setColour__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_RectangleTexture_setColour__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setColour'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setColour(Ogre::ColourValue)\n"
    "    Procedural::RectangleTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n"
    "    Procedural::RectangleTexture::setColour(Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_setX1__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  size_t arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setX1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setX1",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setX1",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setX1",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setX1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setX1__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setX1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setX1",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setX1",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setX1",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setX1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setX1(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setX1__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setX1__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setX1'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setX1(size_t)\n"
    "    Procedural::RectangleTexture::setX1(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_setY1__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  size_t arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setY1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setY1",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setY1",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setY1",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setY1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setY1__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setY1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setY1",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setY1",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setY1",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setY1(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setY1(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setY1__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setY1__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setY1'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setY1(size_t)\n"
    "    Procedural::RectangleTexture::setY1(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_setX2__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  size_t arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setX2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setX2",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setX2",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setX2",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setX2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setX2__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setX2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setX2",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setX2",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setX2",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setX2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setX2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setX2__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setX2__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setX2'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setX2(size_t)\n"
    "    Procedural::RectangleTexture::setX2(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_setY2__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  size_t arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setY2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setY2",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setY2",2,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setY2",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setY2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setY2__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setY2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setY2",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setY2",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setY2",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RectangleTexture *) &(arg1)->setY2(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setY2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setY2__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RectangleTexture_setY2__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setY2'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setY2(size_t)\n"
    "    Procedural::RectangleTexture::setY2(Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::RealRect arg2 ;
  bool arg3 ;
  Ogre::RealRect *argp2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::RealRect");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::RealRect arg2 ;
  Ogre::RealRect *argp2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::RealRect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_float_t,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",2,SWIGTYPE_p_Ogre__TRectT_float_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Rect arg2 ;
  Ogre::Rect *argp2 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::Rect");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__TRectT_long_t,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",2,SWIGTYPE_p_Ogre__TRectT_long_t);
  }
  arg2 = *argp2;
  
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  bool arg4 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",3,"Ogre::Vector2");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Vector2 arg2 ;
  Ogre::Vector2 arg3 ;
  Ogre::Vector2 *argp2 ;
  Ogre::Vector2 *argp3 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::Vector2");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",3,"Ogre::Vector2");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",2,SWIGTYPE_p_Ogre__Vector2);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Ogre__Vector2,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",3,SWIGTYPE_p_Ogre__Vector2);
  }
  arg3 = *argp3;
  
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",5,"size_t");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (size_t)lua_tonumber(L, 5);
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Ogre::Real arg2 ;
  Ogre::Real arg3 ;
  Ogre::Real arg4 ;
  Ogre::Real arg5 ;
  Procedural::RectangleTexture *result = 0 ;
  
  SWIG_check_num_args("Procedural::RectangleTexture::setRectangle",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",1,"Procedural::RectangleTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",2,"Ogre::Real");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",3,"Ogre::Real");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",4,"Ogre::Real");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Procedural::RectangleTexture::setRectangle",5,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_setRectangle",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  arg3 = (Ogre::Real)lua_tonumber(L, 3);
  arg4 = (Ogre::Real)lua_tonumber(L, 4);
  arg5 = (Ogre::Real)lua_tonumber(L, 5);
  result = (Procedural::RectangleTexture *) &(arg1)->setRectangle(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RectangleTexture,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RectangleTexture_setRectangle(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RectangleTexture_setRectangle__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_long_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RectangleTexture_setRectangle__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__TRectT_float_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_RectangleTexture_setRectangle__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_RectangleTexture_setRectangle__SWIG_4(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Ogre__Vector2, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_RectangleTexture_setRectangle__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_RectangleTexture_setRectangle__SWIG_5(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RectangleTexture, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_RectangleTexture_setRectangle__SWIG_6(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RectangleTexture_setRectangle'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::RealRect,bool)\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::RealRect)\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::Rect)\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::Vector2,Ogre::Vector2,bool)\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::Vector2,Ogre::Vector2)\n"
    "    Procedural::RectangleTexture::setRectangle(size_t,size_t,size_t,size_t)\n"
    "    Procedural::RectangleTexture::setRectangle(Ogre::Real,Ogre::Real,Ogre::Real,Ogre::Real)\n");
  lua_error(L);return 0;
}


static int _wrap_RectangleTexture_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::RectangleTexture::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RectangleTexture::process",1,"Procedural::RectangleTexture *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RectangleTexture,0))){
    SWIG_fail_ptr("RectangleTexture_process",1,SWIGTYPE_p_Procedural__RectangleTexture);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RectangleTexture(void *obj) {
Procedural::RectangleTexture *arg1 = (Procedural::RectangleTexture *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RectangleTexture_methods[] = {
    {"setColour", _wrap_RectangleTexture_setColour}, 
    {"setX1", _wrap_RectangleTexture_setX1}, 
    {"setY1", _wrap_RectangleTexture_setY1}, 
    {"setX2", _wrap_RectangleTexture_setX2}, 
    {"setY2", _wrap_RectangleTexture_setY2}, 
    {"setRectangle", _wrap_RectangleTexture_setRectangle}, 
    {"process", _wrap_RectangleTexture_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RectangleTexture_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RectangleTexture_bases[] = {0,0};
static const char *swig_Procedural_RectangleTexture_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_RectangleTexture = { "RectangleTexture", &SWIGTYPE_p_Procedural__RectangleTexture,_wrap_new_RectangleTexture, swig_delete_RectangleTexture, swig_Procedural_RectangleTexture_methods, swig_Procedural_RectangleTexture_attributes, swig_Procedural_RectangleTexture_bases, swig_Procedural_RectangleTexture_base_names };

static int _wrap_new_RotationZoom(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::RotationZoom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::RotationZoom",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_RotationZoom",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::RotationZoom *)new Procedural::RotationZoom(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setCenterX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setCenterX",1,"Procedural::RotationZoom *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setCenterX",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RotationZoom *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setCenterY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setCenterY",1,"Procedural::RotationZoom *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setCenterY",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RotationZoom *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setZoomX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setZoomX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setZoomX",1,"Procedural::RotationZoom *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setZoomX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setZoomX",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RotationZoom *) &(arg1)->setZoomX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setZoomY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setZoomY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setZoomY",1,"Procedural::RotationZoom *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setZoomY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setZoomY",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RotationZoom *) &(arg1)->setZoomY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setRotation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Real arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",1,"Procedural::RotationZoom *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setRotation",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::RotationZoom *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setRotation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",1,"Procedural::RotationZoom *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setRotation",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("RotationZoom_setRotation",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::RotationZoom *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setRotation__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Ogre::Degree arg2 ;
  Ogre::Degree *argp2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setRotation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",1,"Procedural::RotationZoom *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setRotation",2,"Ogre::Degree");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setRotation",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("RotationZoom_setRotation",2,SWIGTYPE_p_Ogre__Degree);
  }
  arg2 = *argp2;
  
  result = (Procedural::RotationZoom *) &(arg1)->setRotation(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_setRotation(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RotationZoom, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RotationZoom_setRotation__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RotationZoom, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_RotationZoom_setRotation__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__RotationZoom, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_RotationZoom_setRotation__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'RotationZoom_setRotation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::RotationZoom::setRotation(Ogre::Real)\n"
    "    Procedural::RotationZoom::setRotation(Ogre::Radian)\n"
    "    Procedural::RotationZoom::setRotation(Ogre::Degree)\n");
  lua_error(L);return 0;
}


static int _wrap_RotationZoom_setWrap(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  bool arg2 ;
  Procedural::RotationZoom *result = 0 ;
  
  SWIG_check_num_args("Procedural::RotationZoom::setWrap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::setWrap",1,"Procedural::RotationZoom *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Procedural::RotationZoom::setWrap",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_setWrap",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (Procedural::RotationZoom *) &(arg1)->setWrap(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__RotationZoom,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RotationZoom_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::RotationZoom::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::RotationZoom::process",1,"Procedural::RotationZoom *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__RotationZoom,0))){
    SWIG_fail_ptr("RotationZoom_process",1,SWIGTYPE_p_Procedural__RotationZoom);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RotationZoom(void *obj) {
Procedural::RotationZoom *arg1 = (Procedural::RotationZoom *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_RotationZoom_methods[] = {
    {"setCenterX", _wrap_RotationZoom_setCenterX}, 
    {"setCenterY", _wrap_RotationZoom_setCenterY}, 
    {"setZoomX", _wrap_RotationZoom_setZoomX}, 
    {"setZoomY", _wrap_RotationZoom_setZoomY}, 
    {"setRotation", _wrap_RotationZoom_setRotation}, 
    {"setWrap", _wrap_RotationZoom_setWrap}, 
    {"process", _wrap_RotationZoom_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_RotationZoom_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_RotationZoom_bases[] = {0,0};
static const char *swig_Procedural_RotationZoom_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_RotationZoom = { "RotationZoom", &SWIGTYPE_p_Procedural__RotationZoom,_wrap_new_RotationZoom, swig_delete_RotationZoom, swig_Procedural_RotationZoom_methods, swig_Procedural_RotationZoom_attributes, swig_Procedural_RotationZoom_bases, swig_Procedural_RotationZoom_base_names };

static int _wrap_new_Segment(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Segment *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment::Segment",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment::Segment",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Segment",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Segment *)new Procedural::Segment(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment_setColourSource(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment *arg1 = (Procedural::Segment *) 0 ;
  Procedural::TextureBufferPtr arg2 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Segment *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment::setColourSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment::setColourSource",1,"Procedural::Segment *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Procedural::Segment::setColourSource",2,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment,0))){
    SWIG_fail_ptr("Segment_setColourSource",1,SWIGTYPE_p_Procedural__Segment);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("Segment_setColourSource",2,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Segment *) &(arg1)->setColourSource(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment_setThreshold(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment *arg1 = (Procedural::Segment *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Segment *result = 0 ;
  
  SWIG_check_num_args("Procedural::Segment::setThreshold",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment::setThreshold",1,"Procedural::Segment *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Segment::setThreshold",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment,0))){
    SWIG_fail_ptr("Segment_setThreshold",1,SWIGTYPE_p_Procedural__Segment);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Segment *) &(arg1)->setThreshold(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Segment,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Segment_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Segment *arg1 = (Procedural::Segment *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Segment::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Segment::process",1,"Procedural::Segment *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Segment,0))){
    SWIG_fail_ptr("Segment_process",1,SWIGTYPE_p_Procedural__Segment);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Segment(void *obj) {
Procedural::Segment *arg1 = (Procedural::Segment *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Segment_methods[] = {
    {"setColourSource", _wrap_Segment_setColourSource}, 
    {"setThreshold", _wrap_Segment_setThreshold}, 
    {"process", _wrap_Segment_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Segment_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Segment_bases[] = {0,0};
static const char *swig_Procedural_Segment_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Segment = { "Segment", &SWIGTYPE_p_Procedural__Segment,_wrap_new_Segment, swig_delete_Segment, swig_Procedural_Segment_methods, swig_Procedural_Segment_attributes, swig_Procedural_Segment_bases, swig_Procedural_Segment_base_names };

static int _wrap_new_Sharpen(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Sharpen *result = 0 ;
  
  SWIG_check_num_args("Procedural::Sharpen::Sharpen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Sharpen::Sharpen",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Sharpen",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Sharpen *)new Procedural::Sharpen(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Sharpen,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sharpen_setSize(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Sharpen *arg1 = (Procedural::Sharpen *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Sharpen *result = 0 ;
  
  SWIG_check_num_args("Procedural::Sharpen::setSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Sharpen::setSize",1,"Procedural::Sharpen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Sharpen::setSize",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Sharpen,0))){
    SWIG_fail_ptr("Sharpen_setSize",1,SWIGTYPE_p_Procedural__Sharpen);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Sharpen *) &(arg1)->setSize(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Sharpen,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sharpen_setSigma(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Sharpen *arg1 = (Procedural::Sharpen *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Sharpen *result = 0 ;
  
  SWIG_check_num_args("Procedural::Sharpen::setSigma",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Sharpen::setSigma",1,"Procedural::Sharpen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Sharpen::setSigma",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Sharpen,0))){
    SWIG_fail_ptr("Sharpen_setSigma",1,SWIGTYPE_p_Procedural__Sharpen);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Sharpen *) &(arg1)->setSigma(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Sharpen,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sharpen_setType(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Sharpen *arg1 = (Procedural::Sharpen *) 0 ;
  Procedural::Sharpen::SHARP_TYPE arg2 ;
  Procedural::Sharpen *result = 0 ;
  
  SWIG_check_num_args("Procedural::Sharpen::setType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Sharpen::setType",1,"Procedural::Sharpen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Sharpen::setType",2,"Procedural::Sharpen::SHARP_TYPE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Sharpen,0))){
    SWIG_fail_ptr("Sharpen_setType",1,SWIGTYPE_p_Procedural__Sharpen);
  }
  
  arg2 = (Procedural::Sharpen::SHARP_TYPE)(int)lua_tonumber(L, 2);
  result = (Procedural::Sharpen *) &(arg1)->setType(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Sharpen,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Sharpen_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Sharpen *arg1 = (Procedural::Sharpen *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Sharpen::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Sharpen::process",1,"Procedural::Sharpen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Sharpen,0))){
    SWIG_fail_ptr("Sharpen_process",1,SWIGTYPE_p_Procedural__Sharpen);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Sharpen(void *obj) {
Procedural::Sharpen *arg1 = (Procedural::Sharpen *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Sharpen_methods[] = {
    {"setSize", _wrap_Sharpen_setSize}, 
    {"setSigma", _wrap_Sharpen_setSigma}, 
    {"setType", _wrap_Sharpen_setType}, 
    {"process", _wrap_Sharpen_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Sharpen_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Sharpen_bases[] = {0,0};
static const char *swig_Procedural_Sharpen_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Sharpen = { "Sharpen", &SWIGTYPE_p_Procedural__Sharpen,_wrap_new_Sharpen, swig_delete_Sharpen, swig_Procedural_Sharpen_methods, swig_Procedural_Sharpen_attributes, swig_Procedural_Sharpen_bases, swig_Procedural_Sharpen_base_names };

static int _wrap_new_Threshold(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Threshold *result = 0 ;
  
  SWIG_check_num_args("Procedural::Threshold::Threshold",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Threshold::Threshold",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Threshold",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Threshold *)new Procedural::Threshold(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Threshold,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Threshold_setThreshold(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Threshold *arg1 = (Procedural::Threshold *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Threshold *result = 0 ;
  
  SWIG_check_num_args("Procedural::Threshold::setThreshold",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Threshold::setThreshold",1,"Procedural::Threshold *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Threshold::setThreshold",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Threshold,0))){
    SWIG_fail_ptr("Threshold_setThreshold",1,SWIGTYPE_p_Procedural__Threshold);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Threshold *) &(arg1)->setThreshold(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Threshold,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Threshold_setRatio(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Threshold *arg1 = (Procedural::Threshold *) 0 ;
  Ogre::uchar arg2 ;
  Procedural::Threshold *result = 0 ;
  
  SWIG_check_num_args("Procedural::Threshold::setRatio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Threshold::setRatio",1,"Procedural::Threshold *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Threshold::setRatio",2,"Ogre::uchar");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Threshold,0))){
    SWIG_fail_ptr("Threshold_setRatio",1,SWIGTYPE_p_Procedural__Threshold);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (Ogre::uchar)lua_tonumber(L, 2);
  result = (Procedural::Threshold *) &(arg1)->setRatio(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Threshold,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Threshold_setMode(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Threshold *arg1 = (Procedural::Threshold *) 0 ;
  Procedural::Threshold::THRESHOLD_MODE arg2 ;
  Procedural::Threshold *result = 0 ;
  
  SWIG_check_num_args("Procedural::Threshold::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Threshold::setMode",1,"Procedural::Threshold *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Threshold::setMode",2,"Procedural::Threshold::THRESHOLD_MODE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Threshold,0))){
    SWIG_fail_ptr("Threshold_setMode",1,SWIGTYPE_p_Procedural__Threshold);
  }
  
  arg2 = (Procedural::Threshold::THRESHOLD_MODE)(int)lua_tonumber(L, 2);
  result = (Procedural::Threshold *) &(arg1)->setMode(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Threshold,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Threshold_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Threshold *arg1 = (Procedural::Threshold *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Threshold::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Threshold::process",1,"Procedural::Threshold *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Threshold,0))){
    SWIG_fail_ptr("Threshold_process",1,SWIGTYPE_p_Procedural__Threshold);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Threshold(void *obj) {
Procedural::Threshold *arg1 = (Procedural::Threshold *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Threshold_methods[] = {
    {"setThreshold", _wrap_Threshold_setThreshold}, 
    {"setRatio", _wrap_Threshold_setRatio}, 
    {"setMode", _wrap_Threshold_setMode}, 
    {"process", _wrap_Threshold_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Threshold_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Threshold_bases[] = {0,0};
static const char *swig_Procedural_Threshold_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Threshold = { "Threshold", &SWIGTYPE_p_Procedural__Threshold,_wrap_new_Threshold, swig_delete_Threshold, swig_Procedural_Threshold_methods, swig_Procedural_Threshold_attributes, swig_Procedural_Threshold_bases, swig_Procedural_Threshold_base_names };

static int _wrap_new_Vortex(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::TextureBufferPtr arg1 = (Procedural::TextureBufferPtr) 0 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::Vortex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::Vortex",1,"Procedural::TextureBufferPtr");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__TextureBuffer,0))){
    SWIG_fail_ptr("new_Vortex",1,SWIGTYPE_p_Procedural__TextureBuffer);
  }
  
  result = (Procedural::Vortex *)new Procedural::Vortex(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setCenterX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setCenterX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setCenterX",1,"Procedural::Vortex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Vortex::setCenterX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setCenterX",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Vortex *) &(arg1)->setCenterX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setCenterY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setCenterY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setCenterY",1,"Procedural::Vortex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Vortex::setCenterY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setCenterY",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Vortex *) &(arg1)->setCenterY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setRadiusX(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setRadiusX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setRadiusX",1,"Procedural::Vortex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Vortex::setRadiusX",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setRadiusX",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Vortex *) &(arg1)->setRadiusX(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setRadiusY(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setRadiusY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setRadiusY",1,"Procedural::Vortex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Vortex::setRadiusY",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setRadiusY",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Vortex *) &(arg1)->setRadiusY(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setTwist__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Real arg2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setTwist",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setTwist",1,"Procedural::Vortex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Procedural::Vortex::setTwist",2,"Ogre::Real");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setTwist",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  arg2 = (Ogre::Real)lua_tonumber(L, 2);
  result = (Procedural::Vortex *) &(arg1)->setTwist(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setTwist__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Radian arg2 ;
  Ogre::Radian *argp2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setTwist",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setTwist",1,"Procedural::Vortex *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Vortex::setTwist",2,"Ogre::Radian");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setTwist",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Radian,0))){
    SWIG_fail_ptr("Vortex_setTwist",2,SWIGTYPE_p_Ogre__Radian);
  }
  arg2 = *argp2;
  
  result = (Procedural::Vortex *) &(arg1)->setTwist(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setTwist__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Ogre::Degree arg2 ;
  Ogre::Degree *argp2 ;
  Procedural::Vortex *result = 0 ;
  
  SWIG_check_num_args("Procedural::Vortex::setTwist",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::setTwist",1,"Procedural::Vortex *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Procedural::Vortex::setTwist",2,"Ogre::Degree");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_setTwist",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Ogre__Degree,0))){
    SWIG_fail_ptr("Vortex_setTwist",2,SWIGTYPE_p_Ogre__Degree);
  }
  arg2 = *argp2;
  
  result = (Procedural::Vortex *) &(arg1)->setTwist(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__Vortex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vortex_setTwist(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Vortex, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Radian, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vortex_setTwist__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Vortex, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Ogre__Degree, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vortex_setTwist__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Procedural__Vortex, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vortex_setTwist__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'Vortex_setTwist'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Procedural::Vortex::setTwist(Ogre::Real)\n"
    "    Procedural::Vortex::setTwist(Ogre::Radian)\n"
    "    Procedural::Vortex::setTwist(Ogre::Degree)\n");
  lua_error(L);return 0;
}


static int _wrap_Vortex_process(lua_State* L) {
  int SWIG_arg = 0;
  Procedural::Vortex *arg1 = (Procedural::Vortex *) 0 ;
  Procedural::TextureBufferPtr result;
  
  SWIG_check_num_args("Procedural::Vortex::process",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Procedural::Vortex::process",1,"Procedural::Vortex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Procedural__Vortex,0))){
    SWIG_fail_ptr("Vortex_process",1,SWIGTYPE_p_Procedural__Vortex);
  }
  
  result = (Procedural::TextureBufferPtr)(arg1)->process();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Procedural__TextureBuffer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vortex(void *obj) {
Procedural::Vortex *arg1 = (Procedural::Vortex *) obj;
delete arg1;
}
static swig_lua_method swig_Procedural_Vortex_methods[] = {
    {"setCenterX", _wrap_Vortex_setCenterX}, 
    {"setCenterY", _wrap_Vortex_setCenterY}, 
    {"setRadiusX", _wrap_Vortex_setRadiusX}, 
    {"setRadiusY", _wrap_Vortex_setRadiusY}, 
    {"setTwist", _wrap_Vortex_setTwist}, 
    {"process", _wrap_Vortex_process}, 
    {0,0}
};
static swig_lua_attribute swig_Procedural_Vortex_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Procedural_Vortex_bases[] = {0,0};
static const char *swig_Procedural_Vortex_base_names[] = {"Procedural::TextureProcessing *",0};
static swig_lua_class _wrap_class_Procedural_Vortex = { "Vortex", &SWIGTYPE_p_Procedural__Vortex,_wrap_new_Vortex, swig_delete_Vortex, swig_Procedural_Vortex_methods, swig_Procedural_Vortex_attributes, swig_Procedural_Vortex_bases, swig_Procedural_Vortex_base_names };

#ifdef __cplusplus
}
#endif

static const struct luaL_reg swig_commands[] = {
    { "Quaternion_Slerp",_wrap_Quaternion_Slerp},
    { "Quaternion_SlerpExtraSpins", _wrap_Quaternion_SlerpExtraSpins},
    { "Quaternion_Intermediate", _wrap_Quaternion_Intermediate},
    { "Quaternion_Squad",_wrap_Quaternion_Squad},
    { "Quaternion_nlerp",_wrap_Quaternion_nlerp},
    { "Math_IAbs", _wrap_Math_IAbs},
    { "Math_ICeil", _wrap_Math_ICeil},
    { "Math_IFloor", _wrap_Math_IFloor},
    { "Math_ISign", _wrap_Math_ISign},
    { "Math_Abs",_wrap_Math_Abs},
    { "Math_ACos", _wrap_Math_ACos},
    { "Math_ASin", _wrap_Math_ASin},
    { "Math_ATan", _wrap_Math_ATan},
    { "Math_ATan2", _wrap_Math_ATan2},
    { "Math_Ceil", _wrap_Math_Ceil},
    { "Math_isNaN", _wrap_Math_isNaN},
    { "Math_Cos",_wrap_Math_Cos},
    { "Math_Exp", _wrap_Math_Exp},
    { "Math_Floor", _wrap_Math_Floor},
    { "Math_Log", _wrap_Math_Log},
    { "Math_Log2", _wrap_Math_Log2},
    { "Math_LogN", _wrap_Math_LogN},
    { "Math_Pow", _wrap_Math_Pow},
    { "Math_Sign",_wrap_Math_Sign},
    { "Math_saturate",_wrap_Math_saturate},
    { "Math_Sin",_wrap_Math_Sin},
    { "Math_Sqr", _wrap_Math_Sqr},
    { "Math_Sqrt",_wrap_Math_Sqrt},
    { "Math_InvSqrt", _wrap_Math_InvSqrt},
    { "Math_UnitRandom", _wrap_Math_UnitRandom},
    { "Math_RangeRandom", _wrap_Math_RangeRandom},
    { "Math_SymmetricRandom", _wrap_Math_SymmetricRandom},
    { "Math_SetRandomValueProvider", _wrap_Math_SetRandomValueProvider},
    { "Math_Tan",_wrap_Math_Tan},
    { "Math_DegreesToRadians", _wrap_Math_DegreesToRadians},
    { "Math_RadiansToDegrees", _wrap_Math_RadiansToDegrees},
    { "Math_setAngleUnit", _wrap_Math_setAngleUnit},
    { "Math_getAngleUnit", _wrap_Math_getAngleUnit},
    { "Math_AngleUnitsToRadians", _wrap_Math_AngleUnitsToRadians},
    { "Math_RadiansToAngleUnits", _wrap_Math_RadiansToAngleUnits},
    { "Math_AngleUnitsToDegrees", _wrap_Math_AngleUnitsToDegrees},
    { "Math_DegreesToAngleUnits", _wrap_Math_DegreesToAngleUnits},
    { "Math_pointInTri2D", _wrap_Math_pointInTri2D},
    { "Math_pointInTri3D", _wrap_Math_pointInTri3D},
    { "Math_intersects",_wrap_Math_intersects},
    { "Math_RealEqual",_wrap_Math_RealEqual},
    { "Math_calculateTangentSpaceVector", _wrap_Math_calculateTangentSpaceVector},
    { "Math_buildReflectionMatrix", _wrap_Math_buildReflectionMatrix},
    { "Math_calculateFaceNormal", _wrap_Math_calculateFaceNormal},
    { "Math_calculateBasicFaceNormal", _wrap_Math_calculateBasicFaceNormal},
    { "Math_calculateFaceNormalWithoutNormalize", _wrap_Math_calculateFaceNormalWithoutNormalize},
    { "Math_calculateBasicFaceNormalWithoutNormalize", _wrap_Math_calculateBasicFaceNormalWithoutNormalize},
    { "Math_gaussianDistribution",_wrap_Math_gaussianDistribution},
    { "Math_makeViewMatrix",_wrap_Math_makeViewMatrix},
    { "Math_boundingRadiusFromAABB", _wrap_Math_boundingRadiusFromAABB},
    { "__mul",_wrap___mul},
    { "__div",_wrap___div},
    { "FastHash",_wrap_FastHash},
    { "findCommandLineOpts", _wrap_findCommandLineOpts},
    {0,0}
};

static swig_lua_var_info swig_variables[] = {
    { "Vector2_ZERO", _wrap_Vector2_ZERO_get, SWIG_Lua_set_immutable },
    { "Vector2_UNIT_X", _wrap_Vector2_UNIT_X_get, SWIG_Lua_set_immutable },
    { "Vector2_UNIT_Y", _wrap_Vector2_UNIT_Y_get, SWIG_Lua_set_immutable },
    { "Vector2_NEGATIVE_UNIT_X", _wrap_Vector2_NEGATIVE_UNIT_X_get, SWIG_Lua_set_immutable },
    { "Vector2_NEGATIVE_UNIT_Y", _wrap_Vector2_NEGATIVE_UNIT_Y_get, SWIG_Lua_set_immutable },
    { "Vector2_UNIT_SCALE", _wrap_Vector2_UNIT_SCALE_get, SWIG_Lua_set_immutable },
    { "Vector3_ZERO", _wrap_Vector3_ZERO_get, SWIG_Lua_set_immutable },
    { "Vector3_UNIT_X", _wrap_Vector3_UNIT_X_get, SWIG_Lua_set_immutable },
    { "Vector3_UNIT_Y", _wrap_Vector3_UNIT_Y_get, SWIG_Lua_set_immutable },
    { "Vector3_UNIT_Z", _wrap_Vector3_UNIT_Z_get, SWIG_Lua_set_immutable },
    { "Vector3_NEGATIVE_UNIT_X", _wrap_Vector3_NEGATIVE_UNIT_X_get, SWIG_Lua_set_immutable },
    { "Vector3_NEGATIVE_UNIT_Y", _wrap_Vector3_NEGATIVE_UNIT_Y_get, SWIG_Lua_set_immutable },
    { "Vector3_NEGATIVE_UNIT_Z", _wrap_Vector3_NEGATIVE_UNIT_Z_get, SWIG_Lua_set_immutable },
    { "Vector3_UNIT_SCALE", _wrap_Vector3_UNIT_SCALE_get, SWIG_Lua_set_immutable },
    { "Vector4_ZERO", _wrap_Vector4_ZERO_get, SWIG_Lua_set_immutable },
    { "Quaternion_msEpsilon", _wrap_Quaternion_msEpsilon_get, SWIG_Lua_set_immutable },
    { "Quaternion_ZERO", _wrap_Quaternion_ZERO_get, SWIG_Lua_set_immutable },
    { "Quaternion_IDENTITY", _wrap_Quaternion_IDENTITY_get, SWIG_Lua_set_immutable },
    { "Math_LOG2", _wrap_Math_LOG2_get, SWIG_Lua_set_immutable },
    { "Math_POS_INFINITY", _wrap_Math_POS_INFINITY_get, SWIG_Lua_set_immutable },
    { "Math_NEG_INFINITY", _wrap_Math_NEG_INFINITY_get, SWIG_Lua_set_immutable },
    { "Math_PI", _wrap_Math_PI_get, SWIG_Lua_set_immutable },
    { "Math_TWO_PI", _wrap_Math_TWO_PI_get, SWIG_Lua_set_immutable },
    { "Math_HALF_PI", _wrap_Math_HALF_PI_get, SWIG_Lua_set_immutable },
    { "Math_fDeg2Rad", _wrap_Math_fDeg2Rad_get, SWIG_Lua_set_immutable },
    { "Math_fRad2Deg", _wrap_Math_fRad2Deg_get, SWIG_Lua_set_immutable },
    { "ColourValue_ZERO", _wrap_ColourValue_ZERO_get, SWIG_Lua_set_immutable },
    { "ColourValue_Black", _wrap_ColourValue_Black_get, SWIG_Lua_set_immutable },
    { "ColourValue_White", _wrap_ColourValue_White_get, SWIG_Lua_set_immutable },
    { "ColourValue_Red", _wrap_ColourValue_Red_get, SWIG_Lua_set_immutable },
    { "ColourValue_Green", _wrap_ColourValue_Green_get, SWIG_Lua_set_immutable },
    { "ColourValue_Blue", _wrap_ColourValue_Blue_get, SWIG_Lua_set_immutable },
    {0,0,0}
};

static swig_lua_const_info swig_constants[] = {
{ SWIG_LUA_INT,     (char *)"OGRE_DOUBLE_PRECISION", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_MEMORY_ALLOCATOR", (long) 4, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_STRING_USE_CUSTOM_MEMORY_ALLOCATOR", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_MEMORY_TRACKER_DEBUG_MODE", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_MEMORY_TRACKER_RELEASE_MODE", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_THREAD_SUPPORT", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_THREAD_PROVIDER", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_FREEIMAGE", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_DDS_CODEC", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_PVRTC_CODEC", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_ETC1_CODEC", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_ZIP_ARCHIVE", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_VIEWPORT_ORIENTATIONMODE", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES2_CG_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES2_GLSL_OPTIMISER", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES2_VAO_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES_STATE_CACHE_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES2_STATE_CACHE_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_GLES3_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_NO_LIBCPP_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_USE_BOOST", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PROFILING", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_WIN32", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_LINUX", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_APPLE", (long) 3, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_APPLE_IOS", (long) 4, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_ANDROID", (long) 5, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_NACL", (long) 6, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_WINRT", (long) 7, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM_BLACKBERRY", (long) 8, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_MSVC", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_GNUC", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_BORL", (long) 3, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_WINSCW", (long) 4, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_GCCE", (long) 5, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_COMPILER_CLANG", (long) 6, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ENDIAN_LITTLE", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ENDIAN_BIG", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ARCHITECTURE_32", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ARCHITECTURE_64", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_PLATFORM", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ARCH_TYPE", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_DEBUG_MODE", (long) 0, 0, 0, 0},
{ SWIG_LUA_STRING,  (char *)"OGRE_PLATFORM_LIB", 0, 0, (void *)"libOgrePlatform.so", 0},
{ SWIG_LUA_INT,     (char *)"OGRE_UNICODE_SUPPORT", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_ENDIAN", (long) 1, 0, 0, 0},
{ SWIG_LUA_STRING,  (char *)"OGRE_BUILD_SUFFIX", 0, 0, (void *)"", 0},
{ SWIG_LUA_INT,     (char *)"OGRE_MEMORY_TRACKER", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_VERSION_MAJOR", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_VERSION_MINOR", (long) 9, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"OGRE_VERSION_PATCH", (long) 0, 0, 0, 0},
{ SWIG_LUA_STRING,  (char *)"OGRE_VERSION_SUFFIX", 0, 0, (void *)"unstable", 0},
{ SWIG_LUA_STRING,  (char *)"OGRE_VERSION_NAME", 0, 0, (void *)"Ghadamon", 0},
{ SWIG_LUA_INT,     (char *)"OGRE_VERSION", (long) ((1 << 16)|(9 << 8)|0), 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Math_AU_DEGREE", (long) Ogre::Math::AU_DEGREE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Math_AU_RADIAN", (long) Ogre::Math::AU_RADIAN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_ALWAYS_FAIL", (long) Ogre::CMPF_ALWAYS_FAIL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_ALWAYS_PASS", (long) Ogre::CMPF_ALWAYS_PASS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_LESS", (long) Ogre::CMPF_LESS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_LESS_EQUAL", (long) Ogre::CMPF_LESS_EQUAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_EQUAL", (long) Ogre::CMPF_EQUAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_NOT_EQUAL", (long) Ogre::CMPF_NOT_EQUAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_GREATER_EQUAL", (long) Ogre::CMPF_GREATER_EQUAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CMPF_GREATER", (long) Ogre::CMPF_GREATER, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TFO_NONE", (long) Ogre::TFO_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TFO_BILINEAR", (long) Ogre::TFO_BILINEAR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TFO_TRILINEAR", (long) Ogre::TFO_TRILINEAR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TFO_ANISOTROPIC", (long) Ogre::TFO_ANISOTROPIC, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FT_MIN", (long) Ogre::FT_MIN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FT_MAG", (long) Ogre::FT_MAG, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FT_MIP", (long) Ogre::FT_MIP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FO_NONE", (long) Ogre::FO_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FO_POINT", (long) Ogre::FO_POINT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FO_LINEAR", (long) Ogre::FO_LINEAR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FO_ANISOTROPIC", (long) Ogre::FO_ANISOTROPIC, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SO_FLAT", (long) Ogre::SO_FLAT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SO_GOURAUD", (long) Ogre::SO_GOURAUD, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SO_PHONG", (long) Ogre::SO_PHONG, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FOG_NONE", (long) Ogre::FOG_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FOG_EXP", (long) Ogre::FOG_EXP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FOG_EXP2", (long) Ogre::FOG_EXP2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FOG_LINEAR", (long) Ogre::FOG_LINEAR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CULL_NONE", (long) Ogre::CULL_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CULL_CLOCKWISE", (long) Ogre::CULL_CLOCKWISE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CULL_ANTICLOCKWISE", (long) Ogre::CULL_ANTICLOCKWISE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"MANUAL_CULL_NONE", (long) Ogre::MANUAL_CULL_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"MANUAL_CULL_BACK", (long) Ogre::MANUAL_CULL_BACK, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"MANUAL_CULL_FRONT", (long) Ogre::MANUAL_CULL_FRONT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_SINE", (long) Ogre::WFT_SINE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_TRIANGLE", (long) Ogre::WFT_TRIANGLE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_SQUARE", (long) Ogre::WFT_SQUARE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_SAWTOOTH", (long) Ogre::WFT_SAWTOOTH, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_INVERSE_SAWTOOTH", (long) Ogre::WFT_INVERSE_SAWTOOTH, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"WFT_PWM", (long) Ogre::WFT_PWM, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PM_POINTS", (long) Ogre::PM_POINTS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PM_WIREFRAME", (long) Ogre::PM_WIREFRAME, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PM_SOLID", (long) Ogre::PM_SOLID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_NONE", (long) Ogre::SHADOWTYPE_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWDETAILTYPE_ADDITIVE", (long) Ogre::SHADOWDETAILTYPE_ADDITIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWDETAILTYPE_MODULATIVE", (long) Ogre::SHADOWDETAILTYPE_MODULATIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWDETAILTYPE_INTEGRATED", (long) Ogre::SHADOWDETAILTYPE_INTEGRATED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWDETAILTYPE_STENCIL", (long) Ogre::SHADOWDETAILTYPE_STENCIL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWDETAILTYPE_TEXTURE", (long) Ogre::SHADOWDETAILTYPE_TEXTURE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_STENCIL_MODULATIVE", (long) Ogre::SHADOWTYPE_STENCIL_MODULATIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_STENCIL_ADDITIVE", (long) Ogre::SHADOWTYPE_STENCIL_ADDITIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_TEXTURE_MODULATIVE", (long) Ogre::SHADOWTYPE_TEXTURE_MODULATIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_TEXTURE_ADDITIVE", (long) Ogre::SHADOWTYPE_TEXTURE_ADDITIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED", (long) Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED", (long) Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TVC_NONE", (long) Ogre::TVC_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TVC_AMBIENT", (long) Ogre::TVC_AMBIENT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TVC_DIFFUSE", (long) Ogre::TVC_DIFFUSE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TVC_SPECULAR", (long) Ogre::TVC_SPECULAR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"TVC_EMISSIVE", (long) Ogre::TVC_EMISSIVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SM_DIRECTION", (long) Ogre::SM_DIRECTION, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SM_DISTANCE", (long) Ogre::SM_DISTANCE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FBT_COLOUR", (long) Ogre::FBT_COLOUR, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FBT_DEPTH", (long) Ogre::FBT_DEPTH, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"FBT_STENCIL", (long) Ogre::FBT_STENCIL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_USE16BIT", (long) Ogre::IM_USE16BIT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_VTFBESTFIT", (long) Ogre::IM_VTFBESTFIT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_VTFBONEMATRIXLOOKUP", (long) Ogre::IM_VTFBONEMATRIXLOOKUP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_USEBONEDUALQUATERNIONS", (long) Ogre::IM_USEBONEDUALQUATERNIONS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_USEONEWEIGHT", (long) Ogre::IM_USEONEWEIGHT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_FORCEONEWEIGHT", (long) Ogre::IM_FORCEONEWEIGHT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IM_USEALL", (long) Ogre::IM_USEALL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CLIPPED_NONE", (long) Ogre::CLIPPED_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CLIPPED_SOME", (long) Ogre::CLIPPED_SOME, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CLIPPED_ALL", (long) Ogre::CLIPPED_ALL, 0, 0, 0},
{ SWIG_LUA_STRING,  (char *)"PROCEDURAL_VERSION_DASH_SEPARATED", 0, 0, (void *)"", 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_WIN32", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_LINUX", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_APPLE", (long) 3, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_SYMBIAN", (long) 4, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_APPLE_IOS", (long) 5, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_ANDROID", (long) 6, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_TEGRA2", (long) 7, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM_NACL", (long) 8, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_PLATFORM", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"PROCEDURAL_DEBUG_MODE", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"AT_NONE", (long) Procedural::AT_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"AT_STRAIGHT", (long) Procedural::AT_STRAIGHT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"AT_CATMULL", (long) Procedural::AT_CATMULL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SIDE_LEFT", (long) Procedural::SIDE_LEFT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SIDE_RIGHT", (long) Procedural::SIDE_RIGHT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Track_AM_ABSOLUTE_LINEIC", (long) Procedural::Track::AM_ABSOLUTE_LINEIC, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Track_AM_RELATIVE_LINEIC", (long) Procedural::Track::AM_RELATIVE_LINEIC, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Track_AM_POINT", (long) Procedural::Track::AM_POINT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Boolean_BT_UNION", (long) Procedural::Boolean::BT_UNION, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Boolean_BT_INTERSECTION", (long) Procedural::Boolean::BT_INTERSECTION, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Boolean_BT_DIFFERENCE", (long) Procedural::Boolean::BT_DIFFERENCE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ShowNormalsGenerator_VS_LINE", (long) Procedural::ShowNormalsGenerator::VS_LINE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ShowNormalsGenerator_VS_ARROW", (long) Procedural::ShowNormalsGenerator::VS_ARROW, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CalculateNormalsModifier_NCM_VERTEX", (long) Procedural::CalculateNormalsModifier::NCM_VERTEX, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"CalculateNormalsModifier_NCM_TRIANGLE", (long) Procedural::CalculateNormalsModifier::NCM_TRIANGLE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"BoxUVModifier_MT_FULL", (long) Procedural::BoxUVModifier::MT_FULL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"BoxUVModifier_MT_CROSS", (long) Procedural::BoxUVModifier::MT_CROSS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"BoxUVModifier_MT_PACKED", (long) Procedural::BoxUVModifier::MT_PACKED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cell_MODE_GRID", (long) Procedural::Cell::MODE_GRID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cell_MODE_CHESSBOARD", (long) Procedural::Cell::MODE_CHESSBOARD, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cell_PATTERN_BOTH", (long) Procedural::Cell::PATTERN_BOTH, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cell_PATTERN_CROSS", (long) Procedural::Cell::PATTERN_CROSS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cell_PATTERN_CONE", (long) Procedural::Cell::PATTERN_CONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Noise_NOISE_WHITE", (long) Procedural::Noise::NOISE_WHITE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Noise_NOISE_PERLIN", (long) Procedural::Noise::NOISE_PERLIN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_COMPENSATION_NORMAL", (long) Procedural::Abnormals::COMPENSATION_NORMAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_COMPENSATION_HEIGHT", (long) Procedural::Abnormals::COMPENSATION_HEIGHT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_COMPENSATION_QUATERNION", (long) Procedural::Abnormals::COMPENSATION_QUATERNION, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_MIRROR_NONE", (long) Procedural::Abnormals::MIRROR_NONE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_MIRROR_X_YZ", (long) Procedural::Abnormals::MIRROR_X_YZ, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_MIRROR_Y_XZ", (long) Procedural::Abnormals::MIRROR_Y_XZ, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Abnormals_MIRROR_X_Y_Z", (long) Procedural::Abnormals::MIRROR_X_Y_Z, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Blur_BLUR_BOX", (long) Procedural::Blur::BLUR_BOX, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Blur_BLUR_MEAN", (long) Procedural::Blur::BLUR_MEAN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Blur_BLUR_GAUSSIAN", (long) Procedural::Blur::BLUR_GAUSSIAN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Channel_SELECT_RED", (long) Procedural::Channel::SELECT_RED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Channel_SELECT_GREEN", (long) Procedural::Channel::SELECT_GREEN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Channel_SELECT_BLUE", (long) Procedural::Channel::SELECT_BLUE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Channel_SELECT_ALPHA", (long) Procedural::Channel::SELECT_ALPHA, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Channel_SELECT_GRAY", (long) Procedural::Channel::SELECT_GRAY, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_ADD_CLAMP", (long) Procedural::Combine::METHOD_ADD_CLAMP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_ADD_WRAP", (long) Procedural::Combine::METHOD_ADD_WRAP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_SUB_CLAMP", (long) Procedural::Combine::METHOD_SUB_CLAMP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_SUB_WRAP", (long) Procedural::Combine::METHOD_SUB_WRAP, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_MULTIPLY", (long) Procedural::Combine::METHOD_MULTIPLY, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_MULTIPLY2", (long) Procedural::Combine::METHOD_MULTIPLY2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_BLEND", (long) Procedural::Combine::METHOD_BLEND, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_ALPHA", (long) Procedural::Combine::METHOD_ALPHA, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Combine_METHOD_LAYER", (long) Procedural::Combine::METHOD_LAYER, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_LENGTH_DECISION_RANDOM", (long) Procedural::Crack::LENGTH_DECISION_RANDOM, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_LENGTH_DECISION_CONSTANT", (long) Procedural::Crack::LENGTH_DECISION_CONSTANT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_LENGTH_DECISION_NORMAL_BASED", (long) Procedural::Crack::LENGTH_DECISION_NORMAL_BASED, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_QUALITY_HIGH_OFF", (long) Procedural::Crack::QUALITY_HIGH_OFF, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_QUALITY_ALPHA", (long) Procedural::Crack::QUALITY_ALPHA, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Crack_QUALITY_SUBPIXEL", (long) Procedural::Crack::QUALITY_SUBPIXEL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_HYPOCYCLOID", (long) Procedural::Cycloid::HYPOCYCLOID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_HYPOTROCHOID", (long) Procedural::Cycloid::HYPOTROCHOID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_EPICYCLOID", (long) Procedural::Cycloid::EPICYCLOID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_EPITROCHOID", (long) Procedural::Cycloid::EPITROCHOID, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_ROSE_CURVE", (long) Procedural::Cycloid::ROSE_CURVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_LISSAJOUS_CURVE", (long) Procedural::Cycloid::LISSAJOUS_CURVE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_PARAMETER_R", (long) Procedural::Cycloid::PARAMETER_R, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_PARAMETER_r", (long) Procedural::Cycloid::PARAMETER_r, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_PARAMETER_d", (long) Procedural::Cycloid::PARAMETER_d, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_PARAMETER_e", (long) Procedural::Cycloid::PARAMETER_e, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Cycloid_PARAMETER_k", (long) Procedural::Cycloid::PARAMETER_k, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"EdgeDetection_DETECTION_HOMOGENITY", (long) Procedural::EdgeDetection::DETECTION_HOMOGENITY, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"EdgeDetection_DETECTION_DIFFERENCE", (long) Procedural::EdgeDetection::DETECTION_DIFFERENCE, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"EdgeDetection_DETECTION_SOBEL", (long) Procedural::EdgeDetection::DETECTION_SOBEL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"EdgeDetection_DETECTION_CANNY", (long) Procedural::EdgeDetection::DETECTION_CANNY, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Flip_FLIP_HORIZONTAL", (long) Procedural::Flip::FLIP_HORIZONTAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Flip_FLIP_VERTICAL", (long) Procedural::Flip::FLIP_VERTICAL, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Flip_FLIP_POINT", (long) Procedural::Flip::FLIP_POINT, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Sharpen_SHARP_BASIC", (long) Procedural::Sharpen::SHARP_BASIC, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Sharpen_SHARP_GAUSSIAN", (long) Procedural::Sharpen::SHARP_GAUSSIAN, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Threshold_MODE_EXPAND_DOWNWARDS", (long) Procedural::Threshold::MODE_EXPAND_DOWNWARDS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Threshold_MODE_EXPAND_UPWARDS", (long) Procedural::Threshold::MODE_EXPAND_UPWARDS, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Threshold_MODE_COMPRESS_BELOW", (long) Procedural::Threshold::MODE_COMPRESS_BELOW, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Threshold_MODE_COMPRESS_ABOVE", (long) Procedural::Threshold::MODE_COMPRESS_ABOVE, 0, 0, 0},
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_Procedural__BoxGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::BoxGenerator > *)  ((Procedural::BoxGenerator *) x));
}
static void *_p_Procedural__TorusKnotGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *)  ((Procedural::TorusKnotGenerator *) x));
}
static void *_p_Procedural__TorusGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::TorusGenerator > *)  ((Procedural::TorusGenerator *) x));
}
static void *_p_Procedural__PlaneGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::PlaneGenerator > *)  ((Procedural::PlaneGenerator *) x));
}
static void *_p_Procedural__CapsuleGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::CapsuleGenerator > *)  ((Procedural::CapsuleGenerator *) x));
}
static void *_p_Procedural__BooleanTo_p_Procedural__MeshGeneratorT_Procedural__Boolean_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::Boolean > *)  ((Procedural::Boolean *) x));
}
static void *_p_Procedural__ExtruderTo_p_Procedural__MeshGeneratorT_Procedural__Extruder_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::Extruder > *)  ((Procedural::Extruder *) x));
}
static void *_p_Procedural__CatmullRomSpline3To_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *)  ((Procedural::CatmullRomSpline3 *) x));
}
static void *_p_Procedural__CatmullRomSpline2To_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *)  ((Procedural::CatmullRomSpline2 *) x));
}
static void *_p_Procedural__RoundedCornerSpline3To_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *)  ((Procedural::RoundedCornerSpline3 *) x));
}
static void *_p_Procedural__RoundedCornerSpline2To_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *)  ((Procedural::RoundedCornerSpline2 *) x));
}
static void *_p_Procedural__KochanekBartelsSpline2To_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *)  ((Procedural::KochanekBartelsSpline2 *) x));
}
static void *_p_Procedural__PlaneTo_p_Ogre__Plane(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Ogre::Plane *)  ((Procedural::Plane *) x));
}
static void *_p_Procedural__TriangulatorTo_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::Triangulator > *)  ((Procedural::Triangulator *) x));
}
static void *_p_Procedural__WhiteNoiseTo_p_Procedural__NoiseBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::NoiseBase *)  ((Procedural::WhiteNoise *) x));
}
static void *_p_Procedural__PerlinNoiseTo_p_Procedural__NoiseBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::NoiseBase *)  ((Procedural::PerlinNoise *) x));
}
static void *_p_Procedural__ConeGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::ConeGenerator > *)  ((Procedural::ConeGenerator *) x));
}
static void *_p_Procedural__TubeGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::TubeGenerator > *)  ((Procedural::TubeGenerator *) x));
}
static void *_p_Procedural__RoundedBoxGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *)  ((Procedural::RoundedBoxGenerator *) x));
}
static void *_p_Procedural__LookupTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Lookup *) x));
}
static void *_p_Procedural__CrackTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Crack *) x));
}
static void *_p_Procedural__BlitTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Blit *) x));
}
static void *_p_Procedural__CombineTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Combine *) x));
}
static void *_p_Procedural__NoiseTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Noise *) x));
}
static void *_p_Procedural__LightTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Light *) x));
}
static void *_p_Procedural__RotationZoomTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::RotationZoom *) x));
}
static void *_p_Procedural__CloudTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Cloud *) x));
}
static void *_p_Procedural__LerpTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Lerp *) x));
}
static void *_p_Procedural__ColoursTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Colours *) x));
}
static void *_p_Procedural__LabyrinthTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Labyrinth *) x));
}
static void *_p_Procedural__TextileTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Textile *) x));
}
static void *_p_Procedural__CellTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Cell *) x));
}
static void *_p_Procedural__InvertTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Invert *) x));
}
static void *_p_Procedural__EdgeDetectionTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::EdgeDetection *) x));
}
static void *_p_Procedural__ThresholdTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Threshold *) x));
}
static void *_p_Procedural__BlurTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Blur *) x));
}
static void *_p_Procedural__OilPaintTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::OilPaint *) x));
}
static void *_p_Procedural__GlowTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Glow *) x));
}
static void *_p_Procedural__FlipTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Flip *) x));
}
static void *_p_Procedural__CycloidTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Cycloid *) x));
}
static void *_p_Procedural__EllipseTextureTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::EllipseTexture *) x));
}
static void *_p_Procedural__CircleTextureTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::CircleTexture *) x));
}
static void *_p_Procedural__RectangleTextureTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::RectangleTexture *) x));
}
static void *_p_Procedural__DilateTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Dilate *) x));
}
static void *_p_Procedural__ImageTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Image *) x));
}
static void *_p_Procedural__DistortTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Distort *) x));
}
static void *_p_Procedural__AlphaTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Alpha *) x));
}
static void *_p_Procedural__SharpenTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Sharpen *) x));
}
static void *_p_Procedural__VortexTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Vortex *) x));
}
static void *_p_Procedural__MarbleTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Marble *) x));
}
static void *_p_Procedural__ChannelTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Channel *) x));
}
static void *_p_Procedural__GradientTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Gradient *) x));
}
static void *_p_Procedural__SegmentTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Segment *) x));
}
static void *_p_Procedural__SolidTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Solid *) x));
}
static void *_p_Procedural__WoodTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Wood *) x));
}
static void *_p_Procedural__ConvolutionTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Convolution *) x));
}
static void *_p_Procedural__NormalsTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Normals *) x));
}
static void *_p_Procedural__AbnormalsTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Abnormals *) x));
}
static void *_p_Procedural__AlphaMaskTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::AlphaMask *) x));
}
static void *_p_Procedural__RandomPixelsTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::RandomPixels *) x));
}
static void *_p_Procedural__JitterTo_p_Procedural__TextureProcessing(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::TextureProcessing *)  ((Procedural::Jitter *) x));
}
static void *_p_Procedural__CubicHermiteSpline3To_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *)  ((Procedural::CubicHermiteSpline3 *) x));
}
static void *_p_Procedural__CubicHermiteSpline2To_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *)  ((Procedural::CubicHermiteSpline2 *) x));
}
static void *_p_Procedural__IcoSphereGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *)  ((Procedural::IcoSphereGenerator *) x));
}
static void *_p_Procedural__BezierCurve3To_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline3< Procedural::BezierCurve3 > *)  ((Procedural::BezierCurve3 *) x));
}
static void *_p_Procedural__BezierCurve2To_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::BaseSpline2< Procedural::BezierCurve2 > *)  ((Procedural::BezierCurve2 *) x));
}
static void *_p_Procedural__CylinderGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::CylinderGenerator > *)  ((Procedural::CylinderGenerator *) x));
}
static void *_p_Procedural__SphereGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::SphereGenerator > *)  ((Procedural::SphereGenerator *) x));
}
static void *_p_Procedural__SpringGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::SpringGenerator > *)  ((Procedural::SpringGenerator *) x));
}
static void *_p_Procedural__LatheTo_p_Procedural__MeshGeneratorT_Procedural__Lathe_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Procedural::MeshGenerator< Procedural::Lathe > *)  ((Procedural::Lathe *) x));
}
static swig_type_info _swigt__p_ControlPoint = {"_p_ControlPoint", "ControlPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MultiShape = {"_p_MultiShape", "MultiShape *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Angle = {"_p_Ogre__Angle", "Ogre::Angle *", 0, 0, (void*)&_wrap_class_Ogre_Angle, 0};
static swig_type_info _swigt__p_Ogre__AxisAlignedBox = {"_p_Ogre__AxisAlignedBox", "Ogre::AxisAlignedBox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Box = {"_p_Ogre__Box", "Ogre::Box *", 0, 0, (void*)&_wrap_class_Ogre_Box, 0};
static swig_type_info _swigt__p_Ogre__ColourValue = {"_p_Ogre__ColourValue", "Ogre::ColourValue *", 0, 0, (void*)&_wrap_class_Ogre_ColourValue, 0};
static swig_type_info _swigt__p_Ogre__Degree = {"_p_Ogre__Degree", "Ogre::Degree *", 0, 0, (void*)&_wrap_class_Ogre_Degree, 0};
static swig_type_info _swigt__p_Ogre__HashedVectorT_Ogre__Light_p_t = {"_p_Ogre__HashedVectorT_Ogre__Light_p_t", "Ogre::LightList *|Ogre::HashedVector< Ogre::Light * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Image = {"_p_Ogre__Image", "Ogre::Image *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__ManualObject = {"_p_Ogre__ManualObject", "Ogre::ManualObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Math = {"_p_Ogre__Math", "Ogre::Math *", 0, 0, (void*)&_wrap_class_Ogre_Math, 0};
static swig_type_info _swigt__p_Ogre__Math__RandomValueProvider = {"_p_Ogre__Math__RandomValueProvider", "Ogre::Math::RandomValueProvider *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Matrix3 = {"_p_Ogre__Matrix3", "Ogre::Matrix3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Matrix4 = {"_p_Ogre__Matrix4", "Ogre::Matrix4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__MeshPtr = {"_p_Ogre__MeshPtr", "Ogre::MeshPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__NameGenerator = {"_p_Ogre__NameGenerator", "Ogre::NameGenerator *", 0, 0, (void*)&_wrap_class_Ogre_NameGenerator, 0};
static swig_type_info _swigt__p_Ogre__Plane = {"_p_Ogre__Plane", "Ogre::Plane *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Quaternion = {"_p_Ogre__Quaternion", "Ogre::Quaternion *", 0, 0, (void*)&_wrap_class_Ogre_Quaternion, 0};
static swig_type_info _swigt__p_Ogre__Radian = {"_p_Ogre__Radian", "Ogre::Radian *", 0, 0, (void*)&_wrap_class_Ogre_Radian, 0};
static swig_type_info _swigt__p_Ogre__Ray = {"_p_Ogre__Ray", "Ogre::Ray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__RenderWindowDescription = {"_p_Ogre__RenderWindowDescription", "Ogre::RenderWindowDescription *", 0, 0, (void*)&_wrap_class_Ogre_RenderWindowDescription, 0};
static swig_type_info _swigt__p_Ogre__SimpleSpline = {"_p_Ogre__SimpleSpline", "Ogre::SimpleSpline *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Sphere = {"_p_Ogre__Sphere", "Ogre::Sphere *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__TRectT_float_t = {"_p_Ogre__TRectT_float_t", "Ogre::TRect< float > *|Ogre::FloatRect *|Ogre::RealRect *|Ogre::TRect< Ogre::Real > *", 0, 0, (void*)&_wrap_class_Ogre_TRect_Sl_Ogre_Real_Sg_, 0};
static swig_type_info _swigt__p_Ogre__TRectT_long_t = {"_p_Ogre__TRectT_long_t", "Ogre::TRect< long > *|Ogre::Rect *", 0, 0, (void*)&_wrap_class_Ogre_TRect_Sl_long_Sg_, 0};
static swig_type_info _swigt__p_Ogre__TexturePtr = {"_p_Ogre__TexturePtr", "Ogre::TexturePtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__Vector2 = {"_p_Ogre__Vector2", "Ogre::Vector2 *", 0, 0, (void*)&_wrap_class_Ogre_Vector2, 0};
static swig_type_info _swigt__p_Ogre__Vector3 = {"_p_Ogre__Vector3", "Ogre::Vector3 *", 0, 0, (void*)&_wrap_class_Ogre_Vector3, 0};
static swig_type_info _swigt__p_Ogre__Vector4 = {"_p_Ogre__Vector4", "Ogre::Vector4 *", 0, 0, (void*)&_wrap_class_Ogre_Vector4, 0};
static swig_type_info _swigt__p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type = {"_p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type", "Ogre::list< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type = {"_p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type", "Ogre::BinaryOptionList *|Ogre::NameValuePairList *|Ogre::AliasTextureNamePairList *|Ogre::map< Ogre::String,Ogre::String,std::less< Ogre::String >,STLAllocator< std::pair< Ogre::String const,Ogre::String >,GeneralAllocPolicy > >::type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type = {"_p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type", "Ogre::UnaryOptionList *|Ogre::map< Ogre::String,bool,std::less< Ogre::String >,STLAllocator< std::pair< Ogre::String const,bool >,GeneralAllocPolicy > >::type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type = {"_p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type", "Ogre::vector< Ogre::Plane,STLAllocator< Ogre::Plane,GeneralAllocPolicy > >::type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type = {"_p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type", "Ogre::vector< Ogre::RenderWindowDescription,STLAllocator< Ogre::RenderWindowDescription,GeneralAllocPolicy > >::type *|Ogre::RenderWindowDescriptionList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type = {"_p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type", "Ogre::vector< Ogre::RenderWindow *,STLAllocator< Ogre::RenderWindow *,GeneralAllocPolicy > >::type *|Ogre::RenderWindowList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Path = {"_p_Path", "Path *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Procedural__Abnormals = {"_p_Procedural__Abnormals", "Procedural::Abnormals *", 0, 0, (void*)&_wrap_class_Procedural_Abnormals, 0};
static swig_type_info _swigt__p_Procedural__Alpha = {"_p_Procedural__Alpha", "Procedural::Alpha *", 0, 0, (void*)&_wrap_class_Procedural_Alpha, 0};
static swig_type_info _swigt__p_Procedural__AlphaMask = {"_p_Procedural__AlphaMask", "Procedural::AlphaMask *", 0, 0, (void*)&_wrap_class_Procedural_AlphaMask, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t = {"_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t", "Procedural::BaseSpline2< Procedural::BezierCurve2 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline2_Sl_Procedural_BezierCurve2_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t = {"_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t", "Procedural::BaseSpline2< Procedural::CatmullRomSpline2 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline2_Sl_Procedural_CatmullRomSpline2_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t = {"_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t", "Procedural::BaseSpline2< Procedural::CubicHermiteSpline2 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline2_Sl_Procedural_CubicHermiteSpline2_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t = {"_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t", "Procedural::BaseSpline2< Procedural::KochanekBartelsSpline2 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline2_Sl_Procedural_KochanekBartelsSpline2_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t = {"_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t", "Procedural::BaseSpline2< Procedural::RoundedCornerSpline2 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline2_Sl_Procedural_RoundedCornerSpline2_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t = {"_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t", "Procedural::BaseSpline3< Procedural::BezierCurve3 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline3_Sl_Procedural_BezierCurve3_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t = {"_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t", "Procedural::BaseSpline3< Procedural::CatmullRomSpline3 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline3_Sl_Procedural_CatmullRomSpline3_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t = {"_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t", "Procedural::BaseSpline3< Procedural::CubicHermiteSpline3 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline3_Sl_Procedural_CubicHermiteSpline3_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t = {"_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t", "Procedural::BaseSpline3< Procedural::RoundedCornerSpline3 > *", 0, 0, (void*)&_wrap_class_Procedural_BaseSpline3_Sl_Procedural_RoundedCornerSpline3_Sg_, 0};
static swig_type_info _swigt__p_Procedural__BezierCurve2 = {"_p_Procedural__BezierCurve2", "Procedural::BezierCurve2 *", 0, 0, (void*)&_wrap_class_Procedural_BezierCurve2, 0};
static swig_type_info _swigt__p_Procedural__BezierCurve3 = {"_p_Procedural__BezierCurve3", "Procedural::BezierCurve3 *", 0, 0, (void*)&_wrap_class_Procedural_BezierCurve3, 0};
static swig_type_info _swigt__p_Procedural__Blit = {"_p_Procedural__Blit", "Procedural::Blit *", 0, 0, (void*)&_wrap_class_Procedural_Blit, 0};
static swig_type_info _swigt__p_Procedural__Blur = {"_p_Procedural__Blur", "Procedural::Blur *", 0, 0, (void*)&_wrap_class_Procedural_Blur, 0};
static swig_type_info _swigt__p_Procedural__Boolean = {"_p_Procedural__Boolean", "Procedural::Boolean *", 0, 0, (void*)&_wrap_class_Procedural_Boolean, 0};
static swig_type_info _swigt__p_Procedural__BoxGenerator = {"_p_Procedural__BoxGenerator", "Procedural::BoxGenerator *", 0, 0, (void*)&_wrap_class_Procedural_BoxGenerator, 0};
static swig_type_info _swigt__p_Procedural__BoxUVModifier = {"_p_Procedural__BoxUVModifier", "Procedural::BoxUVModifier *", 0, 0, (void*)&_wrap_class_Procedural_BoxUVModifier, 0};
static swig_type_info _swigt__p_Procedural__CalculateNormalsModifier = {"_p_Procedural__CalculateNormalsModifier", "Procedural::CalculateNormalsModifier *", 0, 0, (void*)&_wrap_class_Procedural_CalculateNormalsModifier, 0};
static swig_type_info _swigt__p_Procedural__CapsuleGenerator = {"_p_Procedural__CapsuleGenerator", "Procedural::CapsuleGenerator *", 0, 0, (void*)&_wrap_class_Procedural_CapsuleGenerator, 0};
static swig_type_info _swigt__p_Procedural__CatmullRomSpline2 = {"_p_Procedural__CatmullRomSpline2", "Procedural::CatmullRomSpline2 *", 0, 0, (void*)&_wrap_class_Procedural_CatmullRomSpline2, 0};
static swig_type_info _swigt__p_Procedural__CatmullRomSpline3 = {"_p_Procedural__CatmullRomSpline3", "Procedural::CatmullRomSpline3 *", 0, 0, (void*)&_wrap_class_Procedural_CatmullRomSpline3, 0};
static swig_type_info _swigt__p_Procedural__Cell = {"_p_Procedural__Cell", "Procedural::Cell *", 0, 0, (void*)&_wrap_class_Procedural_Cell, 0};
static swig_type_info _swigt__p_Procedural__Channel = {"_p_Procedural__Channel", "Procedural::Channel *", 0, 0, (void*)&_wrap_class_Procedural_Channel, 0};
static swig_type_info _swigt__p_Procedural__Circle = {"_p_Procedural__Circle", "Procedural::Circle *", 0, 0, (void*)&_wrap_class_Procedural_Circle, 0};
static swig_type_info _swigt__p_Procedural__CircleShape = {"_p_Procedural__CircleShape", "Procedural::CircleShape *", 0, 0, (void*)&_wrap_class_Procedural_CircleShape, 0};
static swig_type_info _swigt__p_Procedural__CircleTexture = {"_p_Procedural__CircleTexture", "Procedural::CircleTexture *", 0, 0, (void*)&_wrap_class_Procedural_CircleTexture, 0};
static swig_type_info _swigt__p_Procedural__Cloud = {"_p_Procedural__Cloud", "Procedural::Cloud *", 0, 0, (void*)&_wrap_class_Procedural_Cloud, 0};
static swig_type_info _swigt__p_Procedural__Colours = {"_p_Procedural__Colours", "Procedural::Colours *", 0, 0, (void*)&_wrap_class_Procedural_Colours, 0};
static swig_type_info _swigt__p_Procedural__Combine = {"_p_Procedural__Combine", "Procedural::Combine *", 0, 0, (void*)&_wrap_class_Procedural_Combine, 0};
static swig_type_info _swigt__p_Procedural__ConeGenerator = {"_p_Procedural__ConeGenerator", "Procedural::ConeGenerator *", 0, 0, (void*)&_wrap_class_Procedural_ConeGenerator, 0};
static swig_type_info _swigt__p_Procedural__Convolution = {"_p_Procedural__Convolution", "Procedural::Convolution *", 0, 0, (void*)&_wrap_class_Procedural_Convolution, 0};
static swig_type_info _swigt__p_Procedural__Crack = {"_p_Procedural__Crack", "Procedural::Crack *", 0, 0, (void*)&_wrap_class_Procedural_Crack, 0};
static swig_type_info _swigt__p_Procedural__CubicHermiteSpline2 = {"_p_Procedural__CubicHermiteSpline2", "Procedural::CubicHermiteSpline2 *", 0, 0, (void*)&_wrap_class_Procedural_CubicHermiteSpline2, 0};
static swig_type_info _swigt__p_Procedural__CubicHermiteSpline3 = {"_p_Procedural__CubicHermiteSpline3", "Procedural::CubicHermiteSpline3 *", 0, 0, (void*)&_wrap_class_Procedural_CubicHermiteSpline3, 0};
static swig_type_info _swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t = {"_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t", "Procedural::CubicHermiteSpline2::ControlPoint *|Procedural::CubicHermiteSplineControlPoint< Ogre::Vector2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t = {"_p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t", "Procedural::CubicHermiteSpline3::ControlPoint *|Procedural::CubicHermiteSplineControlPoint< Ogre::Vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Procedural__Cycloid = {"_p_Procedural__Cycloid", "Procedural::Cycloid *", 0, 0, (void*)&_wrap_class_Procedural_Cycloid, 0};
static swig_type_info _swigt__p_Procedural__CylinderGenerator = {"_p_Procedural__CylinderGenerator", "Procedural::CylinderGenerator *", 0, 0, (void*)&_wrap_class_Procedural_CylinderGenerator, 0};
static swig_type_info _swigt__p_Procedural__CylinderUVModifier = {"_p_Procedural__CylinderUVModifier", "Procedural::CylinderUVModifier *", 0, 0, (void*)&_wrap_class_Procedural_CylinderUVModifier, 0};
static swig_type_info _swigt__p_Procedural__Dilate = {"_p_Procedural__Dilate", "Procedural::Dilate *", 0, 0, (void*)&_wrap_class_Procedural_Dilate, 0};
static swig_type_info _swigt__p_Procedural__Distort = {"_p_Procedural__Distort", "Procedural::Distort *", 0, 0, (void*)&_wrap_class_Procedural_Distort, 0};
static swig_type_info _swigt__p_Procedural__EdgeDetection = {"_p_Procedural__EdgeDetection", "Procedural::EdgeDetection *", 0, 0, (void*)&_wrap_class_Procedural_EdgeDetection, 0};
static swig_type_info _swigt__p_Procedural__EllipseShape = {"_p_Procedural__EllipseShape", "Procedural::EllipseShape *", 0, 0, (void*)&_wrap_class_Procedural_EllipseShape, 0};
static swig_type_info _swigt__p_Procedural__EllipseTexture = {"_p_Procedural__EllipseTexture", "Procedural::EllipseTexture *", 0, 0, (void*)&_wrap_class_Procedural_EllipseTexture, 0};
static swig_type_info _swigt__p_Procedural__Extruder = {"_p_Procedural__Extruder", "Procedural::Extruder *", 0, 0, (void*)&_wrap_class_Procedural_Extruder, 0};
static swig_type_info _swigt__p_Procedural__Flip = {"_p_Procedural__Flip", "Procedural::Flip *", 0, 0, (void*)&_wrap_class_Procedural_Flip, 0};
static swig_type_info _swigt__p_Procedural__Glow = {"_p_Procedural__Glow", "Procedural::Glow *", 0, 0, (void*)&_wrap_class_Procedural_Glow, 0};
static swig_type_info _swigt__p_Procedural__Gradient = {"_p_Procedural__Gradient", "Procedural::Gradient *", 0, 0, (void*)&_wrap_class_Procedural_Gradient, 0};
static swig_type_info _swigt__p_Procedural__HelixPath = {"_p_Procedural__HelixPath", "Procedural::HelixPath *", 0, 0, (void*)&_wrap_class_Procedural_HelixPath, 0};
static swig_type_info _swigt__p_Procedural__HemisphereUVModifier = {"_p_Procedural__HemisphereUVModifier", "Procedural::HemisphereUVModifier *", 0, 0, (void*)&_wrap_class_Procedural_HemisphereUVModifier, 0};
static swig_type_info _swigt__p_Procedural__IcoSphereGenerator = {"_p_Procedural__IcoSphereGenerator", "Procedural::IcoSphereGenerator *", 0, 0, (void*)&_wrap_class_Procedural_IcoSphereGenerator, 0};
static swig_type_info _swigt__p_Procedural__Image = {"_p_Procedural__Image", "Procedural::Image *", 0, 0, (void*)&_wrap_class_Procedural_Image, 0};
static swig_type_info _swigt__p_Procedural__IntVector2 = {"_p_Procedural__IntVector2", "Procedural::IntVector2 *", 0, 0, (void*)&_wrap_class_Procedural_IntVector2, 0};
static swig_type_info _swigt__p_Procedural__Invert = {"_p_Procedural__Invert", "Procedural::Invert *", 0, 0, (void*)&_wrap_class_Procedural_Invert, 0};
static swig_type_info _swigt__p_Procedural__Jitter = {"_p_Procedural__Jitter", "Procedural::Jitter *", 0, 0, (void*)&_wrap_class_Procedural_Jitter, 0};
static swig_type_info _swigt__p_Procedural__KochanekBartelsSpline2 = {"_p_Procedural__KochanekBartelsSpline2", "Procedural::KochanekBartelsSpline2 *", 0, 0, (void*)&_wrap_class_Procedural_KochanekBartelsSpline2, 0};
static swig_type_info _swigt__p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t = {"_p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t", "Procedural::KochanekBartelsSplineControlPoint< Ogre::Vector2 > *|Procedural::KochanekBartelsSpline2::ControlPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Procedural__Labyrinth = {"_p_Procedural__Labyrinth", "Procedural::Labyrinth *", 0, 0, (void*)&_wrap_class_Procedural_Labyrinth, 0};
static swig_type_info _swigt__p_Procedural__Lathe = {"_p_Procedural__Lathe", "Procedural::Lathe *", 0, 0, (void*)&_wrap_class_Procedural_Lathe, 0};
static swig_type_info _swigt__p_Procedural__Lerp = {"_p_Procedural__Lerp", "Procedural::Lerp *", 0, 0, (void*)&_wrap_class_Procedural_Lerp, 0};
static swig_type_info _swigt__p_Procedural__Light = {"_p_Procedural__Light", "Procedural::Light *", 0, 0, (void*)&_wrap_class_Procedural_Light, 0};
static swig_type_info _swigt__p_Procedural__Line = {"_p_Procedural__Line", "Procedural::Line *", 0, 0, (void*)&_wrap_class_Procedural_Line, 0};
static swig_type_info _swigt__p_Procedural__Line2D = {"_p_Procedural__Line2D", "Procedural::Line2D *", 0, 0, (void*)&_wrap_class_Procedural_Line2D, 0};
static swig_type_info _swigt__p_Procedural__LinePath = {"_p_Procedural__LinePath", "Procedural::LinePath *", 0, 0, (void*)&_wrap_class_Procedural_LinePath, 0};
static swig_type_info _swigt__p_Procedural__Lookup = {"_p_Procedural__Lookup", "Procedural::Lookup *", 0, 0, (void*)&_wrap_class_Procedural_Lookup, 0};
static swig_type_info _swigt__p_Procedural__Marble = {"_p_Procedural__Marble", "Procedural::Marble *", 0, 0, (void*)&_wrap_class_Procedural_Marble, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__Boolean_t = {"_p_Procedural__MeshGeneratorT_Procedural__Boolean_t", "Procedural::MeshGenerator< Procedural::Boolean > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_Boolean_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t", "Procedural::MeshGenerator< Procedural::BoxGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_BoxGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t", "Procedural::MeshGenerator< Procedural::CapsuleGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_CapsuleGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t", "Procedural::MeshGenerator< Procedural::ConeGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_ConeGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t", "Procedural::MeshGenerator< Procedural::CylinderGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_CylinderGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__Extruder_t = {"_p_Procedural__MeshGeneratorT_Procedural__Extruder_t", "Procedural::MeshGenerator< Procedural::Extruder > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_Extruder_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t", "Procedural::MeshGenerator< Procedural::IcoSphereGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_IcoSphereGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__Lathe_t = {"_p_Procedural__MeshGeneratorT_Procedural__Lathe_t", "Procedural::MeshGenerator< Procedural::Lathe > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_Lathe_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t", "Procedural::MeshGenerator< Procedural::PlaneGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_PlaneGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t", "Procedural::MeshGenerator< Procedural::RoundedBoxGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_RoundedBoxGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t", "Procedural::MeshGenerator< Procedural::SphereGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_SphereGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t", "Procedural::MeshGenerator< Procedural::SpringGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_SpringGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t", "Procedural::MeshGenerator< Procedural::TorusGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_TorusGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t", "Procedural::MeshGenerator< Procedural::TorusKnotGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_TorusKnotGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__Triangulator_t = {"_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t", "Procedural::MeshGenerator< Procedural::Triangulator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_Triangulator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t = {"_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t", "Procedural::MeshGenerator< Procedural::TubeGenerator > *", 0, 0, (void*)&_wrap_class_Procedural_MeshGenerator_Sl_Procedural_TubeGenerator_Sg_, 0};
static swig_type_info _swigt__p_Procedural__MultiShape = {"_p_Procedural__MultiShape", "Procedural::MultiShape *", 0, 0, (void*)&_wrap_class_Procedural_MultiShape, 0};
static swig_type_info _swigt__p_Procedural__Noise = {"_p_Procedural__Noise", "Procedural::Noise *", 0, 0, (void*)&_wrap_class_Procedural_Noise, 0};
static swig_type_info _swigt__p_Procedural__NoiseBase = {"_p_Procedural__NoiseBase", "Procedural::NoiseBase *", 0, 0, (void*)&_wrap_class_Procedural_NoiseBase, 0};
static swig_type_info _swigt__p_Procedural__Normals = {"_p_Procedural__Normals", "Procedural::Normals *", 0, 0, (void*)&_wrap_class_Procedural_Normals, 0};
static swig_type_info _swigt__p_Procedural__OilPaint = {"_p_Procedural__OilPaint", "Procedural::OilPaint *", 0, 0, (void*)&_wrap_class_Procedural_OilPaint, 0};
static swig_type_info _swigt__p_Procedural__Path = {"_p_Procedural__Path", "Procedural::Path *", 0, 0, (void*)&_wrap_class_Procedural_Path, 0};
static swig_type_info _swigt__p_Procedural__PerlinNoise = {"_p_Procedural__PerlinNoise", "Procedural::PerlinNoise *", 0, 0, (void*)&_wrap_class_Procedural_PerlinNoise, 0};
static swig_type_info _swigt__p_Procedural__Plane = {"_p_Procedural__Plane", "Procedural::Plane *", 0, 0, (void*)&_wrap_class_Procedural_Plane, 0};
static swig_type_info _swigt__p_Procedural__PlaneGenerator = {"_p_Procedural__PlaneGenerator", "Procedural::PlaneGenerator *", 0, 0, (void*)&_wrap_class_Procedural_PlaneGenerator, 0};
static swig_type_info _swigt__p_Procedural__PlaneUVModifier = {"_p_Procedural__PlaneUVModifier", "Procedural::PlaneUVModifier *", 0, 0, (void*)&_wrap_class_Procedural_PlaneUVModifier, 0};
static swig_type_info _swigt__p_Procedural__RandomPixels = {"_p_Procedural__RandomPixels", "Procedural::RandomPixels *", 0, 0, (void*)&_wrap_class_Procedural_RandomPixels, 0};
static swig_type_info _swigt__p_Procedural__RectangleShape = {"_p_Procedural__RectangleShape", "Procedural::RectangleShape *", 0, 0, (void*)&_wrap_class_Procedural_RectangleShape, 0};
static swig_type_info _swigt__p_Procedural__RectangleTexture = {"_p_Procedural__RectangleTexture", "Procedural::RectangleTexture *", 0, 0, (void*)&_wrap_class_Procedural_RectangleTexture, 0};
static swig_type_info _swigt__p_Procedural__RotationZoom = {"_p_Procedural__RotationZoom", "Procedural::RotationZoom *", 0, 0, (void*)&_wrap_class_Procedural_RotationZoom, 0};
static swig_type_info _swigt__p_Procedural__RoundedBoxGenerator = {"_p_Procedural__RoundedBoxGenerator", "Procedural::RoundedBoxGenerator *", 0, 0, (void*)&_wrap_class_Procedural_RoundedBoxGenerator, 0};
static swig_type_info _swigt__p_Procedural__RoundedCornerSpline2 = {"_p_Procedural__RoundedCornerSpline2", "Procedural::RoundedCornerSpline2 *", 0, 0, (void*)&_wrap_class_Procedural_RoundedCornerSpline2, 0};
static swig_type_info _swigt__p_Procedural__RoundedCornerSpline3 = {"_p_Procedural__RoundedCornerSpline3", "Procedural::RoundedCornerSpline3 *", 0, 0, (void*)&_wrap_class_Procedural_RoundedCornerSpline3, 0};
static swig_type_info _swigt__p_Procedural__Segment = {"_p_Procedural__Segment", "Procedural::Segment *", 0, 0, (void*)&_wrap_class_Procedural_Segment, 0};
static swig_type_info _swigt__p_Procedural__Segment2D = {"_p_Procedural__Segment2D", "Procedural::Segment2D *", 0, 0, (void*)&_wrap_class_Procedural_Segment2D, 0};
static swig_type_info _swigt__p_Procedural__Segment3D = {"_p_Procedural__Segment3D", "Procedural::Segment3D *", 0, 0, (void*)&_wrap_class_Procedural_Segment3D, 0};
static swig_type_info _swigt__p_Procedural__Shape = {"_p_Procedural__Shape", "Procedural::Shape *", 0, 0, (void*)&_wrap_class_Procedural_Shape, 0};
static swig_type_info _swigt__p_Procedural__Sharpen = {"_p_Procedural__Sharpen", "Procedural::Sharpen *", 0, 0, (void*)&_wrap_class_Procedural_Sharpen, 0};
static swig_type_info _swigt__p_Procedural__ShowNormalsGenerator = {"_p_Procedural__ShowNormalsGenerator", "Procedural::ShowNormalsGenerator *", 0, 0, (void*)&_wrap_class_Procedural_ShowNormalsGenerator, 0};
static swig_type_info _swigt__p_Procedural__Solid = {"_p_Procedural__Solid", "Procedural::Solid *", 0, 0, (void*)&_wrap_class_Procedural_Solid, 0};
static swig_type_info _swigt__p_Procedural__SphereGenerator = {"_p_Procedural__SphereGenerator", "Procedural::SphereGenerator *", 0, 0, (void*)&_wrap_class_Procedural_SphereGenerator, 0};
static swig_type_info _swigt__p_Procedural__SphereUVModifier = {"_p_Procedural__SphereUVModifier", "Procedural::SphereUVModifier *", 0, 0, (void*)&_wrap_class_Procedural_SphereUVModifier, 0};
static swig_type_info _swigt__p_Procedural__SpherifyModifier = {"_p_Procedural__SpherifyModifier", "Procedural::SpherifyModifier *", 0, 0, (void*)&_wrap_class_Procedural_SpherifyModifier, 0};
static swig_type_info _swigt__p_Procedural__SpringGenerator = {"_p_Procedural__SpringGenerator", "Procedural::SpringGenerator *", 0, 0, (void*)&_wrap_class_Procedural_SpringGenerator, 0};
static swig_type_info _swigt__p_Procedural__SvgLoader = {"_p_Procedural__SvgLoader", "Procedural::SvgLoader *", 0, 0, (void*)&_wrap_class_Procedural_SvgLoader, 0};
static swig_type_info _swigt__p_Procedural__Textile = {"_p_Procedural__Textile", "Procedural::Textile *", 0, 0, (void*)&_wrap_class_Procedural_Textile, 0};
static swig_type_info _swigt__p_Procedural__TextureBuffer = {"_p_Procedural__TextureBuffer", "Procedural::TextureBuffer *|Procedural::TextureBufferPtr", 0, 0, (void*)&_wrap_class_Procedural_TextureBuffer, 0};
static swig_type_info _swigt__p_Procedural__TextureProcessing = {"_p_Procedural__TextureProcessing", "Procedural::TextureProcessing *", 0, 0, (void*)&_wrap_class_Procedural_TextureProcessing, 0};
static swig_type_info _swigt__p_Procedural__Threshold = {"_p_Procedural__Threshold", "Procedural::Threshold *", 0, 0, (void*)&_wrap_class_Procedural_Threshold, 0};
static swig_type_info _swigt__p_Procedural__TorusGenerator = {"_p_Procedural__TorusGenerator", "Procedural::TorusGenerator *", 0, 0, (void*)&_wrap_class_Procedural_TorusGenerator, 0};
static swig_type_info _swigt__p_Procedural__TorusKnotGenerator = {"_p_Procedural__TorusKnotGenerator", "Procedural::TorusKnotGenerator *", 0, 0, (void*)&_wrap_class_Procedural_TorusKnotGenerator, 0};
static swig_type_info _swigt__p_Procedural__Track = {"_p_Procedural__Track", "Procedural::Track *", 0, 0, (void*)&_wrap_class_Procedural_Track, 0};
static swig_type_info _swigt__p_Procedural__Triangle2D = {"_p_Procedural__Triangle2D", "Procedural::Triangle2D *", 0, 0, (void*)&_wrap_class_Procedural_Triangle2D, 0};
static swig_type_info _swigt__p_Procedural__Triangle3D = {"_p_Procedural__Triangle3D", "Procedural::Triangle3D *", 0, 0, (void*)&_wrap_class_Procedural_Triangle3D, 0};
static swig_type_info _swigt__p_Procedural__TriangleBuffer = {"_p_Procedural__TriangleBuffer", "Procedural::TriangleBuffer *", 0, 0, (void*)&_wrap_class_Procedural_TriangleBuffer, 0};
static swig_type_info _swigt__p_Procedural__TriangleBuffer__Vertex = {"_p_Procedural__TriangleBuffer__Vertex", "Procedural::TriangleBuffer::Vertex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Procedural__TriangleShape = {"_p_Procedural__TriangleShape", "Procedural::TriangleShape *", 0, 0, (void*)&_wrap_class_Procedural_TriangleShape, 0};
static swig_type_info _swigt__p_Procedural__Triangulator = {"_p_Procedural__Triangulator", "Procedural::Triangulator *", 0, 0, (void*)&_wrap_class_Procedural_Triangulator, 0};
static swig_type_info _swigt__p_Procedural__TubeGenerator = {"_p_Procedural__TubeGenerator", "Procedural::TubeGenerator *", 0, 0, (void*)&_wrap_class_Procedural_TubeGenerator, 0};
static swig_type_info _swigt__p_Procedural__UnweldVerticesModifier = {"_p_Procedural__UnweldVerticesModifier", "Procedural::UnweldVerticesModifier *", 0, 0, (void*)&_wrap_class_Procedural_UnweldVerticesModifier, 0};
static swig_type_info _swigt__p_Procedural__Vector2Comparator = {"_p_Procedural__Vector2Comparator", "Procedural::Vector2Comparator *", 0, 0, (void*)&_wrap_class_Procedural_Vector2Comparator, 0};
static swig_type_info _swigt__p_Procedural__Vector3Comparator = {"_p_Procedural__Vector3Comparator", "Procedural::Vector3Comparator *", 0, 0, (void*)&_wrap_class_Procedural_Vector3Comparator, 0};
static swig_type_info _swigt__p_Procedural__Vortex = {"_p_Procedural__Vortex", "Procedural::Vortex *", 0, 0, (void*)&_wrap_class_Procedural_Vortex, 0};
static swig_type_info _swigt__p_Procedural__WeldVerticesModifier = {"_p_Procedural__WeldVerticesModifier", "Procedural::WeldVerticesModifier *", 0, 0, (void*)&_wrap_class_Procedural_WeldVerticesModifier, 0};
static swig_type_info _swigt__p_Procedural__WhiteNoise = {"_p_Procedural__WhiteNoise", "Procedural::WhiteNoise *", 0, 0, (void*)&_wrap_class_Procedural_WhiteNoise, 0};
static swig_type_info _swigt__p_Procedural__Wood = {"_p_Procedural__Wood", "Procedural::Wood *", 0, 0, (void*)&_wrap_class_Procedural_Wood, 0};
static swig_type_info _swigt__p_Shape = {"_p_Shape", "Shape *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Side = {"_p_Side", "Side *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Track = {"_p_Track", "Track *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Track__AddressingMode = {"_p_Track__AddressingMode", "Track::AddressingMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *|Ogre::Real *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "Ogre::TrackVertexColourType *|int *|Ogre::int32 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "Ogre::int64 *|long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "Ogre::int16 *|short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|Ogre::int8 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "Ogre::StringStream *|Ogre::stringstream *|std::basic_stringstream< char,std::char_traits< char >,std::allocator< char > > *|Ogre::_StringStreamBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator = {"_p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator", "std::map< Ogre::Real,Ogre::Real >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_bool_float_t = {"_p_std__pairT_bool_float_t", "std::pair< bool,float > *|std::pair< bool,Ogre::Real > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *|Ogre::_StringBase *|Ogre::String *", 0, 0, (void*)&_wrap_class_std_string, 0};
static swig_type_info _swigt__p_std__vectorT_Ogre__Vector2_t = {"_p_std__vectorT_Ogre__Vector2_t", "std::vector< Ogre::Vector2 > *|Procedural::PointList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Ogre__Vector2_t__size_type = {"_p_std__vectorT_Ogre__Vector2_t__size_type", "std::vector< Ogre::Vector2 >::size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Ogre__Vector3_t = {"_p_std__vectorT_Ogre__Vector3_t", "std::vector< Ogre::Vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Procedural__Path_t = {"_p_std__vectorT_Procedural__Path_t", "std::vector< Procedural::Path > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Procedural__Segment2D_t = {"_p_std__vectorT_Procedural__Segment2D_t", "std::vector< Procedural::Segment2D > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_Procedural_Segment2D_Sg_, 0};
static swig_type_info _swigt__p_std__vectorT_Procedural__Vertex_t = {"_p_std__vectorT_Procedural__Vertex_t", "std::vector< Procedural::Vertex > *|std::vector< Procedural::TriangleBuffer::Vertex > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Segment2D_t = {"_p_std__vectorT_Segment2D_t", "std::vector< Segment2D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_Segment3D_t = {"_p_std__vectorT_Segment3D_t", "std::vector< Segment3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_int_t = {"_p_std__vectorT_int_t", "std::vector< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "Ogre::uchar *|unsigned char *|Ogre::uint8 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "Ogre::RGBA *|Ogre::uint32 *|unsigned int *|Ogre::uint *|Ogre::ARGB *|Ogre::BGRA *|Ogre::ABGR *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "Ogre::ulong *|unsigned long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "Ogre::uint64 *|unsigned long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "Ogre::uint16 *|unsigned short *|Ogre::ushort *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ControlPoint,
  &_swigt__p_MultiShape,
  &_swigt__p_Ogre__Angle,
  &_swigt__p_Ogre__AxisAlignedBox,
  &_swigt__p_Ogre__Box,
  &_swigt__p_Ogre__ColourValue,
  &_swigt__p_Ogre__Degree,
  &_swigt__p_Ogre__HashedVectorT_Ogre__Light_p_t,
  &_swigt__p_Ogre__Image,
  &_swigt__p_Ogre__ManualObject,
  &_swigt__p_Ogre__Math,
  &_swigt__p_Ogre__Math__RandomValueProvider,
  &_swigt__p_Ogre__Matrix3,
  &_swigt__p_Ogre__Matrix4,
  &_swigt__p_Ogre__MeshPtr,
  &_swigt__p_Ogre__NameGenerator,
  &_swigt__p_Ogre__Plane,
  &_swigt__p_Ogre__Quaternion,
  &_swigt__p_Ogre__Radian,
  &_swigt__p_Ogre__Ray,
  &_swigt__p_Ogre__RenderWindowDescription,
  &_swigt__p_Ogre__SimpleSpline,
  &_swigt__p_Ogre__Sphere,
  &_swigt__p_Ogre__TRectT_float_t,
  &_swigt__p_Ogre__TRectT_long_t,
  &_swigt__p_Ogre__TexturePtr,
  &_swigt__p_Ogre__Vector2,
  &_swigt__p_Ogre__Vector3,
  &_swigt__p_Ogre__Vector4,
  &_swigt__p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type,
  &_swigt__p_Path,
  &_swigt__p_Procedural__Abnormals,
  &_swigt__p_Procedural__Alpha,
  &_swigt__p_Procedural__AlphaMask,
  &_swigt__p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,
  &_swigt__p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,
  &_swigt__p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,
  &_swigt__p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,
  &_swigt__p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,
  &_swigt__p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,
  &_swigt__p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,
  &_swigt__p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,
  &_swigt__p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,
  &_swigt__p_Procedural__BezierCurve2,
  &_swigt__p_Procedural__BezierCurve3,
  &_swigt__p_Procedural__Blit,
  &_swigt__p_Procedural__Blur,
  &_swigt__p_Procedural__Boolean,
  &_swigt__p_Procedural__BoxGenerator,
  &_swigt__p_Procedural__BoxUVModifier,
  &_swigt__p_Procedural__CalculateNormalsModifier,
  &_swigt__p_Procedural__CapsuleGenerator,
  &_swigt__p_Procedural__CatmullRomSpline2,
  &_swigt__p_Procedural__CatmullRomSpline3,
  &_swigt__p_Procedural__Cell,
  &_swigt__p_Procedural__Channel,
  &_swigt__p_Procedural__Circle,
  &_swigt__p_Procedural__CircleShape,
  &_swigt__p_Procedural__CircleTexture,
  &_swigt__p_Procedural__Cloud,
  &_swigt__p_Procedural__Colours,
  &_swigt__p_Procedural__Combine,
  &_swigt__p_Procedural__ConeGenerator,
  &_swigt__p_Procedural__Convolution,
  &_swigt__p_Procedural__Crack,
  &_swigt__p_Procedural__CubicHermiteSpline2,
  &_swigt__p_Procedural__CubicHermiteSpline3,
  &_swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t,
  &_swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t,
  &_swigt__p_Procedural__Cycloid,
  &_swigt__p_Procedural__CylinderGenerator,
  &_swigt__p_Procedural__CylinderUVModifier,
  &_swigt__p_Procedural__Dilate,
  &_swigt__p_Procedural__Distort,
  &_swigt__p_Procedural__EdgeDetection,
  &_swigt__p_Procedural__EllipseShape,
  &_swigt__p_Procedural__EllipseTexture,
  &_swigt__p_Procedural__Extruder,
  &_swigt__p_Procedural__Flip,
  &_swigt__p_Procedural__Glow,
  &_swigt__p_Procedural__Gradient,
  &_swigt__p_Procedural__HelixPath,
  &_swigt__p_Procedural__HemisphereUVModifier,
  &_swigt__p_Procedural__IcoSphereGenerator,
  &_swigt__p_Procedural__Image,
  &_swigt__p_Procedural__IntVector2,
  &_swigt__p_Procedural__Invert,
  &_swigt__p_Procedural__Jitter,
  &_swigt__p_Procedural__KochanekBartelsSpline2,
  &_swigt__p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t,
  &_swigt__p_Procedural__Labyrinth,
  &_swigt__p_Procedural__Lathe,
  &_swigt__p_Procedural__Lerp,
  &_swigt__p_Procedural__Light,
  &_swigt__p_Procedural__Line,
  &_swigt__p_Procedural__Line2D,
  &_swigt__p_Procedural__LinePath,
  &_swigt__p_Procedural__Lookup,
  &_swigt__p_Procedural__Marble,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__Boolean_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__Extruder_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__Lathe_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,
  &_swigt__p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,
  &_swigt__p_Procedural__MultiShape,
  &_swigt__p_Procedural__Noise,
  &_swigt__p_Procedural__NoiseBase,
  &_swigt__p_Procedural__Normals,
  &_swigt__p_Procedural__OilPaint,
  &_swigt__p_Procedural__Path,
  &_swigt__p_Procedural__PerlinNoise,
  &_swigt__p_Procedural__Plane,
  &_swigt__p_Procedural__PlaneGenerator,
  &_swigt__p_Procedural__PlaneUVModifier,
  &_swigt__p_Procedural__RandomPixels,
  &_swigt__p_Procedural__RectangleShape,
  &_swigt__p_Procedural__RectangleTexture,
  &_swigt__p_Procedural__RotationZoom,
  &_swigt__p_Procedural__RoundedBoxGenerator,
  &_swigt__p_Procedural__RoundedCornerSpline2,
  &_swigt__p_Procedural__RoundedCornerSpline3,
  &_swigt__p_Procedural__Segment,
  &_swigt__p_Procedural__Segment2D,
  &_swigt__p_Procedural__Segment3D,
  &_swigt__p_Procedural__Shape,
  &_swigt__p_Procedural__Sharpen,
  &_swigt__p_Procedural__ShowNormalsGenerator,
  &_swigt__p_Procedural__Solid,
  &_swigt__p_Procedural__SphereGenerator,
  &_swigt__p_Procedural__SphereUVModifier,
  &_swigt__p_Procedural__SpherifyModifier,
  &_swigt__p_Procedural__SpringGenerator,
  &_swigt__p_Procedural__SvgLoader,
  &_swigt__p_Procedural__Textile,
  &_swigt__p_Procedural__TextureBuffer,
  &_swigt__p_Procedural__TextureProcessing,
  &_swigt__p_Procedural__Threshold,
  &_swigt__p_Procedural__TorusGenerator,
  &_swigt__p_Procedural__TorusKnotGenerator,
  &_swigt__p_Procedural__Track,
  &_swigt__p_Procedural__Triangle2D,
  &_swigt__p_Procedural__Triangle3D,
  &_swigt__p_Procedural__TriangleBuffer,
  &_swigt__p_Procedural__TriangleBuffer__Vertex,
  &_swigt__p_Procedural__TriangleShape,
  &_swigt__p_Procedural__Triangulator,
  &_swigt__p_Procedural__TubeGenerator,
  &_swigt__p_Procedural__UnweldVerticesModifier,
  &_swigt__p_Procedural__Vector2Comparator,
  &_swigt__p_Procedural__Vector3Comparator,
  &_swigt__p_Procedural__Vortex,
  &_swigt__p_Procedural__WeldVerticesModifier,
  &_swigt__p_Procedural__WhiteNoise,
  &_swigt__p_Procedural__Wood,
  &_swigt__p_Shape,
  &_swigt__p_Side,
  &_swigt__p_Track,
  &_swigt__p_Track__AddressingMode,
  &_swigt__p_float,
  &_swigt__p_int,
  &_swigt__p_long_long,
  &_swigt__p_p_char,
  &_swigt__p_short,
  &_swigt__p_signed_char,
  &_swigt__p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,
  &_swigt__p_std__pairT_bool_float_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorT_Ogre__Vector2_t,
  &_swigt__p_std__vectorT_Ogre__Vector2_t__size_type,
  &_swigt__p_std__vectorT_Ogre__Vector3_t,
  &_swigt__p_std__vectorT_Procedural__Path_t,
  &_swigt__p_std__vectorT_Procedural__Segment2D_t,
  &_swigt__p_std__vectorT_Procedural__Vertex_t,
  &_swigt__p_std__vectorT_Segment2D_t,
  &_swigt__p_std__vectorT_Segment3D_t,
  &_swigt__p_std__vectorT_int_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
};

static swig_cast_info _swigc__p_ControlPoint[] = {  {&_swigt__p_ControlPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MultiShape[] = {  {&_swigt__p_MultiShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Angle[] = {  {&_swigt__p_Ogre__Angle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__AxisAlignedBox[] = {  {&_swigt__p_Ogre__AxisAlignedBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Box[] = {  {&_swigt__p_Ogre__Box, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__ColourValue[] = {  {&_swigt__p_Ogre__ColourValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Degree[] = {  {&_swigt__p_Ogre__Degree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__HashedVectorT_Ogre__Light_p_t[] = {  {&_swigt__p_Ogre__HashedVectorT_Ogre__Light_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Image[] = {  {&_swigt__p_Ogre__Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__ManualObject[] = {  {&_swigt__p_Ogre__ManualObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Math[] = {  {&_swigt__p_Ogre__Math, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Math__RandomValueProvider[] = {  {&_swigt__p_Ogre__Math__RandomValueProvider, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Matrix3[] = {  {&_swigt__p_Ogre__Matrix3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Matrix4[] = {  {&_swigt__p_Ogre__Matrix4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__MeshPtr[] = {  {&_swigt__p_Ogre__MeshPtr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__NameGenerator[] = {  {&_swigt__p_Ogre__NameGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Plane[] = {  {&_swigt__p_Ogre__Plane, 0, 0, 0},  {&_swigt__p_Procedural__Plane, _p_Procedural__PlaneTo_p_Ogre__Plane, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Quaternion[] = {  {&_swigt__p_Ogre__Quaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Radian[] = {  {&_swigt__p_Ogre__Radian, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Ray[] = {  {&_swigt__p_Ogre__Ray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__RenderWindowDescription[] = {  {&_swigt__p_Ogre__RenderWindowDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__SimpleSpline[] = {  {&_swigt__p_Ogre__SimpleSpline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Sphere[] = {  {&_swigt__p_Ogre__Sphere, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__TRectT_float_t[] = {  {&_swigt__p_Ogre__TRectT_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__TRectT_long_t[] = {  {&_swigt__p_Ogre__TRectT_long_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__TexturePtr[] = {  {&_swigt__p_Ogre__TexturePtr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Vector2[] = {  {&_swigt__p_Ogre__Vector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Vector3[] = {  {&_swigt__p_Ogre__Vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__Vector4[] = {  {&_swigt__p_Ogre__Vector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type[] = {  {&_swigt__p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Path[] = {  {&_swigt__p_Path, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Abnormals[] = {  {&_swigt__p_Procedural__Abnormals, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Alpha[] = {  {&_swigt__p_Procedural__Alpha, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__AlphaMask[] = {  {&_swigt__p_Procedural__AlphaMask, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t[] = {  {&_swigt__p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t, 0, 0, 0},  {&_swigt__p_Procedural__BezierCurve2, _p_Procedural__BezierCurve2To_p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t[] = {  {&_swigt__p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t, 0, 0, 0},  {&_swigt__p_Procedural__CatmullRomSpline2, _p_Procedural__CatmullRomSpline2To_p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t[] = {  {&_swigt__p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t, 0, 0, 0},  {&_swigt__p_Procedural__CubicHermiteSpline2, _p_Procedural__CubicHermiteSpline2To_p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t[] = {  {&_swigt__p_Procedural__KochanekBartelsSpline2, _p_Procedural__KochanekBartelsSpline2To_p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t, 0, 0},  {&_swigt__p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t[] = {  {&_swigt__p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t, 0, 0, 0},  {&_swigt__p_Procedural__RoundedCornerSpline2, _p_Procedural__RoundedCornerSpline2To_p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t[] = {  {&_swigt__p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t, 0, 0, 0},  {&_swigt__p_Procedural__BezierCurve3, _p_Procedural__BezierCurve3To_p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t[] = {  {&_swigt__p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t, 0, 0, 0},  {&_swigt__p_Procedural__CatmullRomSpline3, _p_Procedural__CatmullRomSpline3To_p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t[] = {  {&_swigt__p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t, 0, 0, 0},  {&_swigt__p_Procedural__CubicHermiteSpline3, _p_Procedural__CubicHermiteSpline3To_p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t[] = {  {&_swigt__p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t, 0, 0, 0},  {&_swigt__p_Procedural__RoundedCornerSpline3, _p_Procedural__RoundedCornerSpline3To_p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BezierCurve2[] = {  {&_swigt__p_Procedural__BezierCurve2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BezierCurve3[] = {  {&_swigt__p_Procedural__BezierCurve3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Blit[] = {  {&_swigt__p_Procedural__Blit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Blur[] = {  {&_swigt__p_Procedural__Blur, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Boolean[] = {  {&_swigt__p_Procedural__Boolean, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BoxGenerator[] = {  {&_swigt__p_Procedural__BoxGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__BoxUVModifier[] = {  {&_swigt__p_Procedural__BoxUVModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CalculateNormalsModifier[] = {  {&_swigt__p_Procedural__CalculateNormalsModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CapsuleGenerator[] = {  {&_swigt__p_Procedural__CapsuleGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CatmullRomSpline2[] = {  {&_swigt__p_Procedural__CatmullRomSpline2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CatmullRomSpline3[] = {  {&_swigt__p_Procedural__CatmullRomSpline3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Cell[] = {  {&_swigt__p_Procedural__Cell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Channel[] = {  {&_swigt__p_Procedural__Channel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Circle[] = {  {&_swigt__p_Procedural__Circle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CircleShape[] = {  {&_swigt__p_Procedural__CircleShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CircleTexture[] = {  {&_swigt__p_Procedural__CircleTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Cloud[] = {  {&_swigt__p_Procedural__Cloud, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Colours[] = {  {&_swigt__p_Procedural__Colours, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Combine[] = {  {&_swigt__p_Procedural__Combine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__ConeGenerator[] = {  {&_swigt__p_Procedural__ConeGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Convolution[] = {  {&_swigt__p_Procedural__Convolution, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Crack[] = {  {&_swigt__p_Procedural__Crack, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CubicHermiteSpline2[] = {  {&_swigt__p_Procedural__CubicHermiteSpline2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CubicHermiteSpline3[] = {  {&_swigt__p_Procedural__CubicHermiteSpline3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t[] = {  {&_swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t[] = {  {&_swigt__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Cycloid[] = {  {&_swigt__p_Procedural__Cycloid, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CylinderGenerator[] = {  {&_swigt__p_Procedural__CylinderGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__CylinderUVModifier[] = {  {&_swigt__p_Procedural__CylinderUVModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Dilate[] = {  {&_swigt__p_Procedural__Dilate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Distort[] = {  {&_swigt__p_Procedural__Distort, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__EdgeDetection[] = {  {&_swigt__p_Procedural__EdgeDetection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__EllipseShape[] = {  {&_swigt__p_Procedural__EllipseShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__EllipseTexture[] = {  {&_swigt__p_Procedural__EllipseTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Extruder[] = {  {&_swigt__p_Procedural__Extruder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Flip[] = {  {&_swigt__p_Procedural__Flip, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Glow[] = {  {&_swigt__p_Procedural__Glow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Gradient[] = {  {&_swigt__p_Procedural__Gradient, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__HelixPath[] = {  {&_swigt__p_Procedural__HelixPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__HemisphereUVModifier[] = {  {&_swigt__p_Procedural__HemisphereUVModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__IcoSphereGenerator[] = {  {&_swigt__p_Procedural__IcoSphereGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Image[] = {  {&_swigt__p_Procedural__Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__IntVector2[] = {  {&_swigt__p_Procedural__IntVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Invert[] = {  {&_swigt__p_Procedural__Invert, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Jitter[] = {  {&_swigt__p_Procedural__Jitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__KochanekBartelsSpline2[] = {  {&_swigt__p_Procedural__KochanekBartelsSpline2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t[] = {  {&_swigt__p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Labyrinth[] = {  {&_swigt__p_Procedural__Labyrinth, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Lathe[] = {  {&_swigt__p_Procedural__Lathe, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Lerp[] = {  {&_swigt__p_Procedural__Lerp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Light[] = {  {&_swigt__p_Procedural__Light, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Line[] = {  {&_swigt__p_Procedural__Line, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Line2D[] = {  {&_swigt__p_Procedural__Line2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__LinePath[] = {  {&_swigt__p_Procedural__LinePath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Lookup[] = {  {&_swigt__p_Procedural__Lookup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Marble[] = {  {&_swigt__p_Procedural__Marble, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__Boolean_t[] = {  {&_swigt__p_Procedural__Boolean, _p_Procedural__BooleanTo_p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__Boolean_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__BoxGenerator, _p_Procedural__BoxGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t[] = {  {&_swigt__p_Procedural__CapsuleGenerator, _p_Procedural__CapsuleGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__ConeGenerator, _p_Procedural__ConeGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t[] = {  {&_swigt__p_Procedural__CylinderGenerator, _p_Procedural__CylinderGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__Extruder_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0, 0, 0},  {&_swigt__p_Procedural__Extruder, _p_Procedural__ExtruderTo_p_Procedural__MeshGeneratorT_Procedural__Extruder_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__IcoSphereGenerator, _p_Procedural__IcoSphereGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__Lathe_t[] = {  {&_swigt__p_Procedural__Lathe, _p_Procedural__LatheTo_p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__Lathe_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__PlaneGenerator, _p_Procedural__PlaneGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t[] = {  {&_swigt__p_Procedural__RoundedBoxGenerator, _p_Procedural__RoundedBoxGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__SphereGenerator, _p_Procedural__SphereGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__SpringGenerator, _p_Procedural__SpringGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t[] = {  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0, 0, 0},  {&_swigt__p_Procedural__TorusGenerator, _p_Procedural__TorusGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t[] = {  {&_swigt__p_Procedural__TorusKnotGenerator, _p_Procedural__TorusKnotGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__Triangulator_t[] = {  {&_swigt__p_Procedural__Triangulator, _p_Procedural__TriangulatorTo_p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__Triangulator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t[] = {  {&_swigt__p_Procedural__TubeGenerator, _p_Procedural__TubeGeneratorTo_p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0, 0},  {&_swigt__p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__MultiShape[] = {  {&_swigt__p_Procedural__MultiShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Noise[] = {  {&_swigt__p_Procedural__Noise, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__NoiseBase[] = {  {&_swigt__p_Procedural__WhiteNoise, _p_Procedural__WhiteNoiseTo_p_Procedural__NoiseBase, 0, 0},  {&_swigt__p_Procedural__NoiseBase, 0, 0, 0},  {&_swigt__p_Procedural__PerlinNoise, _p_Procedural__PerlinNoiseTo_p_Procedural__NoiseBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Normals[] = {  {&_swigt__p_Procedural__Normals, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__OilPaint[] = {  {&_swigt__p_Procedural__OilPaint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Path[] = {  {&_swigt__p_Procedural__Path, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__PerlinNoise[] = {  {&_swigt__p_Procedural__PerlinNoise, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Plane[] = {  {&_swigt__p_Procedural__Plane, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__PlaneGenerator[] = {  {&_swigt__p_Procedural__PlaneGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__PlaneUVModifier[] = {  {&_swigt__p_Procedural__PlaneUVModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RandomPixels[] = {  {&_swigt__p_Procedural__RandomPixels, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RectangleShape[] = {  {&_swigt__p_Procedural__RectangleShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RectangleTexture[] = {  {&_swigt__p_Procedural__RectangleTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RotationZoom[] = {  {&_swigt__p_Procedural__RotationZoom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RoundedBoxGenerator[] = {  {&_swigt__p_Procedural__RoundedBoxGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RoundedCornerSpline2[] = {  {&_swigt__p_Procedural__RoundedCornerSpline2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__RoundedCornerSpline3[] = {  {&_swigt__p_Procedural__RoundedCornerSpline3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Segment[] = {  {&_swigt__p_Procedural__Segment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Segment2D[] = {  {&_swigt__p_Procedural__Segment2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Segment3D[] = {  {&_swigt__p_Procedural__Segment3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Shape[] = {  {&_swigt__p_Procedural__Shape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Sharpen[] = {  {&_swigt__p_Procedural__Sharpen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__ShowNormalsGenerator[] = {  {&_swigt__p_Procedural__ShowNormalsGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Solid[] = {  {&_swigt__p_Procedural__Solid, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__SphereGenerator[] = {  {&_swigt__p_Procedural__SphereGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__SphereUVModifier[] = {  {&_swigt__p_Procedural__SphereUVModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__SpherifyModifier[] = {  {&_swigt__p_Procedural__SpherifyModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__SpringGenerator[] = {  {&_swigt__p_Procedural__SpringGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__SvgLoader[] = {  {&_swigt__p_Procedural__SvgLoader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Textile[] = {  {&_swigt__p_Procedural__Textile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TextureBuffer[] = {  {&_swigt__p_Procedural__TextureBuffer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TextureProcessing[] = {  {&_swigt__p_Procedural__Vortex, _p_Procedural__VortexTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Combine, _p_Procedural__CombineTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Marble, _p_Procedural__MarbleTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__RotationZoom, _p_Procedural__RotationZoomTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Crack, _p_Procedural__CrackTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Noise, _p_Procedural__NoiseTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Light, _p_Procedural__LightTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Colours, _p_Procedural__ColoursTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Labyrinth, _p_Procedural__LabyrinthTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Textile, _p_Procedural__TextileTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Cloud, _p_Procedural__CloudTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Jitter, _p_Procedural__JitterTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Wood, _p_Procedural__WoodTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Lookup, _p_Procedural__LookupTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Threshold, _p_Procedural__ThresholdTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__EdgeDetection, _p_Procedural__EdgeDetectionTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__OilPaint, _p_Procedural__OilPaintTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Blit, _p_Procedural__BlitTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Cycloid, _p_Procedural__CycloidTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__EllipseTexture, _p_Procedural__EllipseTextureTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__CircleTexture, _p_Procedural__CircleTextureTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__RectangleTexture, _p_Procedural__RectangleTextureTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Distort, _p_Procedural__DistortTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Lerp, _p_Procedural__LerpTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Invert, _p_Procedural__InvertTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__TextureProcessing, 0, 0, 0},  {&_swigt__p_Procedural__Image, _p_Procedural__ImageTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Cell, _p_Procedural__CellTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Sharpen, _p_Procedural__SharpenTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Blur, _p_Procedural__BlurTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Channel, _p_Procedural__ChannelTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Flip, _p_Procedural__FlipTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Gradient, _p_Procedural__GradientTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Alpha, _p_Procedural__AlphaTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Glow, _p_Procedural__GlowTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Dilate, _p_Procedural__DilateTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Segment, _p_Procedural__SegmentTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Convolution, _p_Procedural__ConvolutionTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Normals, _p_Procedural__NormalsTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Abnormals, _p_Procedural__AbnormalsTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__AlphaMask, _p_Procedural__AlphaMaskTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__RandomPixels, _p_Procedural__RandomPixelsTo_p_Procedural__TextureProcessing, 0, 0},  {&_swigt__p_Procedural__Solid, _p_Procedural__SolidTo_p_Procedural__TextureProcessing, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Threshold[] = {  {&_swigt__p_Procedural__Threshold, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TorusGenerator[] = {  {&_swigt__p_Procedural__TorusGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TorusKnotGenerator[] = {  {&_swigt__p_Procedural__TorusKnotGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Track[] = {  {&_swigt__p_Procedural__Track, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Triangle2D[] = {  {&_swigt__p_Procedural__Triangle2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Triangle3D[] = {  {&_swigt__p_Procedural__Triangle3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TriangleBuffer[] = {  {&_swigt__p_Procedural__TriangleBuffer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TriangleBuffer__Vertex[] = {  {&_swigt__p_Procedural__TriangleBuffer__Vertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TriangleShape[] = {  {&_swigt__p_Procedural__TriangleShape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Triangulator[] = {  {&_swigt__p_Procedural__Triangulator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__TubeGenerator[] = {  {&_swigt__p_Procedural__TubeGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__UnweldVerticesModifier[] = {  {&_swigt__p_Procedural__UnweldVerticesModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Vector2Comparator[] = {  {&_swigt__p_Procedural__Vector2Comparator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Vector3Comparator[] = {  {&_swigt__p_Procedural__Vector3Comparator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Vortex[] = {  {&_swigt__p_Procedural__Vortex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__WeldVerticesModifier[] = {  {&_swigt__p_Procedural__WeldVerticesModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__WhiteNoise[] = {  {&_swigt__p_Procedural__WhiteNoise, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Procedural__Wood[] = {  {&_swigt__p_Procedural__Wood, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Shape[] = {  {&_swigt__p_Shape, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Side[] = {  {&_swigt__p_Side, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Track[] = {  {&_swigt__p_Track, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Track__AddressingMode[] = {  {&_swigt__p_Track__AddressingMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator[] = {  {&_swigt__p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_bool_float_t[] = {  {&_swigt__p_std__pairT_bool_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Ogre__Vector2_t[] = {  {&_swigt__p_std__vectorT_Ogre__Vector2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Ogre__Vector2_t__size_type[] = {  {&_swigt__p_std__vectorT_Ogre__Vector2_t__size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Ogre__Vector3_t[] = {  {&_swigt__p_std__vectorT_Ogre__Vector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Procedural__Path_t[] = {  {&_swigt__p_std__vectorT_Procedural__Path_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Procedural__Segment2D_t[] = {  {&_swigt__p_std__vectorT_Procedural__Segment2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Procedural__Vertex_t[] = {  {&_swigt__p_std__vectorT_Procedural__Vertex_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Segment2D_t[] = {  {&_swigt__p_std__vectorT_Segment2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_Segment3D_t[] = {  {&_swigt__p_std__vectorT_Segment3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_int_t[] = {  {&_swigt__p_std__vectorT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ControlPoint,
  _swigc__p_MultiShape,
  _swigc__p_Ogre__Angle,
  _swigc__p_Ogre__AxisAlignedBox,
  _swigc__p_Ogre__Box,
  _swigc__p_Ogre__ColourValue,
  _swigc__p_Ogre__Degree,
  _swigc__p_Ogre__HashedVectorT_Ogre__Light_p_t,
  _swigc__p_Ogre__Image,
  _swigc__p_Ogre__ManualObject,
  _swigc__p_Ogre__Math,
  _swigc__p_Ogre__Math__RandomValueProvider,
  _swigc__p_Ogre__Matrix3,
  _swigc__p_Ogre__Matrix4,
  _swigc__p_Ogre__MeshPtr,
  _swigc__p_Ogre__NameGenerator,
  _swigc__p_Ogre__Plane,
  _swigc__p_Ogre__Quaternion,
  _swigc__p_Ogre__Radian,
  _swigc__p_Ogre__Ray,
  _swigc__p_Ogre__RenderWindowDescription,
  _swigc__p_Ogre__SimpleSpline,
  _swigc__p_Ogre__Sphere,
  _swigc__p_Ogre__TRectT_float_t,
  _swigc__p_Ogre__TRectT_long_t,
  _swigc__p_Ogre__TexturePtr,
  _swigc__p_Ogre__Vector2,
  _swigc__p_Ogre__Vector3,
  _swigc__p_Ogre__Vector4,
  _swigc__p_Ogre__listT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,
  _swigc__p_Ogre__mapT_Ogre__String_Ogre__String_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_Ogre__String_t_GeneralAllocPolicy_t_t__type,
  _swigc__p_Ogre__mapT_Ogre__String_bool_std__lessT_Ogre__String_t_STLAllocatorT_std__pairT_Ogre__String_const_bool_t_GeneralAllocPolicy_t_t__type,
  _swigc__p_Ogre__vectorT_Ogre__Plane_STLAllocatorT_Ogre__Plane_GeneralAllocPolicy_t_t__type,
  _swigc__p_Ogre__vectorT_Ogre__RenderWindowDescription_STLAllocatorT_Ogre__RenderWindowDescription_GeneralAllocPolicy_t_t__type,
  _swigc__p_Ogre__vectorT_Ogre__RenderWindow_p_STLAllocatorT_Ogre__RenderWindow_p_GeneralAllocPolicy_t_t__type,
  _swigc__p_Path,
  _swigc__p_Procedural__Abnormals,
  _swigc__p_Procedural__Alpha,
  _swigc__p_Procedural__AlphaMask,
  _swigc__p_Procedural__BaseSpline2T_Procedural__BezierCurve2_t,
  _swigc__p_Procedural__BaseSpline2T_Procedural__CatmullRomSpline2_t,
  _swigc__p_Procedural__BaseSpline2T_Procedural__CubicHermiteSpline2_t,
  _swigc__p_Procedural__BaseSpline2T_Procedural__KochanekBartelsSpline2_t,
  _swigc__p_Procedural__BaseSpline2T_Procedural__RoundedCornerSpline2_t,
  _swigc__p_Procedural__BaseSpline3T_Procedural__BezierCurve3_t,
  _swigc__p_Procedural__BaseSpline3T_Procedural__CatmullRomSpline3_t,
  _swigc__p_Procedural__BaseSpline3T_Procedural__CubicHermiteSpline3_t,
  _swigc__p_Procedural__BaseSpline3T_Procedural__RoundedCornerSpline3_t,
  _swigc__p_Procedural__BezierCurve2,
  _swigc__p_Procedural__BezierCurve3,
  _swigc__p_Procedural__Blit,
  _swigc__p_Procedural__Blur,
  _swigc__p_Procedural__Boolean,
  _swigc__p_Procedural__BoxGenerator,
  _swigc__p_Procedural__BoxUVModifier,
  _swigc__p_Procedural__CalculateNormalsModifier,
  _swigc__p_Procedural__CapsuleGenerator,
  _swigc__p_Procedural__CatmullRomSpline2,
  _swigc__p_Procedural__CatmullRomSpline3,
  _swigc__p_Procedural__Cell,
  _swigc__p_Procedural__Channel,
  _swigc__p_Procedural__Circle,
  _swigc__p_Procedural__CircleShape,
  _swigc__p_Procedural__CircleTexture,
  _swigc__p_Procedural__Cloud,
  _swigc__p_Procedural__Colours,
  _swigc__p_Procedural__Combine,
  _swigc__p_Procedural__ConeGenerator,
  _swigc__p_Procedural__Convolution,
  _swigc__p_Procedural__Crack,
  _swigc__p_Procedural__CubicHermiteSpline2,
  _swigc__p_Procedural__CubicHermiteSpline3,
  _swigc__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector2_t,
  _swigc__p_Procedural__CubicHermiteSplineControlPointT_Ogre__Vector3_t,
  _swigc__p_Procedural__Cycloid,
  _swigc__p_Procedural__CylinderGenerator,
  _swigc__p_Procedural__CylinderUVModifier,
  _swigc__p_Procedural__Dilate,
  _swigc__p_Procedural__Distort,
  _swigc__p_Procedural__EdgeDetection,
  _swigc__p_Procedural__EllipseShape,
  _swigc__p_Procedural__EllipseTexture,
  _swigc__p_Procedural__Extruder,
  _swigc__p_Procedural__Flip,
  _swigc__p_Procedural__Glow,
  _swigc__p_Procedural__Gradient,
  _swigc__p_Procedural__HelixPath,
  _swigc__p_Procedural__HemisphereUVModifier,
  _swigc__p_Procedural__IcoSphereGenerator,
  _swigc__p_Procedural__Image,
  _swigc__p_Procedural__IntVector2,
  _swigc__p_Procedural__Invert,
  _swigc__p_Procedural__Jitter,
  _swigc__p_Procedural__KochanekBartelsSpline2,
  _swigc__p_Procedural__KochanekBartelsSplineControlPointT_Ogre__Vector2_t,
  _swigc__p_Procedural__Labyrinth,
  _swigc__p_Procedural__Lathe,
  _swigc__p_Procedural__Lerp,
  _swigc__p_Procedural__Light,
  _swigc__p_Procedural__Line,
  _swigc__p_Procedural__Line2D,
  _swigc__p_Procedural__LinePath,
  _swigc__p_Procedural__Lookup,
  _swigc__p_Procedural__Marble,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__Boolean_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__BoxGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__CapsuleGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__ConeGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__CylinderGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__Extruder_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__IcoSphereGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__Lathe_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__PlaneGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__RoundedBoxGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__SphereGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__SpringGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__TorusGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__TorusKnotGenerator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__Triangulator_t,
  _swigc__p_Procedural__MeshGeneratorT_Procedural__TubeGenerator_t,
  _swigc__p_Procedural__MultiShape,
  _swigc__p_Procedural__Noise,
  _swigc__p_Procedural__NoiseBase,
  _swigc__p_Procedural__Normals,
  _swigc__p_Procedural__OilPaint,
  _swigc__p_Procedural__Path,
  _swigc__p_Procedural__PerlinNoise,
  _swigc__p_Procedural__Plane,
  _swigc__p_Procedural__PlaneGenerator,
  _swigc__p_Procedural__PlaneUVModifier,
  _swigc__p_Procedural__RandomPixels,
  _swigc__p_Procedural__RectangleShape,
  _swigc__p_Procedural__RectangleTexture,
  _swigc__p_Procedural__RotationZoom,
  _swigc__p_Procedural__RoundedBoxGenerator,
  _swigc__p_Procedural__RoundedCornerSpline2,
  _swigc__p_Procedural__RoundedCornerSpline3,
  _swigc__p_Procedural__Segment,
  _swigc__p_Procedural__Segment2D,
  _swigc__p_Procedural__Segment3D,
  _swigc__p_Procedural__Shape,
  _swigc__p_Procedural__Sharpen,
  _swigc__p_Procedural__ShowNormalsGenerator,
  _swigc__p_Procedural__Solid,
  _swigc__p_Procedural__SphereGenerator,
  _swigc__p_Procedural__SphereUVModifier,
  _swigc__p_Procedural__SpherifyModifier,
  _swigc__p_Procedural__SpringGenerator,
  _swigc__p_Procedural__SvgLoader,
  _swigc__p_Procedural__Textile,
  _swigc__p_Procedural__TextureBuffer,
  _swigc__p_Procedural__TextureProcessing,
  _swigc__p_Procedural__Threshold,
  _swigc__p_Procedural__TorusGenerator,
  _swigc__p_Procedural__TorusKnotGenerator,
  _swigc__p_Procedural__Track,
  _swigc__p_Procedural__Triangle2D,
  _swigc__p_Procedural__Triangle3D,
  _swigc__p_Procedural__TriangleBuffer,
  _swigc__p_Procedural__TriangleBuffer__Vertex,
  _swigc__p_Procedural__TriangleShape,
  _swigc__p_Procedural__Triangulator,
  _swigc__p_Procedural__TubeGenerator,
  _swigc__p_Procedural__UnweldVerticesModifier,
  _swigc__p_Procedural__Vector2Comparator,
  _swigc__p_Procedural__Vector3Comparator,
  _swigc__p_Procedural__Vortex,
  _swigc__p_Procedural__WeldVerticesModifier,
  _swigc__p_Procedural__WhiteNoise,
  _swigc__p_Procedural__Wood,
  _swigc__p_Shape,
  _swigc__p_Side,
  _swigc__p_Track,
  _swigc__p_Track__AddressingMode,
  _swigc__p_float,
  _swigc__p_int,
  _swigc__p_long_long,
  _swigc__p_p_char,
  _swigc__p_short,
  _swigc__p_signed_char,
  _swigc__p_std__basic_stringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__mapT_Ogre__Real_Ogre__Real_t__const_iterator,
  _swigc__p_std__pairT_bool_float_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorT_Ogre__Vector2_t,
  _swigc__p_std__vectorT_Ogre__Vector2_t__size_type,
  _swigc__p_std__vectorT_Ogre__Vector3_t,
  _swigc__p_std__vectorT_Procedural__Path_t,
  _swigc__p_std__vectorT_Procedural__Segment2D_t,
  _swigc__p_std__vectorT_Procedural__Vertex_t,
  _swigc__p_std__vectorT_Segment2D_t,
  _swigc__p_std__vectorT_Segment3D_t,
  _swigc__p_std__vectorT_int_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
void SWIG_init_user(lua_State* L );
    
#ifdef __cplusplus
extern "C" {
#endif
/* this is the initialization function
  added at the very end of the code
  the function is always called SWIG_init, but an eariler #define will rename it
*/
SWIGEXPORT int SWIG_init(lua_State* L)
{
  int i;
  /* start with global table */
  lua_pushvalue(L,LUA_GLOBALSINDEX);
  /* SWIG's internal initalisation */
  SWIG_InitializeModule((void*)L);
  SWIG_PropagateClientData();
  /* add a global fn */
  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);
  /* begin the module (its a table with the same name as the module) */
  SWIG_Lua_module_begin(L,SWIG_name);
  /* add commands/functions */
  for (i = 0; swig_commands[i].name; i++){
    SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
  }
  /* add variables */
  for (i = 0; swig_variables[i].name; i++){
    SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
  }
  /* set up base class pointers (the hierachy) */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
  /* additional registration structs & classes in lua */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
  /* constants */
  SWIG_Lua_InstallConstants(L,swig_constants);
  /* invoke user-specific initialization */
  SWIG_init_user(L);
  /* end module */
  /* Note: We do not clean up the stack here (Lua will do this for us). At this
     point, we have the globals table and out module table on the stack. Returning
     one value makes the module table the result of the require command. */
  return 1;
}

#ifdef __cplusplus
}
#endif


const char* SWIG_LUACODE=
  "";

void SWIG_init_user(lua_State* L)
{
  /* exec Lua code if applicable */
  SWIG_Lua_dostring(L,SWIG_LUACODE);
}

